---
icon: pen-to-square
date: 2025-01-05
category:
  - Learning Records
tag:
  - Java Functional Programming
---

# Closure and Currying

## Closure

A closure is a combination of a **function object** and **external variables** bound together as a whole. For example,

```java
public class ClosureTest1 {
    interface Lambda {
        int add(int y);
    }
    
    public static void main(String[] args) {
        int x = 10;

        highOrder(y -> x + y);
    }

    static void highOrder(Lambda lambda) {
        System.out.println(lambda.add(20));
    }
}
```

* In the code, $y \rightarrow x + y$ and $x = 10$ form a closure.
* You can imagine that the function object has a backpack that can carry variables with it, so no matter how far the function object is passed, it always carries $x = 10$.
* There is a restriction that the local variable x must be final or effectively final, meaning that although it is not explicitly marked as final, it cannot be reassigned, otherwise it will result in a syntax error.
  * This means that once the closure variable is packed, it cannot change.
  * The reason is simple, to ensure the immutability of the function and prevent breaking the principle.
* A closure is a means to provide data for function execution, allowing the function to use both its parameters and closure variables.



例

```java
public class ClosureTest2 {

    // 闭包作用：给函数对象提供参数以外的数据
    public static void main(String[] args) throws IOException {
        // 创建 10 个任务对象，并且每个任务对象给一个任务编号
        List<Runnable> list = new ArrayList<>();
        for (int i = 0; i < 10; i++) {
            int k = i + 1;
            Runnable task 
                = () -> System.out.println(Thread.currentThread()+":执行任务" + k);
            list.add(task);
        }

        ExecutorService service = Executors.newVirtualThreadPerTaskExecutor();
        for (Runnable task : list) {
            service.submit(task);
        }
        System.in.read();
    }
}
```



## 柯里化（Carrying）

柯里化的作用是让函数对象分步执行（本质上是利用多个函数对象和闭包）

例如：

```java
public class Carrying1Test {
    public static void main(String[] args) {
        highOrder(a -> b -> a + b);
    }

    static void highOrder(Step1 step1) {
        Step2 step2 = step1.exec(10);
        System.out.println(step2.exec(20));
        System.out.println(step2.exec(50));
    }

    interface Step1 {
        Step2 exec(int a);
    }

    interface Step2 {
        int exec(int b);
    }
}
```

*  $a \rightarrow ...$ 是第一个函数对象，它的返回结果  $b \rightarrow ...$ 是第二个函数对象
* 后者与前面的参数 a 构成了闭包
* step1.exec(10) 确定了 a 的值是 10，返回第二个函数对象 step2，a 被放入了 step2 对象的背包记下来了
* step2.exec(20) 确定了 b 的值是 20，此时可以执行 a + b 的操作，得到结果 30
* step2.exec(50) 分析过程类似



## Higher-Order Functions

### 1) Inner Loop

### 2) Traverse Binary Tree

### 3) Simple Stream

### 4) Simple Stream - Simplification

### 5) Simple Stream - Collection