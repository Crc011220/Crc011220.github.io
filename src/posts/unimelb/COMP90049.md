---
icon: pen-to-square
date: 2025-03-02
category:
  - Learning Records
tag:
  - Unimelb
---

# Introduction to Machine Learning (COMP90049)

## Week 1

- Machine learning is a method of teaching software to learn from data and make decisions on their own, without being explicitly programmed.

### Three ingredients for machine learning
1. Data
• Discrete vs continuous vs ...
• Big data vs small data
• Labeled data vs unlabeled data
• Public vs sensitive data

2. Models
• function mapping from inputs to outputs
• probabilistic machine learning models
• geometric machine learning models
• parameters of the function are unknown

3. Learning
• Improving (on a task) after data is taken into account
• Finding the best model parameters (for a given task)
• Supervised vs. unsupervised learning

:::info
Supervised Learning:监督学习使用带有标签的数据进行训练，模型学习输入（features）到输出（labels）之间的映射关系。
Unsupervised Learning:无监督学习使用没有标签的数据，模型通过分析数据的模式和结构来进行学习。
:::

### Linear Algebra Review
#### Matrices
- Matrices addition/subtraction: Add(Subtract) correspond ingentries in A and B 
- Matrix multiplication: Multiply corresponding entries in A and B and sum the products
![Matrix Multiplication](matrix-multiplication.png)
- Matrix transpose: Transpose of a matrix is obtained by interchanging its rows and columns. Matrix is **symmetric** if it is equal to its transpose.
- Matrix inverse: The inverse of a matrix A is denoted by A^-1 and is obtained by multiplying A by its inverse. 
- A matrix cannot be inverted if: More rows than columns, More columns than rows,Redundant rows/columns (linear independence)
#### Vectors
- A vector is a matrix with several rows and **one** column
- Vector addition/subtraction: Add(Subtract) corresponding entries in A and B
- Vector inner product: Multiply corresponding entries in A and B and sum the products
- Vector Euclidean norm: The square root of the sum of the squares of the entries in the vector.
![Verctor Euclidean Norm](vector-norm.png)
- Vector inner product: The dot product of two vectors A and B is the sum of the products of their corresponding entries.
- The cosine of the angle between two vectors can be found by using norms and the inner product

### Instances, Attributes, and Learning Paradigms (Supervised vs. Unsupervised Learning)
- In ML terminology examples are called Instances
- Each instance can have some Features or Attributes
- Concepts are things that we aim to learn. Generally, in the form of labels or classes

#### Unsupervised do not have access to an inventory of classes and instead discover groups of ‘similar’ examples in a given dataset.
- Clustering is unsupervised — the learner operates without a set of labelled training data
- **Success is often measured subjectively; evaluation is problematic**

#### Supervised methods have prior knowledge of classes and set out to discover and categorise new instances according to those classes
- Classification learning is supervised
• In Classification, we can exhaustively list/enumerate all possible labels for a given instance; a correct prediction
entails mapping an instance to the label which is truly correct
- Regression learning is supervised 
• In Regression,"infinitely" many labels are possible, we cannot conceivably enumerate them; a “correct” prediction is when the numeric value is acceptably close to the true value

### Featured Data Types
1. Discrete: Nominal (Categorical)
- Values are distinct symbols, values themselves serve only as labels or names
- No relation is implied among nominal values (no ordering or distance measure)
- Only equality tests can be performed
- e.g. Student Number
2. Ordinal
- An explicit order is imposed on the values
- Addition and subtraction does not make sense
- e.g. Educational Level
3. Continuous: Numeric
- Numeric quantities are real-valued attributes
- All mathematical operations are allowed 

## Equal Width vs. Equal Frequency vs. Clustering

| Method                  | Equal Width Binning          | Equal Frequency Binning       | Clustering                   |
|-------------------------|----------------------------|------------------------------|------------------------------|
| **Definition**          | Each bin has the same width | Each bin contains the same number of data points | Groups data points based on similarity |
| **Type**               | Data discretization        | Data discretization         | Unsupervised learning       |
| **Advantages**         | Easy to compute, simple     | Suitable for skewed distributions | Can detect natural groupings in data |
| **Disadvantages**       | Sparse or dense bins if data density varies | Uneven bin width, harder to interpret | May require tuning (e.g., number of clusters) |
| **Common Algorithms**   | Fixed width intervals      | Quantiles-based binning     | K-Means, DBSCAN, Hierarchical Clustering |
| **Use Cases**          | Histogram creation, feature engineering | Handling skewed data in ML models | Customer segmentation, anomaly detection |

:::info
Equal Width Binning：用于简单离散化，每个 bin 宽度相同，但可能会导致数据密度不均衡。
Equal Frequency Binning：每个 bin 的数据量相等，适合处理偏态数据，但 bin 的宽度不一致，可能难以解释。
Clustering（聚类）：用于无监督学习，根据数据点的相似性自动分组，适合发现隐藏模式，但通常需要调整参数（如 k 值）。
:::

## Standardization vs. Normalization

| **Method**              | **Standardization (Z-score)**            | **Min-Max Normalization**         |
|-------------------------|-----------------------------------------|----------------------------------|
| **Formula**            | \( X' = \frac{X - \mu}{\sigma} \)       | \( X' = \frac{X - X_{\min}}{X_{\max} - X_{\min}} \) |
| **Range**              | Mean = 0, Std = 1                        | [0,1] or [-1,1]                 |
| **Best for**           | Normally distributed data                | Data with fixed bounds          |
| **Sensitive to outliers?** | Less sensitive                          | More sensitive                   |
| **Formula** | (X - mean) / std | (X - min) / (max - min) |
:::info
Standardization：将数据标准化到均值为 0，标准差为 1 的分布，适用于正态分布的数据。
Normalization：将数据缩放到 [0,1] 或 [-1,1] 范围内，适用于数据范围固定的数据。
:::

## Week 2
### K-Nearest Neighbors (KNN)
- supervied learning algorithm
#### KNN Classification
• Return the most common class label among neighbors
• Example: cat vs dog images; text classification; ...
#### KNN Regression
• Return the average value of among K nearest neighbors
• Example: housing price prediction;

#### To measure categorical distance, we can use:
- Hamming distance: number of positions where the two strings differ
- Jaccard Similarity: intersection over union of two sets

#### To measure numerical distance, we can use:
- Manhattan distance: sum of absolute differences between corresponding components
- Euclidean distance: square root of the sum of the squares of the differences between corresponding components
- Cosine distance: 1 minus the cosine of the angle between two vectors

#### To measure oridinal distance, we can use:
- Normalized Ranks: rank each value and normalize them to [0, 1]

#### Majority Vote

#### Inverse Distance
- Give more weight to the nearer neighbors rather than quantity.
- The bigger the weight, the more important the neighbor is.
![Inverse Distance](Inverse-Distance.png)

#### Inverse Linear Distance
- Give more weight to the nearer neighbors, but with a decreasing slope.
- The bigger the weight, the more important the neighbor is.

#### Value of K
| **K Value** | **Bias**               | **Variance**            | **Overfitting**  | **Underfitting**  | **Best For**                                 |
|-------------|------------------------|-------------------------|------------------|-------------------|---------------------------------------------|
| **Small K** (e.g., K=1, K=3) | **Low Bias**: The model can closely follow the data. | **High Variance**: Sensitive to noise and outliers. | Likely to overfit due to high sensitivity to small fluctuations in the training data. | Unlikely to underfit unless the data is too noisy or simple. | - Complex data with clear patterns<br> - When the dataset is relatively small. |
| **Large K** (e.g., K=10, K=20) | **High Bias**: The model becomes less sensitive to variations in the data. | **Low Variance**: Smoothing out the noise by considering more neighbors. | Less likely to overfit as it smooths out fluctuations. | Might underfit if the data has complex relationships or non-linear patterns. | - Noisy data<br> - When a generalization is more important than capturing every detail. |
| **Medium K** (e.g., K=5, K=7) | A balanced approach with moderate bias. | Balanced variance, aiming for generalization. | Minimizes both overfitting and underfitting. | Good compromise between bias and variance. | - Standard choice for most datasets, balancing generalization and accuracy. |

#### Why KNN
- Pros
• Intuitive and simple
• No assumptions
• Supports classification and regression
• No training: new data →evolve and adapt immediately
- Cons
• How to decide on best distance functions?
• How to combine multiple neighbors?
• How to select K ?
• Expensive with large (or growing) data sets

#### Lazy Learning vs. Eager Learning

| Criteria               | Lazy Learning (e.g., KNN)                     | Eager Learning                             |
|------------------------|-----------------------------------------------|--------------------------------------------|
| **Definition**          | Delays learning until a query is made          | Learns from the training data immediately  |
| **Training Phase**      | Fast (no model building)                      | Slow (model is built during training)       |
| **Prediction Phase**    | Slow (requires processing the entire dataset)  | Fast (uses the pre-built model)            |
| **Memory Requirement**  | High (stores the entire training dataset)       | Lower (only stores the model)              |
| **Flexibility**          | High (can adapt to new data easily)            | Low (requires retraining for new data)     |
| **Example**             | K-Nearest Neighbors (KNN)                      | Decision Trees, Neural Networks            |


### Probility
- P(A=a): the probability that random variable A takes value a
- 0 <= P(A=a) <= 1
- P(True) = 1
- P(False) = 0

#### Joint Probability
- P(A, B): joint probability of two events A and B
- the probability of both A and B occurring = P(A ∩ B)

#### Conditional Probability
- P(A|B): the probability of A occurring given that B has occurred
- P(A|B) = P(A ∩ B) / P(B)

#### Independent Probability
- Two events A and B are independent if P(A|B) = P(A)
- P(A, B) = P(A) * P(B)

:::info
#### Disjoint
- P(A∩B)=0

#### Product Rule
- P(A, B) = P(A|B) * P(B) = P(B|A) * P(A)

#### Chain Rule
- P(A,B,C)=P(A)⋅P(B∣A)⋅P(C∣A,B)
:::

#### Bayes' Rule
- P(A|B) = ( P(B|A) * P(A) ) / P(B)
- Bayes’ Rule allows us to compute P(A|B) given knowledge of the ‘inverse’ probability P(B|A).


#### Marginalization
![Marginalization](Marginalization.png)

#### Probability Distributions
- Probability distributions can be discrete or continuous. 
- Discrete Random Variable: Takes on a countable number of distinct values (e.g., number of heads in coin flips). 
- Continuous Random Variable: Takes on an infinite number of possible values (e.g., height of students).

| **Distribution** | **Type** | **Range** | **Parameters** | **Formula** | **Example** | **Use Cases** |
|-----------------|----------|-----------|---------------|-------------|-------------|---------------|
| **Normal** | Continuous | −∞ to +∞ | Mean μ, Variance σ² | <code>P(x) = (1 / √(2πσ²)) * exp(-((x - μ)² / (2σ²)))</code> | Human height, exam scores | Linear regression, Gaussian models |
| **Bernoulli** | Discrete | 0, 1 | Probability p | <code>P(X = k) = p^k (1 - p)^(1 - k)</code> | Coin flip | Binary classification |
| **Binomial** | Discrete | 0 to n | Number of trials n, Success probability p | <code>P(k) = C(n, k) * p^k * (1 - p)^(n - k)</code> | Number of heads in 10 coin flips | Binary classification, hypothesis testing |
| **Multinomial** | Discrete | 0 to n for each category | Number of trials n, Probabilities p₁, ..., pₖ | <code>P(x₁, ..., xₖ) = (n! / (x₁!x₂!...xₖ!)) * ∏(pᵢ^xᵢ)</code> | Rolling a dice multiple times | Text classification, NLP |
| **Categorical** | Discrete | 1 to k | Probabilities p₁, ..., pₖ | <code>P(X = i) = pᵢ</code> | Choosing a color from a set of options | Classification, clustering |

## Week 3

### Zero-R
- A simple baseline model that predicts the most frequent class in the training data.

### One-R
- Also known as Decision stom
- Uses only one feature (“best” feature) to build a model

### Desicion Trees
![Decision Tree Example](Decision-Tree-Example.png)

### ID3 (Iterative Dichotomiser 3)
- A top-down approach that splits the data into smaller subsets based on the value of a chosen feature.

#### Entropy (measure of uncertainty. The expected (average) level of uncertainty (surprise))
- For a Low probability event: if it happens, it’s big news! Big surprise! **High information!**
- For a High probability event: it was likely to happen anyway. Not very surprising. **Low information!**
- Higher H means more uncertain.
![Entropy Example](Entropy-Example.png)
#### Conditional Entropy measures the amount of uncertainty in X given Y.

#### Information Gain (measure of the reduction in entropy after splitting)
- Information gain measures the reduction in entropy about the target variable achieved by partitioning the data based on a given feature.
- Choose the largest as information gain.

#### Shortcomings of IG
- Overfitting: Greedy algorithm may choose a feature that is too specific and does not generalize well to unseen data.
- Gain ratio (GR) reduces the bias for information gain towards highlybranching attributes by normalising relative to the split information
- Split info (SI) is the entropy of a given split (evenness of the distribution ofinstances to attribute values)

### Naive Bayes Theory
:::info
arg max: argument of maximum value
:::

- Supervied ML method

#### Example:
![Naive Bayes Example1-1](Naive-Bayes-Example-1-1.png)
![Naive Bayes Example1-2](Naive-Bayes-Example-1-2.png)

- If any term P(xm|y ) = 0 then the class probability P(y|x ) = 0
- To solve this: use Laplace smoothing.

1. First Solution: We can assign a (small) positive probability 𝜀 to every unseen class-feature combination
2. Second Solution: We can add a “pseudocount” α to each feature count observed during training, often is 1.

- Probabilities are changed drastically when there are few instances; with a large number of instances, the changes are small
-  Laplace smoothing (and smoothing in general) **reduces variance** of the NB classifier because it reduces sensitivity to individual (non-)observations in the training data

### Different Naive Bayes

Naïve Bayes classifiers have several key variants that differ based on how they model the distribution of features. Below is a comparison of the most common types:

| Variant        | Assumption on Feature Distribution | Use Case |
|--------------|----------------------------------|---------|
| **Gaussian Naïve Bayes (GNB)** | Assumes features follow a Gaussian (normal) distribution. | Suitable for continuous data, often used in text classification and real-world datasets with normally distributed features. |
| **Multinomial Naïve Bayes (MNB)** | Assumes feature counts follow a multinomial distribution. | Best for text classification (e.g., spam detection, document classification) where features are word counts or term frequencies. |
| **Bernoulli Naïve Bayes (BNB)** | Assumes binary feature presence (1 = present, 0 = absent). | Used in binary text classification (e.g., sentiment analysis, spam filtering), where features represent whether a word appears in a document. |
| **Complement Naïve Bayes (CNB)** | A modification of Multinomial Naïve Bayes, designed to handle class imbalances. | Works better for imbalanced datasets and improves accuracy by adjusting feature probabilities. |
| **Categorical Naïve Bayes** | Assumes features are discrete categorical variables. | Used for classification tasks with categorical inputs that are not necessarily text-based. |

Each variant modifies the way probabilities are calculated based on the data's nature, making Naïve Bayes a flexible and effective algorithm for different types of classification tasks.


### Conclusion of Naive Bayes
1. Why does it work given that it’s a blatantly wrong model of the data?
- we don’t need the true distribution over P(y|x ), we just need to be able to identify the most likely outcome

2. Advantages of Naive Bayes
- easy to build and estimate
- easy to scale to many feature dimensions (e.g., words in the vocabulary) and data sizes
- reasonably easy to explain why a specific class was predicted
- good starting point for a classification project

## Week 4

### Linear Regression
- A supervised learning algorithm that models the relationship between a scalar dependent variable (y) and one or more explanatory variables (X1, X2,..., Xn).
- The model assumes that the relationship between the dependent and independent variables is linear.
- The goal is to find the best line that fits the data.

#### Loss Function
- The loss function measures the error between the predicted values and the actual values.
- The loss function is used to optimize the model parameters (i.e., the weights and biases) to minimize the loss.

:::info
- When using a regression model for prediction, it is important to only predict within the relevant range of data
- We should not try to extrapolate beyond the range of observed X’s
- Make sure independent variables are NOT highly correlated with each other, otherwise the model becomes unstable
:::

### Optimization
- Find parameter values 𝜽 that maximize (or minimize) the value of a function f(𝜽)

### Iterative Optimization
#### Closed-form solutions
- Previously, we computed the closed form solution for the MLE of the binomial distribution
- We follow our recipe, and arrive at a single solution
#### Unfortunately, life is not always as easy
- Often, no closed-form solution exists
- Instead, we have to iteratively improve our estimate of θˆ until we arrive at a satisfactory solution
- Gradient descent is one popular iterative optimization method

### Gradient Descent
- Descending a mountain (aka. our function) as fast as possible: atevery position take the next step that takes you most directly into the valley

![Gradient Descent](gradient-descent.png)
![Gradient Descent Algorithm](gd-algo.png)

:::info
1. with an appropriate learning rate, GD will find the global minimum for
differentiable convex functions
2. with an appropriate learning rate, GD will find a local minimum for
differentiable non-convex functions
:::

### Logistic Regression
| **Comparison**       | **Naïve Bayes**                         | **Logistic Regression**                  |
|----------------------|--------------------------------------|----------------------------------------|
| **Model Type**       | Generative Model                    | Discriminative Model                  |
| **Probability Learned** | \( P(x, y) \) (Joint Probability) | \( P(y | x) \) (Conditional Probability) |
| **Assumptions**      | Assumes feature independence        | No specific feature independence assumption |
| **Computational Complexity** | Low, fast computation          | Higher, requires gradient descent     |
| **Use Cases**        | Text classification (e.g., spam detection) | Tasks requiring feature relationship modeling |
| **Suitable for Large Datasets?** | Yes, simple computation   | Yes, but computationally more intensive |

:::info
# Understanding Odds and Log Odds in Logistic Regression

## 1. What are Odds?

Odds represent the ratio of the probability of an event occurring to the probability of it not occurring. Mathematically, odds are defined as:

\[
\text{odds} = \frac{P}{1 - P}
\]

where:
- \( P \) is the probability of the event occurring.
- \( 1 - P \) is the probability of the event not occurring.

### **Types of Odds**
- **Odds against an event**: When \( 0 < \text{odds} < 1 \), meaning the event is less likely to happen than not.
- **Odds in favor of an event**: When \( \text{odds} > 1 \), meaning the event is more likely to happen than not.

**Example:**
- If an event has a **60% chance** of occurring (\( P = 0.6 \)), the odds are:
  \[
  \text{odds} = \frac{0.6}{1 - 0.6} = \frac{0.6}{0.4} = 1.5
  \]
  This means the event is **1.5 times more likely** to occur than not.

## 2. Why Use Log Odds (Logit Function)?

Since odds can range from **0 to infinity**, they are not ideal for direct modeling in a regression setting. Instead, we take the **logarithm of odds**, known as the **logit function**:

\[
\text{log odds} = \log \left(\frac{P}{1 - P}\right)
\]

### **Advantages of Log Odds:**
1. **Transforms probability into an unrestricted range**  
   - \( P \) is always between \( 0 \) and \( 1 \), but log odds can take any value from **\(-\infty\) to \(+\infty\)**.
   - This makes it easier to model using linear regression techniques.

2. **Handles Non-Linearity in Probability**  
   - The relationship between probability and log odds is **non-linear**, but when transformed to log odds, it becomes **linear**.

**Example Calculation:**
- If the event has a probability of \( P = 0.8 \):
  \[
  \text{odds} = \frac{0.8}{1 - 0.8} = \frac{0.8}{0.2} = 4
  \]
  - Taking the natural logarithm:
    \[
    \log(4) \approx 1.386
    \]
  - Now, instead of dealing with probabilities, we can work with a linear scale.

## 3. Connection to Logistic Regression

In **logistic regression**, we model the probability of an event occurring using the equation:

\[
\log \left(\frac{P}{1 - P}\right) = \theta_0 + \theta_1 x_1 + \theta_2 x_2 + ... + \theta_n x_n
\]

This means:
- Instead of predicting probabilities directly, logistic regression predicts **log odds**, which follow a linear relationship with input features.
- We then use the **sigmoid function** to convert log odds back into probabilities.

## 4. Conclusion

- **Odds** measure how likely an event is compared to it not happening.
- **Log odds (logit function)** transform probabilities into a linear form, making them easier to model.
- Logistic regression leverages log odds to predict probabilities effectively.

Understanding this transformation is key to interpreting logistic regression results and making informed predictions.

:::

- Logit function: The logarithm of the odds.
### Softmax function: The function that converts a vector of real numbers to a probability distribution.

### Logistic Regression Summary
1.  Pros
- Probabilistic interpretation
- No restrictive assumptions on features
- Often outperforms Naive Bayes
- Particularly suited to frequency-based features (so, popular in NLP)
2. Cons
- Can only learn linear feature-data relationships
- Some feature scaling issues
- Often needs a lot of data to work well
- Regularisation a nuisance, but important since overfitting can be a big problem

## Week 5
### Support Vector Machines (SVM) 
#### Classifier
- A linear classifier (through origin) with parameters divides the space into positive and negative halves

### Hard Margin
![Hard Margin](margin.png)
- The margin is the distance between the decision boundary and the closest data point.
- The goal is to maximize the margin while keeping the data points as far away from the decision boundary as possible.
- The decision boundary is the line that separates the positive and negative data points.
- It is called hard margin because the data points must be correctly classified on both sides of the decision boundary.

#### Soft Margin
- The margin is softened by introducing a penalty term that depends on the distance of the data points from the decision boundary.
- The goal is to minimize the margin while keeping the data points as far away from the decision boundary as possible.
- The decision boundary is the line that separates the positive and negative data points.
- It is called soft margin because the data points can be misclassified on both sides of the decision boundary.


:::info
### Kernel Trick
- The kernel trick is a way to transform non-linear data into a higher-dimensional space where it becomes linearly separable.
- The kernel function is a similarity function that measures the similarity between two data points in the original space.
- The kernel trick allows us to use non-linear models in a linear model.
:::

### Applications of SVM
#### Multiclass problems
1. **Introduce parameter vectors**: If there are \( k \) categories, we introduce a parameter vector \( \theta_1, \theta_2, \ldots, \theta_k \) for each category.
2. **Jointly learn parameters**: Jointly learn these parameters by ensuring that the discriminant function associated with the correct category has the highest value. The goal is to minimize the following expression:
   \[
   \frac{1}{2} \sum_{y=1}^{k} \| \theta_y \|^2
   \]
   The constraint is that for all \( y' \neq y_i \) and \( i = 1, \ldots, n \), it satisfies:
   \[
   (\theta_{y_i} \cdot x_i) \geq (\theta_{y'} \cdot x_i) + 1
   \]
3. **Predict new examples**: Predict the label of a new example based on the following formula:
   \[
   \hat{y} = \arg\max_{y=1,\ldots,k} (\theta^*_y \cdot x)
   \]
#### Rating problems
#### Ordinal regression problems
- Target variable: The target variable in ordinal regression is an ordinal variable, where the categories have a certain order, such as education level (elementary, middle school, high school, university, graduate) or movie ratings (1 star to 5 stars).
- Model purpose: Unlike multiclass classification problems, ordinal regression models not only predict the correct category but also the order relationship between categories.

#### Translate each rating into a set of binary labels
- We can convert these labels into binary labels. For example, we can divide the ratings into two categories: "like" and "dislike". Here is a simple conversion example:

- 1 star and 2 stars: Dislike (represented by 0)
- 3 stars: May require additional processing as it can be considered neutral or context-dependent
- 4 stars and 5 stars: Like (represented by 1)
- Alternatively, we can create a binary label for each rating level as follows:

- 1 star: [1, 0, 0, 0, 0]
- 2 stars: [0, 1, 0, 0, 0]
- 3 stars: [0, 0, 1, 0, 0]
- 4 stars: [0, 0, 0, 1, 0]
- 5 stars: [0, 0, 0, 0, 1]


### Ranking
- In machine learning, ranking tasks typically involve ordering a set of items such that certain items have higher priority over others. SVM can address ranking problems by modifying the standard binary classification SVM, a method commonly known as RankSVM. RankSVM learns a ranking function through pairwise comparisons, ensuring that positive examples rank higher than negative ones.

### Structured prediction
- Structured prediction is a branch of machine learning that involves predicting structured outputs, such as sequences, trees, or graphs. SVM can be extended to handle these problems through Structured SVM. Structured SVM learns a prediction function by maximizing the margin, which can output entire structures rather than simple class labels. This approach is particularly useful in fields like natural language processing, bioinformatics, and computer vision.

**The core idea of Support Vector Machines (SVM) is to find an optimal hyperplane that best separates data points of different classes while maximizing the margin between the classes. This margin is the distance from the hyperplane to the nearest training data point. The goal of SVM is to find a hyperplane with the largest margin, which can improve the model's generalization ability and reduce the risk of overfitting.**

## Week 6 
### Evaluation 
if our model will perform effectively on unseen data

#### Holdout
- Split the data randomly into two parts: a training set and a test set.
- Train the model on the training set and evaluate it on the test set.

#### Holdout Weakness
- The size of the split affects the estimate of the model’s behaviour: Lots of test instances, and few training instances → , the learner doesn’t have enough information to build an accurate model. Lots of training instances, and few test instances → learner builds an accurate model, but test data might not be representative (so estimates of performance can be too high/too low)
- Bias in Sampling: Random sampling of data can lead to different distribution in train and test datasets

#### Stratification
- Stratification ensures that each fold or partition of the data maintains the same class distribution as the original dataset

#### Stratification Weakness
- Complexity: Can be more complex to implement compared to simple random sampling.
- Inefficient Resource Utilization: some data is only used for training and some only for testing

#### k-fold Cross-validation
- Divide the data into k equal parts, and use k-1 parts for training and 1 part for testing.
- Repeat k times, each time using a different part for testing and the remaining parts for training.
- The average performance of the k models is the estimate of the performance of the model on the entire dataset.

#### k-fold Cross-validation Weakness
- Fewer folds: more instances per partition, more variance in performance estimates
- More folds: fewer instances per partition, less variance but slower

#### Hyperparameter Tuning
- If the Decision Tree is too short (Depth is too small), The DT would be too simple (Something like 1-R)
- If the Decision Tree is too long (Depth is too big), The DT would be too complex and cannot generalize well
- To decide about the best depth for a tree (and other hyperparameters), we need a way to measure how well our tree can - edict labels for new, unseen data.
- But… If we use our Test data for hyperparameter tuning, then we don’t have any other (unseen) data to test the performance of the final model (after the hyperparameter tuning) → It will cause data leakage
- We need a third set → Validation data, or use cross-validation to split the data into training, validation, and test sets.

### Evaluation Metrics
- We can present all possible classification results a two-class problem in the following confusion matrix.
- True Positive (TP): The model correctly predicts the positive class.
- False Positive (FP): The model incorrectly predicts the positive class.
- True Negative (TN): The model correctly predicts the negative class.
- False Negative (FN): The model incorrectly predicts the negative class.

#### Recall
- Recall: From the cases that are actually positive, what percentage has been correctly identified (predicted positive) by our classifier. Recall = TP / (TP + FN)

#### Precision
- From the cases that are predicted positive, what percentage are actually positive. Precision = TP / (TP + FP)

#### F1-score
- A popular metric that can help with finding a balance between Precision & Recall is F1-Score. F1-Score is the harmonic mean of Precision and Recall. F1-Score = 2 * (Precision * Recall) / (Precision + Recall)

### Averaging methods
In multi-class problems, Macro Averaging, Micro Averaging, and Weighted Averaging are three methods for calculating the average precision or recall. These methods are particularly useful in evaluating the performance of classification models, especially in datasets with imbalanced classes.
Here is a brief description of these three methods:
### 1. Macro Averaging
Macro Averaging first calculates the metrics (such as precision, recall, or F1 score) for each class, and then calculates the simple arithmetic average of these metrics. It treats each class as equally important, without considering the actual frequency or size of the classes.
The calculation formula is as follows:
$$
\text{Macro Average} = \frac{1}{N} \sum_{i=1}^{N} \text{metric}_i
$$
Where, $N$ is the total number of classes, and $\text{metric}_i$ is the value of the metric for the $i$-th class.
**Advantages**: Each class is treated equally, so this may be a better metric for imbalanced datasets.
**Disadvantages**: If some classes are very few, they may disproportionately affect the overall performance evaluation.
### 2. Micro Averaging
Micro Averaging first calculates the total precision, total recall, and total F1 score for all classes, and then calculates the arithmetic average of these totals. It calculates the metrics by considering individual predictions in each class, so it takes into account the actual frequency of the classes.
The calculation formula is as follows:
$$
\text{Micro Average Precision} = \frac{\sum_{i=1}^{N} TP_i}{\sum_{i=1}^{N} TP_i + \sum_{i=1}^{N} FP_i}
$$
$$
\text{Micro Average Recall} = \frac{\sum_{i=1}^{N} TP_i}{\sum_{i=1}^{N} TP_i + \sum_{i=1}^{N} FN_i}
$$
Where, $TP_i$, $FP_i$, and $FN_i$ are the numbers of true positives, false positives, and false negatives, respectively, for the $i$-th class.
**Advantages**: It takes into account the true distribution of each class, so it is usually a more reliable metric for imbalanced datasets.
**Disadvantages**: It may overlook the imbalance between classes, as the contributions of all classes are averaged.
### 3. Weighted Averaging
Weighted Averaging is a variant of Macro Averaging, which takes into account the support of each class (i.e., the number of instances in each class). The value of the metric for each class is multiplied by the support of that class, and then the average of these weighted values is calculated.
The calculation formula is as follows:
$$
\text{Weighted Average} = \frac{\sum_{i=1}^{N} (\text{metric}_i \times \text{support}_i)}{\sum_{i=1}^{N} \text{support}_i}
$$
Where, $\text{metric}_i$ is the value of the metric for the $i$-th class, and $\text{support}_i$ is the support of the $i$-th class.
**Advantages**: It takes into account the relative size of each class, so it is a fairer metric for imbalanced datasets.
**Disadvantages**: Like Macro Averaging, it may give disproportionate weight to minority classes, which may distort the overall performance evaluation.
The choice of which averaging method to use depends on the specific application scenario and the characteristics of the dataset. In the case of class imbalance, Weighted Averaging is often considered the best choice, as it simultaneously considers the performance and relative importance of each class.

### Regression Performance Metrics
#### MSE, RMSE, and MAE (Mean Squared Error, Root Mean Squared Error, and Mean Absolute Error)
- Sum of Squared Errors (SSE) is the sum of the squared differences between the predicted and actual values.
- MSE emphasizes larger errors due to squaring and is sensitive to outliers.
- RMSE is the square root of MSE, providing a more interpretable metric in the same units as the target variable.
- MAE treats all errors equally, is less sensitive to outliers, and provides a straightforward average error measure.

![Generalization Problem](generalization.png)
1. Evidence of overfitting: large gap between training and test performance
2. Evidence of underfitting: High error rate for both test and training set

### Learning Curves
- A learning curve is a plot of learning performance over experience or time
- y-axis: Performance measured by accuracy, error rate or other metrics
- x-axis: conditions, e.g., sizes of training sets, model complexity, number of iterations…
- The learning curve can be used to identify overfitting, underfitting, or a suitable trade-off between the two.
- Training learning curve: calculated from the training set that shows how well the model is learning.
- Validation learning curve: calculated from a holdout set that shows how well the model is generalising.

#### data trade-off
- More training instances? → (usually) better model
- More evaluation instances? → more reliable estimate of effectivenes 

### Bias and Variance
- Model bias: the tendency of our model to make systematically wrong predictions
- Evaluation bias: the tendency of our evaluation strategy to over- or under-estimate the effectiveness of our model
- Sampling bias: if our training or evaluation dataset isn’t representative of the population.

- Model variance: Sensitivity of a machine learning model's predictions to small changes in the training data, leading to different outcomes when the model is trained on different subsets of the data.
- Evaluation variance: Variability in the performance metrics of a model (such as accuracy, precision, or recall) when evaluated across different test datasets or under different evaluation conditions.

## Week 7: Feature Selection
### Univariate Methods
*   **Concept**: Evaluate each feature individually in relation to the target variable.
*   **Advantages**:
    *   Intuitive approach to assess the "goodness" of each attribute.
    *   Model-independent.
    *   Linear time complexity with respect to the number of attributes.
*   **Good Features**: Features that are "correlated" with the label and can predict it effectively.
*   **Methods**:
    *   **Signal-to-Noise Ratio (SNR)**: Select features with high SNR.
    *   **Mutual Information (MI)**: Measures the dependence between the target variable and each feature. Select features with high MI.
    *   **Chi-Squared Test**: Determines if there is a significant association between categorical variables (for classification tasks).
    *   **ANOVA F-value**: Evaluates the significance of individual features in a dataset (for classification tasks with continuous features).
    *   **Correlation-based Feature Selection (CFS)**: Measures the correlation between each feature and the target variable. Selects features with high correlation.
### Multivariate Methods
*   **Concept**: Consider subsets of features together to capture their combined predictive power.
*   **Limitations of Univariate Methods**: Sometimes, single features may not provide good classification, but a combination of features can lead to better decision boundaries.
*   **Complexity**: Choosing the optimal subset of attributes that gives the best performance on the validation data.
*   **Feature Subset Assessment**:
    *   Split data into training, validation, and test sets.
    *   Train a classifier on each feature subset using the training data.
    *   Select the feature subset that performs best on the validation data.
    *   Test the selected subset on the test data.
*   **Algorithms**: [feature selection algorithms](./feature_selection.png)
### Filter Methods
*   **Concept**: Rank features (or feature subsets) independently of the classifier based on a predefined criterion.
*   **Criterion**: Measure the "relevance" of each feature (or feature subset) with respect to the target variable.
*   **Search Strategy**: Typically involves sorting features based on individual rankings or nested subsets.
*   **Assessment**: No direct assessment, but cross-validation can be used to determine the optimal number of features to select.
### Wrapper Methods
*   **Concept**: Use a classifier to evaluate the "usefulness" of different feature subsets.
*   **Criterion**: Measure the predictive power of each feature subset.
*   **Search Strategy**: Search through the space of all possible feature subsets. Train a new classifier for each candidate subset.
*   **Assessment**: Use cross-validation to evaluate the performance of each subset.
### Embedded Methods
*   **Concept**: Similar to wrapper methods, but utilize the classifier's internal knowledge to guide the search for the best feature subset, avoiding the need to train a new classifier for every candidate subset.
*   **Criterion**: Measure the "usefulness" of each feature subset.
*   **Search Strategy**: Guided search based on the classifier's knowledge.
*   **Assessment**: Use cross-validation.
### Forward Selection (Wrapper Method)
*   **Running Time**: Increases with the number of attributes.
*   **Advantages**: Performs well when the optimal subset is small.
*   **Disadvantages**: May converge to a suboptimal solution and is not feasible for large datasets.
### Forward Selection (Embedded Method)
*   **Running Time**: Faster than the wrapper method.
*   **Advantages**: Uses the classifier's knowledge to evaluate candidate features.
### Backward Elimination (Wrapper Method)
*   **Running Time**: Increases with the number of attributes.
*   **Advantages**: Removes the most irrelevant attributes at the beginning.
*   **Disadvantages**: May converge to a suboptimal solution and is not feasible for large datasets.
### Backward Elimination (Embedded Method)
*   **Running Time**: Faster than the wrapper method.
*   **Advantages**: Uses the classifier's knowledge to evaluate candidate features.
### L0-Norm Regularization
*   **Concept**: Directly minimize the number of features used by the algorithm by promoting zero entries in the weight vector.
*   **Objective Function**: Minimize the number of non-zero entries in the weight vector.
*   **Challenges**: The objective function is non-continuous and non-convex, making the optimization problem combinatorially hard.
### L1-Norm Regularization
*   **Concept**: Use a convex function to promote sparsity in the weight vector, resulting in fewer non-zero entries.
*   **Objective Function**: Minimize the L1 norm of the weight vector (taxicab norm or Manhattan norm).
*   **Advantages**: The optimization problem is convex, making it easier to solve.
*   **Result**: The solution typically has fewer non-zero entries, effectively performing feature selection.

**主成分分析 (PCA**)
* **目标**：找到一组正交的基向量，能够最大限度地解释数据方差。
* **步骤**：
    1. **数据中心化**：将数据集中的每个特征减去其均值，消除均值的影响。
    2. **计算协方差矩阵**：计算中心化数据矩阵的协方差矩阵。
    3. **特征值分解/奇异值分解**：计算协方差矩阵的特征值和特征向量，或者对中心化数据矩阵进行 SVD。
    4. **选择主成分**：选择前 m 个特征值最大的特征向量作为主成分。
    5. **数据降维**：将原始数据投影到主成分构成的子空间中，实现降维。
**PCA 的优势**：
* **简化数据**：减少变量数量，降低模型复杂度。
* **揭示潜在结构**：找到数据背后的潜在维度，帮助理解数据本质。
* **提高效率**：降低计算成本，提高模型训练和预测速度。
**PCA 的局限性**：
* **无法利用类别标签信息**：PCA 无法区分不同类别。
* **最大化方差**：PCA 最大化方差，但不一定能够区分不同类别。
**PCA 的应用**：
* **图像压缩**：将图像分割成小块，并将每个小块投影到低维子空间中，实现压缩。
* **面部表情识别**：将面部图像投影到低维子空间中，提取关键特征，用于表情识别。
**PCA 的评估**：
* **避免破坏交叉验证**：不要在整个数据集上进行降维，否则会破坏交叉验证。
* **在交叉验证的训练集上进行降维**：在交叉验证的每个训练集上进行降维，并在验证集上进行评估。

## Week 8
- 朴素贝叶斯和逻辑回归都是基于概率模型的分类算法，但朴素贝叶斯假设特征之间相互独立，而逻辑回归则没有这个限制。
- 感知器不使用概率模型，而是直接优化分类错误率，更加简单直观。

### ANN
- Artificial neural network is a network of processing elements
- Each element converts inputs to output
- The output is a function (called activation function) of a weighted sum of inputs
- Training an ANN means adjusting weights for training data given a pre-defined network topology

### Perceptron
- The Perceptron is a minimal neural network
- neural networks are composed of neurons
- A neuron is defined as y = f(θ0 + θ1 x1 +...+ θd xd)

### Perceptron Algorithm
- supervised classification algorithm
- 感知器通过调整权重来优化性能，并通过比较预测输出与真实输出之间的差异来更新权重。如果预测正确，则不做任何改变；如果预测错误，则根据实际情况增加或减少权重。
- 一个epoch就是完成一次完整的训练过程
- if mistakes: 𝑦(𝜃 ⋅ 𝒙) ≤ 0, we need to update
- 感知器算法通过迭代地更新权重来最小化误分类的数量。每次迭代中，如果发现某个样本被误分类，就根据学习率和样本的特征更新权重。这个过程重复进行直到达到预定的epoch数。
- can set learning rate 𝜂 as 1 for simplicity

### Online learning vs. Batch learning
- The perceptron algorithm is an online algorithm: update weights after each training example
- In contrast, Naive Bayes and logistic regression (with Gradient Descent) are batch algorithms

### Multi-layer perceptron
- Input layer with input units x: the first layer, takes features x as inputs
- Output layer with output units y: the last layer, has one unit per
possible output (e.g., 1 unit for binary classification)
- Hidden layers with hidden units h: all layers in between.

### Multi-layer Perceptron vs. other Neural Networks
#### Multi-layer Perceptron
• One specific type of neural network
• Feed-forward
• Fully connected
• Supervised learner
#### Other types of neural networks
• Convolutional neural networks
• Recurrent neural networks
• Autoencoder (unsupervised)

### Linear vs. Non-linear classification
#### Linear classification
• The perceptron, naive bayes, logistic regression are linear classifiers
• Decision boundary is a linear combination of features σ𝑖 𝜃𝑖𝑋𝑖
• Cannot learn‘feature interactions’ naturally
#### Non-linear classification
• Neural networks with at least 1 hidden layer and non-linear activations
• Decision boundary is a non-linear function of the inputs

:::info

:::

### Feature engineering vs feature learning
#### Feature Engineering
• The perceptron, naive Bayes and logistic regression require a fixed set of informative features
• e.g., outlook ∈ {overcast, sunny, rainy}, wind ∈ {high, low}, …
• Requiring domain knowledge
#### Feature learning
• Neural networks take as input ‘raw’ numeric data
• They learn features as intermediate representations as part of their target task (e.g., classification)
• Representation learning: learning abstract features that are informative for the target task
• Note: feature engineering is often replaced at the cost of additional parameter tuning (layers, activations, learning rates, …)


### Activation Functions
![activation function](./activationfunctino.png)
1. **Logistic or Sigmoid Function**:
   The output range of this function is between 0 and 1, commonly used in the output layer for binary classification problems.
2. **Hyperbolic Tangent Function (tanh)**:
   The output range of this function is between -1 and 1, more commonly used than the sigmoid function because its output mean is 0, which helps alleviate the gradient vanishing problem.
3. **Rectified Linear Unit (ReLU)**:
   This function directly returns the input value when the input is greater than 0, otherwise returns 0. It is one of the most popular activation functions currently, due to its simplicity, efficiency, and ability to accelerate the training process of neural networks.
- Note that the activation functions must be non-linear, as without this, the model is simply a (complex) linear model

### When is Linear Classification Enough?
• If we know our classes are linearly (approximately) separable
• If the feature space is (very) high-dimensional
...i.e., the number of features exceeds the number of training instances
(kernel trick)
• If the traning set is small
• If interpretability is important, i.e., understanding how (combinations of) features explain different predictions
- …but with increasing availability of data, and more powerful computers, non-linear models are gaining popularity, with currently Neural Networks being their most popular variant.

### Pros and Cons of Neural Networks
#### Pros
• Powerful tool!
• Neural networks with at least 1 hidden layer can approximate any (continuous) function. They are universal approximators
• Automatic feature learning
• Empirically, very good performance for many diverse tasks
#### Cons
• Powerful model increases the danger of ‘overfitting’
• Requires large training data sets
• Often requires powerful compute resources (GPUs)
• Lack of interpretability

## Week 9
| Characteristics | Activation Function | Step Function |
|------|--------------------------|---------------------|
| Definition | Introduces non-linear factors, determines whether a node is activated | Takes different constant values in different intervals |
| Mathematical Properties | Usually continuous and differentiable | Discontinuous, with jumps only at specific points |
| Applications | Introduces non-linearity in neural networks, increasing model complexity | Signal processing, control theory, early perceptron models |
| Common Types | Sigmoid, Tanh, ReLU, Leaky ReLU, Softmax | Heaviside step function |
| Advantages | Improves model expressiveness, suitable for complex pattern recognition | Simple, easy to understand and implement |
| Disadvantages | May cause gradient disappearance or explosion, requires selection of suitable functions | Discontinuous, not suitable for gradient-based optimization algorithms |
| Use in Neural Networks | Widely used, a core component of modern neural networks | Rarely used, mainly in early models |
Summary: Activation functions and step functions have different applications and properties in mathematics and engineering. Activation functions are mainly used in neural networks to introduce non-linearity and improve model expressiveness, while step functions are used in signal processing, control theory, and other fields. In neural networks, step functions are not suitable as activation functions due to their discontinuity.

### Why cannot we use the step functon?
Derivative is not defined at 0.
When it’s not at 0, the derivative is 0.
= No way to update weights and learn anything!

### A problem encountered when training a multilayer perceptron (MLP) and the method to solve it.
1. The update rule depends on the actual target output y: When training a neural network, we typically use an update rule to adjust the network's weights, which depends on the actual target output. However, in a multilayer network, we can only directly obtain the actual output of the final layer, but not the actual output of the hidden layers.
2. We can only access the actual output of the final layer: In a multilayer network, we can only directly observe the output of the final layer, while the output of the hidden layers is not directly observable.
3. We do not know the actual activation of the hidden layers: Since we cannot directly observe the actual output of the hidden layers, we do not know the actual activation state of the hidden layers.
To solve these problems, backpropagation (Backpropagation) provides an effective method. Backpropagation is an algorithm for training multilayer neural networks, which updates the weights in the network by calculating the partial derivatives of the error. This method allows us to effectively calculate the error partial derivatives for each individual weight, thereby updating the weights of the hidden layers, not just the outermost layer. This way, we can still effectively train the entire network without knowing the actual activation of the hidden layers. 
