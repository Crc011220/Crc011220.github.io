---
icon: pen-to-square
date: 2025-03-02
category:
  - Learning Records
tag:
  - Unimelb
---

# Introduction to Machine Learning (COMP90049)

## Week 1

- Machine learning is a method of teaching software to learn from data and make decisions on their own, without being explicitly programmed.

### Three ingredients for machine learning
1. Data
- Discrete vs continuous vs ...
- Big data vs small data
- Labeled data vs unlabeled data
- Public vs sensitive data

2. Models
- function mapping from inputs to outputs
- probabilistic machine learning models
- geometric machine learning models
- parameters of the function are unknown

3. Learning
- Improving (on a task) after data is taken into account
- Finding the best model parameters (for a given task)
- Supervised vs. unsupervised learning

:::info
Supervised Learning:ç›‘ç£å­¦ä¹ ä½¿ç”¨å¸¦æœ‰æ ‡ç­¾çš„æ•°æ®è¿›è¡Œè®­ç»ƒï¼Œæ¨¡å‹å­¦ä¹ è¾“å…¥ï¼ˆfeaturesï¼‰åˆ°è¾“å‡ºï¼ˆlabelsï¼‰ä¹‹é—´çš„æ˜ å°„å…³ç³»ã€‚
Unsupervised Learning:æ— ç›‘ç£å­¦ä¹ ä½¿ç”¨æ²¡æœ‰æ ‡ç­¾çš„æ•°æ®ï¼Œæ¨¡å‹é€šè¿‡åˆ†ææ•°æ®çš„æ¨¡å¼å’Œç»“æ„æ¥è¿›è¡Œå­¦ä¹ ã€‚
:::

### Linear Algebra Review
#### Matrices
- Matrices addition/subtraction: Add(Subtract) correspond ingentries in A and B 
- Matrix multiplication: Multiply corresponding entries in A and B and sum the products
![Matrix Multiplication](matrix-multiplication.png)
- Matrix transpose: Transpose of a matrix is obtained by interchanging its rows and columns. Matrix is **symmetric** if it is equal to its transpose.
- Matrix inverse: The inverse of a matrix A is denoted by A^-1 and is obtained by multiplying A by its inverse. 
- A matrix cannot be inverted if: More rows than columns, More columns than rows,Redundant rows/columns (linear independence)
#### Vectors
- A vector is a matrix with several rows and **one** column
- Vector addition/subtraction: Add(Subtract) corresponding entries in A and B
- Vector inner product: Multiply corresponding entries in A and B and sum the products
- Vector Euclidean norm: The square root of the sum of the squares of the entries in the vector.
![Verctor Euclidean Norm](vector-norm.png)
- Vector inner product: The dot product of two vectors A and B is the sum of the products of their corresponding entries.
- The cosine of the angle between two vectors can be found by using norms and the inner product

### Instances, Attributes, and Learning Paradigms (Supervised vs. Unsupervised Learning)
- In ML terminology examples are called Instances
- Each instance can have some Features or Attributes
- Concepts are things that we aim to learn. Generally, in the form of labels or classes

#### Unsupervised do not have access to an inventory of classes and instead discover groups of â€˜similarâ€™ examples in a given dataset.
- Clustering is unsupervised â€” the learner operates without a set of labelled training data
- **Success is often measured subjectively; evaluation is problematic**

#### Supervised methods have prior knowledge of classes and set out to discover and categorise new instances according to those classes
- Classification learning is supervised
- In Classification, we can exhaustively list/enumerate all possible labels for a given instance; a correct prediction
entails mapping an instance to the label which is truly correct
- Regression learning is supervised 
- In Regression,"infinitely" many labels are possible, we cannot conceivably enumerate them; a â€œcorrectâ€ prediction is when the numeric value is acceptably close to the true value

### Featured Data Types
1. Discrete: Nominal (Categorical)
- Values are distinct symbols, values themselves serve only as labels or names
- No relation is implied among nominal values (no ordering or distance measure)
- Only equality tests can be performed
- e.g. Student Number
2. Ordinal
- An explicit order is imposed on the values
- Addition and subtraction does not make sense
- e.g. Educational Level
3. Continuous: Numeric
- Numeric quantities are real-valued attributes
- All mathematical operations are allowed 

## Equal Width vs. Equal Frequency vs. Clustering

| Method                  | Equal Width Binning          | Equal Frequency Binning       | Clustering                   |
|-------------------------|----------------------------|------------------------------|------------------------------|
| **Definition**          | Each bin has the same width | Each bin contains the same number of data points | Groups data points based on similarity |
| **Type**               | Data discretization        | Data discretization         | Unsupervised learning       |
| **Advantages**         | Easy to compute, simple     | Suitable for skewed distributions | Can detect natural groupings in data |
| **Disadvantages**       | Sparse or dense bins if data density varies | Uneven bin width, harder to interpret | May require tuning (e.g., number of clusters) |
| **Common Algorithms**   | Fixed width intervals      | Quantiles-based binning     | K-Means, DBSCAN, Hierarchical Clustering |
| **Use Cases**          | Histogram creation, feature engineering | Handling skewed data in ML models | Customer segmentation, anomaly detection |

:::info
Equal Width Binningï¼šç”¨äºç®€å•ç¦»æ•£åŒ–ï¼Œæ¯ä¸ª bin å®½åº¦ç›¸åŒï¼Œä½†å¯èƒ½ä¼šå¯¼è‡´æ•°æ®å¯†åº¦ä¸å‡è¡¡ã€‚
Equal Frequency Binningï¼šæ¯ä¸ª bin çš„æ•°æ®é‡ç›¸ç­‰ï¼Œé€‚åˆå¤„ç†åæ€æ•°æ®ï¼Œä½† bin çš„å®½åº¦ä¸ä¸€è‡´ï¼Œå¯èƒ½éš¾ä»¥è§£é‡Šã€‚
Clusteringï¼ˆèšç±»ï¼‰ï¼šç”¨äºæ— ç›‘ç£å­¦ä¹ ï¼Œæ ¹æ®æ•°æ®ç‚¹çš„ç›¸ä¼¼æ€§è‡ªåŠ¨åˆ†ç»„ï¼Œé€‚åˆå‘ç°éšè—æ¨¡å¼ï¼Œä½†é€šå¸¸éœ€è¦è°ƒæ•´å‚æ•°ï¼ˆå¦‚ k å€¼ï¼‰ã€‚
:::

## Standardization vs. Normalization

| **Method**              | **Standardization (Z-score)**            | **Min-Max Normalization**         |
|-------------------------|-----------------------------------------|----------------------------------|
| **Formula**            | \( X' = \frac{X - \mu}{\sigma} \)       | \( X' = \frac{X - X_{\min}}{X_{\max} - X_{\min}} \) |
| **Range**              | Mean = 0, Std = 1                        | [0,1] or [-1,1]                 |
| **Best for**           | Normally distributed data                | Data with fixed bounds          |
| **Sensitive to outliers?** | Less sensitive                          | More sensitive                   |
| **Formula** | (X - mean) / std | (X - min) / (max - min) |
:::info
Standardizationï¼šå°†æ•°æ®æ ‡å‡†åŒ–åˆ°å‡å€¼ä¸º 0ï¼Œæ ‡å‡†å·®ä¸º 1 çš„åˆ†å¸ƒï¼Œé€‚ç”¨äºæ­£æ€åˆ†å¸ƒçš„ æ•°æ®ã€‚
Normalizationï¼šå°†æ•°æ®ç¼©æ”¾åˆ° [0,1] æˆ– [-1,1] èŒƒå›´å†…ï¼Œé€‚ç”¨äºæ•°æ®èŒƒå›´å›ºå®šçš„æ•°æ®ã€‚
:::

## Week 2
### K-Nearest Neighbors (KNN)
- supervied learning algorithm
#### KNN Classification
- Return the most common class label among neighbors
- Example: cat vs dog images; text classification; ...
#### KNN Regression
- Return the average value of among K nearest neighbors
- Example: housing price prediction;

#### To measure categorical distance, we can use:
- Hamming distance: number of positions where the two strings differ
- Jaccard Similarity: intersection over union of two sets

#### To measure numerical distance, we can use:
- Manhattan distance: sum of absolute differences between corresponding components
- Euclidean distance: square root of the sum of the squares of the differences between corresponding components
- Cosine distance: 1 minus the cosine of the angle between two vectors

#### To measure oridinal distance, we can use:
- Normalized Ranks: rank each value and normalize them to [0, 1]

#### Majority Vote

#### Inverse Distance
- Give more weight to the nearer neighbors rather than quantity.
- The bigger the weight, the more important the neighbor is.
![Inverse Distance](Inverse-Distance.png)

#### Inverse Linear Distance
- Give more weight to the nearer neighbors, but with a decreasing slope.
- The bigger the weight, the more important the neighbor is.

| æ–¹æ³•åç§°                    | æ˜¯å¦è€ƒè™‘è·ç¦» | æƒé‡å½¢å¼             | ç‰¹ç‚¹                |
| ----------------------- | ------ | ---------------- | ----------------- |
| Majority Vote           | âŒ ä¸è€ƒè™‘  | æ‰€æœ‰é‚»å±…æƒé‡ç›¸ç­‰         | ç®€å•ã€å®¹æ˜“å®ç°ï¼Œå®¹æ˜“å—å¼‚å¸¸å€¼å½±å“ |
| Inverse Distance        | âœ… å¼ºè°ƒè·ç¦» | æƒé‡ = 1 / è·ç¦»      | è¿‘é‚»å½±å“å¤§ï¼Œè¿œé‚»å½±å“å°ï¼Œæƒé‡ä¸‹é™å¿« |
| Inverse Linear Distance | âœ… å¼ºè°ƒè·ç¦» | æƒé‡ = 1 - d/Dï¼ˆDæ˜¯æœ€å¤§è·ç¦»ï¼Œdæ˜¯å½“å‰è·ç¦»ï¼‰ | æ›´å¹³æ»‘ä¸‹é™ï¼ŒæŠ—å¼‚å¸¸èƒ½åŠ›æ›´å¼º |


#### Value of K
| **K Value** | **Bias**               | **Variance**            | **Overfitting**  | **Underfitting**  | **Best For**                                 |
|-------------|------------------------|-------------------------|------------------|-------------------|---------------------------------------------|
| **Small K** (e.g., K=1, K=3) | **Low Bias**: The model can closely follow the data. | **High Variance**: Sensitive to noise and outliers. | Likely to overfit due to high sensitivity to small fluctuations in the training data. | Unlikely to underfit unless the data is too noisy or simple. | - Complex data with clear patterns<br> - When the dataset is relatively small. |
| **Large K** (e.g., K=10, K=20) | **High Bias**: The model becomes less sensitive to variations in the data. | **Low Variance**: Smoothing out the noise by considering more neighbors. | Less likely to overfit as it smooths out fluctuations. | Might underfit if the data has complex relationships or non-linear patterns. | - Noisy data<br> - When a generalization is more important than capturing every detail. |
| **Medium K** (e.g., K=5, K=7) | A balanced approach with moderate bias. | Balanced variance, aiming for generalization. | Minimizes both overfitting and underfitting. | Good compromise between bias and variance. | - Standard choice for most datasets, balancing generalization and accuracy. |

#### Why KNN
- Pros
- Intuitive and simple
- No assumptions
- Supports classification and regression
- No training: new data â†’evolve and adapt immediately
- Cons
- How to decide on best distance functions?
- How to combine multiple neighbors?
- How to select K ?
- Expensive with large (or growing) data sets

#### Lazy Learning vs. Eager Learning

| Criteria               | Lazy Learning (e.g., KNN)                     | Eager Learning                             |
|------------------------|-----------------------------------------------|--------------------------------------------|
| **Definition**          | Delays learning until a query is made          | Learns from the training data immediately  |
| **Training Phase**      | Fast (no model building)                      | Slow (model is built during training)       |
| **Prediction Phase**    | Slow (requires processing the entire dataset)  | Fast (uses the pre-built model)            |
| **Memory Requirement**  | High (stores the entire training dataset)       | Lower (only stores the model)              |
| **Flexibility**          | High (can adapt to new data easily)            | Low (requires retraining for new data)     |
| **Example**             | K-Nearest Neighbors (KNN)                      | Decision Trees, Neural Networks            |


### Probility
- P(A=a): the probability that random variable A takes value a
- 0 <= P(A=a) <= 1
- P(True) = 1
- P(False) = 0

#### Joint Probability
- P(A, B): joint probability of two events A and B
- the probability of both A and B occurring = P(A âˆ© B)

#### Conditional Probability
- P(A|B): the probability of A occurring given that B has occurred
- P(A|B) = P(A âˆ© B) / P(B)

#### Independent Probability
- Two events A and B are independent if P(A|B) = P(A)
- P(A, B) = P(A) * P(B)

:::info
#### Disjoint
- P(Aâˆ©B)=0

#### Product Rule
- P(A, B) = P(A|B) * P(B) = P(B|A) * P(A)

#### Chain Rule
- P(A,B,C)=P(A)â‹…P(Bâˆ£A)â‹…P(Câˆ£A,B)
:::

#### Bayes' Rule
- P(A|B) = ( P(B|A) * P(A) ) / P(B)
- Bayesâ€™ Rule allows us to compute P(A|B) given knowledge of the â€˜inverseâ€™ probability P(B|A).


#### Marginalization
![Marginalization](Marginalization.png)

#### Probability Distributions
- Probability distributions can be discrete or continuous. 
- Discrete Random Variable: Takes on a countable number of distinct values (e.g., number of heads in coin flips). 
- Continuous Random Variable: Takes on an infinite number of possible values (e.g., height of students).

| **Distribution** | **Type** | **Range** | **Parameters** | **Formula** | **Example** | **Use Cases** |
|-----------------|----------|-----------|---------------|-------------|-------------|---------------|
| **Normal** | Continuous | âˆ’âˆ to +âˆ | Mean Î¼, Variance ÏƒÂ² | <code>P(x) = (1 / âˆš(2Ï€ÏƒÂ²)) * exp(-((x - Î¼)Â² / (2ÏƒÂ²)))</code> | Human height, exam scores | Linear regression, Gaussian models |
| **Bernoulli** | Discrete | 0, 1 | Probability p | <code>P(X = k) = p^k (1 - p)^(1 - k)</code> | Coin flip | Binary classification |
| **Binomial** | Discrete | 0 to n | Number of trials n, Success probability p | <code>P(k) = C(n, k) * p^k * (1 - p)^(n - k)</code> | Number of heads in 10 coin flips | Binary classification, hypothesis testing |
| **Multinomial** | Discrete | 0 to n for each category | Number of trials n, Probabilities pâ‚, ..., pâ‚– | <code>P(xâ‚, ..., xâ‚–) = (n! / (xâ‚!xâ‚‚!...xâ‚–!)) * âˆ(páµ¢^xáµ¢)</code> | Rolling a dice multiple times | Text classification, NLP |
| **Categorical** | Discrete | 1 to k | Probabilities pâ‚, ..., pâ‚– | <code>P(X = i) = páµ¢</code> | Choosing a color from a set of options | Classification, clustering |

## Week 3

### Zero-R
- A simple baseline model that predicts the most frequent class in the training data.

### One-R
- Also known as Decision stom
- Uses only one feature (â€œbestâ€ feature) to build a model

### Desicion Trees
![Decision Tree Example](Decision-Tree-Example.png)
- Choose an attribute to partition the data at the node such that each partition is as pure (homogeneous) as possible.
- In each partition, most of the instances should belong to as few classes as possible
- Each partition should be as large as possible.

### ID3 (Iterative Dichotomiser 3)
- A top-down approach that splits the data into smaller subsets based on the value of a chosen feature.

#### Entropy (measure of uncertainty. The expected (average) level of uncertainty (surprise))
- For a Low probability event: if it happens, itâ€™s big news! Big surprise! **High information!**
- For a High probability event: it was likely to happen anyway. Not very surprising. **Low information!**
- Higher H means more uncertain. 
- Low entropy means high certainty
- High entropy means high uncertainty
![Entropy Example](Entropy-Example.png)
#### Conditional Entropy measures the amount of uncertainty in X given Y.

#### Information Gain (measure of the reduction in entropy after splitting)
- Information gain measures the reduction in entropy about the target variable achieved by partitioning the data based on a given feature.
- Choose the largest as information gain to split the tree.

#### Shortcomings of IG
- Overfitting: Greedy algorithm may choose a feature that is too specific and does not generalize well to unseen data.
- C4.5: use gain ratio to choose the best feature to split the tree.
   - Gain ratio (GR) reduces the bias for information gain towards highly branching attributes by normalising relative to the split information
   - Split info (SI) is the entropy of a given split (evenness of the distribution of instances to attribute values)
   - GR = IG / SI
   - Choose the largest as GR to split the tree.
   - å¦‚æœä¸‹é¢çš„attributeçš„é€‰é¡¹æ˜¯pureçš„ï¼Œå°±ä¸é€‰æ‹©è¿™ä¸ªé€‰é¡¹ä½œä¸ºç»§ç»­çš„åˆ†æ”¯ï¼Œç„¶ååœ¨å‰©ä½™çš„attributeé‡Œé€‰æ‹©GRæœ€å¤§çš„attributeä½œä¸ºç»§ç»­çš„åˆ†æ”¯ã€‚å¦‚æœä¸‹é¢çš„attributeå…¨æ˜¯pureçš„ï¼Œå°±åˆ°è¾¾äº†å¶å­èŠ‚ç‚¹ã€‚

:::info
è®¡ç®— **ä¿¡æ¯å¢ç›Šï¼ˆInformation Gain, IGï¼‰**ã€**å¢ç›Šç‡ï¼ˆGain Ratio, GRï¼‰** å’Œ **åˆ†è£‚ä¿¡æ¯ï¼ˆSplit Information, SIï¼‰**ï¼Œæˆ‘ä»¬éœ€è¦ä»¥è®­ç»ƒé›†ä¸­çš„â€œPLAYâ€åˆ—ä¸ºç›®æ ‡å˜é‡ï¼ˆlabelï¼‰æ¥è¿›è¡Œåˆ†ç±»è¯„ä¼°ã€‚

ä¸‹é¢æ˜¯é€æ­¥è®²è§£å’Œè®¡ç®—æ–¹æ³•ï¼š

---

## âœ… 1. åŸºç¡€å‡†å¤‡

è®­ç»ƒæ•°æ®ï¼ˆ6ä¸ªå®ä¾‹ï¼‰ï¼š

| ID | Outlook | Temp | Humidity | Wind | PLAY |
| -- | ------- | ---- | -------- | ---- | ---- |
| A  | s       | h    | h        | F    | N    |
| B  | s       | h    | h        | T    | N    |
| C  | o       | h    | h        | F    | Y    |
| D  | r       | m    | h        | F    | Y    |
| E  | r       | c    | n        | F    | Y    |
| F  | r       | c    | n        | T    | N    |

* æ­£ç±»ï¼ˆPLAY=Yï¼‰ï¼šCã€Dã€Eï¼ˆ3ä¸ªï¼‰
* è´Ÿç±»ï¼ˆPLAY=Nï¼‰ï¼šAã€Bã€Fï¼ˆ3ä¸ªï¼‰

---

## âœ… 2. è®¡ç®—æ€»ç†µ Entropy(S)

$$
Entropy(S) = -p_+\log_2(p_+) - p_-\log_2(p_-)
$$

$$
p_+ = 3/6 = 0.5,\quad p_- = 0.5
$$

$$
Entropy(S) = -0.5\log_2(0.5) - 0.5\log_2(0.5) = 1
$$

---

## âœ… 3. å¯¹æ¯ä¸ªå±æ€§è®¡ç®—ä¿¡æ¯å¢ç›Šï¼ˆä»¥ Outlook ä¸ºä¾‹ï¼‰

### Outlook çš„å–å€¼æœ‰ï¼š`s`, `o`, `r`

* **sï¼ˆA, Bï¼‰**ï¼šPLAY = N, N â†’ Entropy = 0
* **oï¼ˆCï¼‰**ï¼šPLAY = Y â†’ Entropy = 0
* **rï¼ˆD, E, Fï¼‰**ï¼šPLAY = Y, Y, N â†’

  $$
  p_+ = 2/3, p_- = 1/3  
  \Rightarrow Entropy = -\frac{2}{3}\log_2\frac{2}{3} - \frac{1}{3}\log_2\frac{1}{3} â‰ˆ 0.918
  $$

åŠ æƒæ€»ç†µï¼š

$$
Entropy_{Outlook} = \frac{2}{6} \cdot 0 + \frac{1}{6} \cdot 0 + \frac{3}{6} \cdot 0.918 â‰ˆ 0.459
$$

**ä¿¡æ¯å¢ç›Š**ï¼š

$$
IG(Outlook) = Entropy(S) - Entropy_{Outlook} = 1 - 0.459 = 0.541
$$

---

## âœ… 4. Split Informationï¼ˆSIï¼‰

$$
SI(Outlook) = -\sum_i \frac{|S_i|}{|S|} \log_2 \frac{|S_i|}{|S|}
$$

* s: 2/6 â†’ logâ‚‚(2/6)
* o: 1/6 â†’ logâ‚‚(1/6)
* r: 3/6 â†’ logâ‚‚(3/6)

$$
SI = -(\frac{2}{6} \log_2 \frac{2}{6} + \frac{1}{6} \log_2 \frac{1}{6} + \frac{3}{6} \log_2 \frac{3}{6})  
\approx -(0.389 + 0.431 + 0.5) = 1.32
$$

---

## âœ… 5. Gain Ratioï¼ˆGRï¼‰

$$
GR = \frac{IG}{SI} = \frac{0.541}{1.32} â‰ˆ 0.41
$$

---

## âœ… ç±»ä¼¼æ–¹æ³•å¯ä»¥åº”ç”¨äºå…¶ä»–ç‰¹å¾ï¼š

* æŒ‰ç…§å±æ€§å€¼åˆ†ç»„ï¼Œè®¡ç®—æ¯ç»„çš„ç†µå’ŒåŠ æƒç†µ
* å†ç®—ä¿¡æ¯å¢ç›Šï¼ˆIGï¼‰
* å†ç®—åˆ†è£‚ä¿¡æ¯ï¼ˆSIï¼‰
* æœ€åç®—å¢ç›Šç‡ï¼ˆGRï¼‰

:::

### Naive Bayes Theory
:::info
arg max: argument of maximum value
:::

- Supervied ML method

#### Example:
![Naive Bayes Example1-1](Naive-Bayes-Example-1-1.png)
![Naive Bayes Example1-2](Naive-Bayes-Example-1-2.png)

- If any term P(xm|y ) = 0 then the class probability P(y|x ) = 0
- To solve this: use Laplace smoothing.

1. First Solution: We can assign a (small) positive probability ğœ€ to every unseen class-feature combination
2. Second Solution: We can add a â€œpseudocountâ€ Î± to each feature count observed during training, often is 1.

- Probabilities are changed drastically when there are few instances; with a large number of instances, the changes are small
-  Laplace smoothing (and smoothing in general) **reduces variance** of the NB classifier because it reduces sensitivity to individual (non-)observations in the training data

### Different Naive Bayes

NaÃ¯ve Bayes classifiers have several key variants that differ based on how they model the distribution of features. Below is a comparison of the most common types:

| Variant        | Assumption on Feature Distribution | Use Case |
|--------------|----------------------------------|---------|
| **Gaussian NaÃ¯ve Bayes (GNB)** | Assumes features follow a Gaussian (normal) distribution. | Suitable for continuous data, often used in text classification and real-world datasets with normally distributed features. |
| **Multinomial NaÃ¯ve Bayes (MNB)** | Assumes feature counts follow a multinomial distribution. | Best for text classification (e.g., spam detection, document classification) where features are word counts or term frequencies. |
| **Bernoulli NaÃ¯ve Bayes (BNB)** | Assumes binary feature presence (1 = present, 0 = absent). | Used in binary text classification (e.g., sentiment analysis, spam filtering), where features represent whether a word appears in a document. |
| **Complement NaÃ¯ve Bayes (CNB)** | A modification of Multinomial NaÃ¯ve Bayes, designed to handle class imbalances. | Works better for imbalanced datasets and improves accuracy by adjusting feature probabilities. |
| **Categorical NaÃ¯ve Bayes** | Assumes features are discrete categorical variables. | Used for classification tasks with categorical inputs that are not necessarily text-based. |

Each variant modifies the way probabilities are calculated based on the data's nature, making NaÃ¯ve Bayes a flexible and effective algorithm for different types of classification tasks.


### Conclusion of Naive Bayes
1. Why does it work given that itâ€™s a blatantly wrong model of the data?
- we donâ€™t need the true distribution over P(y|x ), we just need to be able to identify the most likely outcome

2. Advantages of Naive Bayes
- easy to build and estimate
- easy to scale to many feature dimensions (e.g., words in the vocabulary) and data sizes
- reasonably easy to explain why a specific class was predicted
- good starting point for a classification project

:::info
### How NB Works
- Calculate Prior Probabilities: Compute the probability of each class based on the training data.
- Compute Likelihood: Estimate the probability of features given each class using the conditional probability formula.
- Apply Bayesâ€™ Theorem: Use Bayes' rule to compute the posterior probability for each class.
- Classify: Assign the class with the highest posterior probability to the new instance.
:::

## Week 4

### Linear Regression
- A supervised learning algorithm that models the relationship between a scalar dependent variable (y) and one or more explanatory variables (X1, X2,..., Xn).
- The model assumes that the relationship between the dependent and independent variables is linear.
- The goal is to find the best line that fits the data.

#### Loss Function
- The loss function measures the error between the predicted values and the actual values.
- The loss function is used to optimize the model parameters (i.e., the weights and biases) to minimize the loss.

:::info
- When using a regression model for prediction, it is important to only predict within the relevant range of data
- We should not try to extrapolate beyond the range of observed Xâ€™s
- Make sure independent variables are NOT highly correlated with each other, otherwise the model becomes unstable
:::

### Optimization
- Find parameter values ğœ½ that maximize (or minimize) the value of a function f(ğœ½)

### Iterative Optimization
#### Closed-form solutions
- Previously, we computed the closed form solution for the MLE of the binomial distribution
- We follow our recipe, and arrive at a single solution
#### Unfortunately, life is not always as easy
- Often, no closed-form solution exists
- Instead, we have to iteratively improve our estimate of Î¸Ë† until we arrive at a satisfactory solution
- Gradient descent is one popular iterative optimization method

### Gradient Descent
- Descending a mountain (aka. our function) as fast as possible: atevery position take the next step that takes you most directly into the valley

![Gradient Descent](gradient-descent.png)
![Gradient Descent Algorithm](gd-algo.png)

:::info
1. with an appropriate learning rate, GD will find the global minimum for differentiable convex functions (bowl shape)
2. with an appropriate learning rate, GD will find a local minimum for differentiable non-convex functions
:::

### Logistic Regression
| **Comparison**       | **NaÃ¯ve Bayes**                         | **Logistic Regression**                  |
|----------------------|--------------------------------------|----------------------------------------|
| **Model Type**       | Generative Model                    | Discriminative Model                  |
| **Probability Learned** | \( P(x, y) \) (Joint Probability) | \( P(y | x) \) (Conditional Probability) |
| **Assumptions**      | Assumes feature independence        | No specific feature independence assumption |
| **Computational Complexity** | Low, fast computation          | Higher, requires gradient descent     |
| **Use Cases**        | Text classification (e.g., spam detection) | Tasks requiring feature relationship modeling |
| **Suitable for Large Datasets?** | Yes, simple computation   | Yes, but computationally more intensive |

:::info
## Understanding Odds and Log Odds in Logistic Regression

## 1. What are Odds?

Odds represent the ratio of the probability of an event occurring to the probability of it not occurring. Mathematically, odds are defined as:

\[
\text{odds} = \frac{P}{1 - P}
\]

where:
- \( P \) is the probability of the event occurring.
- \( 1 - P \) is the probability of the event not occurring.

### **Types of Odds**
- **Odds against an event**: When \( 0 < \text{odds} < 1 \), meaning the event is less likely to happen than not.
- **Odds in favor of an event**: When \( \text{odds} > 1 \), meaning the event is more likely to happen than not.

**Example:**
- If an event has a **60% chance** of occurring (\( P = 0.6 \)), the odds are:
  \[
  \text{odds} = \frac{0.6}{1 - 0.6} = \frac{0.6}{0.4} = 1.5
  \]
  This means the event is **1.5 times more likely** to occur than not.

## 2. Why Use Log Odds (Logit Function)?

Since odds can range from **0 to infinity**, they are not ideal for direct modeling in a regression setting. Instead, we take the **logarithm of odds**, known as the **logit function**:

\[
\text{log odds} = \log \left(\frac{P}{1 - P}\right)
\]

### **Advantages of Log Odds:**
1. **Transforms probability into an unrestricted range**  
   - \( P \) is always between \( 0 \) and \( 1 \), but log odds can take any value from **\(-\infty\) to \(+\infty\)**.
   - This makes it easier to model using linear regression techniques.

2. **Handles Non-Linearity in Probability**  
   - The relationship between probability and log odds is **non-linear**, but when transformed to log odds, it becomes **linear**.

**Example Calculation:**
- If the event has a probability of \( P = 0.8 \):
  \[
  \text{odds} = \frac{0.8}{1 - 0.8} = \frac{0.8}{0.2} = 4
  \]
  - Taking the natural logarithm:
    \[
    \log(4) \approx 1.386
    \]
  - Now, instead of dealing with probabilities, we can work with a linear scale.

## 3. Connection to Logistic Regression

In **logistic regression**, we model the probability of an event occurring using the equation:

\[
\log \left(\frac{P}{1 - P}\right) = \theta_0 + \theta_1 x_1 + \theta_2 x_2 + ... + \theta_n x_n
\]

This means:
- Instead of predicting probabilities directly, logistic regression predicts **log odds**, which follow a linear relationship with input features.
- We then use the **sigmoid function** to convert log odds back into probabilities.

## 4. Conclusion

- **Odds** measure how likely an event is compared to it not happening.
- **Log odds (logit function)** transform probabilities into a linear form, making them easier to model.
- Logistic regression leverages log odds to predict probabilities effectively.

Understanding this transformation is key to interpreting logistic regression results and making informed predictions.

:::

- Logit function: The logarithm of the odds.
### Softmax function: The function that converts a vector of real numbers to a probability distribution.

### Logistic Regression Summary
1.  Pros
- Probabilistic interpretation
- No restrictive assumptions on features
- Often outperforms Naive Bayes
- Particularly suited to frequency-based features (so, popular in NLP)
2. Cons
- Can only learn linear feature-data relationships
- Some feature scaling issues
- Often needs a lot of data to work well
- Regularisation a nuisance, but important since overfitting can be a big problem

## Week 5
### Support Vector Machines (SVM) 
#### Classifier
- A linear classifier (through origin) with parameters divides the space into positive and negative halves

### Hard Margin
![Hard Margin](margin.png)
- The margin is the distance between the decision boundary and the closest data point.
- The goal is to maximize the margin while keeping the data points as far away from the decision boundary as possible.
- The decision boundary is the line that separates the positive and negative data points.
- It is called hard margin because the data points must be correctly classified on both sides of the decision boundary.

#### Soft Margin
- The margin is softened by introducing a penalty term that depends on the distance of the data points from the decision boundary.
- The goal is to minimize the margin while keeping the data points as far away from the decision boundary as possible.
- The decision boundary is the line that separates the positive and negative data points.
- It is called soft margin because the data points can be misclassified on both sides of the decision boundary.


:::info
### Kernel Trick
- The kernel trick is a way to transform non-linear data into a higher-dimensional space where it becomes linearly separable.
- The kernel function is a similarity function that measures the similarity between two data points in the original space.
- The kernel trick allows us to use non-linear models in a linear model.
:::

### Applications of SVM
#### Multiclass problems
1. **Introduce parameter vectors**: If there are \( k \) categories, we introduce a parameter vector \( \theta_1, \theta_2, \ldots, \theta_k \) for each category.
2. **Jointly learn parameters**: Jointly learn these parameters by ensuring that the discriminant function associated with the correct category has the highest value. The goal is to minimize the following expression:
   \[
   \frac{1}{2} \sum_{y=1}^{k} \| \theta_y \|^2
   \]
   The constraint is that for all \( y' \neq y_i \) and \( i = 1, \ldots, n \), it satisfies:
   \[
   (\theta_{y_i} \cdot x_i) \geq (\theta_{y'} \cdot x_i) + 1
   \]
3. **Predict new examples**: Predict the label of a new example based on the following formula:
   \[
   \hat{y} = \arg\max_{y=1,\ldots,k} (\theta^*_y \cdot x)
   \]
#### Rating problems
#### Ordinal regression problems
- Target variable: The target variable in ordinal regression is an ordinal variable, where the categories have a certain order, such as education level (elementary, middle school, high school, university, graduate) or movie ratings (1 star to 5 stars).
- Model purpose: Unlike multiclass classification problems, ordinal regression models not only predict the correct category but also the order relationship between categories.

#### Translate each rating into a set of binary labels
- We can convert these labels into binary labels. For example, we can divide the ratings into two categories: "like" and "dislike". Here is a simple conversion example:

- 1 star and 2 stars: Dislike (represented by 0)
- 3 stars: May require additional processing as it can be considered neutral or context-dependent
- 4 stars and 5 stars: Like (represented by 1)
- Alternatively, we can create a binary label for each rating level as follows:

- 1 star: [1, 0, 0, 0, 0]
- 2 stars: [0, 1, 0, 0, 0]
- 3 stars: [0, 0, 1, 0, 0]
- 4 stars: [0, 0, 0, 1, 0]
- 5 stars: [0, 0, 0, 0, 1]


### Ranking
- In machine learning, ranking tasks typically involve ordering a set of items such that certain items have higher priority over others. SVM can address ranking problems by modifying the standard binary classification SVM, a method commonly known as RankSVM. RankSVM learns a ranking function through pairwise comparisons, ensuring that positive examples rank higher than negative ones.

### Structured prediction
- Structured prediction is a branch of machine learning that involves predicting structured outputs, such as sequences, trees, or graphs. SVM can be extended to handle these problems through Structured SVM. Structured SVM learns a prediction function by maximizing the margin, which can output entire structures rather than simple class labels. This approach is particularly useful in fields like natural language processing, bioinformatics, and computer vision.

**The core idea of Support Vector Machines (SVM) is to find an optimal hyperplane that best separates data points of different classes while maximizing the margin between the classes. This margin is the distance from the hyperplane to the nearest training data point. The goal of SVM is to find a hyperplane with the largest margin, which can improve the model's generalization ability and reduce the risk of overfitting.**

## Week 6 
:::info
| æ–¹æ³•                   | æè¿°             | ä¼˜ç‚¹        | ç¼ºç‚¹             |
| -------------------- | -------------- | --------- | -------------- |
| **Holdout**          | ç®€å•åˆ’åˆ†ä¸ºè®­ç»ƒ+æµ‹è¯•     | å¿«é€Ÿã€å®ç°ç®€å•   | ç»“æœå¯èƒ½ä¸ç¨³å®š        |
| **Stratification**   | åˆ†å±‚æŠ½æ ·ï¼Œä¿æŒç±»åˆ«åˆ†å¸ƒ    | ä¿è¯å„ç±»åˆ«æ¯”ä¾‹å‡è¡¡ | é€šå¸¸ä¸å…¶ä»–æ–¹æ³•ç»“åˆä½¿ç”¨    |
| **Cross-validation** | å¤šæ¬¡åˆ’åˆ†è®­ç»ƒ+éªŒè¯ï¼Œè½®æµè®­ç»ƒ | ç»“æœç¨³å¥ã€æ³›åŒ–æ›´å¥½ | è®¡ç®—æˆæœ¬è¾ƒé«˜ï¼ˆè®­ç»ƒå¤šæ¬¡æ¨¡å‹ï¼‰ |

| Scenario | Holdout | Cross-Validation |
|----------|--------|------------------|
| Large dataset (millions of records) | âœ… Works well | âŒ Too slow |
| Small dataset (few thousand samples) | âŒ Might not be reliable | âœ… More accurate |
| Need fast evaluation | âœ… Quick & simple | âŒ Computationally heavy |
| Hyperparameter tuning | âŒ Risky (prone to overfitting) | âœ… More stable |
| Deep learning models (large compute cost) | âœ… Saves time | âŒ Too expensive |
:::
### Evaluation 
if our model will perform effectively on unseen data

#### Holdout
- Split the data randomly into two parts: a training set and a test set.
- Train the model on the training set and evaluate it on the test set.

#### Holdout Weakness
- The size of the split affects the estimate of the modelâ€™s behaviour: Lots of test instances, and few training instances â†’ , the learner doesnâ€™t have enough information to build an accurate model. Lots of training instances, and few test instances â†’ learner builds an accurate model, but test data might not be representative (so estimates of performance can be too high/too low)
- Bias in Sampling: Random sampling of data can lead to different distribution in train and test datasets

#### Stratification
- Stratification ensures that each fold or partition of the data maintains the same class distribution as the original dataset

#### Stratification Weakness
- Complexity: Can be more complex to implement compared to simple random sampling.
- Inefficient Resource Utilization: some data is only used for training and some only for testing

#### k-fold Cross-validation
- Divide the data into k equal parts, and use k-1 parts for training and 1 part for testing.
- Repeat k times, each time using a different part for testing and the remaining parts for training.
- The average performance of the k models is the estimate of the performance of the model on the entire dataset.

#### k-fold Cross-validation Weakness
- Fewer folds: more instances per partition, more variance in performance estimates
- More folds: fewer instances per partition, less variance but slower

#### Hyperparameter Tuning
- If the Decision Tree is too short (Depth is too small), The DT would be too simple (Something like 1-R)
- If the Decision Tree is too long (Depth is too big), The DT would be too complex and cannot generalize well
- To decide about the best depth for a tree (and other hyperparameters), we need a way to measure how well our tree can - edict labels for new, unseen data.
- Butâ€¦ If we use our Test data for hyperparameter tuning, then we donâ€™t have any other (unseen) data to test the performance of the final model (after the hyperparameter tuning) â†’ It will cause data leakage
- We need a third set â†’ Validation data, or use cross-validation to split the data into training, validation, and test sets.

### Classification Evaluation Metrics
- We can present all possible classification results a two-class problem in the following **confusion matrix**.
- **Confusion matrix is for classification problems.**
- True Positive (TP): The model correctly predicts the positive class.
- False Positive (FP): The model incorrectly predicts the positive class.
- True Negative (TN): The model correctly predicts the negative class.
- False Negative (FN): The model incorrectly predicts the negative class.

#### Recall
- Recall: From the cases that are actually positive, what percentage has been correctly identified (predicted positive) by our classifier. **Recall = TP / (TP + FN)**

#### Precision
- From the cases that are predicted positive, what percentage are actually positive. **Precision = TP / (TP + FP**)

#### F1-score
- A popular metric that can help with finding a balance between Precision & Recall is F1-Score. F1-Score is the harmonic mean of Precision and Recall. **F1-Score = 2 * (Precision * Recall) / (Precision + Recall)**

### Averaging methods
In multi-class problems, Macro Averaging, Micro Averaging, and Weighted Averaging are three methods for calculating the average precision or recall. These methods are particularly useful in evaluating the performance of classification models, especially in datasets with imbalanced classes.
Here is a brief description of these three methods:
### 1. Macro Averaging
Macro Averaging first calculates the metrics (such as precision, recall, or F1 score) for each class, and then calculates the simple arithmetic average of these metrics. It treats each class as equally important, without considering the actual frequency or size of the classes.
The calculation formula is as follows:
$$
\text{Macro Average} = \frac{1}{N} \sum_{i=1}^{N} \text{metric}_i
$$
Where, $N$ is the total number of classes, and $\text{metric}_i$ is the value of the metric for the $i$-th class.
**Advantages**: Each class is treated equally, so this may be a better metric for imbalanced datasets.
**Disadvantages**: If some classes are very few, they may disproportionately affect the overall performance evaluation.
### 2. Micro Averaging
Micro Averaging first calculates the total precision, total recall, and total F1 score for all classes, and then calculates the arithmetic average of these totals. It calculates the metrics by considering individual predictions in each class, so it takes into account the actual frequency of the classes.
The calculation formula is as follows:
$$
\text{Micro Average Precision} = \frac{\sum_{i=1}^{N} TP_i}{\sum_{i=1}^{N} TP_i + \sum_{i=1}^{N} FP_i}
$$
$$
\text{Micro Average Recall} = \frac{\sum_{i=1}^{N} TP_i}{\sum_{i=1}^{N} TP_i + \sum_{i=1}^{N} FN_i}
$$
Where, $TP_i$, $FP_i$, and $FN_i$ are the numbers of true positives, false positives, and false negatives, respectively, for the $i$-th class.
**Advantages**: It takes into account the true distribution of each class, so it is usually a more reliable metric for imbalanced datasets.
**Disadvantages**: It may overlook the imbalance between classes, as the contributions of all classes are averaged.
### 3. Weighted Averaging
Weighted Averaging is a variant of Macro Averaging, which takes into account the support of each class (i.e., the number of instances in each class). The value of the metric for each class is multiplied by the support of that class, and then the average of these weighted values is calculated.
The calculation formula is as follows:
$$
\text{Weighted Average} = \frac{\sum_{i=1}^{N} (\text{metric}_i \times \text{support}_i)}{\sum_{i=1}^{N} \text{support}_i}
$$
Where, $\text{metric}_i$ is the value of the metric for the $i$-th class, and $\text{support}_i$ is the support of the $i$-th class.
**Advantages**: It takes into account the relative size of each class, so it is a fairer metric for imbalanced datasets.
**Disadvantages**: Like Macro Averaging, it may give disproportionate weight to minority classes, which may distort the overall performance evaluation.
The choice of which averaging method to use depends on the specific application scenario and the characteristics of the dataset. In the case of class imbalance, Weighted Averaging is often considered the best choice, as it simultaneously considers the performance and relative importance of each class.

:::info
- If we want to prioritize small classes and ensure each class is given equal importance, macro averaging is the better choice.
- If we care more about overall system performance, where larger classes influence the results more (common in real-world applications like fraud detection), micro averaging is preferable.
:::

### **Regression** Performance Metrics
#### MSE, RMSE, and MAE (Mean Squared Error, Root Mean Squared Error, and Mean Absolute Error)
- Sum of Squared Errors (SSE) is the sum of the squared differences between the predicted and actual values.
- MSE emphasizes larger errors due to squaring and is sensitive to outliers.
- RMSE is the square root of MSE, providing a more interpretable metric in the same units as the target variable.
- MAE treats all errors equally, is less sensitive to outliers, and provides a straightforward average error measure.

![Generalization Problem](generalization.png)
1. Evidence of overfitting: large gap between training and test performance
2. Evidence of underfitting: High error rate for both test and training set

### Learning Curves
- A learning curve is a plot of learning performance over experience or time
- y-axis: Performance measured by accuracy, error rate or other metrics
- x-axis: conditions, e.g., sizes of training sets, model complexity, number of iterationsâ€¦
- The learning curve can be used to identify overfitting, underfitting, or a suitable trade-off between the two.
- Training learning curve: calculated from the training set that shows how well the model is learning.
- Validation learning curve: calculated from a holdout set that shows how well the model is generalising.

#### data trade-off
- More training instances? â†’ (usually) better model
- More evaluation instances? â†’ more reliable estimate of effectivenes 

### Bias and Variance
- Model bias: the tendency of our model to make systematically wrong predictions
- Evaluation bias: the tendency of our evaluation strategy to over- or under-estimate the effectiveness of our model
- Sampling bias: if our training or evaluation dataset isnâ€™t representative of the population.

- Model variance: Sensitivity of a machine learning model's predictions to small changes in the training data, leading to different outcomes when the model is trained on different subsets of the data.
- Evaluation variance: Variability in the performance metrics of a model (such as accuracy, precision, or recall) when evaluated across different test datasets or under different evaluation conditions.

## Week 7: Feature Selection
### Univariate Methods
*   **Concept**: Evaluate each feature individually in relation to the target variable.
*   **Advantages**:
    *   Intuitive approach to assess the "goodness" of each attribute.
    *   Model-independent.
    *   Linear time complexity with respect to the number of attributes.
*   **Good Features**: Features that are "correlated" with the label and can predict it effectively.
*   **Methods**:
    *   **Signal-to-Noise Ratio (SNR)**: Select features with high SNR.
    *   **Mutual Information (MI)**: Measures the dependence between the target variable and each feature. Select features with high MI.
    *   **Chi-Squared Test**: Determines if there is a significant association between categorical variables (for classification tasks).
    *   **ANOVA F-value**: Evaluates the significance of individual features in a dataset (for classification tasks with continuous features).
    *   **Correlation-based Feature Selection (CFS)**: Measures the correlation between each feature and the target variable. Selects features with high correlation.
### Multivariate Methods
*   **Concept**: Consider subsets of features together to capture their combined predictive power.
*   **Limitations of Univariate Methods**: Sometimes, single features may not provide good classification, but a combination of features can lead to better decision boundaries.
*   **Complexity**: Choosing the optimal subset of attributes that gives the best performance on the validation data.
*   **Feature Subset Assessment**:
    *   Split data into training, validation, and test sets.
    *   Train a classifier on each feature subset using the training data.
    *   Select the feature subset that performs best on the validation data.
    *   Test the selected subset on the test data.
*   **Algorithms**: ![feature selection algorithms](./feature_selection.png)
### Filter Methods
*   **Concept**: Rank features (or feature subsets) independently of the classifier based on a predefined criterion.
*   **Criterion**: Measure the "relevance" of each feature (or feature subset) with respect to the target variable.
*   **Search Strategy**: Typically involves sorting features based on individual rankings or nested subsets.
*   **Assessment**: No direct assessment, but cross-validation can be used to determine the optimal number of features to select.
### Wrapper Methods
*   **Concept**: Use a classifier to evaluate the "usefulness" of different feature subsets.
*   **Criterion**: Measure the predictive power of each feature subset.
*   **Search Strategy**: Search through the space of all possible feature subsets. Train a new classifier for each candidate subset.
*   **Assessment**: Use cross-validation to evaluate the performance of each subset.
### Embedded Methods
*   **Concept**: Similar to wrapper methods, but utilize the classifier's internal knowledge to guide the search for the best feature subset, avoiding the need to train a new classifier for every candidate subset.
*   **Criterion**: Measure the "usefulness" of each feature subset.
*   **Search Strategy**: Guided search based on the classifier's knowledge.
*   **Assessment**: Use cross-validation.
### Forward Selection (Wrapper Method)
*   **Running Time**: Increases with the number of attributes.
*   **Advantages**: Performs well when the optimal subset is small.
*   **Disadvantages**: May converge to a suboptimal solution and is not feasible for large datasets.
### Forward Selection (Embedded Method)
*   **Running Time**: Faster than the wrapper method.
*   **Advantages**: Uses the classifier's knowledge to evaluate candidate features.
### Backward Elimination (Wrapper Method)
*   **Running Time**: Increases with the number of attributes.
*   **Advantages**: Removes the most irrelevant attributes at the beginning.
*   **Disadvantages**: May converge to a suboptimal solution and is not feasible for large datasets.
### Backward Elimination (Embedded Method)
*   **Running Time**: Faster than the wrapper method.
*   **Advantages**: Uses the classifier's knowledge to evaluate candidate features.
### L0-Norm Regularization
*   **Concept**: Directly minimize the number of features used by the algorithm by promoting zero entries in the weight vector.
*   **Objective Function**: Minimize the number of non-zero entries in the weight vector.
*   **Challenges**: The objective function is non-continuous and non-convex, making the optimization problem combinatorially hard.
### L1-Norm Regularization
*   **Concept**: Use a convex function to promote sparsity in the weight vector, resulting in fewer non-zero entries.
*   **Objective Function**: Minimize the L1 norm of the weight vector (taxicab norm or Manhattan norm).
*   **Advantages**: The optimization problem is convex, making it easier to solve.
*   **Result**: The solution typically has fewer non-zero entries, effectively performing feature selection.

**ä¸»æˆåˆ†åˆ†æ (PCA**)
* **ç›®æ ‡**ï¼šæ‰¾åˆ°ä¸€ç»„æ­£äº¤çš„åŸºå‘é‡ï¼Œèƒ½å¤Ÿæœ€å¤§é™åº¦åœ°è§£é‡Šæ•°æ®æ–¹å·®ã€‚
* **æ­¥éª¤**ï¼š
    1. **æ•°æ®ä¸­å¿ƒåŒ–**ï¼šå°†æ•°æ®é›†ä¸­çš„æ¯ä¸ªç‰¹å¾å‡å»å…¶å‡å€¼ï¼Œæ¶ˆé™¤å‡å€¼çš„å½±å“ã€‚
    2. **è®¡ç®—åæ–¹å·®çŸ©é˜µ**ï¼šè®¡ç®—ä¸­å¿ƒåŒ–æ•°æ®çŸ©é˜µçš„åæ–¹å·®çŸ©é˜µã€‚
    3. **ç‰¹å¾å€¼åˆ†è§£/å¥‡å¼‚å€¼åˆ†è§£**ï¼šè®¡ç®—åæ–¹å·®çŸ©é˜µçš„ç‰¹å¾å€¼å’Œç‰¹å¾å‘é‡ï¼Œæˆ–è€…å¯¹ä¸­å¿ƒåŒ–æ•°æ®çŸ©é˜µè¿›è¡Œ SVDã€‚
    4. **é€‰æ‹©ä¸»æˆåˆ†**ï¼šé€‰æ‹©å‰ m ä¸ªç‰¹å¾å€¼æœ€å¤§çš„ç‰¹å¾å‘é‡ä½œä¸ºä¸»æˆåˆ†ã€‚
    5. **æ•°æ®é™ç»´**ï¼šå°†åŸå§‹æ•°æ®æŠ•å½±åˆ°ä¸»æˆåˆ†æ„æˆçš„å­ç©ºé—´ä¸­ï¼Œå®ç°é™ç»´ã€‚
- **PCA çš„ä¼˜åŠ¿**ï¼š
* **ç®€åŒ–æ•°æ®**ï¼šå‡å°‘å˜é‡æ•°é‡ï¼Œé™ä½æ¨¡å‹å¤æ‚åº¦ã€‚
* **æ­ç¤ºæ½œåœ¨ç»“æ„**ï¼šæ‰¾åˆ°æ•°æ®èƒŒåçš„æ½œåœ¨ç»´åº¦ï¼Œå¸®åŠ©ç†è§£æ•°æ®æœ¬è´¨ã€‚
* **æé«˜æ•ˆç‡**ï¼šé™ä½è®¡ç®—æˆæœ¬ï¼Œæé«˜æ¨¡å‹è®­ç»ƒå’Œé¢„æµ‹é€Ÿåº¦ã€‚
- **PCA çš„å±€é™æ€§**ï¼š
* **æ— æ³•åˆ©ç”¨ç±»åˆ«æ ‡ç­¾ä¿¡æ¯**ï¼šPCA æ— æ³•åŒºåˆ†ä¸åŒç±»åˆ«ã€‚
* **æœ€å¤§åŒ–æ–¹å·®**ï¼šPCA æœ€å¤§åŒ–æ–¹å·®ï¼Œä½†ä¸ä¸€å®šèƒ½å¤ŸåŒºåˆ†ä¸åŒç±»åˆ«ã€‚
- **PCA çš„åº”ç”¨**ï¼š
* **å›¾åƒå‹ç¼©**ï¼šå°†å›¾åƒåˆ†å‰²æˆå°å—ï¼Œå¹¶å°†æ¯ä¸ªå°å—æŠ•å½±åˆ°ä½ç»´å­ç©ºé—´ä¸­ï¼Œå®ç°å‹ç¼©ã€‚
* **é¢éƒ¨è¡¨æƒ…è¯†åˆ«**ï¼šå°†é¢éƒ¨å›¾åƒæŠ•å½±åˆ°ä½ç»´å­ç©ºé—´ä¸­ï¼Œæå–å…³é”®ç‰¹å¾ï¼Œç”¨äºè¡¨æƒ…è¯†åˆ«ã€‚
**PCA çš„è¯„ä¼°**ï¼š
* **é¿å…ç ´åäº¤å‰éªŒè¯**ï¼šä¸è¦åœ¨æ•´ä¸ªæ•°æ®é›†ä¸Šè¿›è¡Œé™ç»´ï¼Œå¦åˆ™ä¼šç ´åäº¤å‰éªŒè¯ã€‚
* **åœ¨äº¤å‰éªŒè¯çš„è®­ç»ƒé›†ä¸Šè¿›è¡Œé™ç»´**ï¼šåœ¨äº¤å‰éªŒè¯çš„æ¯ä¸ªè®­ç»ƒé›†ä¸Šè¿›è¡Œé™ç»´ï¼Œå¹¶åœ¨éªŒè¯é›†ä¸Šè¿›è¡Œè¯„ä¼°ã€‚

## Week 8
- æœ´ç´ è´å¶æ–¯å’Œé€»è¾‘å›å½’éƒ½æ˜¯åŸºäºæ¦‚ç‡æ¨¡å‹çš„åˆ†ç±»ç®—æ³•ï¼Œä½†æœ´ç´ è´å¶æ–¯å‡è®¾ç‰¹å¾ä¹‹é—´ç›¸äº’ç‹¬ç«‹ï¼Œè€Œé€»è¾‘å›å½’åˆ™æ²¡æœ‰è¿™ä¸ªé™åˆ¶ã€‚
- æ„ŸçŸ¥å™¨ä¸ä½¿ç”¨æ¦‚ç‡æ¨¡å‹ï¼Œè€Œæ˜¯ç›´æ¥ä¼˜åŒ–åˆ†ç±»é”™è¯¯ç‡ï¼Œæ›´åŠ ç®€å•ç›´è§‚ã€‚

### ANN
- Artificial neural network is a network of processing elements
- Each element converts inputs to output
- The output is a function (called activation function) of a weighted sum of inputs
- Training an ANN means adjusting weights for training data given a pre-defined network topology

### Perceptron
- The Perceptron is a minimal neural network
- neural networks are composed of neurons
- A neuron is defined as y = f(Î¸0 + Î¸1 x1 +...+ Î¸d xd)

### Perceptron Algorithm
- supervised classification algorithm
- æ„ŸçŸ¥å™¨é€šè¿‡è°ƒæ•´æƒé‡æ¥ä¼˜åŒ–æ€§èƒ½ï¼Œå¹¶é€šè¿‡æ¯”è¾ƒé¢„æµ‹è¾“å‡ºä¸çœŸå®è¾“å‡ºä¹‹é—´çš„å·®å¼‚æ¥æ›´æ–°æƒé‡ã€‚å¦‚æœé¢„æµ‹æ­£ç¡®ï¼Œåˆ™ä¸åšä»»ä½•æ”¹å˜ï¼›å¦‚æœé¢„æµ‹é”™è¯¯ï¼Œåˆ™æ ¹æ®å®é™…æƒ…å†µå¢åŠ æˆ–å‡å°‘æƒé‡ã€‚
- ä¸€ä¸ªepochå°±æ˜¯å®Œæˆä¸€æ¬¡å®Œæ•´çš„è®­ç»ƒè¿‡ç¨‹
- if mistakes: ğ‘¦(ğœƒ â‹… ğ’™) â‰¤ 0, we need to update
- æ„ŸçŸ¥å™¨ç®—æ³•é€šè¿‡è¿­ä»£åœ°æ›´æ–°æƒé‡æ¥æœ€å°åŒ–è¯¯åˆ†ç±»çš„æ•°é‡ã€‚æ¯æ¬¡è¿­ä»£ä¸­ï¼Œå¦‚æœå‘ç°æŸä¸ªæ ·æœ¬è¢«è¯¯åˆ†ç±»ï¼Œå°±æ ¹æ®å­¦ä¹ ç‡å’Œæ ·æœ¬çš„ç‰¹å¾æ›´æ–°æƒé‡ã€‚è¿™ä¸ªè¿‡ç¨‹é‡å¤è¿›è¡Œç›´åˆ°è¾¾åˆ°é¢„å®šçš„epochæ•°ã€‚
- can set learning rate ğœ‚ as 1 for simplicity

### Online learning vs. Batch learning
- The perceptron algorithm is an online algorithm: update weights after each training example
- In contrast, Naive Bayes and logistic regression (with Gradient Descent) are batch algorithms

### Multi-layer perceptron
- Input layer with input units x: the first layer, takes features x as inputs
- Output layer with output units y: the last layer, has one unit per
possible output (e.g., 1 unit for binary classification)
- Hidden layers with hidden units h: all layers in between.

### Multi-layer Perceptron vs. other Neural Networks
#### Multi-layer Perceptron
- One specific type of neural network
- Feed-forward
- Fully connected
- Supervised learner
#### Other types of neural networks
- Convolutional neural networks
- Recurrent neural networks
- Autoencoder (unsupervised)

### Linear vs. Non-linear classification
#### Linear classification
- The perceptron, naive bayes, logistic regression are linear classifiers
- Decision boundary is a linear combination of features Ïƒğ‘– ğœƒğ‘–ğ‘‹ğ‘–
- Cannot learnâ€˜feature interactionsâ€™ naturally
#### Non-linear classification
- Neural networks with at least 1 hidden layer and non-linear activations
- Decision boundary is a non-linear function of the inputs

### Feature engineering vs feature learning
| é¡¹ç›®           | Feature Engineeringï¼ˆç‰¹å¾å·¥ç¨‹ï¼‰              | Feature Learningï¼ˆç‰¹å¾å­¦ä¹ ï¼‰         |
| ------------ | -------------------------------------- | ------------------------------ |
| **ä½¿ç”¨æ–¹å¼**     | äººå·¥è®¾è®¡å¹¶æå–ç‰¹å¾ä½œä¸ºæ¨¡å‹è¾“å…¥                        | æ¨¡å‹ä»åŸå§‹æ•°æ®ä¸­è‡ªåŠ¨å­¦ä¹ ç‰¹å¾                 |
| **å…¸å‹æ¨¡å‹**     | æ„ŸçŸ¥æœºã€æœ´ç´ è´å¶æ–¯ã€é€»è¾‘å›å½’ã€å†³ç­–æ ‘ç­‰                    | ç¥ç»ç½‘ç»œï¼ˆMLPã€CNNã€RNNã€Transformerç­‰ï¼‰ |
| **æ•°æ®è¾“å…¥**     | éœ€è¦æ˜¯äººç±»ç†è§£çš„ã€é«˜è´¨é‡çš„â€œç‰¹å¾â€ï¼ˆå¦‚ sunny, overcast ç­‰ï¼‰ | åŸå§‹çš„æ•°å€¼æ•°æ®ï¼Œå¦‚å›¾åƒåƒç´ ã€æ–‡æœ¬è¯å‘é‡ã€éŸ³é¢‘ä¿¡å·       |
| **æ˜¯å¦éœ€è¦é¢†åŸŸçŸ¥è¯†** | âœ… éœ€è¦ï¼Œç‰¹å¾æå–è¦ä¾èµ–ä¸“å®¶ç»éªŒ                       | âŒ ä¸éœ€è¦ï¼Œæ¨¡å‹è‡ªåŠ¨å­¦å‡ºä¸ä»»åŠ¡ç›¸å…³çš„ç‰¹å¾           |
| **æ§åˆ¶æƒ/å¯è§£é‡Šæ€§** | é«˜ï¼ˆä½ çŸ¥é“æ¨¡å‹åœ¨ç”¨ä»€ä¹ˆç‰¹å¾ï¼‰                         | ä½ï¼ˆä¸­é—´ç‰¹å¾éš¾è§£é‡Šï¼Œä½†é€šå¸¸æ›´æœ‰æ•ˆï¼‰              |
| **å¯¹è°ƒå‚çš„ä¾èµ–**   | ç›¸å¯¹è¾ƒå°‘ï¼ˆå› ä¸ºç‰¹å¾æ˜¯å›ºå®šçš„ï¼‰                         | é«˜ï¼ˆè¦è°ƒç½‘ç»œç»“æ„ã€æ¿€æ´»å‡½æ•°ã€å­¦ä¹ ç‡ç­‰è¶…å‚æ•°ï¼‰         |



### Activation Functions
![activation function](./activationfunctino.png)
1. **Logistic or Sigmoid Function**:
   The output range of this function is between 0 and 1, commonly used in the output layer for binary classification problems. But will cause gradient vanishing problem, not commonly used.
2. **Hyperbolic Tangent Function (tanh)**:
   The output range of this function is between -1 and 1, more commonly used than the sigmoid function because its output mean is 0, which helps alleviate the gradient vanishing problem.
3. **Rectified Linear Unit (ReLU)**: Most commonly used activation function
   This function directly returns the input value when the input is greater than 0, otherwise returns 0. It is one of the most popular activation functions currently, due to its simplicity, efficiency, and ability to accelerate the training process of neural networks.
- Note that the activation functions must be non-linear, as without this, the model is simply a (complex) linear model
:::info
### æ„ŸçŸ¥æœºå­¦ä¹ è§„åˆ™
- äºŒåˆ†ç±»é—®é¢˜ï¼šsigmoid
- å¤šåˆ†ç±»é—®é¢˜ï¼šsoftmax
- å¤šæ ‡ç­¾é—®é¢˜ï¼šsigmoid
- çº¿æ€§å›å½’: çº¿æ€§å‡½æ•°

### Formula
#### ğŸ§® **å…¬å¼ 1ï¼šçº¿æ€§ç»„åˆï¼ˆPerceptron ä¸­çš„åŠ æƒæ±‚å’Œï¼‰**

$$
\Sigma = \theta_0 + \theta_1 \cdot x_1 + \theta_2 \cdot x_2
$$

#### âœ… å«ä¹‰ï¼š

* $\Sigma$ï¼šæ„ŸçŸ¥æœºçš„ä¸­é—´ç»“æœï¼ˆè¿˜æ²¡ç»è¿‡æ¿€æ´»å‡½æ•°ï¼‰
* $\theta_0$ï¼šåç½®é¡¹ï¼ˆbiasï¼‰
* $\theta_1, \theta_2$ï¼šè¾“å…¥ç‰¹å¾çš„æƒé‡
* $x_1, x_2$ï¼šè¾“å…¥ç‰¹å¾å€¼

è¿™æ˜¯æ„ŸçŸ¥æœºå¯¹ä¸€ä¸ªè¾“å…¥æ ·æœ¬åšå‡ºçš„â€œçº¿æ€§æ‰“åˆ†â€ã€‚

---

#### ğŸ” **å…¬å¼ 2ï¼šæ„ŸçŸ¥æœºæƒé‡æ›´æ–°è§„åˆ™ï¼ˆPerceptron Learning Ruleï¼‰**

$$
\theta_j^{(t)} \leftarrow \theta_j^{(t-1)} + \eta \cdot (y^{(i)} - \hat{y}^{(i,t)}) \cdot x_j^{(i)}
$$

#### âœ… å«ä¹‰ï¼š

* $\theta_j^{(t)}$ï¼šç¬¬ $t$ æ¬¡æ›´æ–°åç¬¬ $j$ ä¸ªæƒé‡
* $\theta_j^{(t-1)}$ï¼šä¸Šä¸€æ¬¡çš„æƒé‡å€¼
* $\eta$ï¼šå­¦ä¹ ç‡ï¼ˆlearning rateï¼‰
* $y^{(i)}$ï¼šç¬¬ $i$ ä¸ªè®­ç»ƒæ ·æœ¬çš„çœŸå®æ ‡ç­¾
* $\hat{y}^{(i,t)}$ï¼šå½“å‰æ¨¡å‹å¯¹æ ·æœ¬ $i$ çš„é¢„æµ‹ï¼ˆç»è¿‡æ¿€æ´»å‡½æ•°ï¼‰
* $x_j^{(i)}$ï¼šæ ·æœ¬ $i$ çš„ç¬¬ $j$ ä¸ªç‰¹å¾

åªåœ¨é¢„æµ‹é”™è¯¯ï¼ˆå³ $y \ne \hat{y}$ï¼‰æ—¶æ‰æ›´æ–°ã€‚
---

è¿™ä¸¤ä¸ªå…¬å¼ä¸€èµ·æ„æˆäº†æ„ŸçŸ¥æœºçš„æ ¸å¿ƒå·¥ä½œæœºåˆ¶ï¼š

> **å…ˆç”¨ç¬¬ä¸€ä¸ªå…¬å¼è®¡ç®—é¢„æµ‹ï¼Œå†æ ¹æ®ç¬¬äºŒä¸ªå…¬å¼æ›´æ–°æƒé‡ã€‚**
:::

### When is Linear Classification Enough?
- If we know our classes are linearly (approximately) separable
- If the feature space is (very) high-dimensional
...i.e., the number of features exceeds the number of training instances
(kernel trick)
- If the traning set is small
- If interpretability is important, i.e., understanding how (combinations of) features explain different predictions
- â€¦but with increasing availability of data, and more powerful computers, non-linear models are gaining popularity, with currently Neural Networks being their most popular variant.

### Pros and Cons of Neural Networks
#### Pros
- Powerful tool!
- Neural networks with at least 1 hidden layer can approximate any (continuous) function. They are universal approximators
- Automatic feature learning
- Empirically, very good performance for many diverse tasks
#### Cons
- Powerful model increases the danger of â€˜overfittingâ€™
- Requires large training data sets
- Often requires powerful compute resources (GPUs)
- Lack of interpretability

## Week 9
| Characteristics | Activation Function | Step Function |
|------|--------------------------|---------------------|
| Definition | Introduces non-linear factors, determines whether a node is activated | Takes different constant values in different intervals |
| Mathematical Properties | Usually continuous and differentiable | Discontinuous, with jumps only at specific points |
| Applications | Introduces non-linearity in neural networks, increasing model complexity | Signal processing, control theory, early perceptron models |
| Common Types | Sigmoid, Tanh, ReLU, Leaky ReLU, Softmax | Heaviside step function |
| Advantages | Improves model expressiveness, suitable for complex pattern recognition | Simple, easy to understand and implement |
| Disadvantages | May cause gradient disappearance or explosion, requires selection of suitable functions | Discontinuous, not suitable for gradient-based optimization algorithms |
| Use in Neural Networks | Widely used, a core component of modern neural networks | Rarely used, mainly in early models |
Summary: Activation functions and step functions have different applications and properties in mathematics and engineering. Activation functions are mainly used in neural networks to introduce non-linearity and improve model expressiveness, while step functions are used in signal processing, control theory, and other fields. In neural networks, step functions are not suitable as activation functions due to their discontinuity.

### Why cannot we use the step functon?
Derivative is not defined at 0.
When itâ€™s not at 0, the derivative is 0.
= No way to update weights and learn anything!

### A problem encountered when training a multilayer perceptron (MLP) and the method to solve it.
1. The update rule depends on the actual target output y: When training a neural network, we typically use an update rule to adjust the network's weights, which depends on the actual target output. However, in a multilayer network, we can only directly obtain the actual output of the final layer, but not the actual output of the hidden layers.
2. We can only access the actual output of the final layer: In a multilayer network, we can only directly observe the output of the final layer, while the output of the hidden layers is not directly observable.
3. We do not know the actual activation of the hidden layers: Since we cannot directly observe the actual output of the hidden layers, we do not know the actual activation state of the hidden layers.
To solve these problems, backpropagation (Backpropagation) provides an effective method. Backpropagation is an algorithm for training multilayer neural networks, which updates the weights in the network by calculating the partial derivatives of the error. This method allows us to effectively calculate the error partial derivatives for each individual weight, thereby updating the weights of the hidden layers, not just the outermost layer. This way, we can still effectively train the entire network without knowing the actual activation of the hidden layers. 

### Comparison of Perceptron and Backpropagation
| æ„ŸçŸ¥æœºæ›´æ–°                  | Backprop                |
| ---------------------- | ----------------------- |
| åªæœ‰ä¸€å±‚ï¼ˆè¾“å‡ºå±‚ï¼‰              | å¤šå±‚ï¼ˆå«éšè—å±‚ï¼‰                |
| æƒé‡æ›´æ–°åŸºäºè¯¯å·® $y - \hat{y}$ | åŸºäºæŸå¤±å‡½æ•°å¯¹æ¯ä¸ªæƒé‡çš„å¯¼æ•°          |
| æ²¡æœ‰é“¾å¼æ³•åˆ™                 | ä½¿ç”¨é“¾å¼æ³•åˆ™ï¼ˆé“¾å¼æ±‚å¯¼ï¼‰            |
| ä¸éœ€è¦æ¿€æ´»å‡½æ•°çš„å¯¼æ•°             | å¿…é¡»ä½¿ç”¨æ¿€æ´»å‡½æ•°çš„å¯¼æ•°ï¼ˆå¦‚ sigmoid'ï¼‰ |
| ç®€å•å¿«é€Ÿï¼Œä½†åªèƒ½å¤„ç†çº¿æ€§å¯åˆ†         | æ›´å¤æ‚ï¼Œä½†å¯ä»¥æ‹Ÿåˆéçº¿æ€§å‡½æ•°          |

### Backpropagation
**è®­ç»ƒå¤šå±‚æ„ŸçŸ¥æœºï¼ˆMLPï¼‰** çš„æ ‡å‡†æµç¨‹ï¼Œç”¨äºç†è§£ **åå‘ä¼ æ’­ï¼ˆBackpropagationï¼‰+ æ¢¯åº¦ä¸‹é™ï¼ˆGradient Descentï¼‰** çš„å…¨è¿‡ç¨‹ã€‚

#### **Step 1: Forward propagate an input x**

è¾“å…¥ $\mathbf{x}$ï¼ˆè®­ç»ƒæ ·æœ¬ï¼‰è¿›å…¥ç¥ç»ç½‘ç»œï¼š

* ä¸€å±‚ä¸€å±‚åœ°æ‰§è¡Œçº¿æ€§å˜æ¢å’Œæ¿€æ´»å‡½æ•°
* å¯¹æ¯ä¸€å±‚ $l$ï¼š

  $$
  \mathbf{z}^{(l)} = \mathbf{W}^{(l)} \mathbf{a}^{(l-1)} + \mathbf{b}^{(l)} \\
  \mathbf{a}^{(l)} = f(\mathbf{z}^{(l)})
  $$

  å…¶ä¸­ $f$ æ˜¯æ¿€æ´»å‡½æ•°ï¼ˆå¦‚ ReLUã€Sigmoidï¼‰

âœ… æœ€ç»ˆå¾—åˆ°è¾“å‡º $\hat{y}$

#### **Step 2: Compute the predicted output $\hat{y}$**

è¿™æ˜¯å‰å‘ä¼ æ’­çš„æœ€åç»“æœï¼š

$$
\hat{y} = \text{MLP}(\mathbf{x})
$$

å¯èƒ½æ˜¯ï¼š

* æ ‡é‡ï¼ˆç”¨äºäºŒåˆ†ç±»ï¼‰
* å‘é‡ï¼ˆç”¨äºå¤šåˆ†ç±»ï¼Œæ¯”å¦‚ç»è¿‡ softmaxï¼‰

#### **Step 3: Compare $\hat{y}$ with true output $y$, compute error**

å®šä¹‰ä¸€ä¸ª **æŸå¤±å‡½æ•°ï¼ˆLoss Functionï¼‰**ï¼š

å¸¸ç”¨çš„æŸå¤±å‡½æ•°ï¼š

* å‡æ–¹è¯¯å·®ï¼ˆMSEï¼‰ï¼š$\frac{1}{2} (y - \hat{y})^2$
* äº¤å‰ç†µï¼ˆCross-Entropyï¼‰ç”¨äºåˆ†ç±»

è®°ä¸ºï¼š

$$
\mathcal{L}(\hat{y}, y)
$$

æˆ‘ä»¬ç°åœ¨çŸ¥é“å½“å‰é¢„æµ‹æœ‰å¤šâ€œé”™â€ã€‚

#### **Step 4: Modify each weight to reduce the error (Gradient Descent)**

è¿™ä¸€æ­¥å°±æ˜¯ **åå‘ä¼ æ’­çš„æ ¸å¿ƒ**ï¼š

1. é€šè¿‡ **é“¾å¼æ³•åˆ™** è®¡ç®—æŸå¤±å‡½æ•°å¯¹æ¯ä¸€å±‚æƒé‡çš„æ¢¯åº¦ï¼š

$$
\frac{\partial \mathcal{L}}{\partial \mathbf{W}^{(l)}}
$$

2. ä½¿ç”¨ **æ¢¯åº¦ä¸‹é™** æ›´æ–°æ¯ä¸€å±‚æƒé‡ï¼š

$$
\mathbf{W}^{(l)} \leftarrow \mathbf{W}^{(l)} - \eta \cdot \frac{\partial \mathcal{L}}{\partial \mathbf{W}^{(l)}}
$$

$$
\mathbf{b}^{(l)} \leftarrow \mathbf{b}^{(l)} - \eta \cdot \frac{\partial \mathcal{L}}{\partial \mathbf{b}^{(l)}}
$$

å…¶ä¸­ $\eta$ æ˜¯å­¦ä¹ ç‡ã€‚

ğŸ” æ¯ä¸€å±‚çš„æ¢¯åº¦ä¾èµ–äºåä¸€å±‚çš„æ¢¯åº¦ï¼šè¿™å°±æ˜¯**åå‘ä¼ æ’­**ï¼ˆè¯¯å·®ä»è¾“å‡ºå±‚ä¼ å›éšè—å±‚ï¼‰

#### **Step 5: Repeat for all data and multiple epochs**

* å¯¹è®­ç»ƒé›†ä¸­çš„æ¯ä¸ªæ ·æœ¬é‡å¤ä¸Šé¢è¿‡ç¨‹ï¼ˆå¯èƒ½ä½¿ç”¨ mini-batchï¼‰
* è¿›è¡Œå¤šä¸ªè½®ï¼ˆepochsï¼‰ï¼Œç›´åˆ°æŸå¤±ä¸å†æ˜æ˜¾ä¸‹é™

#### âœ¨ æ€»ç»“æµç¨‹å›¾

```
Input x
  â†“
[Forward Propagation]
  â†“
Predicted Output Å·
  â†“
Compare with True Output y
  â†“
[Compute Loss]
  â†“
[Backpropagation: compute gradients]
  â†“
Update weights with Gradient Descent
  â†“
Repeat
```

---


### Generalized Delta Rule
The **Generalized Delta Rule** æ˜¯ **åå‘ä¼ æ’­ç®—æ³•ï¼ˆBackpropagationï¼‰** çš„æ•°å­¦æ ¸å¿ƒï¼Œç”¨äºè®­ç»ƒå¤šå±‚æ„ŸçŸ¥æœºï¼ˆMLPï¼‰ã€‚å®ƒæ˜¯ä¸€ç§å°†æ„ŸçŸ¥æœºçš„ç®€å•â€œè¯¯å·®æ›´æ–°è§„åˆ™â€æ¨å¹¿åˆ°å¤šå±‚ç¥ç»ç½‘ç»œä¸­çš„æ–¹æ³•ã€‚

---

#### ğŸ§  ä¸€å¥è¯è§£é‡Šï¼š

> **Generalized Delta Rule** å°±æ˜¯ç”¨**é“¾å¼æ³•åˆ™**è®¡ç®—éšè—å±‚ä¸­æ¯ä¸ªç¥ç»å…ƒçš„è¯¯å·®ä¿¡å·ï¼Œå¹¶æ®æ­¤æ›´æ–°æƒé‡ã€‚

#### ğŸ§® å›é¡¾æ„ŸçŸ¥æœºçš„åŸºæœ¬æ›´æ–°ï¼š

åœ¨å•å±‚æ„ŸçŸ¥æœºä¸­ï¼Œå¦‚æœè¾“å‡ºæ˜¯ï¼š

$$
\hat{y} = f(\theta^T x)
$$

è¯¯å·®æ˜¯ï¼š

$$
\delta = y - \hat{y}
$$

ç„¶åæˆ‘ä»¬æ›´æ–°æƒé‡ï¼š

$$
\theta \leftarrow \theta + \eta \cdot \delta \cdot x
$$

ä½†å¯¹äºå¤šå±‚ç¥ç»ç½‘ç»œï¼ˆæœ‰éšè—å±‚ï¼‰ï¼Œæˆ‘ä»¬ä¸èƒ½ç›´æ¥ç”¨ $y - \hat{y}$ æ¥æ›´æ–°éšè—å±‚çš„æƒé‡ã€‚

#### ğŸš€ Generalized Delta Rule çš„æ ¸å¿ƒæ€æƒ³ï¼š

å¯¹äºä»»æ„ç¥ç»å…ƒ $j$ çš„æƒé‡ $w_{ji}$ï¼Œæ›´æ–°å…¬å¼ä¸ºï¼š

$$
w_{ji} \leftarrow w_{ji} + \eta \cdot \delta_j \cdot x_i
$$

å…¶ä¸­ï¼š

* $\eta$ï¼šå­¦ä¹ ç‡
* $\delta_j$ï¼šç¬¬ $j$ ä¸ªç¥ç»å…ƒçš„â€œè¯¯å·®ä¿¡å·â€
* $x_i$ï¼šè¾“å…¥ï¼ˆæ¥è‡ªä¸Šä¸€å±‚ï¼‰

#### â—å…³é”®ç‚¹åœ¨äºæ€ä¹ˆå®šä¹‰ $\delta_j$ï¼ˆè¯¯å·®ä¿¡å·ï¼‰

#### ğŸ‘‰ å¯¹äºè¾“å‡ºå±‚çš„ç¥ç»å…ƒï¼š

$$
\delta_j = (y_j - \hat{y}_j) \cdot f'(z_j)
$$

* $f'(z_j)$ï¼šæ¿€æ´»å‡½æ•°çš„å¯¼æ•°
* $z_j$ï¼šæœªæ¿€æ´»å‰çš„çº¿æ€§è¾“å…¥

#### ğŸ‘‰ å¯¹äºéšè—å±‚çš„ç¥ç»å…ƒï¼š

$$
\delta_j = f'(z_j) \cdot \sum_k \delta_k \cdot w_{kj}
$$

* $\delta_k$ï¼šæ¥è‡ªä¸‹ä¸€å±‚ï¼ˆé è¿‘è¾“å‡ºå±‚ï¼‰çš„è¯¯å·®ä¿¡å·
* $w_{kj}$ï¼šä»æœ¬å±‚ç¥ç»å…ƒ $j$ åˆ°ä¸‹ä¸€å±‚ç¥ç»å…ƒ $k$ çš„æƒé‡

#### ğŸ§  æ€»ç»“

| é¡¹ç›®      | æ„ŸçŸ¥æœº               | Generalized Delta Rule (Backprop) |
| ------- | ----------------- | --------------------------------- |
| é€‚ç”¨ç½‘ç»œ    | å•å±‚                | å¤šå±‚ï¼ˆå«éšè—å±‚ï¼‰                          |
| è¯¯å·®ä¼ æ’­    | ç›´æ¥ç”¨ $y - \hat{y}$ | ä½¿ç”¨é“¾å¼æ³•åˆ™é€å±‚ä¼ æ’­                        |
| æ¿€æ´»å‡½æ•°å¯¼æ•°  | ä¸éœ€è¦               | å¿…é¡»è®¡ç®— $f'(z)$                      |
| æ”¯æŒéçº¿æ€§   | âŒ                 | âœ…                                 |
| æ”¯æŒéšè—å±‚è®­ç»ƒ | âŒ                 | âœ…                                 |



### Discriminative and Generative
"**Discriminative**" and "**Generative**" are two different model approaches in machine learning used for classification or prediction tasks, but their **modeling ideas and goals differ**. Here are their main differences:

---

### ğŸ” One-sentence Difference:

* **Discriminative Models**: Directly learn the **mapping from input to output** (i.e., learn $P(y \mid x)$).
* **Generative Models**: Learn the **data generation process** (i.e., learn $P(x, y)$, which can derive $P(x \mid y)$ and $P(y)$).

---

### ğŸ“š More Specifically:

| Attribute     | Discriminative Models                        | Generative Models                             |
| ------------- | -------------------------------------------- | --------------------------------------------- |
| What is learned? | Learn $P(y \mid x)$: the probability of class y given input x | Learn $P(x \mid y)$ and $P(y)$: how input x is generated by class y |
| Examples      | Logistic Regression, SVM, Random Forest, BERT | Naive Bayes, HMM, GMM, GAN, VAE               |
| Capabilities  | Classification, regression                   | Classification, sample generation (images, text), missing value imputation, data simulation |
| Model input distribution? | âŒ Does not model the distribution of $x$ | âœ… Models the generation mechanism of $x$     |
| Can generate data? | âŒ No                                    | âœ… Can generate new samples (images, text, etc.) |
| Typical performance | More accurate for classification (because it directly optimizes the classification task) | More robust with less data, but may have slightly weaker classification performance |

---

### ğŸ“ Classic Examples:

#### Naive Bayes (Generative)

* Assume you know the word frequency for each class (e.g., "spam" or "normal email").
* You can first generate a spam email and then see if a new email resembles spam.

#### Logistic Regression (Discriminative)

* Only learns to directly determine from the features of an email whether it is spam or normal.

---

### âœ… When to Use Which?

* Use **Discriminative**:

  * Classification is the sole task (e.g., sentiment classification, image recognition)
  * Sufficient data is available, aiming for the best prediction performance

* Use **Generative**:

  * Want to **generate data** (images, speech, text, etc.)
  * There is **missing data**, **few-shot learning**, or a need for stronger expressive capability

---

## Week 10
### Unsupervised Learning
- Finding the correct label for an instance can be hard and expensive (the labelling usually should be done manually)
- Labelled data is limited
- On the other hand, we have access to many more datasets that are not labelled

### Types of unsupervised learning
- PCA: simplify complex datasets with many features by extracting the most essential information
- Clustering: Finding groups of items that are similar
- Anomaly detection: detecting rare occurrences that seem suspicious because they're different from the established pattern
- Associate Rule Mining: Given a set of transactions, find rules that will predict the occurrence of an item based on the occurrences of other items in the transaction

### Clustering

| Dimension | Type | Description | Example Algorithm |
|-----------|------|-------------|-------------------|
| Membership | Exclusive | Each point belongs to only one cluster | K-Means |
|            | Overlapping | A point can belong to multiple clusters | FCM, GMM |
| Assignment Method | Deterministic | Clear membership | K-Means |
|                  | Probabilistic | Probabilistic membership | GMM, FCM |
| Structure | Hierarchical | Tree structure | Hierarchical Clustering |
|           | Partitioning | Flat partitioning | K-Means |
| Coverage | Partial | Not all points need to be covered | Clustering with outlier handling |
|          | Complete | All points are classified | Most traditional clustering |
| Intra-cluster Characteristics | Homogeneous | Clusters are as similar as possible | Most clustering algorithms |
|                              | Heterogeneous | Allows significant differences within clusters | Used for specific needs |

---
### K-means
#### K-means clustering process (exclusive, complete and partitioning clustering method)
- Ask the user how many clusters they would like (K)
-  Randomly pick K points (as seeds or initial cluster centroids)
-  Repeat
   - Assign each instance to the cluster with the nearest centroid
   - Recompute the centroid of each cluster
- Until the centroids donâ€™t change (or until changes are smaller than a threshold, or until relatively few points change clusters)

#### K-means limitaion
- â€œmeanâ€ is ill-defined for categorical attributes
- Sensitive to outliers
- Sensitive to Initial Centroids
- Not able to handle non-spherical clusters
- Not able to handle clusters of differing sizes
- Not able to handle clusters with different densities
- Requires Predefined Number of Clusters (K): Determining the optimal number of clusters can be a challenging task

#### K-means strengths
- Simplicity: straightforward and easy-to-understand algorithm.
- Scalability: computationally efficient and can converge relatively quickly. Suitable for clustering tasks involving a large number of data points.
- Interpretable Results: Clusters can be easily interpreted and visualised.
- Applicability: K-means is applicable to a wide range of clustering tasks (often good enough).

#### Elbow Method (to find optimal K)
- A â€œgoodâ€ cluster should have High cluster cohesion (Intra-cluster distances are minimized) and High Cluster Separation (Inter-cluster distances are maximized)
- To measure Cohesion: Within-cluster Sum of Squares (WCSS): the sum of the squared distance between each point and the centroid in a cluster (Cluster Cohesion)
- Look for a point where the reduction in WCSS significantly slows down: that is the Elbow point

### Hierarchical Clustering
- Agglomerative (Bottom-up) clustering
   - Start with the points (instances) as individual clusters
   - At each step, merge the closest pair of clusters until only one cluster (or k clusters) left

![Agglomerative (Bottom-up) clustering](./agglomerative.png)
- Single Linkage: Distance between the closest members of the cluster
   - Can handle non-similar shapes
   - Sensitive to noise and outliers
- Complete Linkage: Distance between the furthest members of the cluster
   - Less sensitive to noise and outliers
   - Tends to create spherical clusters with a consistent diameter.
   - Tends to break large clusters
- Centroid Linkage: Distance between the two centroids

#### Strength
- No assumption of any particular number of clusters
   - Any desired number of clusters can be obtained by 'cutting' the dendrogram at the appropriate level
- No assumption of cluster shape
   - not assume specific shapes or distributions for the clusters.
   - can handle clusters of various shapes, sizes, and densities
- They may correspond to meaningful taxonomies
   - Examples in biological sciences (e.g., animal kingdom, phylogeny reconstruction, â€¦)

#### Weakness
- Once a decision is made to combine two clusters, it cannot be undone, i.e., an object that is in the wrong cluster will always stay there.
- No objective function is directly minimised, i.e., no 'relative' quality measure

### Clustering Metrics
#### WCSS and BCSS
![WCSS](./wcss.png)
![BCSS](./bcss.png)

- The two main concepts used to evaluate the goodness of a clustering structure without relying on external information (i.e., unsupervised evaluation) are:

   - **Cohesion (Intra-cluster Similarity)** â€“ Measures how closely related the points within the same cluster are. A good clustering structure should have high cohesion, meaning data points within a cluster should be densely packed and similar to one another. This is typically evaluated using metrics like within-cluster sum of squares (WCSS).

   - **Separation (Inter-cluster Dissimilarity)** â€“ Measures how well-separated different clusters are from each other. A strong clustering structure should have high separation, meaning clusters are distinct and far apart from one another. This is often evaluated using metrics like between-cluster sum of squares (BCSS).

- These two principles ensure that clusters are both internally coherent and externally distinct, leading to a well-formed clustering solution.

#### Calinski-Harabasz Index
![Calinski-Harabasz Index](./calinski-harabasz.png)

### Homogeneity
- Whether each cluster contains only data points that are all from the same class. Homogeneity checks if all the items in a cluster are the same type.
### Completeness
- Whether all data points of a particular class are assigned to the same cluster.

#### Why Do We Need Both Metrics?
- Homogeneity alone can be misleading. It only checks whether all instances within a cluster share the same label but does not ensure that instances of the same class are grouped together.

- Thus, a good clustering solution should aim for both high homogeneity and high completeness to ensure meaningful and accurate grouping of data points.

#### æ•°å­¦å…¬å¼ & å¦‚ä½•è®¡ç®—

è¿™ä¸¤ä¸ªæŒ‡æ ‡éƒ½åŸºäº **æ¡ä»¶ç†µï¼ˆconditional entropyï¼‰** çš„æ¦‚å¿µï¼Œå¹¶ä¸”å’Œ **V-measure** æœ‰å…³è”ã€‚

æˆ‘ä»¬ç”¨ä»¥ä¸‹å˜é‡è¡¨ç¤ºï¼š

- $ C $ï¼šçœŸå®çš„ç±»åˆ«ï¼ˆclassï¼‰
- $ K $ï¼šèšç±»çš„ç»“æœï¼ˆclusterï¼‰

##### 1. Homogeneity (h)

$$
h = 
\begin{cases}
    1 - \frac{H(C|K)}{H(C)} & \text{if } H(C) \neq 0 \\
    1 & \text{otherwise}
\end{cases}
$$

å…¶ä¸­ï¼š
- $ H(C|K) $ï¼šç»™å®šèšç±»ç»“æœçš„ç±»åˆ«æ¡ä»¶ç†µï¼ˆè¡¨ç¤ºæ¯ä¸ªç°‡å†…éƒ¨çš„ç±»åˆ«åˆ†å¸ƒæ··ä¹±ç¨‹åº¦ï¼‰
- $ H(C) $ï¼šç±»åˆ«çš„æ€»ç†µï¼ˆåŸå§‹ç±»åˆ«åˆ†å¸ƒçš„ä¸ç¡®å®šæ€§ï¼‰

ğŸ’¡ å«ä¹‰ï¼šå¦‚æœæ¯ä¸ªç°‡é‡Œçš„ç±»åˆ«éƒ½å¾ˆå•ä¸€ï¼ˆ$ H(C|K) \approx 0 $ï¼‰ï¼Œåˆ™ `h â‰ˆ 1`ï¼Œè¯´æ˜åŒè´¨æ€§å¾ˆå¥½ã€‚

---

##### 2. Completeness (c)

$$
c = 
\begin{cases}
    1 - \frac{H(K|C)}{H(K)} & \text{if } H(K) \neq 0 \\
    1 & \text{otherwise}
\end{cases}
$$

å…¶ä¸­ï¼š
- $ H(K|C) $ï¼šç»™å®šçœŸå®ç±»åˆ«çš„èšç±»æ¡ä»¶ç†µï¼ˆè¡¨ç¤ºæ¯ä¸ªç±»åˆ«åœ¨èšç±»ç»“æœä¸­è¢«æ‰“æ•£çš„ç¨‹åº¦ï¼‰
- $ H(K) $ï¼šèšç±»ç»“æœçš„æ€»ç†µï¼ˆèšç±»åˆ†å¸ƒçš„ä¸ç¡®å®šæ€§ï¼‰

ğŸ’¡ å«ä¹‰ï¼šå¦‚æœæ¯ä¸ªç±»åˆ«éƒ½è¢«é›†ä¸­åœ¨æŸä¸€ä¸ªç°‡ä¸­ï¼ˆ$ H(K|C) \approx 0 $ï¼‰ï¼Œåˆ™ `c â‰ˆ 1`ï¼Œè¯´æ˜å®Œæ•´æ€§å¾ˆå¥½ã€‚

---

#### ä¸¾ä¸ªä¾‹å­è¯´æ˜æ€ä¹ˆç®—

### ç¤ºä¾‹è¾“å…¥ï¼š

| æ•°æ®ç‚¹ | çœŸå®ç±»åˆ«ï¼ˆClassï¼‰ | èšç±»ç»“æœï¼ˆClusterï¼‰ |
|--------|------------------|---------------------|
| A      | Cat              | 1                   |
| B      | Cat              | 1                   |
| C      | Dog              | 1                   |
| D      | Dog              | 2                   |
| E      | Bird             | 2                   |

æˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼š

- Cluster 1 åŒ…å« Cat, Cat, Dog â†’ ä¸åŒç±» â†’ **åŒè´¨æ€§å·®**
- Cat åˆ†å¸ƒåœ¨ Cluster 1 â†’ å®Œæ•´æ€§ OK
- Dog åˆ†å¸ƒåœ¨ Cluster 1 å’Œ Cluster 2 â†’ **å®Œæ•´æ€§å·®**

---

#### æ‰‹åŠ¨è®¡ç®—ï¼ˆç®€åŒ–ç†è§£ï¼‰ï¼š

- **åŒè´¨æ€§**ï¼ˆHomogeneityï¼‰ï¼š
  - Cluster 1: ä¸¤ä¸ªçŒ« + ä¸€ä¸ªç‹— â†’ ä¸çº¯
  - Cluster 2: ä¸€ä¸ªç‹— + ä¸€ä¸ªé¸Ÿ â†’ æ›´ä¸çº¯
  - æ‰€ä»¥ `h < 1`

- **å®Œæ•´æ€§**ï¼ˆCompletenessï¼‰ï¼š
  - çŒ«éƒ½åœ¨ cluster 1 â†’ OK
  - ç‹—åˆ†å¸ƒåœ¨ä¸¤ä¸ª cluster â†’ ä¸å®Œæ•´
  - é¸Ÿåœ¨ cluster 2 â†’ OK
  - æ‰€ä»¥ `c < 1`

---

### Issues of unsupervised learning
- Ambiguity in Interpretation
   - Clusters or embeddings may not align with human-understandable or task-relevant categories.
   - Clusters or latent features are often hard to interpret or evaluate objectively
- Wrong Direction
   - The model may find structure, but there's no guarantee it's meaningful or useful for our task

### Semi-supervised learning
- learning from both labelled and unlabelled data, often more unlabelled
- Two common strategies within semi-supervised learning are self-training and active learning
:::info
| ç±»å‹              | æ˜¯å¦éœ€è¦æ ‡ç­¾  | åº”ç”¨åœºæ™¯        |
| --------------- | ------- | ----------- |
| Supervised      | âœ… æ˜¯     | åˆ†ç±»ã€å›å½’       |
| Semi-supervised | âœ… éƒ¨åˆ†æœ‰æ ‡ç­¾ | èµ„æºæœ‰é™ä½†æ•°æ®å¤š    |
| Unsupervised    | âŒ å¦     | èšç±»ã€å¼‚å¸¸æ£€æµ‹ã€é™ç»´ç­‰ |

:::

### Self-tranining
- Repeat
- Train a model f on L using any supervised learning method
- Apply f to predict the labels on each instance in U
- Identify a subset of U with â€œhigh confidenceâ€ labels
- Remove them from U and add them to L with the classifier predictions as the â€œground-truthâ€
- Until L does not change
#### Problems and Solution
- é”™è¯¯ä¼ æ’­ (Classification errors can propagate)ï¼šè¿™æ˜¯è‡ªè®­ç»ƒçš„ä¸€ä¸ªä¸»è¦é£é™©ã€‚å¦‚æœæ¨¡å‹åœ¨é¢„æµ‹æœªæ ‡è®°æ•°æ®çš„æ ‡ç­¾æ—¶çŠ¯äº†é”™è¯¯ï¼ˆæ¯”å¦‚ç»™äº†ä¸€ä¸ªé«˜ç½®ä¿¡åº¦çš„é”™è¯¯æ ‡ç­¾ï¼‰ï¼Œå¹¶ä¸”è¿™ä¸ªé”™è¯¯çš„æ•°æ®è¢«åŠ å…¥äº† Lï¼Œé‚£ä¹ˆåœ¨ä¸‹ä¸€è½®è®­ç»ƒä¸­ï¼Œè¿™ä¸ªé”™è¯¯çš„æ•°æ®å°±ä¼šè¢«å½“ä½œâ€œæ­£ç¡®â€çš„æ ‡ç­¾æ¥è®­ç»ƒæ¨¡å‹ã€‚è¿™ä¼šå¯¼è‡´æ¨¡å‹åœ¨æ–°æ•°æ®ä¸Šè¡¨ç°æ›´å·®ï¼Œé”™è¯¯ä¼šåƒæ»šé›ªçƒä¸€æ ·è¶Šæ»šè¶Šå¤§ã€‚
- é«˜ç½®ä¿¡åº¦é˜ˆå€¼ï¼šä¸€ä¸ªå¸¸ç”¨çš„ç­–ç•¥æ˜¯ï¼Œæ¨¡å‹åœ¨é¢„æµ‹æœªæ ‡è®°æ•°æ®æ ‡ç­¾æ—¶ï¼Œåªæœ‰å½“å®ƒå¯¹é¢„æµ‹ç»“æœéå¸¸â€œè‡ªä¿¡â€ï¼ˆç½®ä¿¡åº¦é«˜äºæŸä¸ªé¢„è®¾çš„é˜ˆå€¼ï¼‰æ—¶ï¼Œæ‰æŠŠè¿™ä¸ªé¢„æµ‹çš„æ ‡ç­¾å’Œå¯¹åº”çš„æ•°æ®åŠ å…¥åˆ° L ä¸­ã€‚å¦‚æœæ¨¡å‹å¯¹é¢„æµ‹ç»“æœä¸å¤ªç¡®å®šï¼ˆç½®ä¿¡åº¦ä½ï¼‰ï¼Œå°±è®¤ä¸ºè¿™ä¸ªé¢„æµ‹ä¸å¯é ï¼Œä¸æŠŠå®ƒåŠ å…¥ Lï¼Œä»è€Œé¿å…å¼•å…¥é”™è¯¯æ ‡ç­¾ã€‚

### Active Learning
- pose queries (unlabelled instances) for labelling by an oracle (e.g. a human annotator)

#### Uncertain Sampling
1. Least Confidence: Choose samples with the smallest predicted probability for the most likely class
2. Margin Sampling: Choose samples where the difference between the top two predicted class probabilities is smallest
3. Entropy sampling: Select the sample with the highest prediction entropy
#### Query Strategies
- Query by Committee(QBC) If the committee disagrees on an instance, the model is uncertain and would benefit most from seeing the true label.
:::info
| ç­–ç•¥                       | å…³é”®ç‚¹         | ä¼˜åŠ¿          | åŠ£åŠ¿              |
| ------------------------ | ----------- | ----------- | --------------- |
| **Uncertainty Sampling** | åˆ©ç”¨å•ä¸ªæ¨¡å‹çš„ä¸ç¡®å®šæ€§ | ç®€å•é«˜æ•ˆï¼Œæ˜“å®ç°    | å¯èƒ½åå‘å¼‚å¸¸ç‚¹         |
| **QBC**                  | åˆ©ç”¨å¤šä¸ªæ¨¡å‹çš„ä¸ä¸€è‡´  | æ›´ç¨³å¥ï¼Œæ•æ‰â€œäº‰è®®ç‚¹â€ | ç®—æ³•å¤æ‚åº¦é«˜ï¼Œéœ€è¦è®­ç»ƒå¤šä¸ªæ¨¡å‹ |
:::

### Data Augmentation
- Bootstrap sampling: create â€œnewâ€ datasets by resampling existing data, with or without replacement
- Cross validation / repeated random subsampling are based on the same idea
- Each â€œbatchâ€ has a slightly different distribution of instances, forces model to use different features and not get stuck in local minima
- Advantages
   - More data nearly always improves learning
   - Most learning algorithms have some robustness to noise
- Disadvantages
   - Biased training data
   - May introduce features that donâ€™t exist in the real world
   - May propagate errors
   - Increases problems with interpretability and transparency

### Unsupervised pre-training
#### BERT
- pretrained language model developed by Google that understands text by looking at both left and right context simultaneously
- **Masked Language Modelling (MLM)**: Predict missing words in a sentence. "The cat [MASK] on the mat."
- **Next Sentence Prediction (NSP)**: Predict if one sentence follows another.
:::info
-**é¢„è®­ç»ƒï¼ˆPre-trainingï¼‰**ï¼š
æ¨¡å‹å…ˆåœ¨å¤§è§„æ¨¡çš„æ— æ ‡ç­¾æ•°æ®ä¸Šè®­ç»ƒï¼Œæ¯”å¦‚è®©è¯­è¨€æ¨¡å‹é¢„æµ‹å¥å­ä¸­çš„ä¸‹ä¸€ä¸ªè¯ï¼Œæˆ–è€…è®©å›¾åƒæ¨¡å‹è¯†åˆ«å›¾åƒä¸­çš„ç‰¹å¾ã€‚è¿™ä¸ªé˜¶æ®µæ¨¡å‹å­¦ä¹ çš„æ˜¯é€šç”¨çš„â€œçŸ¥è¯†â€æˆ–â€œè¡¨ç¤ºâ€ï¼Œä½†æ²¡æœ‰ç‰¹å®šä»»åŠ¡çš„æ ‡ç­¾æŒ‡å¯¼ã€‚
- **è¿ç§»ï¼ˆTransferï¼‰**ï¼š
æŠŠé¢„è®­ç»ƒå¾—åˆ°çš„æ¨¡å‹å‚æ•°ï¼ˆæƒé‡ï¼‰æ‹¿è¿‡æ¥ï¼Œä½œä¸ºä¸€ä¸ªâ€œèµ·ç‚¹â€æˆ–è€…â€œåˆå§‹æ¨¡å‹â€ã€‚
- **å¾®è°ƒï¼ˆFine-tuningï¼‰**ï¼š
ç„¶åç”¨ä½ æ‰‹å¤´å…·ä½“çš„æœ‰æ ‡ç­¾æ•°æ®ï¼ˆæ¯”å¦‚åˆ†ç±»ä»»åŠ¡çš„æ ‡ç­¾ï¼‰å¯¹è¿™ä¸ªæ¨¡å‹è¿›è¡Œé’ˆå¯¹æ€§çš„è®­ç»ƒï¼Œè®©æ¨¡å‹å­¦ä¼šå…·ä½“ä»»åŠ¡çš„è¦æ±‚ã€‚è¿™ä¸ªè¿‡ç¨‹ä¼šç¨å¾®è°ƒæ•´é¢„è®­ç»ƒæ—¶å­¦åˆ°çš„å‚æ•°ï¼Œä½¿æ¨¡å‹æ›´é€‚åˆä½ çš„ç‰¹å®šä»»åŠ¡ã€‚
:::

## Week 11
### Parametric Models and Non-parametric Models:
| Feature              | Parametric Models                                          | Non-parametric Models                                      |
|----------------------|------------------------------------------------------------|------------------------------------------------------------|
| Assumptions          | Strong assumptions about data distribution (e.g., normal distribution, linear relationship) | Almost no assumptions about data distribution               |
| Number of Parameters | Fixed number of parameters, usually few                    | Number of parameters is not fixed, can be many              |
| Model Complexity     | Relatively low model complexity                            | Model complexity can be high                                |
| Training Data Needs  | Usually requires less training data                        | May require a large amount of training data                 |
| Generalization Ability | Depends on the accuracy of assumptions                   | Generally strong generalization ability as it does not rely on specific assumptions |
| Overfitting Risk     | Risk of overfitting, especially if assumptions do not match the true distribution | Also has overfitting risk, but can usually be controlled through model selection and regularization |
| Computational Efficiency | Usually high computational efficiency                   | Computational efficiency can be low, especially for large datasets |
| Flexibility          | Low flexibility, constrained by assumptions                | High flexibility, able to adapt to complex data structures and relationships |
| Examples             | Linear regression, logistic regression, Naive Bayes        | K-nearest neighbors, decision trees, random forests, support vector machines |
| Application Scenarios | Suitable for situations where assumptions are reasonable and data volume is small | Suitable for situations with large data volumes, complex relationships, or unknown assumptions |
| Model Interpretability | Usually has good interpretability                         | Interpretability may be poor, especially for complex models |

### Ensembles
- Ensemble learning (aka. Classifier combination): constructs a set of base classifiers from a given set of training data and aggregates the outputs into a single meta-classifier
- Intuition 1: the combination of lots of weak classifiers can be at least as good as one strong classifier
- Intuition 2: the combination of a selection of strong classifiers is (usually) at least as good as the best of the base classifiers
- Ensembles are effective when individual classifiers are slightly better than random (error < 0.5).

#### When does ensemble learning work?
- The classifiers should not make the same mistakes (not the same bias)
- The base classifiers are reasonably accurate (better than chance), slightly
better than random (error < 0.5).

### Different classifiers (different models or the same model with feature manipulation): Stacking
### 1. Stacking
**Description:**
- **Different classifiers (different models or the same model with feature manipulation):** Stacking, also known as stacked generalization, involves training on multiple different models (these models can be different algorithms or the same algorithm with different features or hyperparameters). The predictions of these models are then used as input features to train a higher-level model (meta-learner, usually a simple linear model like logistic regression).
**How it works:**
1. **Level 0 models:** Train multiple base models on the complete dataset.
2. **Level 1 model:** Use the predictions of the base models as input features to train a higher-level model (meta-learner).
**Key Points:**
- **Diversity:** The effectiveness of stacking relies on the diversity of the base models.
- **Complexity:** It can be more complex compared to other ensemble methods, and implementing and tuning parameters can be more difficult.
- **Application Scenarios:** Stacking is useful when you can use multiple different models or when you want to leverage the strengths of different algorithms.
**In short:** Stacking uses multiple different models to make predictions and uses these predictions as features for another model to obtain the final prediction.

### Same classifier, instance manipulation: Bagging (primarily targets variance reduction)
### 2. Bagging
**Description:**
- **Same classifier, instance manipulation:** Bagging, or Bootstrap Aggregating, primarily reduces variance by manipulating data instances. It is often used to reduce the variance of models, especially those complex models sensitive to small changes in the training data (e.g., decision trees).
**How it works:**
1. **Bootstrap Sampling:** Perform sampling with replacement from the original dataset to create multiple different training sets (called bootstrap samples).
2. **Parallel Training:** Independently train the same model on each bootstrap sample.
3. **Aggregate Predictions:** Average the predictions (regression) or use majority voting (classification) for all models.
**Key Points:**
- **Variance Reduction:** Bagging primarily improves model stability by reducing variance.
- **Parallelism:** Models in bagging are trained in parallel.
- **Application Scenarios:** Suitable for models that are very sensitive to small changes in the training data, such as decision trees.
**In short:** Bagging improves model stability by repeatedly sampling the original data, training the same model on each sample, and then aggregating the predictions of these models.

:::info
Random Forest is considered a "Bagging" (Bootstrap Aggregating) method because it uses bootstrap sampling techniques when constructing each decision tree. Bagging is an ensemble learning method whose core idea is to create multiple subsets from the original dataset through bootstrap sampling, train a base learner (e.g., decision tree) on each subset, and finally improve the overall model's performance by combining the predictions of these base learners.
In Random Forest, the specific application of Bagging is reflected in the following aspects:
1. **Bootstrap Sampling:** For the original dataset, Random Forest performs multiple bootstrap samplings, each generating a subset of the same size as the original dataset but with possibly repeated elements. These subsets are used to train different decision trees.
2. **Independent Training:** Each decision tree is independently trained on its respective bootstrap sample, meaning they do not share the same training data.
3. **Combine Predictions:** In the prediction phase, Random Forest combines the predictions of all decision trees. For classification problems, majority voting is usually used; for regression problems, the average prediction value is used.
Through this method, Random Forest uses Bagging techniques to reduce model variance, improve generalization ability, and enhance robustness to noise and outliers. Each tree is trained on a slightly different data subset, which helps introduce diversity, making the overall model more stable and accurate. Therefore, Random Forest is classified as a Bagging method.
- Random Forest adopts both feature manipulation and instance manipulation approaches. 
:::

### Same classifier, algorithm manipulation: Boosting (primarily targets bias reduction)
### 3. Boosting
**Description:**
- **Same classifier, algorithm manipulation:** Boosting primarily reduces bias by gradually adjusting the model during training. It weights training samples so that the model focuses more on previously misclassified samples.
**How it works:**
1. **Initialization:** Initialize the weights of all samples equally.
2. **Iterative Training:** Gradually train the model, adjusting the weights of the samples based on the error rate of the previous model so that the weights of misclassified samples increase.
3. **Combine Models:** Combine all models, usually weighting them based on each model's accuracy.
**Key Points:**
- **Bias Reduction:** Boosting primarily improves model accuracy by reducing bias.
- **Sequentiality:** Models in boosting are trained sequentially, with each model depending on the output of the previous model.
- **Application Scenarios:** Suitable for tasks where performance can be improved by focusing on difficult samples.
**In short:** Boosting improves model accuracy by gradually adjusting the training process so that the model focuses more on samples misclassified by previous models.
**Summary:**
- **Stacking** uses multiple different models and inputs their outputs as features into another model.
- **Bagging** uses the same model but trains on different data subsets to reduce variance.
- **Boosting** uses the same model but gradually adjusts the model during training to reduce bias.

| Feature | Stacking | Bagging | Boosting |
|---------|----------|---------|----------|
| **Model Type** | Different classifiers (different models or the same model with different feature processing) | Same classifier | Same classifier |
| **Objective** | Combine predictions of multiple models to improve overall performance | Primarily reduce variance | Primarily reduce bias |
| **Instance Processing** | Use the original dataset | Perform bootstrap sampling (sampling with replacement) on training data | Adjust sample weights based on errors from the previous round of models |
| **Model Processing** | Use different models or the same model with different feature processing | Use the same model | Use the same model |
| **Algorithm Processing** | Use a meta-learner to combine predictions of multiple models | No specific algorithm processing | Adjust model weights through boosting algorithms (e.g., AdaBoost, Gradient Boosting) |
| **Advantages** | Combine advantages of different models to improve generalization ability | Reduce overfitting, improve model stability | Improve prediction accuracy, reduce bias |
| **Disadvantages** | High computational complexity, requires training multiple models and a meta-learner | May increase model variance, sensitive to outliers | May lead to overfitting, sensitive to noise |
| **Typical Applications** | Combine different types of models (e.g., decision trees, neural networks, SVM) | Random Forest | AdaBoost, Gradient Boosting Machines (GBM) |
| **Applicable Scenarios** | Scenarios requiring the combination of multiple models to improve performance | Scenarios requiring variance reduction and improved model stability | Scenarios requiring bias reduction and improved prediction accuracy |

### Summary
- **Stacking** improves overall performance by combining predictions of different models, suitable for scenarios requiring the combination of multiple models to improve performance.
- **Bagging** reduces model variance and improves stability through bootstrap sampling, suitable for scenarios requiring variance reduction and improved model stability.
- **Boosting** reduces model bias and improves prediction accuracy by adjusting sample weights, suitable for scenarios requiring bias reduction and improved prediction accuracy.


### Anomaly Detection
- Anomalies are different from noise
   - Noise is random error or variance in a measured variable
   - Noise should be removed before anomaly detection

### Types of Anomaly
#### Global Anomaly
- significantly deviates from the rest of the data
#### Contextual Anomaly
- deviates significantly based on a selected context
   - Contextual attributes: define the context, e.g., time & location
   - Behavioural attributes: characteristics of the object, used in anomaly evaluation, e.g., temperature
#### Collective Anomaly
- deviates significantly from the majority of the data

### Anomaly Detection Algorithms
#### Supervised Anomaly Detection
- Use labelled data to train a model to detect anomalies
- Challenges
   - Labeling data is expensive and time-consuming
   - Anomalies are often rare and difficult to detect
   - Anomalies may change over time
   - Cannot detect unknown and emerging anomalies
   - Anomalies may be specific to a particular context
   - Anomalies may be specific to a particular user or group of users

#### Semi-Supervised Anomaly Detection
- Labels are available only for normal data
- apply the trained model to both unlabelled and labelled data
- Any instance that falls outside the learned decision boundary is marked as a potential anomaly
- Challenges
   - Require labels from the normal class
   - Possible high false alarm rate - previously unseen (yet legitimate) data records may be recognised as anomalies

#### Unsupervised Anomaly Detection
- Assume the normal objects are somewhat "clustered" into multiple groups, each having some distinct features
- An outlier is expected to be far away from any groups of normal objects
- Challenges
   - Normal objects may not share any strong patterns, but the collective outliers may share high similarity in a small area
   - Ex. In intrusion detection, normal activities are diverse
   - Unsupervised methods may have a high false positive rate but still miss many real outliers

#### Unsupervised Anomaly Detection Approaches
- Statistical (model-based)
   - Assume that normal data follow some statistical model, such as Gaussian distribution
- Proximity-based
   - An object is an outlier if the nearest neighbours of the object are far away
- Density-based
   - Outliers are objects in regions of low density
- Clustering-based
   - Normal data belong to large and dense clusters

#### Statistical (model-based)
- Pros
   - Statistical tests are well-understood and well-validated.
   - Quantitative measure of the degree to which an object is an outlier.
- Cons
   - Data may be hard to model parametrically.
   - Multiple modes
   - Variable density
   - In high dimensions, data may be insufficient to estimate the true distribution.

#### Proximity-based
- Pros
   - Easier to define a proximity measure for a dataset than to determine its statistical distribution.
   - Quantitative measure of the degree to which an object is an outlier.
   - Deals naturally with multiple modes.
- Cons
   - O(n^2) complexity.
   - Score sensitive to choice of k.
   - Does not work well if the data has widely variable density.

#### Density-based
- Pros
   - Quantitative measure of the degree to which an object is an outlier.
   - It can work well even if the data has variable density.
- Cons
   - O(n^2) complexity
   - Must choose parameters
   - k for nearest neighbours
   - d for distance threshold

#### Clustering-based
- Pros
   - Some clustering techniques have O(n) complexity.
   - Extends the concept of outlier from single objects to groups of objects.
- Cons
   - Requires thresholds for large and small clusters.
   - Sensitive to the number of clusters chosen.
   - Outliers may affect the initial formation of clusters.

## Week 12
### Bias
#### Out-group homogeneity bias (Stereotypes/Prejudice)
- Humans tend to perceive out-group members as less nuanced than in-group members.
#### Correlation Fallacy
- Humans have a tendency to mistake correlation (two co-incidentally co-occurring events) with causation.
#### Historical Bias
- A randomly sampled data set, reflects the world as it was including existing biases which should not be carried forward

### Measurement Bias
- Noisy measurement â†’ errors or missing data points which are not randomly distributed
- Mistaking a (noisy) proxy for a label of interest
- Oversimplification of the quantity of interest
- should 1. Know your domain 2. Know your task 3. Know your data

### Model Bias
- Weak models: high bias â€“ low variance
- Unjustified model assumptions
- Blind loss functions: Blind to certain types of errors
- should 1. Carefully consider model assumptions 2. Carefully choose loss functions 3. Model groups separately 4. Represent groups fairly in the data

### Evaluation / Deployment Bias
- Test set not representative
- Overfit to a test set
- Evaluation metrics may not capture all quantities of interest (disregard minority groups or average effects)
- Use of systems in ways they were not intended to use. Lack of education of end-users.