---
icon: pen-to-square
date: 2025-03-02
category:
  - Learning Records
tag:
  - Unimelb
---

# Declarative Programming (COMP90048)

## Week 1

#### Imperative languages are based on commands, in the form of instructions and statements.
- Commands are executed.
- Commands have an effect, such as to update the computation state,and later code may depend on this update.
#### Logic programming languages are based on finding values that satisfy a set of constraints.
- Constraints may have multiple solutions or none at all.
- Constraints do not have an effect.
#### Functional languages are based on evaluating expressions.
- Expressions are evaluated.
- Expressions do not have an effect.

## Prolog
Prolog is a declarative programming language. It is based on logic programming and uses the predicate calculus.

```prolog
% import the test.pl file
% (A small part of) the British Royal family
% parent(queen_elizabeth, prince_charles).
% parent(prince_philip, prince_charles).
% parent(prince_charles, prince_william).
% parent(prince_charles, prince_harry).
% parent(princess_diana, prince_william).
% parent(princess_diana, prince_harry).
?- [test].
%queries
?- parent(prince_charles, prince_william).
% true
% This query asks: of whom Prince Charles is a parent?
?- parent(prince_charles, X)
```

- If there is more than one answer to the query, Prolog prints them one at a time, pausing to see if more solutions are wanted. Typing semicolon asks for more solutions; just hitting enter (return) finishes without more solutions.

### Rules
**Rules need to be written in the file .pl**
```prolog
% â€œX is grandparent of Z if X is parent of Y and Y is parent of Z .â€
grandparent(X,Z) :- parent(X, Y), parent(Y, Z).
```
- Rules can be recursive. Prolog has no looping constructs, so recursion is widely used.
```prolog
% A personâ€™s ancestors are their parents and the ancestors of their parents.
ancestor(Anc, Desc) :-parent(Parent, Desc),ancestor(Anc, Parent).
```

### Equality
- Equality in Prolog, written â€œ=â€ and used as an infix operator, can be used both to bind variables and to check for equality. Prolog is a single-assignment language: once bound, a variable cannot be reassigned.

### Disjunction and Conjunction
- Goals can be combined with disjunction (or) as well as conjunction (and). Disjunction is written â€œ;â€ and used as an infix operator. Conjunction (â€œ,â€) has higher precedence (binds tighter) than disjunction, but parentheses can be used to achieve the desired precedence.

### Negation
- Negation in Prolog is written â€œ\+â€ and used as a prefix operator. Negation has higher (tighter) precedence than both conjunction and disjunction. Be sure to leave a space between the \+ and an open parenthesis.
```prolog
% Who are the parents of Prince William other than Prince Charles?
?- parent(X, prince_william), \+ X = prince_charles.
X = princess_diana.
```
- Disequality in Prolog is written as an infix â€œ\=â€. So X \= Y is the same as \+ X = Y.

### Closed World Assumption
- Prolog assumes that all terms are true, unless explicitly stated otherwise. This is called the closed world assumption (CWA). **This means that if a term is not mentioned in the program, it is assumed to be false**. This can be a problem if the program is used to reason about real-world situations, where some terms may be unknown or undecidable.

:::info
1. Variables must start with an uppercase letter (A-Z) or _.
2. Atoms (constants) must start with a lowercase letter (a-z) or be enclosed in single quotes ('...').
3. Prolog is strictly case-sensitive, so X and x are completely different!
:::

## Week 2
### Prolog Concepts
- In Prolog, all data structures are called term. A term can be atomic orcompound, or it can be a variable.
- An atom begins with a lower case letter and follows with letters, digits and underscores
- each compound term is a functor (sometimes called function symbol) followed by one or more arguments in parentheses, separated by commas.
- List: [] is the empty list, [H | T] is a list with head H and tail T.
- A variable is also a term. It denotes a single unknown term. A variable name begins with an upper case letter or underscore, followed by any number of letters, digits, and underscores.
- Prolog is a single-assignment language: a variable can only be bound (assigned) once.
- A term is a ground term if it contains no variables, and it is a nonground term if it contains at least one variable.
- A substitution is a mapping from variables to terms.Any ground Prolog term has only one instance, while a nonground Prolog terms has an infinite number of instances.

### Proper Lists
- A proper list is either empty ([]) or not ([X | Y]), in which case, the tail of the list must be a proper list. We can define a predicate to recognise these.
```prolog
proper_list([]).
proper_list([_Head|Tail]) :-
proper_list(Tail).
```

### Append
- The append operation is used to concatenate two lists. It is defined as follows:
```prolog
append([], C, C).
append([A|B], C, [A|BC]) :-
append(B, C, BC).
```

### e.g. Find the first n th elements of a list
```prolog
% Find the first n th elements of a list
take(N, List, Front) :-
length(Front,N),
append(Front, _, List).
```

### Arithmetic
- Use the built-in predicate is/2 (an infix operator) evaluates expressions.
![Prolog Arithmetic Expressions](Prolog-Arithmetic-Expressions.png)

### Logic and Resolution

#### 1. **Resolution Method (Resolution)**:
Resolution is an inference method used in automated reasoning systems (like Prolog). It works by applying facts and rules to a goal, simplifying the goal until it becomes either a tautology or a contradiction.

#### 2. **Rules and Facts**:
- **Facts** are known true statements.
- **Rules** are conditional inferences and are written in the form of `head :- body`. This means if `body` is true, then `head` is true.

#### 3. **Resolution Algorithm**:
- The core of the resolution method is to use **proof by contradiction** (driving reasoning through negation of the goal).
- It simplifies the goal by matching it with rules and facts in the program until a conclusion is reached, or no solution is found.

#### 4. **Specific Process**:
- Select a clause and attempt to match it with the goal.
- Use logical reasoning to reduce the goal until it is either true (tautology) or false (contradiction). If the goal is true, a solution has been found. If false, there is no solution.

#### Summary:
Resolution in Prolog is used to derive a goal step by step by applying rules, rather than directly "computing" the result. It is a **logic programming** approach based on inference.


## Week 3

### Debugger

- The debugger prints the current port, execution depth, and goal (with the current variable bindings) at each step.
- use `trace.` to start tracing, and `notrace.` to stop tracing. `creep` can be used to step through the program one step at a time.
- Bird box model: the debugger shows the current state of the program, and the user can selectively step through the program to examine the intermediate states.

### Infinite backtracking loop
- If a goal cannot be proven, Prolog will backtrack and try other possibilities. This can lead to an infinite loop.
- To avoid this, we can use the `once` predicate, which will try to prove the goal once, and fail if it cannot be provenã€‚


### Tail Recursion
- Tail recursion is a special case of recursion where the recursive call is the last operation performed in the function.
- Efficiency: Tail recursion helps to avoid adding stack frames with each recursive call, thereby reducing memory consumption. Especially with deep recursion, it can prevent stack overflow errors.
- Optimization: Some Prolog implementations can optimize tail-recursive predicates by reusing the same stack frame, making the performance of tail recursion as efficient as iterative solutions.

- We make factorial tail recursive by introducing an accumulating parameter, or just an accumulator. This is an extra parameter to the predicate that holds a partially computed result.

## Week 4
### Homoiconicity
- Homoiconicity is a property of programming languages that allows the use of data structures as first-class citizens.
- In Prolog, this means that terms can be constructed and manipulated at runtime, and that the language itself can be used as a data structure.
### Auto-loading
- Many SWI Prolog â€œbuilt-insâ€, such as append/3, are not actually built-in, but are auto-loaded. 

:::info
### Call
square(X, Y) :- Y is X * X.
?- call(square, 5, Y).
Y = 25.
:::

e.g.
```prolog
filter(_, [], []).
filter(P, [X|Xs], Filtered) :-
    ( call(P, X) ->
        Filtered = [X|Filtered1]
    ;
        Filtered = Filtered1
    ),
    filter(P, Xs, Filtered1).
```
```bash
# ä¿ç•™å¶æ•°
filter(even, [1,2,3,4,5,6], Result).
# Result å°†æ˜¯ [2,4,6]

# ä¿ç•™å¤§äº3çš„æ•°
filter(X > 3, [1,2,3,4,5,6], Result).
# Result å°†æ˜¯ [4,5,6]
```
### Setof
- The `setof` construct is used to generate a set of solutions to a goal. It is similar to `findall`, but it returns a set of solutions instead of a list.
Templateï¼šæ¨¡æ¿é¡¹ï¼Œé€šå¸¸åŒ…å«Goalä¸­çš„å˜é‡
Goalï¼šè¦æ±‚è§£çš„ç›®æ ‡
Listï¼šæ”¶é›†çš„è§£çš„æœ‰åºåˆ—è¡¨
e.g.
```bash
#  æ‰¾å‡ºèƒ½è¢«3æ•´é™¤çš„æ•°
setof(X, X in 1..10, Y)
# Y å°†æ˜¯ [3, 6, 9]

# æ›´å¤æ‚çš„ä¾‹å­
setof(X, Y^(parent(Y, X)), Children)
# æ‰¾å‡ºæ¯ä¸ªçˆ¶äº²çš„å­©å­åˆ—è¡¨
```
Use existential quantification, written with infix caret (Ë†), to collect
solutions for a template regardless of the bindings of some of the variables
not in the Template.

### Bagof
- The bagof/3 predicate is just like setof/3, except that it does not sort the result or remove duplicates.

### Comparing 
- Prolog, somewhat arbitrarily, uses the ordering: **Variables < Numbers < Atoms < CompoundTerms**
- `@<, @=<, @>, and @>=`

### Sorting
- sort list according to @< ordering
- sort/2 sorts a list, removing duplicates, 
- msort/2 sorts a list, without removing duplicates, and 
- keysort/2 stably sorts list of X-Y terms, only comparing X parts

### Determining term types
```bash
?- integer(3)
true.

?- float(3.14)
true.

?- atom(hello)
true.
```
### Others
- var/1 holds for unbound variables, nonvar/1 holds for any term other
than an unbound variable, and ground/1 holds for ground terms (this
requires traversing the whole term). Using these or the predicates on the
previous slide can make your code behave differently in different modes.
```prolog
% Define a custom infix operator
:- op(Precedence, Type, OperatorName).
:- op(500, yfx, '+>').  

% Now it can be used like this
test(X) :- 3 +> 4 = X.
- write/1 is handy for printing messages
```
### Propagation and Labeling  
- Propagation: Reducing the domain of variables through constraints to improve solving efficiency.
- Labeling: Selecting specific values for variables to try to satisfy all constraints.

### CLP(FD)
- In the CLP(FD) (Constraint Logic Programming over Finite Domains) library, more advanced arithmetic constraint predicates are provided, which can be used for bidirectional reasoning (i.e., in,out and out,in modes).
| **Arithmetic Predicate** | **Limitation** | **CLP(FD) Alternative** | **Advantage** |
|--------------------------|----------------|-------------------------|---------------|
| `is/2`                   | Right side must be ground | `#=/2`  | Supports variable inference |
| `=:=/2`                  | Can only compare known values | `#=/2`  | Suitable for variables |
| `=\=/2`                  | Can only compare known values | `#\=/2` | Suitable for variables |
| `=< /2`                  | Can only compare known values | `#=</2` | Suitable for variables |

| **Operator**             | **Description**                |
|--------------------------|--------------------------------|
| `Expr1 #= Expr2`         | `Expr1` equals `Expr2`         |
| `Expr1 #\= Expr2`        | `Expr1` not equal to `Expr2`   |
| `Expr1 #> Expr2`         | `Expr1` greater than `Expr2`   |
| `Expr1 #< Expr2`         | `Expr1` less than `Expr2`      |
| `Expr1 #>= Expr2`        | `Expr1` greater than or equal to `Expr2` |
| `Expr1 #=< Expr2`        | `Expr1` less than or equal to `Expr2`    |
| `Var in Low..High`       | `Low â‰¤ Var â‰¤ High`             |
| `List ins Low..High`     | Each `Var` in `List` is between `Low..High` |

- label/1 is an enumeration predicate used to search for specific assignments of variables to satisfy all defined constraints. It traverses possible values of variables and solves them.

- Generate-and-Test requires generating candidate solutions before validation, which is less efficient.
- Constrain-and-Generate reduces the range of candidate solutions through constraints, usually more efficient.
- Through labeling, Prolog can automate the search process and provide the final solution.

## Week 5
### Haskell
- Haskell is a purely functional programming language. It is statically typed, and supports pattern matching, higher-order functions, and lazy evaluation.

### [] in Haskell
- The empty list is denoted by [], and it is a built-in data type in Haskell.
- ["a","b"] is syntactic suger for `"a" : "b" : []`.

### Functions in Haskell

:::info
Haskell æ˜¯ä¸€ç§çº¯å‡½æ•°å¼ç¼–ç¨‹è¯­è¨€ï¼Œå®ƒå¼ºè°ƒåœ¨ç¼–ç¨‹ä¸­ä½¿ç”¨å‡½æ•°ã€‚åœ¨ Haskell ä¸­ï¼Œå‡½æ•°æ˜¯ä¸€ç­‰å…¬æ°‘ï¼Œè¿™æ„å‘³ç€å®ƒä»¬å¯ä»¥åƒå…¶ä»–æ•°æ®ç±»å‹ä¸€æ ·è¢«ä¼ é€’å’Œæ“ä½œã€‚ä¸‹é¢æ˜¯ä¸€äº›å…³äº Haskell å‡½æ•°çš„åŸºæœ¬ä»‹ç»ï¼š
### å‡½æ•°å®šä¹‰
åœ¨ Haskell ä¸­ï¼Œå‡½æ•°é€šè¿‡ä»¥ä¸‹è¯­æ³•å®šä¹‰ï¼š
```haskell
name :: TypeSignature
name parameter1 parameter2 ... = expression
```
- `name` æ˜¯å‡½æ•°çš„åç§°ã€‚
- `TypeSignature` æ˜¯å‡½æ•°çš„ç±»å‹ç­¾åï¼Œå®ƒå£°æ˜äº†å‡½æ•°çš„è¾“å…¥ç±»å‹å’Œè¾“å‡ºç±»å‹ã€‚
- `parameter1`, `parameter2`, ... æ˜¯å‡½æ•°çš„å‚æ•°ã€‚
- `expression` æ˜¯å‡½æ•°ä½“ï¼Œå®ƒå®šä¹‰äº†å¦‚ä½•ä»å‚æ•°è®¡ç®—ç»“æœã€‚
### ç¤ºä¾‹
è¿™æ˜¯ä¸€ä¸ªç®€å•çš„ Haskell å‡½æ•°ï¼Œå®ƒå°†ä¸¤ä¸ªæ•°å­—ç›¸åŠ ï¼š
```haskell
add :: Num a => a -> a -> a
add x y = x + y
```
åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œ`add` æ˜¯å‡½æ•°åï¼Œ`Num a =>` è¡¨ç¤ºè¿™ä¸ªå‡½æ•°é€‚ç”¨äºä»»ä½•æ•°å€¼ç±»å‹ `a`ï¼Œ`a -> a -> a` æ˜¯ç±»å‹ç­¾åï¼Œè¡¨ç¤ºå‡½æ•°æ¥å—ä¸¤ä¸ªç±»å‹ä¸º `a` çš„å‚æ•°å¹¶è¿”å›ä¸€ä¸ªç±»å‹ä¸º `a` çš„ç»“æœã€‚
### å‡½æ•°è°ƒç”¨
åœ¨ Haskell ä¸­ï¼Œå‡½æ•°è°ƒç”¨ä¸ä½¿ç”¨æ‹¬å·ï¼Œè€Œæ˜¯é€šè¿‡ç©ºæ ¼åˆ†éš”å‚æ•°ï¼š
```haskell
result = add 3 4
```
è¿™å°†è¿”å› `7`ã€‚
### æ¨¡å¼åŒ¹é…
Haskell å‡½æ•°é€šå¸¸ä½¿ç”¨æ¨¡å¼åŒ¹é…æ¥å®šä¹‰ä¸åŒçš„è¡Œä¸ºï¼Œè¿™ç±»ä¼¼äºå…¶ä»–è¯­è¨€ä¸­çš„ switch è¯­å¥æˆ–å¤šä¸ª if-else è¯­å¥ã€‚ä¾‹å¦‚ï¼š
```haskell
factorial :: (Integral a) => a -> a
factorial 0 = 1
factorial n = n * factorial (n - 1)
```
è¿™é‡Œï¼Œ`factorial` å‡½æ•°é€šè¿‡æ¨¡å¼åŒ¹é…å®šä¹‰äº†ä¸¤ç§æƒ…å†µï¼šå½“è¾“å…¥ä¸º `0` æ—¶è¿”å› `1`ï¼Œå¦åˆ™é€’å½’åœ°è®¡ç®— `n * (n - 1)!`ã€‚
### é€’å½’
ç”±äº Haskell æ²¡æœ‰ while æˆ– for å¾ªç¯ï¼Œé€’å½’æ˜¯æ‰§è¡Œé‡å¤ä»»åŠ¡çš„ä¸»è¦æ–¹å¼ã€‚ä¸Šé¢çš„ `factorial` å‡½æ•°å°±æ˜¯ä¸€ä¸ªé€’å½’çš„ä¾‹å­ã€‚
### é«˜é˜¶å‡½æ•°
Haskell æ”¯æŒé«˜é˜¶å‡½æ•°ï¼Œå³å¯ä»¥æ¥å—å…¶ä»–å‡½æ•°ä½œä¸ºå‚æ•°æˆ–è¿”å›å‡½æ•°ä½œä¸ºç»“æœçš„å‡½æ•°ã€‚ä¾‹å¦‚ï¼š
```haskell
applyTwice :: (a -> a) -> a -> a
applyTwice f x = f (f x)
```
è¿™ä¸ª `applyTwice` å‡½æ•°æ¥å—ä¸€ä¸ªå‡½æ•° `f` å’Œä¸€ä¸ªå‚æ•° `x`ï¼Œç„¶åä¸¤æ¬¡åº”ç”¨ `f` åˆ° `x` ä¸Šã€‚
### æƒ°æ€§è®¡ç®—
Haskell ä½¿ç”¨æƒ°æ€§è®¡ç®—æ¨¡å‹ï¼Œè¿™æ„å‘³ç€è¡¨è¾¾å¼åªåœ¨éœ€è¦æ—¶è®¡ç®—ã€‚è¿™å…è®¸ Haskell ç¨‹åºä»¥éå¸¸é«˜æ•ˆçš„æ–¹å¼å¤„ç†æ— é™æ•°æ®ç»“æ„å’Œå…¶ä»–é«˜çº§æŠ½è±¡ã€‚
è¿™äº›æ˜¯ Haskell å‡½æ•°çš„ä¸€äº›åŸºæœ¬æ¦‚å¿µã€‚Haskell çš„å¼ºå¤§ä¹‹å¤„åœ¨äºå®ƒçš„ç±»å‹ç³»ç»Ÿå’Œå‡½æ•°å¼ç¼–ç¨‹èŒƒå¼ï¼Œè¿™ä½¿å¾—ç¼–å†™ç®€æ´ã€å¯é‡ç”¨å’Œé«˜æ•ˆçš„ä»£ç æˆä¸ºå¯èƒ½ã€‚

:::


### Referential transparency
- A function is referentially transparent if it always returns the same result when given the same arguments.


### Useful Haskell Built in Functions
- length computes the number of elements in a list
- null returns True if a list is empty, and False otherwise
- the !! operator gets the nth element of a list, as in [1,2,3,4] !! 2, which gives us 3 (note zero-based list indexing).
- the ++ operator joins two lists together, as in [1,2] ++ [3,4], which gives us [1,2,3,4]
- head and tail separate a list into its first and remaining elements
- last and init do just the opposite
- take n and drop n split the list at an arbitrary point

### Common List Functions
head, tail, last, init, take and drop sum  maximum elem !! ++ splitAt

### Basic Types
- Int: Integer, 32-bit signed integer
- Integer: Integer, arbitrary-precision integer
- Float: Floating-point number
- Char: Character
- String: List of characters
- Bool: Boolean
- Tuple: Fixed-size collection of values
- List: Variable-size collection of values


## Week 6
### Binary Tree
### Search Tree
### Expression Tree

## Week 7

### Common Functions in Data.List
| å‡½æ•°       | ç±»å‹ç­¾å                        | ä½œç”¨è¯´æ˜               | ç¤ºä¾‹ä»£ç                   | è¾“å‡ºç»“æœ                  |
| -------- | --------------------------- | ------------------ | --------------------- | --------------------- |
| `map`    | `(a -> b) -> [a] -> [b]`    | å¯¹åˆ—è¡¨æ¯ä¸ªå…ƒç´ åº”ç”¨ä¸€ä¸ªå‡½æ•°      | `map (*2) [1,2,3]`    | `[2,4,6]`             |
| `sort`   | `Ord a => [a] -> [a]`       | å‡åºæ’åº               | `sort [3,1,2]`        | `[1,2,3]`             |
| `filter` | `(a -> Bool) -> [a] -> [a]` | ä¿ç•™æ»¡è¶³æ¡ä»¶çš„å…ƒç´           | `filter even [1..6]`  | `[2,4,6]`             |
| `group`  | `Eq a => [a] -> [[a]]`      | æŠŠç›¸é‚»ç›¸ç­‰çš„å…ƒç´ åˆ†ç»„         | `group [1,1,2,3,3,3]` | `[[1,1],[2],[3,3,3]]` |
| `nub`    | `Eq a => [a] -> [a]`        | å»é™¤é‡å¤å…ƒç´ ï¼ˆä¿ç•™ç¬¬ä¸€ä¸ªå‡ºç°çš„ï¼‰   | `nub [1,2,2,3,1]`     | `[1,2,3]`             |
| `delete` | `Eq a => a -> [a] -> [a]`   | åˆ é™¤åˆ—è¡¨ä¸­ç¬¬ä¸€ä¸ªåŒ¹é…çš„å…ƒç´       | `delete 2 [1,2,3,2]`  | `[1,3,2]`             |
| `(\\)`   | `Eq a => [a] -> [a] -> [a]` | åˆ—è¡¨å·®ï¼šä»å·¦è¾¹åˆ—è¡¨ä¸­åˆ å»å³è¾¹æ‰€æœ‰å…ƒç´  | `[1,2,2,3] \\ [2,3]`  | `[1,2]`               |


### List Comprehension
#### Home-made map
```haskell
myMap :: (a -> b) -> [a] -> [b]
myMap f xs = [f x | x <- xs]
```

#### Home-made filter
```haskell
myFilter :: (a -> Bool) -> [a] -> [a]
myFilter p xs = [x | x <- xs, p x]
```

#### Loop Conversion
```text
function matches xs ys: 
    set l to [] 
    for x in xs: 
        for y in ys: 
            if x == y: 
                append x to l 
    return (length l)
```

è¿™æ®µé€»è¾‘çš„ä½œç”¨æ˜¯ï¼š
**ç»Ÿè®¡åœ¨ä¸¤ä¸ªåˆ—è¡¨ `xs` å’Œ `ys` ä¸­ç›¸ç­‰çš„å…ƒç´ å¯¹çš„æ•°é‡ï¼ˆåŒ…æ‹¬é‡å¤ï¼‰**ã€‚

---

#### âœ… Haskell ç‰ˆæœ¬çš„å†™æ³•ï¼š

```haskell
matches :: Eq a => [a] -> [a] -> Int
matches xs ys = length [x | x <- xs, y <- ys, x == y]
```

---

#### ğŸ” åˆ†è§£è§£é‡Šï¼š

* `[x | x <- xs, y <- ys, x == y]`
  è¿™æ˜¯ä¸€ç§åˆ—è¡¨æ¨å¯¼ï¼Œç”Ÿæˆä¸€ä¸ªæ–°åˆ—è¡¨ï¼ŒåŒ…å«æ‰€æœ‰ `x`ï¼Œæ»¡è¶³ï¼š

  * `x` æ¥è‡ª `xs`
  * `y` æ¥è‡ª `ys`
  * åªæœ‰å½“ `x == y` æ—¶æ‰ç•™ä¸‹

* ç„¶åç”¨ `length` æ¥ç»Ÿè®¡è¿™æ ·çš„åŒ¹é…æœ‰å¤šå°‘ä¸ªã€‚
