---
icon: pen-to-square
date: 2025-07-21
category:
  - Learning Records
tag:
  - Review
---

# 数据库

## 数据库概念
- 数据库系统是由数据库、数据库管理系统（及其应用开发工具）、应用程序和数据库管理员（Data Base Administrator，DBA）组成的存储、管理、处理和维护数据的系统

### 数据库技术发展
| 阶段            | 主要特点                                                        | 使用场景举例            |
| ------------- | ----------------------------------------------------------- | ----------------- |
| **人工管理阶段**    | - 数据**不保存**<br>- 应用程序直接管理数据<br>- 数据面向应用<br>- 无独立性           | 最早期（如纸质记录、临时内存）   |
| **文件系统管理阶段**  | - 数据存放于**文件**<br>- 程序与数据有**一定独立性**<br>- 文件种类繁多<br>- 冗余高、共享差 | 早期计算机系统、C语言读写文件   |
| **数据库管理阶段**   | - **结构化存储**<br>- 数据共享性好，冗余低<br>- 数据独立性强<br>- 由 **DBMS统一管理** | 现代企业信息系统、MIS 系统等  |
| **高级数据库管理阶段** | - 支持**分布式、大数据、对象、图形、云原生**等特性<br>- 支持复杂查询、事务与安全机制            | 云数据库、分布式数据库、图数据库等 |


### 数据库系统特点
- 数据结构化
- 数据的共享度高
- 数据的独立性高
- 统一管理和控制

### 数据模型组成要素
| 要素        | 说明                                     | 快速识记关键词         |
| --------- | -------------------------------------- | --------------- |
| **数据结构**  | 描述数据库的组成对象和对象之间的联系，包括类型、属性、关系等         | **结构=对象 + 联系**  |
| **数据操作**  | 对数据库中对象实例执行的各种操作（如查询、插入、删除、更新）以及操作规则   | **操作=能做啥 + 规则** |
| **完整性约束** | 用于**约束和规范数据**的合法性，保证数据库中数据的**正确性与一致性** | **约束=规则 + 依赖性** |

### 数据模型
| 数据模型     | 结构特征                                 | 优点/特点                                                               | 口诀速记        |
| -------- | ------------------------------------ | ------------------------------------------------------------------- | ----------- |
| **层次模型** | - 一棵树结构<br>- 只有一个根结点<br>- 每个结点仅有一个双亲 | - 层次清晰，结构简单<br>- 查询速度快<br>- 插入/修改不方便                                | **一根一亲是层次** |
| **网状模型** | - 图结构<br>- 结点可有多个双亲<br>- 可有多个根       | - 灵活性强，能描述复杂关系<br>- 查询复杂，开发难度高                                      | **多根多亲是网状** |
| **关系模型** | - 表格结构（关系）<br>- 用元组、属性、关系表示一切        | - 建立在**数学基础**上<br>- 概念**单一清晰**<br>- 易学易用<br>  - 数据**独立性高**、**安全性好** | **全是表，关系妙** |

- 数据模型的抽象层次从高到低分为:概念模型、逻辑模型(结构模型)、物理模型。其中结构数据模型是数据库中将现实世界的概念模型转换为计算机可以处理的形式的第二层抽象。

### 关系模型的数据模型
| 术语         | 对应解释                   | 速记法             |
| ---------- | ---------------------- | --------------- |
| **关系 relation**     | 一张表（如学生登记表）            | 📋“表就是关系”       |
| **元组 tuple**     | 表中一行数据（如一个学生记录）        | 📌“一行一元组”       |
| **属性 attribute**     | 表中的一列（如学号、姓名等）         | 📊“一列一属性”       |
| **码 key** | 能唯一标识一行的字段（如学号）        | 🔐“唯一识别靠主码”     |
| **域 domain**      | 某属性的取值范围（如性别 ∈ {男, 女}） | 📎“属性取值有范围，称为域” |
| **分量 component**     | 一个元组中的某个属性值（如“王小明”）    | 🔍“属性值称作分量”     |

#### 举例讲解
表名（关系）：学生登记表

| 学号      | 姓名  | 年龄 | 性别 | 系名  | 年级   |
| ------- | --- | -- | -- | --- | ---- |
| 2013004 | 王小明 | 19 | 女  | 社会学 | 2013 |
| 2013006 | 黄大鹏 | 20 | 男  | 商品学 | 2013 |
| 2013008 | 张文斌 | 18 | 女  | 法律  | 2013 |

* **关系（Relation）**：这整张表就是一个关系，名字可以叫 `学生`。
* **元组（Tuple）**：每一行是一个元组，例如 `（2013004, 王小明, 19, 女, 社会学, 2013）`
* **属性（Attribute）**：如“姓名”“年龄”等列。
* **码（Key）**：学号唯一标识学生，是主码。
* **域（Domain）**：

  * `性别属性 ∈ {男，女}`
  * `年龄属性 ∈ \[15, 45]`
* **分量**：王小明、20、社会学等具体值就是分量。


### 关系模型性质
| 编号 | 性质说明              | 关键词   | 速记法        |
| -- | ----------------- | ----- | ---------- |
| 1  | 行的顺序无关，元组互换不影响关系  | 行可调   | “行换不影响”    |
| 2  | 分量必须是原子量，不可再分     | 原子分量  | “分量不可再拆”   |
| 3  | 不能有重复行，元组必须唯一     | 无重复元组 | “两行不能完全相同” |
| 4  | 属性名唯一，不能有相同列名     | 列名唯一  | “列名不能重样”   |
| 5  | 列的顺序无关，属性互换不影响    | 列可调   | “列调换无影响”   |
| 6  | 同列数据来自同一域，即数据类型一致 | 同域同质  | “同一列必须同质”  |


### ER图
| 内容               | 图形表示 | 快速记法                          |
| ---------------- | ---- | ----------------------------- |
| **E-R 图：实体-联系图** | -    | “E 是 Entity，R 是 Relationship” |
| **图形表示法**        |      |                               |
| 实体（Entity）       | ▭ 矩形 | “实体是框——人、物、概念” 矩形框内写明实体名               |
| 属性（Attribute）    | ⬭ 椭圆 | “属性像蛋——描述实体的特征” 用无向边将其对应的实体型连接起来              |
| 联系（Relationship） | ◇ 菱形 | “联系是菱形——谁和谁之间的关系” 菱形框内写明联系名，并用无向边分别与有关实体型连接起来            |
| **联系类型（基数）**     |      | “一多多多要分清”                     |
| 一对一（1:1）         |      | 每个实体只联系一个实体                   |
| 一对多（1:N）        |      | 一个对应多个                        |
| 多对一（N:1）         |      | 多个对应一个                        |
| 多对多（M\:N）        |      | 多个对多个                         |

- 实体:客观存在并且可以区分的具体事物或者抽象概念。
- 实体型:实体集的名称及其所有属性名的集合称为实体型。
- 实体集:所有属性名完全相同的实体集合在一起， 称为实体集。

### 三级模式
| 名称      | 又称     | 面向对象    | 作用 & 特点                                |
| ------- | ------ | ------- | -------------------------------------- |
| **模式**  | 逻辑模式   | 面向整个数据库 | 描述**全体数据的逻辑结构**，所有用户共享，<br>是数据库的“总体视图” |
| **外模式** | 子模式、视图 | 面向用户    | 是**每个用户看到的数据子集**，用于**控制访问权限、安全性、定制视图** |
| **内模式** | 存储模式   | 面向系统    | 定义**物理存储方式**：如何在磁盘上保存数据（如索引结构、压缩、加密）   |

- 数据库三级模式结构包括外模式、概念模式和内模式,这种划分的主要目的就是实现数据独立性。

### 二级映像
| 映像名称     | 映射对象      | 作用             | 保证什么独立性   | 说明               |
| -------- | --------- | -------------- | --------- | ---------------- |
| 外模式/模式映像 | 外模式 ←→ 模式 | 定义用户视图和逻辑结构的对应 | **逻辑独立性** | 模式改了，外模式不动，程序不改  |
| 模式/内模式映像 | 模式 ←→ 内模式 | 定义逻辑结构和物理结构的对应 | **物理独立性** | 存储方式改了，模式不动，程序不改 |

## 关系数据库概论
### 关系数据结构
| 名称  | 作用         | 特点            |
| --- | ---------- | ------------- |
| 超码 Superkey | 能唯一识别元组    | 可能含多余字段       |
| 候选码 Candidate Key | 最简超码       | 不能再删字段        |
| 主码 Primary Key | 候选码中选一个做代表 | 只能有一个         |
| 外码 Foreign Key | 指向别的表的主码   | 表间建立联系，非自己表主码 |

### 关系操作
| 运算   | 符号 | 类似集合什么操作？   | 常用场景          |
| ---- | -- | ----------- | ------------- |
| 并    | ∪  | 集合并集        | 多个条件取并集       |
| 差    | −  | 集合差集        | 去除某些元组        |
| 交    | ∩  | 集合交集        | 找共同数据         |
| 笛卡尔积 | ×  | 所有组合        | 连接前的构造中间表     |
| 选择   | σ  | 筛选行         | `WHERE` 子句作用  |
| 投影   | π  | 选列          | `SELECT` 子句作用 |
| 连接   | ⨝  | 基于笛卡尔积的筛选组合 | 表关联查询         |
| 除    | ÷  | 含义较特殊：全包含匹配 | 满足所有条件的筛选（高级） |

- 关系的基本操作有五种，分别是：选择、投影、并、差、笛卡尔积

### 关系完整性
| **完整性类型**    | **约束对象**        | **规则内容**                 | **允许为空？**            | **举例**                           |
| ------------ | --------------- | ------------------------ | -------------------- | -------------------------------- |
| **实体完整性**    | 主码（Primary Key） | 每个关系必须有主码，且主码不能为空，且唯一    | ❌ **不允许为空**          | 学生表中的 `学号` 是主码，不能为 `NULL`，不能重复   |
| **参照完整性**    | 外码（Foreign Key） | 外码必须引用另一个关系中的主码值，或者为空    | ✅ **允许为空**，但如不为空必须有效 | 成绩表中的 `学号` 是外码，必须能在学生表中找到对应 `学号` |
| **用户自定义完整性** | 任意属性（字段）        | 针对具体应用逻辑的业务规则（如取值范围、格式等） | 看定义（由用户决定）           | 年龄必须大于 0；邮箱格式必须合法；性别只能是男/女等      |

- 参照完整性共分四种模式：不执行操作、级联、置空、设置默认值。

| 模式         | 触发场景（主表操作） | 从表外键处理逻辑               | 前提条件                     |
|--------------|----------------------|--------------------------------|------------------------------|
| 不执行操作   | 删除/修改主键        | 拒绝操作，报错                 | 无（强制保证关联）           |
| 级联         | 删除/修改主键        | 同步删除/修改外键              | 无（自动执行）               |
| 置空         | 删除/修改主键        | 外键设为 NULL                  | 外键列允许 NULL              |
| 设置默认值   | 删除/修改主键        | 外键设为默认值                 | 外键列已设置默认值           |


## SQL
### 特点
| **特点**    | **说明**                                                | **速记关键词** |
| --------- | ----------------------------------------------------- | --------- |
| 综合统一      | 集数据定义语言（DDL）、数据操纵语言（DML）、数据控制语言（DCL）于一体，支持数据库生命周期全部活动 | 统一、全功能    |
| 高度非过程化    | 用户只需关注“做什么”，不必关心“怎么做”，存取路径对用户透明，简化操作                  | 非过程化、做什么  |
| 面向集合的操作方式 | SQL操作的是数据集合，结果也是集合，而不是单条记录的处理                         | 面向集合      |
| 一种语法多种使用  | SQL既能独立执行，也能嵌入C、Java等宿主语言中使用                          | 独立/嵌入     |
| 语言简洁易学    | 核心功能仅用九个动词实现，功能强大且语法简单                                | 简洁、易用     |

### 模式操作
| **操作** | **SQL语句格式**                               | **说明**          | **速记关键词**                               |            |
| ------ | ----------------------------------------- | --------------- | --------------------------------------- | ---------- |
| 定义模式   | `CREATE SCHEMA <模式名> AUTHORIZATION <用户名>` | 创建一个新的模式，并指定所有者 | 创建模式、指定用户                               |            |
| 删除模式   | `DROP SCHEMA <模式名> <CASCADE RESTRICT>` | 删除指定模式，`CASCADE`表示级联删除，`RESTRICT`表示限制删除 | 删除模式、级联/限制 |

### 基本表操作
| **操作** | **SQL语句格式**                               | **说明**          | **速记关键词**                               |            |
| ------ | ----------------------------------------- | --------------- | --------------------------------------- | ---------- |
| 定义基本表   | `CREATE TABLE <表名> (<列名> <数据类型> [完整性约束])` | 创建一个新的基本表 | 创建表、定义列、完整性约束                     |            |
| 删除基本表   | `DROP TABLE <表名>`                       | 删除指定基本表     | 删除表                                    |            |
| 修改基本表   | `ALTER TABLE <表名> <修改操作>`           | 修改指定基本表     | 修改表、修改列、修改约束                     |            |

### 索引和视图操作 
1. 每个索引都需要占用磁盘空间
2. 过多索引会降低更新、插入、删除等操作的性能
3. 优化器在选择索引时需要更多的时间

| **考点** | **操作** | **SQL语句格式**                        | **说明**        | **速记关键词** |
| ------ | ------ | ---------------------------------- | ------------- | --------- |
| 索引操作   | 建立索引   | `CREATE INDEX <索引名称> ON <表名>(列名);` | 创建索引，提高查询效率   | 建立索引、加速查询 |
| 索引操作   | 删除索引   | `DROP INDEX <索引名称>;`               | 删除指定索引        | 删除索引      |
| 视图操作   | 定义视图   | `CREATE VIEW <视图名> AS SELECT ...`  | 创建一个视图，简化复杂查询 | 创建视图      |
| 视图操作   | 删除视图   | `DROP VIEW <视图名>;`                 | 删除指定视图        | 删除视图      |
| 视图操作   | 更新视图   | `UPDATE <视图名> SET ...`             | 对视图的数据进行更新    | 更新视图      |

### 查询操作
| **SQL 关键字**    | **作用说明**                                 | **速记要点**           |
| -------------- | ---------------------------------------- | ------------------ |
| ALL / DISTINCT | 控制是否去重，DISTINCT 去除重复元组，ALL 保留重复元组，默认 ALL | 默认 ALL，DISTINCT 去重 |
| 目标列表达式         | 查询的列或表达式，作为结果集的列名                        | 每个表达式对应结果中的一
| FROM           | 指定查询的数据来源，表或视图                           | 可多表或视图查询           |
| WHERE          | 过滤条件，只输出满足条件的记录                          | 可省略，查询所有记录         |
| GROUP BY       | 按某列分组，将具有相同值的行归为一组                       | 分组字段值相同的元组归为一组     |
| HAVING         | 对分组后的结果过滤，只输出满足条件的分组                     | 只能与 GROUP BY 联合使用  |
| ORDER BY       | 对结果排序，默认升序（ASC），可指定降序（DESC）              | ASC 可省略，DESC 指定降序  |

- 聚合函数：COUNT、SUM、AVG、MAX、MIN 后面不可以加 `WHERE` 子句
```sql
-- 错误写法，聚合函数后不能直接用 WHERE
SELECT department, COUNT(*)
FROM employees
WHERE COUNT(*) > 5
GROUP BY department;

-- 正确写法，用 HAVING 过滤聚合结果
SELECT department, COUNT(*)
FROM employees
GROUP BY department -- group by 后面可以不加having
HAVING COUNT(*) > 5; -- having后面不一定非得用聚合函数，但大多数情况下是用来过滤聚合结果的
```

### 更新操作
| 内容            | 说明                                                                                | 示例                                                 |
| ------------- | --------------------------------------------------------------------------------- | -------------------------------------------------- |
| 插入数据 (INSERT) | `INSERT INTO <表名> [(属性列表)] VALUES (常量列表);`<br>必须为 NOT NULL 且无默认值列赋值。字符串和日期用单引号括起。 | `INSERT INTO Student (id, name) VALUES (1, '张三');` |
| 修改数据 (UPDATE) | `UPDATE <表名> SET 列名=表达式 [, 列名=表达式 ...] [WHERE 条件];`<br>无 WHERE 则更新全表。             | `UPDATE Student SET age=20 WHERE id=1;`            |
| 删除数据 (DELETE) | `DELETE FROM <表名> [WHERE 条件];`<br>无 WHERE 则删除所有记录但保留表结构。                          | `DELETE FROM Student WHERE age<18;`                |


### 查询条件
| 内容说明                                 | 说明示例                                        |
| ------------------------------------ | ------------------------------------------- |
| 比较大小：=、>、<、>=、<=、!=（<>）、!>、!<        | `age >= 18`                                 |
| 确定范围：BETWEEN…AND… 和 NOT BETWEEN…AND… | `salary BETWEEN 3000 AND 6000`              |
| 确定集合：IN                              | `department IN ('IT','HR')`                 |
| 字符匹配：LIKE 用于模糊匹配，支持通配符 `%` 和 `_`     | `name LIKE 'J%'`                            |
| 涉及空值查询：用 IS NULL 或 IS NOT NULL 查询空值  | `address IS NULL`                           |
| 多重条件：用 AND、OR 连接，AND 优先级高，括号改变优先级    | `(age > 20 AND city='NY') OR salary > 5000` |

## 安全性

### 安全级别标准
| 级别  | 说明                                     |
| --- | -------------------------------------- |
| D级  | 最低级别，未满足更高级别安全要求。                      |
| C1级 | 提供基本的自主安全保护（DAC），实现用户和数据分离，限制权限传播。     |
| C2级 | 最低档安全产品，支持用户身份注册、审计和资源隔离，细化DAC控制。      |
| B1级 | 标记安全保护，数据加标记，对主体和客体执行强制访问控制（MAC）和审计。   |
| B2级 | 结构化保护，形式化安全策略，所有主体和客体均受DAC和MAC控制。      |
| B3级 | 安全域，满足访问监控器要求，增强审计和系统恢复能力。             |
| A1级 | 验证设计，在B3基础上提供系统的形式化设计说明和验证，确保安全措施真正实施。 |

### 安全机制
| 安全机制    | 说明                           |
| ------- | ---------------------------- |
| 用户标识与鉴别 | 确认用户身份，如用户名、密码、生物识别等，防止冒用。   |
| 存取控制    | 控制用户对数据库对象的访问权限，限制非法访问。      |
| 授权与回收   | 给用户分配权限（授权），并在不需要时撤销权限（回收）。  |
| 视图机制    | 通过视图限制用户只能看到特定的数据，达到数据隔离和安全。 |
| 审计      | 记录数据库访问和操作日志，用于事后安全分析和责任追踪。  |
| 数据加密    | 对数据库中存储或传输的数据进行加密，保护数据机密性。   |

#### 用户标识与鉴别
| 类型     | 说明                                |
| ------ | --------------------------------- |
| 用户标识   | 通过用户名或用户标识号表示身份，系统核对合法性，决定是否允许访问。 |
| 口令     | 用户输入密码进行身份验证，输入时屏幕不显示，保护口令安全。     |
| 利用个人特征 | 通过生物特征识别验证身份，如指纹识别、面部识别等。         |
| 智能卡    | 使用带有微处理器和存储的智能卡作为身份验证工具，安全可靠。     |


### 授权和回收

#### 授权示例

**例子 1：给用户 `alice` 授予对表 `employees` 的查询权限**
```sql
GRANT SELECT ON TABLE employees TO alice;
```

**例子 2：给用户 `bob` 授予对数据库 `sales_db` 中多个表的插入和更新权限**

```sql
GRANT INSERT, UPDATE ON TABLE orders TO bob;
GRANT INSERT, UPDATE ON TABLE customers TO bob;
```

**例子 3：给所有用户（PUBLIC）授予对视图 `public_view` 的查询权限**

```sql
GRANT SELECT ON VIEW public_view TO PUBLIC;
```

**例子 4：给用户 `charlie` 授予权限并允许他将权限继续授权给其他人**

```sql
GRANT SELECT, UPDATE ON TABLE products TO charlie WITH GRANT OPTION;
```

#### 收回权限示例

**例子 1：收回用户 `alice` 对表 `employees` 的查询权限**

```sql
REVOKE SELECT ON TABLE employees FROM alice;
```

**例子 2：收回用户 `bob` 对表 `orders` 和 `customers` 的插入和更新权限**

```sql
REVOKE INSERT, UPDATE ON TABLE orders FROM bob;
REVOKE INSERT, UPDATE ON TABLE customers FROM bob;
```

**例子 3：收回所有用户对视图 `public_view` 的查询权限**

```sql
REVOKE SELECT ON VIEW public_view FROM PUBLIC;
```

**例子 4：级联收回权限（例如收回 `charlie` 权限，并自动收回他授权给他人的权限）**

```sql
REVOKE SELECT, UPDATE ON TABLE products FROM charlie CASCADE;
```

### 数据库角色
| 考点     | 内容             | SQL 语句示例                                                                     | 说明                                 |
| ------ | -------------- | ---------------------------------------------------------------------------- | ---------------------------------- |
| 角色创建   | 创建一个空角色        | `CREATE ROLE role_name;`                                                     | 角色刚创建时没有任何权限                       |
| 给角色授权  | 给角色授予权限        | `GRANT SELECT, INSERT ON TABLE employees TO role_name;`                      | 数据库管理员或用户授予角色权限                    |
| 角色赋予   | 将一个角色授予用户或其他角色 | `GRANT role1 TO role2;`<br>`GRANT role_name TO user_name WITH ADMIN OPTION;` | 角色继承权限，`WITH ADMIN OPTION`可授权再授予权限 |
| 收回角色权限 | 收回角色的权限        | `REVOKE SELECT ON TABLE employees FROM role_name;`                           | 由角色创建者或拥有ADMIN OPTION的用户执行         |

## 关系数据查询与优化
### 一般步骤
| 步骤 | 说明 |
| --- | --- |
| 1 | 把查询转换成某种内部表示，通常用的关系数据库 |
| 2 | 把语法树转换成标准（优化）形式 |
| 3 | 选择低层的存取路径 |
| 4 | 生成查询计划，选择代价最小的 |

### 规范化
#### 解决的问题
- 数据冗余：多余存在的数据
- 插入异常：应能插入的数据不能插入
- 删除异常：不应该删除的数据被删除
- 修改异常：造成数据不一致的现象

#### 规范化理论
| 范式             | 主要要求                              | 解决问题                 | 例子说明                                              |
| -------------- | --------------------------------- | -------------------- | ------------------------------------------------- |
| **第一范式 (1NF)** | 属性值都是原子值，不可再分                     | 数据项必须原子化，避免嵌套结构      | 学生表中“爱好”不能写成“篮球,足球”，而要拆成多行或单独字段保存                 |
| **第二范式 (2NF)** | 满足1NF，且非主属性完全函数依赖于主码              | 消除部分函数依赖，解决数据冗余和插入异常 | 学生成绩表：主键(学号,课程号)，成绩属性依赖于两个字段，学生姓名只依赖学号，拆成学生表和成绩表  |
| **第三范式 (3NF)** | 满足2NF，消除非主属性对主码的传递函数依赖            | 消除传递依赖，避免数据更新异常      | 员工表有部门号、部门名称，部门名称依赖部门号，拆成员工表和部门表                  |
| **BCNF**       | 关系中所有决定因素都是候选码，消除主属性对主码的部分与传递依赖   | 解决特殊依赖问题             | 表中候选键有多个，且存在决定非候选键的非候选键的情况，需要拆分                   |
| **第四范式 (4NF)** | 消除多值依赖，即一个属性集多值依赖于主键，不允许出现多对多多值依赖 | 解决多值依赖导致的冗余          | 学生-课程-兴趣三元关系，一个学生可能选多门课程，也可能有多种兴趣，拆成学生-课程表和学生-兴趣表 |
| **第五范式 (5NF)** | 每个连接依赖都是由候选码决定的，消除连接依赖，保证无冗余      | 解决复杂的连接依赖导致数据冗余      | 订单中商品、供应商、客户三者相关关系，拆分为三个表，保证恢复原始数据需要连接三张表         |


#### 1NF 例子

| 学号  | 姓名 | 爱好    |                  |
| --- | -- | ----- | ---------------- |
| 001 | 张三 | 篮球,足球 | ← 不符合1NF，爱好不是原子值 |

改成：

| 学号  | 姓名 | 爱好 |         |
| --- | -- | -- | ------- |
| 001 | 张三 | 篮球 |         |
| 001 | 张三 | 足球 | ← 符合1NF |

#### 2NF 例子

假设成绩表：

| 学号  | 课程号 | 学生姓名 | 成绩 |
| --- | --- | ---- | -- |
| 001 | 01  | 张三   | 90 |

主键是(学号,课程号)，学生姓名只依赖学号，存在部分依赖，违反2NF。

拆分为：

学生表：

| 学号  | 学生姓名 |
| --- | ---- |
| 001 | 张三   |

成绩表：

| 学号  | 课程号 | 成绩 |
| --- | --- | -- |
| 001 | 01  | 90 |

#### 3NF 例子

员工表：

| 员工号  | 员工名 | 部门号 | 部门名称 |
| ---- | --- | --- | ---- |
| 1001 | 李四  | D01 | 财务部  |

部门名称依赖部门号，部门号依赖员工号，传递依赖。拆分为：

员工表：

| 员工号  | 员工名 | 部门号 |
| ---- | --- | --- |
| 1001 | 李四  | D01 |

部门表：

| 部门号 | 部门名称 |
| --- | ---- |
| D01 | 财务部  |

#### BCNF 例子

假设表：

| 学生 | 课程 | 教师  |
| -- | -- | --- |
| 张三 | 数学 | 王老师 |
| 张三 | 语文 | 李老师 |

假设约束：

* 学生 + 课程 决定教师（一个学生一个课程对应一个教师）
* 教师 决定课程（一个教师只教一门课）

这里“教师→课程”不是候选码，违反BCNF，需要拆分。

拆分为：

| 教师  | 课程 |
| --- | -- |
| 王老师 | 数学 |
| 李老师 | 语文 |

和

| 学生 | 教师  |
| -- | --- |
| 张三 | 王老师 |
| 张三 | 李老师 |

#### 4NF 例子

学生-课程-兴趣：

| 学生 | 课程 | 兴趣 |
| -- | -- | -- |
| 张三 | 数学 | 足球 |
| 张三 | 数学 | 篮球 |
| 张三 | 语文 | 足球 |
| 张三 | 语文 | 篮球 |

兴趣和课程无直接关联，存在多值依赖。拆分为两张表：

学生-课程：

| 学生 | 课程 |
| -- | -- |
| 张三 | 数学 |
| 张三 | 语文 |

学生-兴趣：

| 学生 | 兴趣 |
| -- | -- |
| 张三 | 足球 |
| 张三 | 篮球 |

#### 5NF 例子

订单系统中有3个属性：

| 订单号 | 商品 | 供应商 |
| --- | -- | --- |
| 001 | A  | X   |
| 001 | B  | X   |
| 001 | A  | Y   |

商品供应商和订单之间有连接依赖。5NF保证这张表可以被拆分成更细的表，通过连接能完全恢复原始数据，且无冗余。

拆分为：

订单-商品：

| 订单号 | 商品 |
| --- | -- |
| 001 | A  |
| 001 | B  |

订单-供应商：

| 订单号 | 供应商 |
| --- | --- |
| 001 | X   |

商品-供应商：

| 商品 | 供应商 |
| -- | --- |
| A  | X   |
| A  | Y   |

## 数据库设计
### 设计方法
| 设计方法                  | 主要内容与特点                                                                    |
| --------------------- | -------------------------------------------------------------------------- |
| **新奥尔良设计方法**          | - 将数据库设计分成四大阶段：需求分析、概念设计、逻辑设计、物理设计。<br>- 每阶段采用与阶段相符的辅助手段。<br>- 属于规范化的设计流程。 |
| **基于 E-R 模型的数据库设计方法** | - 主要用于概念设计阶段。<br>- 通过构建实体-联系图（E-R图）描述数据库的结构和联系。<br>- 广泛采用的设计方法。            |
| **第三范式的设计方法**         | - 依据关系数据库的规范化理论。<br>- 在逻辑设计阶段采用，确保关系满足第三范式，减少冗余和异常。                        |
| **ODL（对象定义语言）方法**     | - 面向对象的数据库设计方法。<br>- 用面向对象的术语和概念描述数据库结构。                                   |
### 设计策略
| 策略名称         | 主要内容                                                                                |
| ------------ | ----------------------------------------------------------------------------------- |
| **自顶向下设计策略** | - 从一般到特殊的开发方式。<br>- 从企业高层管理开始，分析企业的目标、对象和策略，构建抽象的高层数据模型。<br>- 逐步细化模型，直到识别出具体数据库和应用。 |
| **自底向上设计策略** | - 逆向于自顶向下，从细节到整体。<br>- 从基层业务和数据处理开始分析设计。<br>- 将各个系统综合集中，再分析设计上一层系统，直到构建完整的信息系统。     |

### 设计步骤
| 阶段          | 内容说明                                                         |
| ----------- | ------------------------------------------------------------ |
| **需求分析**    | - 准确了解和分析用户需求（数据和处理）。<br>- 是设计的基础且最困难耗时。<br>- 需求分析不足会导致设计返工。 |
| **概念结构设计**  | - 通过综合、归纳、抽象用户需求，形成与具体DBMS无关的概念模型（如E-R模型）。                   |
| **逻辑结构设计**  | - 将概念结构转换成具体DBMS支持的数据模型（关系模型等），并对模型进行优化。                     |
| **物理结构设计**  | - 根据应用环境选择适合的存储结构和存取方法，实现逻辑模型的物理存储。                          |
| **数据库实施**   | - 利用DBMS语言和宿主语言建立数据库、编写调试程序、组织数据导入、进行试运行。                    |
| **系统运行与维护** | - 应用系统试运行后正式运行。<br>- 在运行过程中持续评估、调整和修改。<br>- 设计过程是不断反复完善的过程。  |

### DBA（数据库管理员 Database Administrator）工作内容
| DBA 工作内容          | 具体说明                                                          |
| ----------------- | ------------------------------------------------------------- |
| **数据库的转储和恢复**     | - 制定转储计划，保障故障发生时能快速恢复数据库至一致状态。<br>- 尽量减少对数据库的破坏。              |
| **数据库的安全性与完整性控制** | - 根据实际需求调整安全控制，如数据密级变化、用户权限变动。<br>- 修改和维护数据库完整性约束，保证数据有效。     |
| **数据库性能监督、分析与改造** | - 利用 DBMS 提供的性能检测工具监控系统。<br>- 分析性能数据，判断是否需要优化，如调整物理参数、重组织数据库。 |
| **数据库重组织与重构造**    | - 随着数据库运行，数据增删改导致存储碎片和性能下降。<br>- DBA进行重组织或部分重组织提升存储效率和访问性能。   |

### ER图的冲突
| 冲突类型     | 具体内容                                                                                         | 解决思路（简述）           |
| -------- | -------------------------------------------------------------------------------------------- | ------------------ |
| **属性冲突** | - 属性域冲突：同一属性在不同系统中类型、取值范围或集合不同（如零件号整数vs字符型，年龄整数vs出生日期）。<br>- 属性取值单位冲突：同一属性单位不同（如重量有公斤、斤、克等）。 | 统一属性类型、定义标准单位与格式   |
| **命名冲突** | - 同名异义：不同含义的对象却用同一名字。<br>- 异名同义：同一对象在不同系统中名字不一样。                                             | 统一命名规范，建立映射关系      |
| **结构冲突** | - 同一对象在不同系统抽象不同。<br>- 同一实体的属性个数、属性顺序不同。                                                      | 属性并集，调整属性次序，形成统一结构 |


## 数据库恢复技术
- Begin Transaction 开始事务
- Commit 提交事务
- Rollback 回滚事务

### 事务
| 考点                | 内容                               | 速记点                                                                                                                                                 |
| ----------------- | -------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------- |
| **事务的 ACID 性质**   | 事务应满足4个基本性质：原子性、一致性、隔离性、持续性（持久性） | 1. **原子性**：事务中的操作要么全部完成，要么全部不做<br>2. **一致性**：事务执行后数据库从一个一致状态转到另一个一致状态<br>3. **隔离性**：事务执行过程不被其他事务干扰，各事务相互隔离<br>4. **持续性**：事务一旦提交，对数据库的改变永久保存，后续故障不影响 |
| **事务的 ACID 实现过程** | 事务4性质由数据库管理系统（DBMS）的不同子系统保证      | 1. 原子性由事务管理子系统实现<br>2. 一致性由完整性子系统实现<br>3. 隔离性由并发控制子系统实现<br>4. 持续性由恢复管理子系统实现                                                                         |


### 故障和恢复技术
| 类别     | 故障描述                  | 恢复关键机制      | 关键操作速记                                                     |
| ------ | --------------------- | ----------- | ---------------------------------------------------------- |
| 🔸事务故障 | 程序主动/被动终止、断电崩溃        | UNDO 撤销事务   | 反向扫描日志，执行逆操作（写入“更新前的值”）                                    |
| 🔹系统故障 | 系统崩溃、断电等，内存数据丢失       | UNDO + REDO | 1. 正向日志：找 UNDO/REDO 队列<br>2. UNDO：反向写入旧值<br>3. REDO：正向写入新值 |
| 🔺介质故障 | 磁盘损坏、数据和日志文件同时丢失（最严重） | 备份 + REDO   | 1. 装入最近一次转储（备份）<br>2. 装入日志副本<br>3. 扫描日志重做已提交事务             |

#### 事务故障恢复
| 分类            | 内容                                                         |
| ------------- | ---------------------------------------------------------- |
| 🔹 **速记点 1**  | **事务故障**：事务未执行完就中止，需**撤销其已对数据库的修改**，称为 UNDO。               |
| 📂 **日志处理步骤** | 恢复子系统通过**反向扫描日志**，恢复被中断事务的执行前状态。                           |
| 步骤一（1）        | **反向扫描日志文件**（从后往前）查找该事务的更新操作。                              |
| 步骤二（2）        | 对每条更新记录执行**逆操作**（UNDO）：                                    |
|               | - 插入操作 → 执行删除（原值为空）<br> - 删除操作 → 执行插入<br> - 修改操作 → 用旧值覆盖新值 |
| 步骤三（3）        | 继续反向扫描，查找该事务的其他更新操作，并同样执行 UNDO。                            |
| 步骤四（4）        | 一直处理到遇到该事务的**开始标记**，此时恢复结束。                                |
| 💡 说明         | 过程由系统自动完成，对用户透明，**无需人工干预**。                                |

#### 系统故障恢复
  | 分类            | 内容                                                          |
| ------------- | ----------------------------------------------------------- |
| 🔹 **速记点 2**  | **系统故障**：如断电/系统崩溃，需根据日志**撤销未完成事务（UNDO）**，**重做已提交事务（REDO）**。 |
| 📂 **日志处理步骤** | 通过**日志扫描**识别哪些事务要撤销，哪些事务要重做。                                |
| 步骤一（1）        | **正向扫描日志**：                                                 |
|               | - 找出已提交事务（有 BEGIN 和 COMMIT）→ 加入 **REDO-LIST**               |
|               | - 找出未完成事务（只有 BEGIN 无 COMMIT）→ 加入 **UNDO-LIST**              |
| 步骤二（2）        | **对 UNDO-LIST 执行撤销操作（UNDO）**：                               |
|               | - **反向扫描日志**，每条更新操作执行逆操作（写入旧值）                              |
| 步骤三（3）        | **对 REDO-LIST 执行重做操作（REDO）**：                               |
|               | - **正向扫描日志**，每条更新操作重新执行（写入新值）                               |
| 💡 说明         | UNDO 撤销未完成事务，REDO 重做已提交事务；该过程由系统自动执行，对用户透明。                 |

#### 介质故障恢复
- 恢复方法是重装数据库，然后重做已完成的事务

| 步骤  | 内容                                                |
| --- | ------------------------------------------------- |
| 1️⃣ | **装入数据库最近一次的备份副本**（即最近一次转储），恢复到**转储时刻的一致状态**      |
| 2️⃣ | **装入转储结束时刻的日志文件副本**，扫描找出已提交事务，加入 **REDO-LIST**    |
| 3️⃣ | **正向扫描日志**，对 REDO-LIST 中事务执行重做（写入更新后的值），恢复到最近一致状态 |

### 数据库镜像
- 出现介质故障，可由镜像磁盘继续提供使用，同时数据库管理系统自动利用镜像磁盘数据进行数据库的恢复，不需要关闭系统和重装数据库副本
- 可以用于并发操作，即当一个用户对数据加排他锁修改数据时，其他用户可以读镜像数据库上的数据，而不必等待该用户释放锁

## 并发控制
### 并发问题
| 异常类型                         | 描述速记                                     | 举例简要说明                                       | 事务隔离级别影响      |
| ---------------------------- | ---------------------------------------- | -------------------------------------------- | ------------- |
| 🔸丢失修改（Lost Update）          | 两个事务**同时修改**同一数据，一个事务的修改被另一个覆盖           | T1 和 T2 都修改余额，T2 提交覆盖 T1 的更新                 | **读已提交**即可避免  |
| 🔹读脏数据（Dirty Read）           | 一个事务读取到**另一个事务尚未提交的数据**，但后者回滚导致读到“脏”内容   | T1 修改余额但未提交，T2 读取该余额，T1 回滚 → T2读的是脏数据        | **读已提交**可避免   |
| 🔺不可重复读（Non-repeatable Read） | 一个事务两次读取同一数据，**中间被其他事务修改并提交**，两次读结果不同    | T1 先读余额，T2 修改并提交，T1 再读余额发现变了                 | **可重复读**可避免   |
| 🔻幻读（Phantom Read）\*         | 一个事务两次查询满足某条件的多行记录，**中间有事务新增/删除满足条件的记录** | T1 查找工资 >5000 的人，T2 插入一个新员工工资 6000，T1 再查数量变化 | **可串行化**才完全避免 |

### 三级封锁协议
| 封锁协议级别   | 加锁要求                                   | 解决的问题                 | 仍然存在的问题        |
| -------- | -------------------------------------- | --------------------- | -------------- |
| 🔹一级封锁协议 | 对**修改的数据**加 **X 锁（排他锁）**，**直到事务结束才释放** | ✅防止丢失修改（Lost Update）  | ❌可能读脏数据，❌不可重复读 |
| 🔸二级封锁协议 | 在一级基础上，**对读取的数据加 S 锁（共享锁）**，**读完立即释放** | ✅防止丢失修改，✅防止读脏数据       | ❌不可重复读仍存在      |
| 🔺三级封锁协议 | 在二级基础上，**S/X 锁直到事务结束才释放**              | ✅防止丢失修改，✅防止读脏数据，✅可重复读 | ✅实现可重复读，无幻读保障  |

### 2PL（两阶段封锁）
| 阶段     | 内容                                                         |
| ------ | ---------------------------------------------------------- |
| 第一阶段 | 加锁阶段：事务可以获得锁，但不能释放锁。                    |
| 第二阶段 | 解锁阶段：事务可以释放锁，但不能获得新锁。                    |
| 说明     | 两阶段封锁协议可以解决丢失修改、读脏数据、不可重复读的问题。 |

#### 2PL 类型
| 类型            | 是否可串行化 | 是否避免死锁 | 说明                  |
| ------------- | ------ | ------ | ------------------- |
| **基本两级封锁协议**  | ✅      | ❌      | 标准2PL，存在死锁风险        |
| **严格两级封锁协议**  | ✅      | ❌      | 所有**X锁**直到事务结束才释放   |
| **强两级封锁协议**   | ✅      | ❌      | **S锁/X锁**都直到事务结束才释放 |
| **保守（静态）2PL** | ✅      | ✅      | 开始前一次性申请所有锁，避免死锁    |

### 活锁和死锁
| 问题类型             | 定义                    | 表现特征                          | 示例                       | 解决方法                                      |
| ---------------- | --------------------- | ----------------------------- | ------------------------ | ----------------------------------------- |
| **活锁**（Livelock） | 事务不断尝试执行但始终无法完成       | 一直请求资源、**未被阻塞**，但始终**让给其他事务** | T1释放锁后系统把锁给T3，T2始终请求不到   | ✅ 先来先服务（FIFO）<br>✅ 公平调度策略<br>✅ 引入随机等待或优先级 |
| **死锁**（Deadlock） | 事务**相互等待对方资源**，形成循环依赖 | 所有事务都**被阻塞**，永远无法继续           | T1锁A → 请求B<br>T2锁B → 请求A | ✅ 超时机制<br>✅ 资源一次性申请（预占）<br>✅ 死锁检测与恢复      |


### 死锁预防和解除
| 分类          | 名称                        | 核心原理                   | 示例 / 特点                | 优缺点                    |
| ----------- | ------------------------- | ---------------------- | ---------------------- | ---------------------- |
| 🔒 **死锁预防** | **一次封锁法**                 | 事务一次性加锁所有资源，否则不能执行     | T1 启动时就加锁 R1、R2，防止后续等待 | ✅ 简单<br>❌ 不灵活、资源利用率低   |
| 🔒          | **顺序封锁法**                 | 所有事务按**统一顺序**加锁，避免循环等待 | 在B树中按从上到下顺序加锁          | ✅ 易实现<br>❌ 编码复杂、数据结构相关 |
| 🚨 **死锁诊断** | **超时法**                   | 等待超时即认为死锁              | T2 等待超时，系统中止T2         | ✅ 实现简单<br>❌ 易误判或延迟处理   |
| 🚨          | **事务等待图（Wait-for Graph）** | 构图找**是否有回路** → 有则死锁    | T1→T2→T3→T1 构成环路表示死锁   | ✅ 精确检测<br>❌ 算法复杂，需周期检测 |

## 其他
### SAVEPOINT
- SAVEPOINT（保存点）是数据库事务中的一个标记，用于在事务内部设置一个 “中间节点”，允许事务在执行过程中部分回滚到该节点，而不必回滚整个事务。
  - 创建保存点：`SAVEPOINT savepoint_name`
  - 回滚到保存点：`ROLLBACK TO SAVEPOINT savepoint_name`
  - 删除保存点：`RELEASE SAVEPOINT savepoint_name`

### SQL包含
- 一：数据查询语言（DQL：Data Query Language）
- 二：数据操作语言（DML：Data Manipulation Language）
- 三：事务处理语言（TPL）
- 四：数据控制语言（DCL）
- 五：数据定义语言（DDL）
- 六：指针控制语言（CCL）
