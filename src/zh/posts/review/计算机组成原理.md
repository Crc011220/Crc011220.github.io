---
icon: pen-to-square
date: 2025-07-06
category:
  - Learning Records
tag:
  - Algorithm
---

# 计算机组成原理


### ✅ 机器数的形式 —— 计算机中数的真实表示方式

在计算机中，**“机器数”**是指将**真数（数学中的原始数）转换成计算机内部可以识别的二进制形式**，并带有符号位或其他编码格式的**存储表示**。

---

## 🧠 一、什么是“机器数”？

> **机器数 = 用一定规则将数转换为计算机内部二进制的形式。**

它包含：

* **符号**（正负号）
* **数值部分**（整数或浮点数）
* **长度限制**（比如 8 位、32 位等）

---

## ✅ 二、常见机器数的形式（速记）

| 类型      | 含义                            | 说明              |
| ------- | ----------------------------- | --------------- |
| **原码**  | 最高位是符号位，后面是绝对值的二进制            | 优点直观，缺点：正负零两个   |
| **反码**  | 正数反码 = 原码，负数反码 = 符号位不变，其余按位取反 | 易于做减法，仍有±0问题    |
| **补码**  | 正数补码 = 原码，负数补码 = 反码 + 1       | ✅ 现代计算机实际使用的表示法 |
| **移码**  | 用于浮点数的阶码表示（偏移表示）              | 全为非负数，方便比较大小    |
| **浮点数** | 用 **IEEE 754** 标准表示实数         | 有符号位 + 阶码 + 尾数  |

---

## 🎯 三、整数机器数的表示方式详解（以8位为例）

### ✅ 1. 原码（Sign-Magnitude）

| 真数 | 原码表示（二进制）  |
| -- | ---------- |
| +5 | `00000101` |
| -5 | `10000101` |

> 第一位是符号位（0 正，1 负），其余是绝对值的二进制。

---

### ✅ 2. 反码（One's Complement）

| 真数 | 反码表示（二进制）  |
| -- | ---------- |
| +5 | `00000101` |
| -5 | `11111010` |

> 正数反码 = 原码
> 负数反码 = 原码除了符号位外全部取反

---

### ✅ 3. 补码（Two's Complement）⭐最重要！

| 真数 | 补码表示（二进制）  |
| -- | ---------- |
| +5 | `00000101` |
| -5 | `11111011` |

> 负数补码 = 反码 + 1
> ✅ 补码唯一，无“负零”，方便加减法统一处理

---

## ✅ 四、浮点数机器数（IEEE 754 标准）

### 格式（以 32 位单精度为例）：

```
| 1 位符号位 | 8 位阶码（移码） | 23 位尾数（有效数位） |
```

* **符号位**：0 正，1 负
* **阶码**：真实指数 + 127（移码）
* **尾数**：省略了隐藏的第一位 1，称“规格化”

---

### ✳️ 举个例子：

> 真数：`-6.25`
> IEEE 754 表示（32 位）：

| 部分  | 值                                                |
| --- | ------------------------------------------------ |
| 符号位 | 1                                                |
| 阶码  | `10000001` （即 129 = 2 + 127）                     |
| 尾数  | `.1001` → 转换为 23 位存储形式：`10010000000000000000000` |

最终二进制机器数（32 位）是：

```
1 10000001 10010000000000000000000
```

---

## 🧠 为什么需要这么多形式？

| 编码方式 | 用途     | 原因            |
| ---- | ------ | ------------- |
| 原码   | 理论学习用  | 直观，符合数学习惯     |
| 反码   | 减法便捷   | 让加法器也能做减法     |
| 补码   | 实际硬件使用 | 统一加减逻辑，无负零    |
| 移码   | 浮点阶码用  | 避免负数，便于比较大小   |
| 浮点表示 | 表示实数   | 能表示非常大或非常小的小数 |

---
你这两条补码运算速记点很关键，下面我帮你拆解并详细解释，方便你理解和记忆，顺便纠正一点小细节：

---

## 速记点 5：补码加法

> **两个补码表示的数相加，符号位参与运算，两个数的和的补码等于两个数补码的和**

### 解释：

* 补码表示的整数加法，可以直接把两个补码的二进制数按位相加（包括符号位）
* 不用区分正负，计算过程统一
* 如果有溢出（进位超出位宽），舍弃最高位进位

### 举例：

假设用 4 位补码表示

| 数字 | 补码   |
| -- | ---- |
| +3 | 0011 |
| -2 | 1110 |

计算：3 + (-2)

```
  0011  (+3)
+ 1110  (-2)
=10001  （5 位，丢弃最高位的进位1）
=0001   (+1)
```

结果是 +1，正确！

---

## 速记点 6：补码减法

> $X - Y$\_补 = $X + (-Y)$\_补 = $X$\_补 + $-Y$\_补

> 已知 $Y$\_补，求 $-Y$\_补的方法是：将 $Y$\_补连同符号位一起按位取反，末尾加 1，符号不单独参与运算。

---

### 解释：

* 减法转化为加法：减去 Y 等同于加上 -Y
* 求 -Y 的补码：

  1. 对 Y 的补码全位取反（包括符号位）
  2. 结果加 1

### 举例：

用 4 位补码表示

Y = +2，补码 = 0010

求 -Y：

* 按位取反：`0010` → `1101`
* 加 1：`1101 + 1 = 1110`，即 -2 的补码

---

### 注意：

* **符号位是参与取反运算的！**
  不是“符号不参与运算”，而是符号位也参与取反。

---

## 总结小口诀：

* **加法直接加，符号位一起算，丢掉溢出位，结果就是和**
* **减法变加法，求负先反码，全部按位反，再加一就是负**

---

需要我帮你写个示范的代码或画个图说明补码加减法过程吗？





