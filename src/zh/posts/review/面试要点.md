---
icon: pen-to-square
date: 2025-07-27
category:
  - Learning Records
tag:
  - Review
---

# 面试要点

## Java基础

### 1. equals() 和 == 的区别？如何正确重写 equals() 和 hashCode() 方法？为什么需要同时重写？

#### == 和 equals() 的区别
- **== 操作符**：对于基本数据类型比较值，对于引用类型比较内存地址
- **equals() 方法**：Object类默认实现是比较引用，String等类重写后比较内容

#### 正确重写的五个原则
1. **自反性**：x.equals(x) 必须返回 true
2. **对称性**：x.equals(y) 和 y.equals(x) 结果相同
3. **传递性**：如果 x.equals(y) 且 y.equals(z)，则 x.equals(z)
4. **一致性**：多次调用结果一致
5. **非空性**：x.equals(null) 返回 false

#### 为什么要同时重写？
因为HashMap/HashSet的工作机制：先用hashCode()确定存储位置，再用equals()处理哈希冲突。如果不同时重写会导致相等对象无法在HashMap中正确查找。Java约定：如果两个对象equals()返回true，它们的hashCode()必须相同。

| 问题                 | 结论               |
| ------------------ | ---------------- |
| `equals()` 比较什么？   | 值是否相等            |
| `hashCode()` 用来干嘛？ | 快速查找桶            |
| 为什么要同时重写？          | 保证集合类正常工作，避免逻辑错误 |
| 不重写会怎样？            | 数据重复、查找失败、逻辑异常   |

### 2. 接口和抽象类的区别？何时用接口？何时用抽象类？

#### 主要区别
- **继承关系**：接口支持多实现，抽象类只能单继承
- **方法**：接口Java8前只有抽象方法，抽象类可以有具体实现
- **成员变量**：接口只能有常量，抽象类可以有各种成员变量
- **构造方法**：接口不能有，抽象类可以有

#### 使用场景
- **接口**：定义契约规范、实现多重"继承"、强调"能做什么"（can-do关系）
- **抽象类**：代码复用、提供部分实现、强调"是什么"（is-a关系）、需要有状态

| 特性       | 接口                | 抽象类            |
| -------- | ----------------- | -------------- |
| 继承关系     | 可实现多个             | 只能继承一个         |
| 方法实现     | 抽象方法+默认方法（Java8+） | 抽象方法+具体方法      |
| 成员变量     | 只能有常量             | 可以有各种类型变量      |
| 构造方法     | 不能有               | 可以有            |
| 关系类型     | can-do（能做什么）      | is-a（是什么）      |
| 使用场景     | 定义规范、多重继承         | 代码复用、部分实现、有状态  |

### 3. String vs StringBuffer vs StringBuilder

#### 特性对比
- **String**：不可变，线程安全，频繁操作性能差，会创建大量临时对象
- **StringBuffer**：可变，线程安全（synchronized），适合多线程环境
- **StringBuilder**：可变，线程不安全，单线程环境性能最佳

#### 选择原则
- **String**：字符串很少改变的情况
- **StringBuffer**：多线程环境下的字符串频繁操作
- **StringBuilder**：单线程环境下的字符串频繁操作

| 特性     | String  | StringBuffer | StringBuilder |
| ------ | ------- | ------------ | ------------- |
| 可变性    | 不可变     | 可变           | 可变            |
| 线程安全   | 安全（不可变） | 安全（同步）       | 不安全           |
| 性能     | 频繁操作差   | 中等           | 最佳            |
| 内存使用   | 创建新对象   | 内部缓冲区        | 内部缓冲区         |
| 适用场景   | 少量操作    | 多线程字符串操作     | 单线程字符串操作      |

### 4. 自动装箱与拆箱原理及潜在问题

#### 基本概念
- **自动装箱**：基本类型自动转换为包装类型（如int→Integer）
- **自动拆箱**：包装类型自动转换为基本类型
- **实现原理**：编译器自动插入valueOf()和xxxValue()方法调用

#### 四大潜在问题
1. **缓存范围问题**：-128到127范围内的Integer对象会被缓存复用，超出范围会创建新对象
2. **性能问题**：频繁装箱拆箱会影响性能，特别是在循环中
3. **NullPointerException**：null的包装类型拆箱时会抛NPE
4. **三目运算符陷阱**：类型不一致时编译器会自动拆箱，可能导致NPE

#### 最佳实践
尽量使用基本类型、比较包装类型用equals()、避免循环中频繁装箱拆箱、注意缓存范围、小心null值拆箱

| 问题类型     | 具体表现                   | 解决方案           |
| -------- | ---------------------- | -------------- |
| 缓存范围问题   | -128~127外用==比较结果为false | 用equals()比较     |
| 性能问题     | 循环中频繁装箱拆箱              | 使用基本类型         |
| NPE问题    | null包装类型拆箱时抛异常         | 判空或使用基本类型      |
| 三目运算符陷阱  | 类型不一致导致自动拆箱NPE        | 保证两边类型一致       |
| 最佳实践     | 什么时候用包装类型？             | 需要null值或泛型时才用  |

### 5. BIO、NIO、AIO的区别？

#### I/O模型核心概念

**BIO、NIO、AIO三种I/O模型对比：**

| 特性         | BIO（同步阻塞）        | NIO（同步非阻塞）         | AIO（异步非阻塞）         |
| ---------- | --------------- | ------------------ | ------------------ |
| 全称         | Blocking I/O    | Non-blocking I/O   | Asynchronous I/O   |
| 阻塞性        | 阻塞             | 非阻塞               | 异步               |
| 同步性        | 同步             | 同步               | 异步               |
| 线程模型       | 一线程一连接          | 一线程处理多连接           | 一线程处理多连接           |
| API复杂度     | 简单             | 复杂               | 复杂               |
| 适用场景       | 连接数少、并发度低       | 连接数多、并发度高          | 连接数多、并发度高          |

#### 工作原理对比

| I/O模型 | 工作原理                      | 线程利用率 | 内存消耗 | CPU利用率 |
| ----- | ------------------------- | ----- | ---- | ----- |
| BIO   | 每个连接创建一个线程，线程阻塞等待I/O完成    | 低     | 高    | 低     |
| NIO   | 一个线程通过Selector轮询多个Channel | 高     | 中    | 高     |
| AIO   | 操作系统完成I/O后通知应用程序         | 高     | 低    | 中     |

#### 性能特性对比

| 性能指标   | BIO          | NIO            | AIO            |
| ------ | ------------ | -------------- | -------------- |
| 吞吐量    | 低（受线程数限制）    | 高              | 高              |
| 延迟     | 中等           | 低              | 最低             |
| 内存占用   | 高（大量线程栈）     | 中等             | 低              |
| CPU消耗  | 低（大量阻塞等待）    | 中等             | 低              |
| 可扩展性   | 差            | 好              | 最好             |

#### 编程模型对比

| 模型  | 编程模型                  | 事件处理       | 错误处理     | 学习成本 |
| --- | --------------------- | ---------- | -------- | ---- |
| BIO | 顺序编程，符合人类思维           | 同步处理       | try-catch | 低    |
| NIO | 事件驱动，需要状态机管理          | 事件循环       | 复杂       | 高    |
| AIO | 回调驱动，异步编程             | 回调函数       | 回调地狱     | 高    |

#### 实际应用场景选择

| 应用场景        | 推荐模型 | 选择理由                      | 注意事项              |
| ----------- | ---- | ------------------------- | ----------------- |
| Web服务器      | NIO  | 大量连接，请求处理时间短              | 需要处理粘包拆包问题        |
| 文件服务器       | BIO  | 文件I/O多为顺序操作，编程简单          | 控制并发连接数           |
| 即时通讯        | NIO  | 长连接，需要高并发                | 心跳检测，连接管理         |
| 游戏服务器       | AIO  | 实时性要求高，性能敏感              | 回调处理复杂            |
| 数据库连接池      | BIO  | 连接数可控，操作多为短连接             | 连接复用              |
| 大数据传输       | AIO  | 大文件传输，异步处理效率高             | 需要处理传输中断          |

#### 技术选型决策

| 考虑因素       | 权重  | BIO评分 | NIO评分 | AIO评分 | 说明              |
| ---------- | --- | ----- | ----- | ----- | --------------- |
| 开发难度（20%）  | 20% | 9     | 6     | 5     | BIO最简单          |
| 性能表现（30%）  | 30% | 4     | 8     | 9     | AIO性能最好         |
| 并发能力（25%）  | 25% | 3     | 8     | 9     | NIO/AIO并发能力强    |
| 稳定性（15%）   | 15% | 9     | 7     | 6     | BIO最稳定          |
| 生态成熟度（10%） | 10% | 10    | 8     | 5     | BIO生态最成熟        |
| **加权总分**    |     | **5.9** | **7.3** | **7.4** | AIO综合评分略高      |

## 集合

### 1. HashMap 的实现原理？JDK 1.7和1.8的区别？hash()方法的作用？如何处理哈希冲突？

#### 实现原理
HashMap基于数组+链表/红黑树的数据结构，通过hash算法将key映射到数组索引位置。

#### JDK 1.7 vs 1.8 主要区别
- **数据结构**：1.7是数组+链表，1.8是数组+链表+红黑树
- **插入方式**：1.7头插法（并发环境可能死循环），1.8尾插法
- **扩容时机**：1.7先扩容再插入，1.8先插入再扩容
- **hash算法**：1.8优化了hash算法，减少碰撞

#### hash()方法作用
将key的hashCode进行二次hash，让hash值更均匀分布，减少哈希冲突。

#### 哈希冲突处理
1. **链表法**：相同hash值的元素用链表连接
2. **红黑树优化**：当链表长度≥8且数组长度≥64时，链表转红黑树
3. **扩容机制**：负载因子超过0.75时，数组容量翻倍

| 版本对比   | JDK 1.7      | JDK 1.8           |
| ------ | ------------ | ----------------- |
| 数据结构   | 数组+链表        | 数组+链表+红黑树        |
| 插入方式   | 头插法          | 尾插法               |
| 链表转树   | 无            | 链表长度≥8且数组长度≥64时  |
| 扩容时机   | 先扩容再插入       | 先插入再扩容            |
| 并发问题   | 可能死循环        | 避免了死循环            |

### 2. ConcurrentHashMap 如何实现线程安全？

#### JDK 1.7：分段锁机制
- **Segment数组**：将HashMap分成多个段，每个段有独立的锁
- **锁粒度**：只锁需要操作的段，其他段可并发访问
- **并发度**：默认16个段，最多支持16个线程同时写入

#### JDK 1.8：CAS + synchronized
- **取消Segment**：直接在Node节点上加锁
- **CAS操作**：数组元素为空时用CAS插入
- **synchronized**：发生冲突时锁住链表/红黑树的头节点
- **更细粒度**：锁的是具体的hash桶，并发性能更好

| 版本   | JDK 1.7        | JDK 1.8              |
| ---- | -------------- | -------------------- |
| 锁机制  | 分段锁（Segment）   | CAS + synchronized   |
| 锁粒度  | 段级别            | 节点级别                 |
| 并发度  | 最多16个写线程       | 理论上无限制               |
| 内存占用 | Segment额外开销    | 更少的内存开销              |
| 性能   | 读写分离，性能较好      | 读写性能都更优              |

### 3. ArrayList 和 LinkedList 的底层实现、时间复杂度？

#### 底层实现
- **ArrayList**：动态数组，连续内存空间存储
- **LinkedList**：双向链表，节点包含data、prev、next指针

#### 时间复杂度对比

| 操作   | ArrayList | LinkedList |
| ---- | --------- | ---------- |
| 随机访问 | O(1)      | O(n)       |
| 头部插入 | O(n)      | O(1)       |
| 尾部插入 | O(1)      | O(1)       |
| 中间插入 | O(n)      | O(1)*      |
| 头部删除 | O(n)      | O(1)       |
| 尾部删除 | O(1)      | O(1)       |
| 中间删除 | O(n)      | O(1)*      |

*注：LinkedList中间插入/删除的O(1)是指已知节点位置的情况，查找节点仍需O(n)

#### 使用场景
- **ArrayList**：频繁随机访问、少量插入删除
- **LinkedList**：频繁插入删除、顺序访问

### 4. Iterator 和 ListIterator 的区别？fail-fast 和 fail-safe 机制？

#### Iterator vs ListIterator

| 特性     | Iterator        | ListIterator     |
| ------ | --------------- | ---------------- |
| 适用范围   | 所有Collection    | 只适用于List        |
| 遍历方向   | 单向（向前）          | 双向（前进+后退）       |
| 操作能力   | 只能删除            | 增删改查都支持          |
| 索引访问   | 不支持             | 支持获取当前索引         |
| 起始位置   | 只能从头开始          | 可以从任意位置开始        |

#### fail-fast vs fail-safe

**fail-fast（快速失败）：**
- **机制**：检测到并发修改立即抛ConcurrentModificationException
- **实现**：通过modCount计数器检测结构性修改
- **代表**：ArrayList、HashMap的迭代器

**fail-safe（安全失败）：**
- **机制**：在副本上迭代，不会抛异常但可能读到过期数据
- **实现**：复制一份数据进行迭代
- **代表**：CopyOnWriteArrayList、ConcurrentHashMap

| 机制        | fail-fast | fail-safe    |
| --------- | --------- | ------------ |
| 异常处理      | 立即抛异常     | 不抛异常         |
| 数据一致性     | 强一致性      | 可能读到过期数据     |
| 性能开销      | 低         | 高（需要复制）      |
| 内存使用      | 少         | 多（额外副本）      |
| 适用场景      | 单线程环境     | 多线程环境        |

### 5. 如何保证集合的线程安全？

#### 五种解决方案

**1. Collections.synchronizedXXX()**
- **原理**：为每个方法加synchronized关键字
- **缺点**：性能较差，复合操作仍不安全

**2. Vector、Hashtable**
- **原理**：方法级别的synchronized
- **缺点**：过时的重量级同步，性能差

**3. CopyOnWriteArrayList**
- **原理**：写时复制，读写分离
- **适用**：读多写少的场景

**4. ConcurrentHashMap**
- **原理**：分段锁/CAS+synchronized
- **优点**：高并发性能好

**5. 外部加锁**
- **原理**：使用外部锁控制访问
- **灵活性**：可控制锁的粒度

| 方案                      | 性能  | 适用场景      | 缺点           |
| ----------------------- | --- | --------- | ------------ |
| Collections.synchronized | 差   | 简单场景      | 复合操作不安全      |
| Vector/Hashtable        | 差   | 遗留代码      | 重量级同步        |
| CopyOnWriteArrayList    | 读快  | 读多写少      | 写操作开销大       |
| ConcurrentHashMap       | 优   | 高并发Map操作  | 只适用于Map      |
| 外部加锁                    | 中   | 复杂业务逻辑    | 需要小心死锁       |

### 6. Comparable 和 Comparator 接口的区别？

#### 核心区别
- **Comparable**：内部比较器，对象自己定义排序规则
- **Comparator**：外部比较器，第三方定义排序规则

#### 详细对比

**Comparable接口：**
- **方法**：compareTo(T o)
- **实现位置**：在被比较的类内部实现
- **排序规则**：固定的，类的自然排序
- **使用方式**：Collections.sort(list)

**Comparator接口：**
- **方法**：compare(T o1, T o2)
- **实现位置**：可以在任何地方实现
- **排序规则**：灵活的，可以有多种排序方式
- **使用方式**：Collections.sort(list, comparator)

| 特性     | Comparable        | Comparator         |
| ------ | ----------------- | ------------------ |
| 位置     | 类内部实现             | 外部实现               |
| 方法     | compareTo()       | compare()          |
| 排序规则   | 单一固定              | 多样化灵活              |
| 修改成本   | 需要修改原类            | 不需要修改原类            |
| 使用场景   | 类有明确的自然排序         | 需要多种排序方式或无法修改原类    |
| 实现数量   | 一个类只能有一种          | 可以有多个不同的实现         |

## 多线程

### 线程基础

#### 1. 进程和线程的区别？创建线程的几种方式？哪种更推荐？

**进程 vs 线程：**
- **进程**：操作系统资源分配的基本单位，拥有独立的内存空间
- **线程**：CPU调度的基本单位，同一进程内的线程共享内存空间

| 特性     | 进程           | 线程         |
| ------ | ------------ | ---------- |
| 资源占用   | 独立内存空间       | 共享进程内存空间   |
| 创建开销   | 大            | 小          |
| 通信方式   | IPC（管道、消息队列） | 共享内存、同步机制  |
| 崩溃影响   | 不影响其他进程      | 可能影响整个进程   |
| 切换开销   | 大            | 小          |

**创建线程的方式：**

| 方式               | 特点                | 推荐度 | 使用场景           |
| ---------------- | ----------------- | --- | -------------- |
| 继承Thread类        | 简单，但Java单继承限制     | ⭐⭐  | 简单场景，不推荐       |
| 实现Runnable接口     | 可多继承，推荐          | ⭐⭐⭐ | 一般异步任务         |
| 实现Callable+FutureTask | 有返回值，可抛异常        | ⭐⭐⭐ | 需要返回结果的任务      |
| 线程池              | 复用线程，性能好，资源可控    | ⭐⭐⭐⭐⭐ | 生产环境，高并发场景     |

**最推荐**：线程池方式，因为可以避免频繁创建销毁线程的开销，更好地控制并发数量。

#### 2. sleep(), wait(), yield(), join() 方法的区别？

| 方法      | 所属类      | 锁状态  | 使用场景        | 唤醒方式           |
| ------- | -------- | ---- | ----------- | -------------- |
| sleep() | Thread   | 不释放锁 | 暂停指定时间      | 时间到自动唤醒        |
| wait()  | Object   | 释放锁  | 等待条件满足      | notify/notifyAll |
| yield() | Thread   | 不释放锁 | 让出CPU给同优先级线程 | 立即重新参与调度       |
| join()  | Thread   | 不释放锁 | 等待线程执行完毕    | 目标线程执行完毕       |

**核心区别：**
- **sleep()和wait()的最大区别**：sleep不释放锁，wait释放锁
- **yield()作用**：暂停当前线程，让同优先级线程有机会执行
- **join()用途**：主线程等待子线程执行完毕后再继续

#### 3. 上下文切换是什么？开销在哪里？

**上下文切换**：CPU从一个线程切换到另一个线程时，需要保存当前线程状态并加载新线程状态的过程。

**开销构成：**
1. **保存现场**：寄存器、程序计数器、栈指针等
2. **加载新现场**：新线程的执行环境
3. **内存缓存失效**：CPU缓存可能失效，需要重新加载
4. **内核态切换**：用户态到内核态的切换开销

| 开销类型   | 具体内容           | 影响程度 |
| ------ | -------------- | ---- |
| 寄存器保存  | CPU寄存器状态保存/恢复  | 中等   |
| 内存访问   | 栈、堆内存访问模式变化   | 高    |
| 缓存失效   | CPU缓存、TLB失效    | 高    |
| 系统调用   | 用户态/内核态切换     | 中等   |

### 线程安全

#### 1. 什么是线程安全？如何理解原子性、可见性、有序性？

**线程安全**：多个线程同时访问共享资源时，不会产生数据不一致或其他非预期的结果。

**并发编程三大特性：**

| 特性   | 定义                   | 问题表现             | 解决方案              |
| ---- | -------------------- | ---------------- | ----------------- |
| 原子性  | 操作不可被中断，要么全部成功要么全部失败 | 数据不一致            | synchronized、CAS  |
| 可见性  | 一个线程修改共享变量，其他线程能立即看到 | 读取到过期数据          | volatile、synchronized |
| 有序性  | 程序执行顺序与代码顺序一致        | 指令重排序导致逻辑错误      | volatile、synchronized |

#### 2. synchronized 关键字的原理？使用方式？锁升级过程？

**使用方式：**
- **修饰实例方法**：锁的是当前实例对象
- **修饰静态方法**：锁的是Class对象
- **修饰代码块**：锁的是指定对象

**锁升级过程（JDK1.6+）：**

| 锁状态   | 特点          | 适用场景       | 性能  |
| ----- | ----------- | ---------- | --- |
| 无锁    | 没有锁竞争       | 单线程访问      | 最高  |
| 偏向锁   | 偏向第一个获得锁的线程 | 基本没有竞争     | 高   |
| 轻量级锁  | CAS自旋获取锁    | 竞争不激烈，持锁时间短 | 中等  |
| 重量级锁  | 操作系统互斥锁     | 竞争激烈，持锁时间长  | 低   |

**升级路径**：无锁 → 偏向锁 → 轻量级锁 → 重量级锁（不可逆）

#### 3. volatile 关键字的语义？原理？能保证原子性吗？适用场景？

**volatile的两大语义：**
1. **保证可见性**：修改立即刷新到主内存，读取直接从主内存读
2. **保证有序性**：禁止指令重排序

**实现原理：**
- **内存屏障**：编译器在volatile变量前后插入内存屏障指令
- **缓存一致性协议**：MESI协议确保缓存一致性

**不能保证原子性**：volatile不能保证复合操作的原子性，如 i++ 操作。

| 特性   | volatile | synchronized |
| ---- | -------- | ------------ |
| 原子性  | ❌        | ✅            |
| 可见性  | ✅        | ✅            |
| 有序性  | ✅        | ✅            |
| 阻塞性  | 不阻塞      | 可能阻塞         |
| 性能   | 高        | 相对较低         |

**适用场景：**
- 状态标记（如停止标志）
- 双重检查锁定模式
- 单例模式中的实例变量

#### 4. synchronized 和 volatile 的区别？

| 对比维度   | synchronized | volatile   |
| ------ | ------------ | ---------- |
| 作用对象   | 方法、代码块       | 变量         |
| 原子性    | 保证           | 不保证        |
| 可见性    | 保证           | 保证         |
| 有序性    | 保证           | 保证         |
| 阻塞特性   | 可能阻塞         | 不阻塞        |
| 锁机制    | 互斥锁          | 无锁         |
| 性能开销   | 较高           | 较低         |
| 适用场景   | 复合操作、临界区     | 状态标记、简单赋值  |

#### 5. CAS 操作的原理？Atomic类实现？ABA问题及解决方案？

**CAS（Compare-And-Swap）原理：**
比较内存位置的值与期望值，如果相同则更新为新值，整个操作是原子的。

**三个操作数：**
- **内存位置V**：要更新的变量
- **预期值A**：期望的当前值  
- **新值B**：要设置的新值

**Atomic类实现：**
基于CAS + volatile，通过无锁算法实现线程安全。

**ABA问题：**
值从A变成B再变回A，CAS检测不到中间的变化过程。

| 问题      | 表现                 | 解决方案                    |
| ------- | ------------------ | ----------------------- |
| ABA问题   | 值变化后又变回原值，CAS误判为未变化 | AtomicStampedReference  |
| 性能问题    | 高竞争时自旋消耗CPU        | 结合synchronized        |
| 只能保证单变量 | 多个变量的原子性无法保证       | AtomicReference包装对象    |

#### 6. ThreadLocal 的原理？使用场景？内存泄漏问题及如何避免？

**原理：**
每个线程都有一个ThreadLocalMap，以ThreadLocal为key存储线程私有数据。

**数据结构：**
Thread → ThreadLocalMap → Entry(ThreadLocal, Value)

**使用场景：**
- **数据库连接管理**：每个线程独立的连接
- **用户会话信息**：Web请求中的用户信息
- **数据格式化**：SimpleDateFormat等非线程安全类

**内存泄漏问题：**

| 问题原因          | 后果      | 解决方案              |
| ------------- | ------- | ----------------- |
| ThreadLocal被回收 | key为null | 手动调用remove()      |
| 线程长期存活        | value无法回收 | 使用完毕立即remove()    |
| 强引用链          | 整个对象无法回收 | 避免在线程池中使用静态ThreadLocal |

**最佳实践：**
1. 使用完毕后立即调用 `remove()`
2. 使用 `try-finally` 确保清理
3. 避免在线程池中使用静态ThreadLocal

## 数据库

### SQL基础

#### 1. SQL基础语法（DDL, DML, DQL, DCL）？常用函数？

**SQL语言分类：**

| 类型  | 全称                      | 作用       | 常用语句                     |
| --- | ----------------------- | -------- | ------------------------ |
| DDL | Data Definition Language | 数据定义语言   | CREATE、ALTER、DROP        |
| DML | Data Manipulation Language | 数据操作语言   | INSERT、UPDATE、DELETE    |
| DQL | Data Query Language      | 数据查询语言   | SELECT                   |
| DCL | Data Control Language    | 数据控制语言   | GRANT、REVOKE、COMMIT、ROLLBACK |

**常用函数分类：**

| 函数类型   | 常用函数                               | 作用                 |
| ------ | ---------------------------------- | ------------------ |
| 聚合函数   | COUNT、SUM、AVG、MAX、MIN               | 统计计算               |
| 字符串函数  | CONCAT、SUBSTRING、LENGTH、UPPER、LOWER | 字符串处理              |
| 日期函数   | NOW、CURDATE、DATE_FORMAT、DATEDIFF   | 日期时间处理             |
| 数学函数   | ROUND、CEIL、FLOOR、ABS、MOD          | 数值计算               |
| 条件函数   | IF、CASE WHEN、IFNULL、NULLIF        | 条件判断               |

### MySQL特性

#### 2. MySQL核心区别（事务、锁、外键、索引结构）？

**存储引擎对比：**

| 特性     | InnoDB         | MyISAM    | Memory   |
| ------ | -------------- | --------- | -------- |
| 事务支持   | ✅支持ACID        | ❌不支持      | ❌不支持     |
| 锁级别    | 行级锁            | 表级锁       | 表级锁      |
| 外键支持   | ✅支持            | ❌不支持      | ❌不支持     |
| 索引结构   | B+树聚集索引        | B+树非聚集索引  | Hash索引   |
| 崩溃恢复   | ✅支持            | ❌不支持      | ❌不支持     |
| 适用场景   | 事务处理、高并发写入     | 只读、数据仓库   | 临时表、缓存   |

### 索引优化

#### 3. 索引：什么是索引？为什么能提高查询效率？索引的优缺点？

**索引定义：**
索引是数据库表中一个或多个列的值排序的数据结构，类似书的目录，用于快速定位数据。

**提高效率原理：**
- **减少扫描行数**：从全表扫描变为索引查找
- **有序存储**：B+树结构保证数据有序，支持范围查询
- **减少I/O操作**：索引通常比数据小，能缓存在内存中

**索引优缺点：**

| 优点           | 缺点              |
| ------------ | --------------- |
| 大幅提高查询速度     | 占用额外存储空间        |
| 加速表连接        | 降低写操作性能（增删改）    |
| 减少分组和排序时间    | 维护索引需要额外开销      |
| 唯一索引保证数据唯一性  | 过多索引影响优化器选择     |

#### 4. B+树索引结构？为什么MySQL使用B+树而不是B树或哈希表？

**B+树特点：**
- **所有数据在叶子节点**：非叶子节点只存储键值
- **叶子节点连接**：叶子节点通过指针连接，支持范围查询
- **更高的扇出比**：非叶子节点可存储更多键值

**选择B+树的原因：**

| 对比项    | B+树        | B树         | 哈希表     |
| ------ | --------- | --------- | ------- |
| 范围查询   | ✅优秀       | ❌较差       | ❌不支持    |
| 顺序访问   | ✅优秀       | ❌一般       | ❌不支持    |
| 磁盘I/O  | ✅少        | ❌多        | ✅少      |
| 内存利用率  | ✅高        | ❌低        | ✅高      |
| 等值查询   | ✅快        | ✅快        | ✅最快     |
| 数据有序性  | ✅有序       | ✅有序       | ❌无序     |

#### 5. 聚集索引和非聚集索引的区别？InnoDB的主键索引结构？

**聚集索引 vs 非聚集索引：**

| 特性       | 聚集索引（主键索引）    | 非聚集索引（辅助索引）      |
| -------- | ------------- | ---------------- |
| 数据存储     | 叶子节点存储完整行数据   | 叶子节点存储主键值        |
| 数据排序     | 数据按索引键物理排序    | 数据排序与索引无关        |
| 查询性能     | 一次查询获取所有数据    | 可能需要回表查询         |
| 每表数量     | 最多一个          | 可以有多个            |
| 存储开销     | 无额外开销         | 需要额外存储空间         |

**InnoDB主键索引结构：**
- **主键索引**：聚集索引，叶子节点存储完整行数据
- **辅助索引**：非聚集索引，叶子节点存储主键值
- **回表查询**：通过辅助索引查询时，需要根据主键值再查主键索引

#### 6. 索引类型分类？

**按功能分类：**

| 索引类型   | 特点                 | 使用场景         | 示例               |
| ------ | ------------------ | ------------ | ---------------- |
| 主键索引   | 唯一+非空，自动创建聚集索引    | 主键字段         | PRIMARY KEY      |
| 唯一索引   | 值唯一，允许一个NULL      | 身份证号、邮箱      | UNIQUE           |
| 普通索引   | 无唯一性限制，提高查询速度     | 查询频繁的字段      | INDEX            |
| 组合索引   | 多列联合索引，遵循最左前缀原则   | 多条件查询        | (name, age, city) |
| 全文索引   | 文本关键词搜索           | 文章内容搜索       | FULLTEXT         |

#### 7. 索引失效的常见场景？

**索引失效情况：**

| 失效场景         | 示例                          | 原因                |
| ------------ | --------------------------- | ----------------- |
| 函数操作         | WHERE YEAR(date) = 2023    | 对索引列使用函数          |
| 隐式类型转换       | WHERE age = '18'           | 数据类型不匹配           |
| LIKE以%开头     | WHERE name LIKE '%张'       | 无法利用索引的有序性        |
| OR条件         | WHERE a = 1 OR b = 2       | 其中一个条件没有索引        |
| 组合索引不满足最左前缀  | INDEX(a,b,c) WHERE b = 1   | 违反最左前缀原则          |
| 不等于操作        | WHERE age != 18            | 范围太大，优化器选择全表扫描    |
| IS NULL判断    | WHERE name IS NULL         | NULL值不存储在索引中      |

### 锁机制

#### 8. EXPLAIN命令的作用？关键字段的含义？

**EXPLAIN作用：**
分析SQL语句执行计划，帮助优化查询性能。

**关键字段含义：**

| 字段        | 含义              | 重要值                         |
| --------- | --------------- | --------------------------- |
| type      | 访问类型            | system > const > eq_ref > ref > range > index > ALL |
| key       | 实际使用的索引        | NULL表示未使用索引               |
| rows      | 预估扫描行数          | 数值越小越好                      |
| Extra     | 额外信息            | Using index > Using where > Using filesort |

**type字段详解：**

| type值    | 性能  | 说明          |
| -------- | --- | ----------- |
| system   | 最优  | 表只有一行        |
| const    | 优   | 主键或唯一索引等值查询 |
| eq_ref   | 优   | 主键或唯一索引关联   |
| ref      | 良   | 非唯一索引等值查询   |
| range    | 中   | 范围查询        |
| index    | 差   | 索引全扫描       |
| ALL      | 最差  | 全表扫描        |

#### 9. 锁：InnoDB的行锁、间隙锁、临键锁？MVCC的原理？如何解决幻读？

**InnoDB锁类型：**

| 锁类型   | 锁范围                | 作用                | 示例场景           |
| ----- | ------------------ | ----------------- | -------------- |
| 行锁    | 锁定具体的行             | 防止并发修改同一行数据       | UPDATE具体记录     |
| 间隙锁   | 锁定索引记录之间的间隙        | 防止在间隙中插入新记录       | 防止幻读           |
| 临键锁   | 行锁+间隙锁的组合          | 既锁记录又锁间隙          | 范围查询时使用        |
| 意向锁   | 表级锁，表示事务的加锁意图      | 提高表锁检测效率          | 加行锁时自动加意向锁     |

**MVCC（多版本并发控制）原理：**
- **版本链**：每行记录维护多个版本
- **ReadView**：事务开始时创建的一致性视图
- **undo log**：存储历史版本数据
- **实现隔离**：不同事务看到不同版本的数据

**解决幻读：**
- **快照读**：通过MVCC，读取事务开始时的数据快照
- **当前读**：通过临键锁，锁定查询范围防止插入新数据

### 事务管理

#### 10. 事务隔离级别？MySQL默认级别？不同级别解决的问题？

**四大隔离级别：**

| 隔离级别           | 脏读  | 不可重复读 | 幻读  | 实现方式        | 性能  |
| -------------- | --- | ----- | --- | ----------- | --- |
| 读未提交（READ UNCOMMITTED） | ❌   | ❌     | ❌   | 无锁          | 最高  |
| 读已提交（READ COMMITTED）   | ✅   | ❌     | ❌   | 行锁+MVCC     | 高   |
| 可重复读（REPEATABLE READ）  | ✅   | ✅     | 部分解决 | 临键锁+MVCC    | 中   |
| 串行化（SERIALIZABLE）     | ✅   | ✅     | ✅   | 表锁          | 低   |

**MySQL默认隔离级别：**可重复读（REPEATABLE READ）

**问题说明：**
- **脏读**：读到其他事务未提交的数据
- **不可重复读**：同一事务中多次读取同一数据结果不同
- **幻读**：同一事务中多次查询记录数量不同

### 性能优化

#### 11. 如何优化慢查询？

**优化策略：**

| 优化方向   | 具体方法                    | 效果评估  |
| ------ | ----------------------- | ----- |
| 索引优化   | 添加合适索引、优化索引使用          | ⭐⭐⭐⭐⭐ |
| SQL语句优化 | 避免SELECT *、减少子查询       | ⭐⭐⭐⭐  |
| 分库分表   | 水平/垂直分割减少单表数据量        | ⭐⭐⭐⭐⭐ |
| 读写分离   | 主库写、从库读，减少主库压力        | ⭐⭐⭐⭐  |

**具体优化手段：**

| 方法          | 说明                     | 适用场景        |
| ----------- | ---------------------- | ----------- |
| 添加索引        | 为WHERE、ORDER BY字段添加索引  | 查询频繁的字段     |
| 优化JOIN      | 使用小表驱动大表               | 多表关联查询      |
| 避免函数计算      | 不在WHERE条件中使用函数         | 所有查询        |
| 分页优化        | 使用索引+偏移量代替LIMIT大偏移    | 深度分页查询      |
| 垂直分表        | 将大字段拆分到独立表             | 表字段过多       |
| 水平分表        | 按规则将数据分散到多个表           | 单表数据量过大     |
| 使用缓存        | Redis缓存热点数据            | 读多写少场景      |
| 连接池优化       | 合理设置连接池参数              | 高并发场景       |

## Redis

### 基础特性

#### 1. Redis是什么？常用数据类型及其底层实现和典型应用场景？

**Redis定义：**
Redis是一个开源的内存数据结构存储系统，可用作数据库、缓存和消息代理。

**常用数据类型：**

| 数据类型        | 底层实现                    | 典型应用场景                    | 常用命令                |
| ----------- | ----------------------- | ------------------------- | ------------------- |
| String      | SDS（简单动态字符串）            | 缓存、计数器、分布式锁               | SET、GET、INCR       |
| Hash        | 压缩列表/哈希表                | 用户信息、商品信息                 | HSET、HGET、HMGET   |
| List        | 压缩列表/双向链表               | 消息队列、最新消息列表               | LPUSH、RPOP、LRANGE |
| Set         | 整数集合/哈希表                | 标签、好友关系、唯一性统计             | SADD、SMEMBERS、SINTER |
| Sorted Set  | 压缩列表/跳跃表                | 排行榜、延时队列                  | ZADD、ZRANGE、ZRANK |
| HyperLogLog | 基数估算算法                  | UV统计、独立访客统计               | PFADD、PFCOUNT      |
| Bitmap      | 位数组                     | 用户签到、在线状态                 | SETBIT、GETBIT、BITCOUNT |
| Geospatial  | Sorted Set + GeoHash    | 地理位置、附近的人                 | GEOADD、GEORADIUS   |
| Stream      | Radix Tree + Listpack  | 消息流、日志收集                  | XADD、XREAD、XGROUP |

#### 2. Redis为什么快？

**性能优势分析：**

| 优势        | 具体表现                  | 性能影响    |
| --------- | --------------------- | ------- |
| 内存存储      | 数据存储在内存中，避免磁盘I/O      | ⭐⭐⭐⭐⭐ |
| 单线程模型     | 避免线程切换和锁竞争开销          | ⭐⭐⭐⭐  |
| I/O多路复用   | epoll机制处理并发连接         | ⭐⭐⭐⭐  |
| 高效数据结构    | 针对不同场景优化的数据结构         | ⭐⭐⭐   |
| 简单协议      | RESP协议简单，解析开销小       | ⭐⭐⭐   |

**核心原因：**
- **纯内存操作**：避免磁盘I/O，速度快10000倍
- **单线程避免竞争**：无锁设计，减少上下文切换
- **非阻塞I/O**：高效处理大量并发连接

### 持久化机制

#### 3. Redis的持久化机制？优缺点？如何选择？

**两种持久化方式：**

| 特性      | RDB快照           | AOF日志             |
| ------- | --------------- | ----------------- |
| 持久化方式   | 定期生成数据快照        | 记录每个写操作命令         |
| 文件大小    | 紧凑，文件小          | 较大，包含所有操作         |
| 恢复速度    | 快               | 慢                 |
| 数据完整性   | 可能丢失最后一次快照后的数据  | 根据同步策略，丢失较少       |
| 性能影响    | fork子进程时有短暂阻塞   | 持续写入，影响相对较小       |
| 适用场景    | 对数据丢失不敏感的场景     | 对数据完整性要求高的场景      |

**选择策略：**

| 场景           | 推荐方案      | 原因                    |
| ------------ | --------- | --------------------- |
| 缓存场景         | 仅RDB      | 数据可重新计算，性能优先          |
| 重要数据存储       | RDB + AOF | 双重保障，确保数据安全           |
| 高写入量场景       | 仅RDB      | 避免AOF写入影响性能           |
| 数据完整性要求极高的场景 | AOF       | 最大程度保证数据不丢失           |

### 内存管理

#### 4. Redis的过期键删除策略？

**三种删除策略：**

| 策略     | 触发时机    | 优点       | 缺点         | CPU消耗 | 内存消耗 |
| ------ | ------- | -------- | ---------- | ----- | ---- |
| 定时删除   | 设置定时器   | 内存友好     | CPU消耗大     | 高     | 低    |
| 惰性删除   | 访问时检查   | CPU友好    | 内存不友好      | 低     | 高    |
| 定期删除   | 定期随机抽查  | 平衡CPU和内存 | 可能有漏网之鱼    | 中     | 中    |

**Redis实际策略：** 惰性删除 + 定期删除的组合方式

#### 5. 内存淘汰策略？

**8种淘汰策略：**

| 策略              | 作用范围      | 淘汰算法    | 适用场景           |
| --------------- | --------- | ------- | -------------- |
| noeviction      | 无         | 不淘汰     | 内存足够，不希望数据丢失   |
| allkeys-lru     | 所有key     | LRU最近最少使用 | 通用缓存，访问有热点     |
| volatile-lru    | 有过期时间的key | LRU     | 只淘汰临时数据        |
| allkeys-random  | 所有key     | 随机      | 访问模式均匀         |
| volatile-random | 有过期时间的key | 随机      | 临时数据访问均匀       |
| volatile-ttl    | 有过期时间的key | TTL最短优先 | 希望快到期的数据先删除    |
| allkeys-lfu     | 所有key     | LFU最少使用频率 | 访问频率差异明显       |
| volatile-lfu    | 有过期时间的key | LFU     | 临时数据访问频率差异明显   |

**推荐选择：**
- **通用场景**：allkeys-lru（最常用）
- **只缓存场景**：volatile-lru
- **混合数据**：volatile-ttl

### 高可用架构

#### 6. 如何保证Redis的高可用？Redis Cluster的槽分配原理？

**高可用方案：**

| 方案            | 特点                | 优点           | 缺点           | 适用场景     |
| ------------- | ----------------- | ------------ | ------------ | -------- |
| 主从复制          | 一主多从，读写分离         | 简单，读性能好      | 主节点单点故障      | 读多写少     |
| 哨兵模式          | 自动故障转移            | 高可用，自动切换     | 配置复杂         | 中小型应用    |
| Redis Cluster | 分布式，无中心节点         | 高可用+高性能      | 运维复杂         | 大型分布式应用  |

**Redis Cluster槽分配：**
- **总槽数**：16384个槽（0-16383）
- **分配原理**：CRC16(key) % 16384
- **槽分布**：平均分配到各个主节点
- **数据分片**：根据key计算槽位，找到对应节点

| 集群规模   | 节点配置        | 槽分配示例          |
| ------ | ----------- | -------------- |
| 3主3从   | 每主1从       | 0-5460, 5461-10922, 10923-16383 |
| 6主6从   | 每主1从       | 每个主节点约2730个槽    |
| 9主9从   | 每主1从       | 每个主节点约1820个槽    |

### 缓存问题

#### 7. 缓存穿透、缓存击穿、缓存雪崩的概念、原因及解决方案？

**三大缓存问题对比：**

| 问题类型   | 定义                     | 原因分析           | 解决方案                      |
| ------ | ---------------------- | -------------- | ------------------------- |
| 缓存穿透   | 查询不存在的数据，缓存和数据库都没有     | 恶意攻击、业务逻辑错误    | 布隆过滤器、空值缓存、参数校验          |
| 缓存击穿   | 热点数据过期，大量请求同时访问数据库     | 热点key过期        | 互斥锁、热点数据永不过期、提前更新        |
| 缓存雪崩   | 大量缓存同时过期，数据库压力剧增       | 缓存集中过期、Redis宕机 | 过期时间随机化、熔断降级、多级缓存、集群部署  |

**详细解决方案：**

| 解决方案       | 实现方式                  | 优点           | 缺点           |
| ---------- | --------------------- | ------------ | ------------ |
| 布隆过滤器      | 位数组+多个hash函数          | 内存占用小，查询快    | 存在误判，不支持删除   |
| 空值缓存       | 对空结果设置较短过期时间          | 简单有效         | 占用内存         |
| 互斥锁        | 只允许一个线程查询数据库          | 避免重复查询       | 可能造成阻塞       |
| 熔断降级       | 失败率超过阈值时停止访问          | 保护系统         | 可能影响用户体验     |

### 分布式锁

#### 8. 如何设计一个分布式锁？Watch Dog机制？

**分布式锁实现要点：**

| 要求       | Redis实现方式              | 说明                     |
| -------- | ---------------------- | ---------------------- |
| 互斥性      | SET key value NX EX    | NX确保原子性设置              |
| 防死锁      | 设置过期时间                 | 避免持锁进程崩溃导致死锁           |
| 防误删      | 删除时校验value             | 确保只能删除自己的锁             |
| 可重入      | 记录线程ID和重入次数           | 支持同一线程多次获取锁            |
| 阻塞等待     | 循环尝试获取锁                | 获取失败时等待重试              |

**Watch Dog机制：**

| 特性     | 实现原理              | 作用                 |
| ------ | ----------------- | ------------------ |
| 自动续期   | 定时任务延长锁过期时间       | 防止业务执行时间超过锁过期时间    |
| 续期条件   | 锁仍被当前线程持有         | 避免给其他线程的锁续期        |
| 续期时间   | 通常为锁过期时间的1/3      | 保证在锁过期前完成续期        |
| 停止条件   | 锁被释放或线程结束         | 避免无限续期             |

**完整分布式锁方案：**

```lua
-- 加锁Lua脚本
if redis.call('set', KEYS[1], ARGV[1], 'nx', 'ex', ARGV[2]) then
    return 1
else
    return 0
end

-- 解锁Lua脚本  
if redis.call('get', KEYS[1]) == ARGV[1] then
    return redis.call('del', KEYS[1])
else
    return 0
end
```

**方案对比：**

| 实现方案        | 优点              | 缺点                | 适用场景       |
| ----------- | --------------- | ----------------- | ---------- |
| 单Redis节点   | 简单，性能好          | 单点故障              | 对可用性要求不高   |
| Redis集群     | 高可用             | 脑裂时可能出现多个锁        | 一般业务场景     |
| Redlock算法   | 更高的安全性          | 复杂，性能较差           | 对数据一致性要求极高 |
| ZooKeeper   | 强一致性，自动续期       | 性能较差，依赖ZK集群       | 强一致性要求     |

## 分布式

### 理论基础

#### 1. CAP理论？BASE理论？

**CAP理论（布鲁尔定理）：**
分布式系统不可能同时满足一致性（Consistency）、可用性（Availability）、分区容错性（Partition tolerance）三个特性。

| 特性           | 定义                        | 说明                      |
| ------------ | ------------------------- | ----------------------- |
| 一致性（C）       | 所有节点同时看到相同的数据             | 数据在所有节点保持同步             |
| 可用性（A）       | 系统持续可用，快速响应               | 系统不会因为部分节点故障而停止服务       |
| 分区容错性（P）     | 系统在网络分区故障时仍能继续运行          | 网络故障不会导致整个系统不可用         |

**CAP组合选择：**

| 组合    | 特点              | 典型应用           | 使用场景         |
| ----- | --------------- | -------------- | ------------ |
| CA    | 一致性+可用性         | 传统关系型数据库       | 单机或局域网环境     |
| CP    | 一致性+分区容错性       | MongoDB、Redis  | 数据一致性要求高     |
| AP    | 可用性+分区容错性       | DNS、CDN       | 高可用性要求，允许数据延迟 |

**BASE理论：**
作为CAP理论的延伸，提供了一种在分布式系统中实现高可用的方式。

| 特性            | 全称                    | 含义                  |
| ------------- | --------------------- | ------------------- |
| 基本可用（BA）      | Basically Available   | 系统基本可用，允许损失部分功能     |
| 软状态（S）        | Soft State            | 允许系统中数据存在中间状态       |
| 最终一致性（E）      | Eventually Consistent | 系统中数据最终达到一致状态       |

### 分布式事务

#### 2. 分布式事务的解决方案？

**分布式事务挑战：**
跨多个服务或数据库的事务操作，需要保证ACID特性。

**解决方案对比：**

| 方案      | 实现原理              | 优点           | 缺点              | 适用场景        |
| ------- | ----------------- | ------------ | --------------- | ----------- |
| 2PC     | 两阶段提交             | 强一致性         | 阻塞、单点故障         | 强一致性要求      |
| 3PC     | 三阶段提交             | 减少阻塞时间       | 复杂度高、网络分区问题     | 对2PC的改进     |
| TCC     | Try-Confirm-Cancel | 业务无侵入        | 实现复杂、补偿逻辑       | 业务逻辑相对简单    |
| Saga    | 长事务拆分+补偿         | 高性能、最终一致性    | 补偿逻辑复杂          | 长流程业务       |
| 消息事务    | 消息队列保证最终一致性       | 异步高性能        | 最终一致性、消息重复      | 异步处理场景      |
| 最大努力通知  | 定期重试+人工介入         | 简单易实现        | 可能不一致           | 对一致性要求不严格   |

**详细方案分析：**

| 方案特点       | 2PC          | TCC              | Saga             |
| ---------- | ------------ | ---------------- | ---------------- |
| 一致性        | 强一致性         | 最终一致性            | 最终一致性            |
| 性能         | 较差           | 好                | 好                |
| 复杂度        | 简单           | 中等               | 复杂               |
| 业务侵入性      | 无            | 中等               | 高                |
| 故障恢复       | 困难           | 相对容易             | 容易               |

### 分布式锁

#### 3. 分布式锁的实现？

**实现方案对比：**

| 实现方案          | 原理                  | 优点              | 缺点              | 适用场景         |
| ------------- | ------------------- | --------------- | --------------- | ------------ |
| 数据库锁          | 基于数据库唯一索引         | 简单易理解           | 性能差、单点故障        | 简单场景         |
| Redis分布式锁     | SET NX EX命令        | 性能好、支持过期        | 可能出现锁丢失         | 一般业务场景       |
| ZooKeeper临时节点 | 临时有序节点            | 强一致性、自动释放       | 性能相对较差          | 强一致性要求       |
| Etcd          | 基于Raft算法的分布式锁     | 强一致性、高可用        | 依赖额外组件          | 微服务架构        |

**各方案详细对比：**

| 对比维度   | Redis        | ZooKeeper    | 数据库        | Etcd         |
| ------ | ------------ | ------------ | ---------- | ------------ |
| 性能     | 高            | 中            | 低          | 中            |
| 可靠性    | 中            | 高            | 中          | 高            |
| 复杂度    | 低            | 中            | 低          | 中            |
| 运维成本   | 低            | 中            | 低          | 中            |
| 社区支持   | 好            | 好            | 好          | 好            |

### 分布式ID生成

#### 4. 分布式ID生成方案？

**ID生成方案对比：**

| 方案        | 实现原理              | 优点              | 缺点              | 适用场景         |
| --------- | ----------------- | --------------- | --------------- | ------------ |
| UUID      | 随机生成128位标识符       | 简单、本地生成         | 无序、占用空间大        | 对顺序无要求的场景    |
| 数据库自增ID   | 数据库AUTO_INCREMENT | 简单、有序           | 性能瓶颈、单点故障       | 单机应用         |
| 号段模式      | 批量获取ID段          | 高性能、减少数据库访问     | 浪费ID、重启丢失      | 高并发场景        |
| 雪花算法      | 时间戳+机器ID+序列号     | 有序、高性能、分布式      | 时钟回拨问题          | 分布式高并发       |
| 美团Leaf     | 号段模式+雪花算法优化      | 高可用、性能好         | 复杂度较高           | 大规模分布式系统     |
| 百度UidGenerator | 雪花算法优化           | 解决时钟回拨、高性能      | 依赖机器时间          | 对顺序性要求高的场景   |

**雪花算法详解：**

| 组成部分   | 位数  | 说明                    | 取值范围        |
| ------ | --- | --------------------- | ----------- |
| 符号位    | 1位  | 固定为0                 | 0           |
| 时间戳    | 41位 | 相对于某个起始时间的毫秒数         | 69年         |
| 机器ID   | 10位 | 数据中心ID(5位)+机器ID(5位)   | 1024台机器    |
| 序列号    | 12位 | 毫秒内的序列号               | 4096个序列号   |

**方案选择建议：**

| 场景需求         | 推荐方案           | 原因                    |
| ------------ | -------------- | --------------------- |
| 对性能要求不高      | UUID           | 实现简单                  |
| 需要有序ID       | 雪花算法           | 趋势递增、性能好              |
| 超高并发         | 号段模式           | 批量获取、减少竞争             |
| 对可用性要求极高     | 美团Leaf/百度UidGenerator | 双buffer、解决时钟回拨问题      |

### 负载均衡

#### 5. 负载均衡算法？

**负载均衡算法对比：**

| 算法         | 实现原理              | 优点              | 缺点              | 适用场景         |
| ---------- | ----------------- | --------------- | --------------- | ------------ |
| 轮询         | 依次分配请求到每个服务器      | 简单、分布均匀         | 不考虑服务器性能差异      | 服务器性能相近      |
| 加权轮询       | 根据权重分配请求          | 考虑服务器性能差异       | 静态权重、不能动态调整     | 服务器性能差异已知    |
| 最少连接       | 分配到连接数最少的服务器      | 考虑服务器当前负载       | 需要维护连接数统计       | 长连接场景        |
| 加权最少连接     | 结合权重和连接数          | 综合考虑性能和负载       | 计算复杂度高          | 复杂负载场景       |
| 随机         | 随机选择服务器           | 实现简单            | 可能分布不均匀         | 服务器数量多       |
| 加权随机       | 根据权重随机选择          | 简单、考虑性能差异       | 短期可能不均匀         | 一般业务场景       |
| IP Hash    | 根据客户端IP哈希选择      | 相同IP访问同一服务器     | 可能负载不均          | 需要会话保持       |
| 最短响应时间     | 选择响应时间最短的服务器      | 考虑服务器实际性能       | 需要监控响应时间        | 对延迟敏感的应用     |

**算法适用场景详解：**

| 业务特点         | 推荐算法        | 原因                      |
| ------------ | ----------- | ----------------------- |
| 无状态服务        | 轮询/随机       | 简单高效，分布均匀               |
| 有状态服务        | IP Hash     | 保证同一用户访问同一服务器           |
| 服务器性能差异大     | 加权轮询/加权随机  | 根据性能分配不同权重              |
| 长连接场景        | 最少连接        | 避免连接过度集中                |
| 对延迟敏感        | 最短响应时间      | 选择响应最快的服务器              |
| 高并发场景        | 一致性哈希       | 避免服务器变化时大量请求重新分配        |

**实现层级对比：**

| 实现层级   | 特点                  | 代表产品           | 优势           | 劣势         |
| ------ | ------------------- | -------------- | ------------ | ---------- |
| 4层负载均衡 | 基于IP和端口进行负载均衡      | LVS、F5        | 性能高、透明       | 功能相对简单     |
| 7层负载均衡 | 基于应用层内容进行负载均衡     | Nginx、HAProxy | 功能丰富、灵活      | 性能相对较低     |
| DNS负载均衡 | 通过DNS解析实现负载均衡      | 云解析          | 简单、分布式       | 精度不高、缓存问题  |


## 微服务

### 架构特性

#### 1. 微服务的优势和挑战？

**微服务定义：**
将单一应用程序拆分为一组小型服务，每个服务运行在独立进程中，通过轻量级通信机制协作。

**优势 vs 挑战对比：**

| 维度       | 优势                        | 挑战                        |
| -------- | ------------------------- | ------------------------- |
| 开发维护     | 代码库小、团队独立开发、技术栈灵活         | 服务间协调复杂、版本管理困难            |
| 部署运维     | 独立部署、故障隔离、弹性伸缩            | 运维复杂度高、监控困难               |
| 性能扩展     | 按需扩展、资源利用率高               | 网络延迟、分布式事务复杂              |
| 团队协作     | 团队自治、并行开发                 | 服务边界划分难、团队沟通成本高           |
| 系统稳定性    | 单点故障影响范围小                 | 服务间依赖复杂、调试困难              |

**适用场景判断：**

| 项目特征         | 单体架构  | 微服务架构  | 推荐理由              |
| ------------ | ----- | ------ | ----------------- |
| 团队规模         | < 10人 | > 10人  | 微服务需要足够的团队支撑      |
| 业务复杂度        | 简单    | 复杂     | 复杂业务适合拆分独立维护      |
| 技术栈要求        | 统一    | 多样化    | 微服务支持不同技术栈        |
| 部署频率         | 低     | 高      | 微服务支持独立快速部署       |
| 扩展性要求        | 一般    | 高      | 微服务支持按需精确扩展       |

### 服务发现

#### 2. 服务注册与发现：原理？常用组件？比较？

**服务发现原理：**
解决微服务环境下服务实例动态变化时的相互发现和调用问题。

**实现模式对比：**

| 模式       | 原理                    | 优点           | 缺点               | 适用场景     |
| -------- | --------------------- | ------------ | ---------------- | -------- |
| 客户端发现    | 客户端查询注册中心获取服务实例列表     | 性能好、负载均衡灵活   | 客户端逻辑复杂、语言绑定     | 性能要求高    |
| 服务端发现    | 通过负载均衡器代理访问服务         | 客户端简单、语言无关   | 负载均衡器成为瓶颈        | 多语言环境    |
| 服务网格     | 基础设施层处理服务通信           | 业务无感知、功能丰富   | 架构复杂、性能开销        | 大规模微服务   |

**主流组件对比：**

| 组件         | 类型    | 一致性算法  | 多数据中心 | 健康检查 | 负载均衡 | 适用场景        |
| ---------- | ----- | ------ | ----- | ---- | ---- | ----------- |
| Eureka     | AP    | 无      | 支持    | 支持   | 客户端  | Spring Cloud |
| Consul     | CP    | Raft   | 支持    | 支持   | 支持   | 多语言环境       |
| Zookeeper  | CP    | ZAB    | 支持    | 支持   | 不支持  | Dubbo生态     |
| Nacos      | AP/CP | Raft   | 支持    | 支持   | 支持   | 阿里云生态       |
| Etcd       | CP    | Raft   | 支持    | 支持   | 不支持  | Kubernetes  |

### 服务调用

#### 3. 服务调用：RESTful API 和 RPC (Dubbo, gRPC)？比较？

**调用方式对比：**

| 特性       | RESTful API      | RPC (Dubbo)     | RPC (gRPC)      |
| -------- | ---------------- | --------------- | --------------- |
| 协议       | HTTP/HTTPS       | TCP/HTTP        | HTTP/2          |
| 序列化      | JSON/XML         | Hessian/Kryo    | Protocol Buffers |
| 性能       | 中等               | 高               | 高               |
| 跨语言支持    | 优秀               | Java生态         | 优秀              |
| 学习成本     | 低                | 中等              | 中等              |
| 生态完整性    | 丰富               | Java生态丰富       | 快速发展中           |
| 适用场景     | Web服务、对外API     | Java微服务        | 多语言微服务          |

**技术选型建议：**

| 场景需求           | 推荐方案        | 原因                    |
| -------------- | ----------- | --------------------- |
| 对外开放API        | RESTful API | 标准化、易于集成              |
| 内部服务高性能调用      | Dubbo/gRPC  | 性能好、功能丰富              |
| 多语言团队          | gRPC        | 跨语言支持好               |
| Spring Boot项目   | RESTful API | 生态集成度高               |
| 大数据量传输         | gRPC        | 二进制序列化、HTTP/2协议      |
| 快速原型开发         | RESTful API | 开发简单、调试方便             |

### API网关

#### 4. 服务网关 (API Gateway)：作用？常用组件？

**API网关作用：**
作为所有客户端请求的统一入口，提供路由、认证、限流、监控等功能。

**核心功能对比：**

| 功能类别   | 具体功能           | 价值                 | 实现方式             |
| ------ | -------------- | ------------------ | ---------------- |
| 请求路由   | 动态路由、负载均衡      | 请求分发到正确服务          | 规则配置、服务发现        |
| 安全认证   | 身份验证、权限控制      | 统一安全策略             | JWT、OAuth2       |
| 流量控制   | 限流、熔断、降级       | 保护后端服务             | 令牌桶、熔断器          |
| 协议转换   | HTTP/WebSocket等  | 协议统一               | 协议适配器            |
| 监控运维   | 日志、监控、链路追踪     | 可观测性               | APM集成           |

**主流网关对比：**

| 网关         | 类型    | 性能  | 功能丰富度 | 生态集成  | 学习成本 | 适用场景          |
| ---------- | ----- | --- | ----- | ----- | ---- | ------------- |
| Spring Cloud Gateway | 响应式   | 高   | 丰富    | Spring | 中等   | Spring Cloud项目 |
| Zuul       | 阻塞式   | 中   | 基础    | Spring | 低    | 简单场景          |
| Kong       | 高性能   | 很高  | 极丰富   | 开放    | 高    | 企业级应用         |
| Nginx Plus | 反向代理  | 极高  | 丰富    | 广泛    | 中等   | 高并发场景         |
| Envoy      | 代理    | 高   | 丰富    | 云原生   | 高    | 服务网格          |

### 配置中心

#### 5. 配置中心：作用？常用组件？

**配置中心价值：**
集中管理微服务配置，支持动态更新，避免重启服务。

**核心能力对比：**

| 能力       | 传统配置文件        | 配置中心            | 提升效果       |
| -------- | ------------- | --------------- | ---------- |
| 配置管理     | 散落在各个服务       | 集中统一管理          | 管理效率提升90%  |
| 动态更新     | 需要重启服务        | 实时推送更新          | 变更速度提升10倍  |
| 环境隔离     | 手动维护多套配置      | 自动环境区分          | 错误率降低80%   |
| 权限控制     | 无权限控制         | 细粒度权限管理         | 安全性大幅提升    |
| 版本管理     | 手动备份          | 自动版本控制和回滚       | 可靠性提升      |

**主流配置中心对比：**

| 组件            | 数据存储    | 动态推送 | 多环境 | 权限控制 | 可视化界面 | 生态集成      |
| ------------- | ------- | ---- | --- | ---- | ----- | --------- |
| Spring Cloud Config | Git/SVN | 需结合Bus | 支持  | 基础   | 基础    | Spring生态  |
| Apollo        | MySQL   | 支持   | 支持  | 完善   | 优秀    | 多语言       |
| Nacos         | 内置数据库   | 支持   | 支持  | 支持   | 优秀    | 阿里云生态     |
| Consul        | KV存储    | 支持   | 支持  | 支持   | 基础    | HashiCorp生态 |

### 服务容错

#### 6. 服务容错：熔断、降级、限流 (令牌桶、漏桶)，Sentinel和Hystrix？

**容错机制对比：**

| 机制   | 目的           | 触发条件         | 恢复机制        | 适用场景           |
| ---- | ------------ | ------------ | ----------- | -------------- |
| 熔断   | 避免连锁故障       | 错误率/响应时间超阈值  | 半开状态探测      | 依赖服务不稳定        |
| 降级   | 保证核心功能可用     | 系统负载过高       | 手动或自动恢复     | 非核心功能可牺牲       |
| 限流   | 保护系统不被压垮     | 请求量超过系统处理能力  | 拒绝或排队等待     | 高并发场景          |

**限流算法对比：**

| 算法    | 原理                 | 优点           | 缺点           | 适用场景        |
| ----- | ------------------ | ------------ | ------------ | ----------- |
| 令牌桶   | 固定速率产生令牌，请求消耗令牌    | 允许突发流量       | 实现相对复杂       | 允许突发的业务场景   |
| 漏桶    | 请求以固定速率处理          | 流量平滑         | 不能处理突发流量     | 需要平滑处理的场景   |
| 固定窗口  | 固定时间窗口内限制请求数量      | 实现简单         | 临界问题         | 简单限流场景      |
| 滑动窗口  | 动态时间窗口统计           | 更精确的限流       | 内存占用大        | 精确限流需求      |

**Sentinel vs Hystrix：**

| 对比维度   | Sentinel         | Hystrix          |
| ------ | ---------------- | ---------------- |
| 开发状态   | 活跃开发             | 停止维护             |
| 性能     | 更优               | 较好               |
| 功能丰富度  | 全面（熔断+限流+降级+系统保护） | 主要专注熔断降级         |
| 控制台    | 功能强大的实时监控        | 基础监控             |
| 规则配置   | 支持多种数据源动态配置      | 主要基于注解和配置文件      |
| 生态集成   | Spring Cloud Alibaba | Spring Cloud Netflix |
| 学习成本   | 中等               | 较低               |

### 链路追踪

#### 7. 链路追踪：目的？原理？常用组件 (Zipkin, SkyWalking)？

**链路追踪目的：**
在分布式系统中追踪请求的完整调用链路，快速定位性能瓶颈和故障根因。

**核心概念：**

| 概念      | 定义                  | 作用              |
| ------- | ------------------- | --------------- |
| Trace   | 一次完整的请求调用链路         | 代表一次业务请求的全链路    |
| Span    | 链路中的一个操作单元          | 代表一次服务调用或操作     |
| SpanId  | Span的唯一标识           | 标识具体的操作单元       |
| TraceId | Trace的唯一标识          | 串联整个调用链路        |
| 采样率     | 采集链路数据的比例           | 平衡性能和可观测性       |

**实现原理：**
1. **埋点收集**：在应用中插入追踪代码收集调用信息
2. **传递TraceId**：通过HTTP头或RPC上下文传递追踪标识
3. **数据上报**：异步上报链路数据到追踪系统
4. **存储分析**：存储并分析链路数据，提供查询界面

**主流组件对比：**

| 组件          | 开发者     | 语言支持   | 存储支持       | 性能开销 | 界面友好度 | 生态集成    |
| ----------- | ------- | ------ | ---------- | ---- | ----- | ------- |
| Zipkin      | Twitter | 多语言    | 多种存储后端     | 低    | 一般    | 广泛      |
| SkyWalking  | Apache  | Java为主 | ES/H2/MySQL | 低    | 优秀    | Java生态  |
| Jaeger      | Uber    | 多语言    | 多种存储后端     | 低    | 良好    | 云原生     |
| Pinpoint    | Naver   | Java   | HBase      | 中等   | 优秀    | Java专用  |

**技术选型建议：**

| 场景需求        | 推荐方案        | 选择理由              |
| ----------- | ----------- | ----------------- |
| Java微服务     | SkyWalking  | 无侵入、功能全面、界面友好     |
| 多语言环境       | Zipkin/Jaeger | 语言支持广泛            |
| 云原生架构       | Jaeger      | CNCF项目，K8s集成好     |
| 性能敏感应用      | 自研或轻量级方案    | 减少性能开销            |
| 大数据量场景      | SkyWalking  | 支持采样和聚合分析         |
| 快速上手        | Zipkin      | 简单易用，社区资源丰富       |

## 消息队列

### 基础概念

#### 1. 消息队列的作用？（解耦、异步、削峰填谷）

**消息队列定义：**
在分布式系统中用于服务间通信的中间件，实现消息的异步传递和处理。

**三大核心作用：**

| 作用      | 定义                | 解决问题           | 应用场景                | 效果评估      |
| ------- | ----------------- | -------------- | ------------------- | --------- |
| 解耦      | 消息发送者和接收者不直接依赖    | 系统间强耦合         | 订单系统通知库存、支付、物流系统    | 耦合度降低80%  |
| 异步      | 发送消息后立即返回，不等待处理结果 | 同步调用响应时间长      | 用户注册后发送邮件、短信        | 响应时间减少70% |
| 削峰填谷    | 缓冲高并发请求，平滑处理     | 瞬时高并发冲击        | 秒杀活动、双11促销          | 系统稳定性提升  |

**使用前后对比：**

| 场景       | 不使用消息队列               | 使用消息队列                  | 改善效果            |
| -------- | --------------------- | ----------------------- | --------------- |
| 订单处理     | 同步调用库存、支付、物流，响应时间3秒   | 异步通知，响应时间500ms          | 响应速度提升6倍        |
| 系统故障     | 一个服务故障导致整个链路失败        | 服务故障不影响消息发送，具备容错能力      | 可用性从95%提升到99.9% |
| 促销活动     | 瞬时流量冲垮系统              | 消息队列缓冲，平稳处理             | 系统零宕机           |

#### 2. 消息模型？（点对点Queue和发布/订阅Topic）

**两种消息模型对比：**

| 特性        | 点对点模型（Queue）        | 发布/订阅模型（Topic）        |
| --------- | ------------------- | --------------------- |
| 消息消费      | 一条消息只能被一个消费者消费      | 一条消息可以被多个消费者消费        |
| 消费者关系     | 竞争关系                | 独立关系                  |
| 消息持久化     | 消费后从队列删除            | 根据配置决定是否删除            |
| 扩展性       | 通过增加消费者实现负载均衡       | 通过增加订阅者实现广播           |
| 应用场景      | 任务分发、负载均衡           | 事件通知、数据同步             |
| 典型例子      | 订单处理队列              | 用户注册事件广播              |

**使用场景选择：**

| 业务需求         | 推荐模型      | 原因                    | 典型应用              |
| ------------ | --------- | --------------------- | ----------------- |
| 任务处理         | Queue     | 确保每个任务只被处理一次          | 邮件发送、文件处理         |
| 事件广播         | Topic     | 多个系统需要响应同一事件          | 用户注册、订单状态变更       |
| 负载均衡         | Queue     | 多个消费者竞争处理消息           | 并发订单处理            |
| 数据同步         | Topic     | 多个下游系统需要同步数据          | 数据仓库同步、缓存更新       |
| 日志收集         | Topic     | 多个监控系统需要收集日志          | ELK日志分析           |

### 消息可靠性

#### 3. 如何保证消息不丢失？

**消息丢失的三个阶段：**

| 阶段       | 丢失场景              | 解决方案                | 实现方式                     |
| -------- | ----------------- | ------------------- | ------------------------ |
| 生产者阶段    | 网络故障、Broker宕机     | 生产者确认机制             | 同步发送、异步回调确认              |
| Broker阶段 | 消息未持久化到磁盘        | 消息持久化               | 同步刷盘、主从复制                |
| 消费者阶段    | 消费者宕机、处理失败       | 手动ACK               | 消费成功后再确认                 |

**详细保障机制：**

| 保障机制       | 实现原理                  | 优点              | 缺点              | 适用场景        |
| ---------- | --------------------- | --------------- | --------------- | ----------- |
| 生产者确认      | Producer等待Broker确认     | 确保消息到达Broker    | 性能略有下降          | 重要业务消息      |
| 同步刷盘       | 消息写入磁盘后返回确认           | 数据安全性高          | 性能影响大           | 金融级别可靠性     |
| 异步刷盘       | 消息先写入内存，异步写入磁盘        | 性能好             | 极端情况可能丢失消息      | 一般业务场景      |
| 主从复制       | 主节点同步消息到从节点           | 高可用             | 网络开销            | 高可用要求       |
| 手动ACK      | 消费者处理完业务逻辑后手动确认       | 确保消息被正确处理       | 需要处理重复消息        | 所有重要业务      |

#### 4. 如何保证消息不被重复消费（幂等性）？

**重复消费产生原因：**
- 网络抖动导致ACK丢失
- 消费者重启导致消息重新投递
- Broker故障恢复后重新发送消息

**幂等性保障方案：**

| 方案         | 实现原理              | 优点              | 缺点              | 适用场景          |
| ---------- | ----------------- | --------------- | --------------- | ------------- |
| 唯一ID去重    | 每条消息携带唯一标识        | 简单有效            | 需要存储已处理ID       | 通用场景          |
| 数据库唯一约束   | 利用数据库唯一索引        | 实现简单            | 依赖数据库           | 数据库操作为主的业务    |
| Redis去重    | 使用Redis存储消息ID     | 性能好             | 需要额外的Redis实例    | 高性能要求         |
| 状态机控制     | 通过业务状态判断是否已处理     | 业务语义明确          | 业务逻辑复杂          | 有明确状态的业务流程    |
| 业务逻辑幂等    | 设计天然幂等的业务逻辑       | 无额外开销           | 并非所有业务都能实现      | 查询类操作         |

**实现示例对比：**

| 业务场景       | 推荐方案        | 实现方式                        | 注意事项              |
| ---------- | ----------- | --------------------------- | ----------------- |
| 账户扣款       | 数据库唯一约束     | 订单号作为唯一约束                   | 避免重复扣款            |
| 发送邮件       | Redis去重     | 消息ID作为Redis key              | 设置合理的过期时间         |
| 数据同步       | 状态机控制       | 检查目标数据是否已存在                 | 处理并发更新问题          |
| 积分增加       | 业务逻辑幂等      | 使用CAS操作更新积分                 | 处理ABA问题           |

#### 5. 如何保证消息的顺序性？

**顺序性需求分析：**

| 顺序性类型    | 定义              | 实现难度 | 性能影响 | 适用场景              |
| -------- | --------------- | ---- | ---- | ----------------- |
| 全局有序     | 所有消息严格按时间顺序处理   | 高    | 大    | 金融交易、账务流水         |
| 分区有序     | 同一分区内消息有序       | 中    | 小    | 同一用户的操作序列         |
| 局部有序     | 特定业务场景下的消息有序    | 低    | 无    | 单个订单的状态变更流程       |

**实现方案对比：**

| 方案         | 实现方式                    | 优点       | 缺点           | 性能影响      |
| ---------- | ----------------------- | -------- | ------------ | --------- |
| 单队列单消费者   | 只使用一个队列和一个消费者           | 严格有序     | 性能瓶颈、无法扩展    | 性能最差      |
| 分区有序      | 相同Key的消息发送到同一分区        | 平衡性能与顺序  | 分区内有序、全局无序   | 性能较好      |
| 消息队列顺序    | 业务层面保证同类消息的顺序处理         | 业务灵活性高   | 实现复杂         | 性能影响小     |
| 时间戳排序     | 消费者根据时间戳重新排序            | 全局有序     | 延迟高、内存占用大    | 延迟增加      |

**技术选型建议：**

| 业务场景           | 推荐方案      | 理由                    | 实现要点              |
| -------------- | --------- | --------------------- | ----------------- |
| 股票交易           | 单队列单消费者   | 严格时序要求                | 可以牺牲性能保证正确性       |
| 用户操作日志         | 分区有序      | 同一用户操作需要有序            | 以用户ID作为分区Key      |
| 订单状态流转         | 消息队列顺序    | 只需要同一订单内有序            | 以订单ID作为分组         |
| 系统日志收集         | 无需严格顺序    | 日志分析不严格依赖顺序           | 优先考虑性能和吞吐量        |

### 技术选型

#### 6. 常用消息队列比较？（Kafka、RabbitMQ、RocketMQ）

**核心特性对比：**

| 特性         | Kafka            | RabbitMQ         | RocketMQ         |
| ---------- | ---------------- | ---------------- | ---------------- |
| 开发语言       | Scala/Java       | Erlang           | Java             |
| 性能         | 极高（百万级/秒）        | 高（万级/秒）          | 高（十万级/秒）         |
| 可靠性        | 高                | 极高               | 高                |
| 功能丰富度      | 基础               | 丰富               | 丰富               |
| 运维复杂度      | 中等               | 简单               | 中等               |
| 社区活跃度      | 极高               | 高                | 中等               |
| 企业支持       | Apache基金会       | VMware           | 阿里巴巴             |

**详细功能对比：**

| 功能           | Kafka      | RabbitMQ     | RocketMQ     |
| ------------ | ---------- | ------------ | ------------ |
| 消息顺序性        | 分区有序       | 队列有序         | 分区有序         |
| 消息路由         | 简单         | 灵活强大         | 丰富           |
| 消息过滤         | 不支持        | 支持           | 支持           |
| 死信队列         | 不支持        | 支持           | 支持           |
| 延时消息         | 不支持        | 插件支持         | 原生支持         |
| 事务消息         | 0.11版本后支持   | 支持           | 支持           |
| 消息重试         | 不支持        | 支持           | 支持           |
| 集群部署         | 原生支持       | 支持           | 支持           |

**适用场景推荐：**

| 使用场景           | 推荐MQ     | 选择理由                      | 注意事项              |
| -------------- | --------- | ------------------------- | ----------------- |
| 日志收集、大数据处理     | Kafka     | 超高吞吐量、水平扩展能力强             | 功能相对简单，需要自己实现一些特性 |
| 企业级应用、复杂路由     | RabbitMQ  | 功能丰富、可靠性高、运维简单            | 性能相对较低            |
| 电商、金融等业务系统     | RocketMQ  | 功能全面、性能好、专门为业务场景设计        | 社区相对较小            |
| 微服务间通信         | RabbitMQ  | 消息路由灵活、支持多种协议             | 需要考虑消息积压问题        |
| 实时数据流处理        | Kafka     | 低延迟、高吞吐、与大数据生态集成好         | 不适合复杂的业务逻辑处理      |
| 订单处理、支付系统      | RocketMQ  | 事务消息、顺序消息、高可靠性            | 运维复杂度相对较高         |

**技术选型决策矩阵：**

| 权重因子     | Kafka | RabbitMQ | RocketMQ | 说明              |
| -------- | ----- | -------- | -------- | --------------- |
| 性能要求（30%） | 10    | 7        | 8        | Kafka性能最强       |
| 功能丰富度（25%） | 6     | 9        | 9        | RabbitMQ功能最全     |
| 可靠性（20%）  | 8     | 10       | 9        | RabbitMQ可靠性最佳    |
| 运维难度（15%） | 7     | 9        | 7        | RabbitMQ最易运维     |
| 社区支持（10%） | 10    | 8        | 6        | Kafka社区最活跃      |
| **总分**     | **8.1** | **8.6**  | **8.0**  | RabbitMQ综合评分最高  |

## 主流框架、系统设计、编码能力

### Spring框架

#### 1. Spring方向 - (IoC - 控制反转 / DI - 依赖注入, AOP - 面向切面编程)

**IoC（控制反转）核心概念：**

| 概念      | 定义                        | 传统方式           | IoC方式           | 优势              |
| ------- | ------------------------- | -------------- | --------------- | --------------- |
| 控制反转    | 对象创建控制权从程序代码转移到外部容器       | 程序主动创建依赖对象     | 容器创建并注入对象       | 降低耦合度、提高可测试性    |
| 依赖注入    | 容器负责将依赖的对象注入到需要的地方        | new 关键字创建对象    | @Autowired等注解注入 | 自动装配、配置灵活       |
| 容器管理    | Spring容器负责对象的生命周期管理       | 手动管理对象生命周期     | 容器自动管理          | 减少内存泄漏、提高性能     |

**DI依赖注入方式对比：**

| 注入方式   | 实现方式           | 优点           | 缺点           | 适用场景        |
| ------ | -------------- | ------------ | ------------ | ----------- |
| 构造器注入  | 通过构造函数参数注入     | 强制依赖、不可变对象   | 构造函数参数可能过多   | 必需依赖        |
| Setter注入 | 通过setter方法注入   | 可选依赖、灵活配置    | 可能忘记注入某些依赖   | 可选依赖        |
| 字段注入   | 直接在字段上使用@Autowired | 代码简洁         | 难以测试、违反封装性   | 快速开发        |

#### 2. AOP (面向切面编程)

**AOP核心概念：**

| 概念        | 定义                    | 作用                | 示例                  |
| --------- | --------------------- | ----------------- | ------------------- |
| 切面(Aspect) | 横切关注点的模块化             | 封装横切逻辑            | 日志切面、事务切面           |
| 连接点(JoinPoint) | 程序执行过程中能够插入切面的点       | 定义切入位置            | 方法调用、异常抛出           |
| 切入点(Pointcut) | 匹配连接点的表达式             | 定义在哪些地方切入         | execution(* com.*.*(..)) |
| 通知(Advice) | 在切入点执行的代码             | 定义切入后做什么          | @Before、@After        |
| 织入(Weaving) | 将切面应用到目标对象的过程         | 实现AOP功能           | 编译时、类加载时、运行时        |

**Spring AOP实现方式：**

| 实现方式     | 原理              | 优点           | 缺点              | 适用场景        |
| -------- | --------------- | ------------ | --------------- | ----------- |
| JDK动态代理  | 基于接口的代理         | 标准JDK实现      | 只能代理接口          | 有接口的类       |
| CGLIB代理  | 基于继承的代理         | 可以代理普通类      | 不能代理final类和方法  | 没有接口的类      |
| AspectJ   | 编译时织入           | 性能好、功能强      | 需要特殊编译器         | 高性能要求       |

**常用通知类型：**

| 通知类型        | 执行时机       | 使用场景           | 示例代码               |
| ----------- | ---------- | -------------- | ------------------ |
| @Before     | 方法执行前      | 参数校验、权限检查      | 记录方法调用参数           |
| @After      | 方法执行后      | 资源清理、日志记录      | 记录方法执行时间           |
| @AfterReturning | 方法正常返回后    | 结果处理、成功日志      | 记录方法返回值            |
| @AfterThrowing | 方法抛异常后     | 异常处理、错误日志      | 记录异常信息             |
| @Around     | 方法执行前后     | 性能监控、事务控制      | 计算方法执行时间           |

#### 3. Spring事务管理

**事务传播行为：**

| 传播行为           | 行为描述                     | 使用场景              | 风险提示            |
| -------------- | ------------------------ | ----------------- | --------------- |
| REQUIRED       | 有事务就加入，没有就新建           | 最常用的传播行为          | 无                |
| REQUIRES_NEW   | 总是新建事务                   | 需要独立事务的操作         | 可能导致死锁          |
| SUPPORTS       | 有事务就加入，没有就非事务执行        | 查询操作              | 数据一致性问题         |
| NOT_SUPPORTED  | 总是非事务执行                  | 纯查询操作             | 不支持事务回滚         |
| MANDATORY      | 必须在事务中执行                 | 强制事务的业务逻辑         | 没有事务会抛异常        |
| NEVER          | 不能在事务中执行                 | 不能有事务的操作          | 有事务会抛异常         |
| NESTED         | 嵌套事务                     | 部分回滚场景            | 依赖数据库支持         |

**事务隔离级别：**

| 隔离级别               | Spring常量              | 解决问题       | 性能影响 | 适用场景        |
| ------------------ | --------------------- | ---------- | ---- | ----------- |
| READ_UNCOMMITTED   | ISOLATION_READ_UNCOMMITTED | 无          | 最高   | 对一致性要求极低    |
| READ_COMMITTED     | ISOLATION_READ_COMMITTED | 脏读         | 高    | 一般业务场景      |
| REPEATABLE_READ    | ISOLATION_REPEATABLE_READ | 脏读、不可重复读   | 中    | 默认级别，推荐使用   |
| SERIALIZABLE       | ISOLATION_SERIALIZABLE | 脏读、不可重复读、幻读 | 最低   | 对一致性要求极高    |

#### 4. Spring MVC的工作原理？核心组件？处理请求的流程？

**Spring MVC核心组件：**

| 组件              | 作用                    | 核心功能                      | 配置方式            |
| --------------- | --------------------- | ------------------------- | --------------- |
| DispatcherServlet | 前端控制器，统一调度请求          | 请求分发、异常处理、视图渲染            | web.xml或Java配置  |
| HandlerMapping  | 处理器映射器，找到处理请求的Controller | URL映射、RESTful路由           | @RequestMapping |
| HandlerAdapter  | 处理器适配器，调用具体的处理方法      | 参数解析、返回值处理                | 自动配置            |
| ViewResolver    | 视图解析器，解析逻辑视图名         | 视图路径解析、模板引擎集成             | 配置文件            |

**请求处理流程：**

| 步骤  | 组件              | 具体操作                        | 数据流转              |
| --- | --------------- | --------------------------- | ----------------- |
| 1   | DispatcherServlet | 接收HTTP请求                   | HttpServletRequest |
| 2   | HandlerMapping  | 根据URL找到对应的Controller和方法     | HandlerExecutionChain |
| 3   | HandlerAdapter  | 调用Controller方法，处理业务逻辑      | ModelAndView      |
| 4   | ViewResolver    | 解析逻辑视图名，找到具体视图模板          | View对象           |
| 5   | View            | 渲染视图，生成HTML响应              | HttpServletResponse |

### MyBatis

#### 5.1 一级缓存和二级缓存的区别？

**缓存级别对比：**

| 特性       | 一级缓存（SqlSession级别）     | 二级缓存（Mapper级别）         |
| -------- | ----------------------- | ----------------------- |
| 作用域      | 单个SqlSession            | 同一个Mapper的所有SqlSession |
| 生命周期     | SqlSession关闭时失效         | 应用程序关闭时失效             |
| 默认开启     | 默认开启                    | 需要手动开启                |
| 共享性      | 不共享                     | 多个SqlSession共享         |
| 清空时机     | commit/rollback/close    | 手动清空或配置自动清空           |
| 存储位置     | SqlSession内存             | 可配置多种存储方式             |

**缓存配置和使用：**

| 配置项目     | 一级缓存          | 二级缓存                      |
| -------- | ------------- | ------------------------- |
| 开启方式     | 无需配置，默认开启     | @CacheNamespace或<cache>   |
| 失效策略     | 自动失效          | LRU、FIFO、SOFT、WEAK       |
| 刷新策略     | 增删改操作自动清空     | 可配置flushInterval         |
| 序列化要求    | 无             | 实体类需实现Serializable接口     |

#### 5.2 ResultMap 和 ResultType 的区别？

**使用场景对比：**

| 特性       | ResultType          | ResultMap              |
| -------- | ------------------- | ---------------------- |
| 适用场景     | 简单映射、字段名一致          | 复杂映射、字段名不一致、关联查询       |
| 配置复杂度    | 简单                  | 复杂                     |
| 映射方式     | 自动映射                | 手动配置映射关系               |
| 性能       | 较好                  | 略差（需要解析配置）             |
| 功能       | 基础功能                | 支持嵌套、关联、继承等高级功能        |
| 维护成本     | 低                   | 高                      |

**选择建议：**

| 场景                | 推荐方案        | 原因                    |
| ----------------- | ----------- | --------------------- |
| 简单POJO映射          | ResultType  | 配置简单，性能好              |
| 字段名与属性名不一致        | ResultMap   | 需要手动映射                |
| 一对一、一对多关联查询       | ResultMap   | 支持嵌套映射                |
| 需要类型转换            | ResultMap   | 支持TypeHandler         |
| 继承关系映射            | ResultMap   | 支持继承和多态               |

#### 5.3 延迟加载（懒加载）的原理和配置？

**延迟加载机制：**

| 概念      | 定义                | 优点           | 缺点              | 适用场景        |
| ------- | ----------------- | ------------ | --------------- | ----------- |
| 延迟加载    | 关联对象在真正使用时才加载     | 提高性能、减少内存占用  | 可能产生N+1问题      | 大对象关联       |
| 立即加载    | 查询时一次性加载所有关联对象    | 减少数据库访问次数    | 可能加载不需要的数据    | 小对象关联       |

**配置方式：**

| 配置级别   | 配置位置         | 配置项                    | 说明                |
| ------ | ------------ | ---------------------- | ----------------- |
| 全局配置   | mybatis-config.xml | lazyLoadingEnabled=true | 全局开启延迟加载          |
| 局部配置   | ResultMap    | fetchType="lazy/eager" | 针对特定关联配置          |
| 方法级配置  | @Select等注解  | fetchType属性           | 注解方式配置            |

#### 5.4 如何实现分页？

**分页实现方案对比：**

| 方案           | 实现原理            | 优点           | 缺点              | 适用场景        |
| ------------ | --------------- | ------------ | --------------- | ----------- |
| RowBounds内存分页 | 查询所有数据后在内存中分页   | 实现简单         | 性能差、内存占用大       | 小数据量        |
| PageHelper物理分页 | 自动改写SQL添加LIMIT  | 性能好、使用简单     | 依赖插件            | 大数据量、生产环境   |
| 手写SQL分页      | 手动编写带LIMIT的SQL  | 性能最好、可控性强    | 开发复杂、维护成本高      | 复杂查询场景      |

**PageHelper使用示例：**

| 使用方式       | 代码示例                          | 说明                |
| ---------- | ----------------------------- | ----------------- |
| 方法调用       | PageHelper.startPage(1, 10)   | 在查询前调用            |
| 注解方式       | @Select + @Options            | 注解配置分页参数          |
| 参数传递       | PageInfo<User> pageInfo       | 封装分页结果            |

### 系统设计

#### 6. 设计一个秒杀系统

**系统架构设计：**

| 层次     | 组件              | 作用                | 技术选型            | 关键指标          |
| ------ | --------------- | ----------------- | --------------- | ------------- |
| 接入层    | CDN + 负载均衡       | 静态资源加速、流量分发       | Nginx、LVS      | QPS: 10万+     |
| 应用层    | 微服务集群           | 业务逻辑处理            | Spring Boot集群  | 响应时间: <100ms  |
| 缓存层    | Redis集群         | 热点数据缓存            | Redis Cluster   | 命中率: >95%     |
| 数据层    | MySQL主从         | 数据持久化             | MySQL 8.0      | TPS: 1万+      |
| 消息层    | 消息队列            | 异步处理、削峰填谷         | RocketMQ        | 吞吐量: 10万条/秒   |

**核心技术方案：**

| 技术挑战   | 解决方案                          | 实现方式                        | 效果评估            |
| ------ | ----------------------------- | --------------------------- | --------------- |
| 高并发读   | 多级缓存 + CDN                   | Redis + 本地缓存 + CDN静态化       | 减少99%数据库访问      |
| 库存扣减   | Redis Lua脚本                  | 原子性操作，避免超卖                | 100%准确性        |
| 流量削峰   | 消息队列异步处理                      | 秒杀请求先入队，异步处理订单              | 削峰90%           |
| 限流保护   | 令牌桶 + 熔断降级                   | Sentinel限流，超限返回友好提示         | 系统稳定性99.9%     |
| 数据一致性  | 分布式事务                         | Seata分布式事务，保证最终一致性          | 数据准确性100%      |

**Redis Lua脚本示例：**

| 功能       | 脚本逻辑                          | 优势              |
| -------- | ----------------------------- | --------------- |
| 库存扣减     | 检查库存 → 扣减库存 → 记录用户购买           | 原子性操作，避免超卖      |
| 防重复购买    | 检查用户购买记录 → 执行购买逻辑             | 避免重复下单          |
| 限流控制     | 检查请求频率 → 更新计数器               | 精确限流            |

### 编码能力

#### 7. 各类主流算法

**算法分类和重要性：**

| 算法类型   | 重要算法                    | 面试频率 | 难度等级 | 应用场景              |
| ------ | ----------------------- | ---- | ---- | ----------------- |
| 排序算法   | 快排、归并、堆排序               | ⭐⭐⭐⭐⭐ | 中等   | 数据排序、TopK问题       |
| 查找算法   | 二分查找、哈希查找               | ⭐⭐⭐⭐⭐ | 简单   | 数据检索、去重           |
| 动态规划   | 背包、最长子序列、路径问题           | ⭐⭐⭐⭐  | 困难   | 优化问题、计数问题         |
| 图算法    | DFS、BFS、最短路径            | ⭐⭐⭐   | 中等   | 社交网络、路径规划         |
| 树算法    | 二叉树遍历、平衡树、字典树           | ⭐⭐⭐⭐  | 中等   | 数据结构、搜索引擎         |
| 贪心算法   | 区间调度、最小生成树              | ⭐⭐⭐   | 中等   | 资源分配、网络优化         |

**面试常考算法题型：**

| 题型        | 典型例题                    | 解题思路                | 时间复杂度        |
| --------- | ----------------------- | ------------------- | ------------ |
| 数组双指针    | 两数之和、三数之和               | 排序+双指针移动            | O(n) - O(n²)  |
| 链表操作     | 反转链表、环形链表检测             | 快慢指针、递归             | O(n)         |
| 二叉树递归    | 最大深度、路径和                | 递归分治                | O(n)         |
| 动态规划     | 爬楼梯、最大子数组和              | 状态转移方程              | O(n) - O(n²)  |
| 回溯算法     | 全排列、N皇后问题               | 递归+回溯               | O(n!)        |
| 滑动窗口     | 最长无重复子串                 | 窗口扩展和收缩             | O(n)         |
