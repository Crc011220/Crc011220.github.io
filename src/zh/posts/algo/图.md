---
icon: pen-to-square
date: 2025-05-22
category:
  - Learning Records
tag:
  - Algorithm
---

# 图

## 图的种类
- 有向图
- 无向图
- 加权图

## 度
- 度：一个顶点的度是与该顶点相关联的边的条数
- 入度：有向图中，有多少边指向该节点
- 出度：有向图中，该节点指向了多少边

## 图的存储
- 连通图：在无向图中，任何两个节点都是可以到达的，我们称之为连通图
- 强连通图：在有向图中，任何两个节点是可以相互到达的，我们称之为强连通图

## 图的表示
- 邻接矩阵：是图的另一种表示方式，它是一个二维数组，其中每个元素表示两个节点之间是否有边。
    - 表达方式简单，易于理解
    - 检查任意两个顶点间是否存在边的操作非常快
    - 适合稠密图，在边数接近顶点数平方的图中，邻接矩阵是一种空间效率较高的表示方法。
    - 遇到稀疏图，会导致申请过大的二维数组造成空间浪费 且遍历 边 的时候需要遍历整个n * n矩阵，造成时间浪费

- 邻接表：是图的另一种表示方式，它是一个链表，其中每个节点表示一个顶点，每个节点包含一个指向其他节点的指针。
    - 对于稀疏图的存储，只需要存储边，空间利用率高
    - 遍历节点连接情况相对容易
    - 检查任意两个节点间是否存在边，效率相对低，需要 O(V)时间，V表示某节点连接其他节点的数量。
    - 实现相对复杂，不易理解

## 图的遍历
- 深度优先搜索
- 广度优先搜索

### 深度优先搜索
``` psudocode
void dfs(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本节点所连接的其他节点) {
        处理节点;
        dfs(图，选择的节点); // 递归
        回溯，撤销处理结果
    }
}
```

### 广度优先搜索
- 需要借用一个辅助数据结构即队列来实现，队列先进先出，符合一层一层遍历的逻辑。
- 需要一个visited数组防止重复访问，加入队列后立马标记为已访问。
``` java
public class Solution {
    // 四个方向：右、下、上、左
    private static final int[][] DIRECTIONS = {
        {0, 1}, {1, 0}, {-1, 0}, {0, -1}
    };

    public void bfs(char[][] grid, boolean[][] visited, int startX, int startY) {
        int m = grid.length; // 行
        int n = grid[0].length; // 列

        Queue<int[]> queue = new LinkedList<>(); // 队列 int[] 表示坐标
        queue.offer(new int[]{startX, startY}); // 起点坐标入队
        visited[startX][startY] = true; // 标记起点已访问

        while (!queue.isEmpty()) {
            int[] current = queue.poll(); // 取出当前节点并出队
            int curX = current[0]; // 当前节点x坐标
            int curY = current[1]; // 当前节点y坐标

            for (int[] dir : DIRECTIONS) {
                int nextX = curX + dir[0]; // 下一个节点x坐标
                int nextY = curY + dir[1]; // 下一个节点y坐标

                // 越界检查
                if (nextX < 0 || nextX >= m || nextY < 0 || nextY >= n) continue; // 越界，跳过这次
                // 是否访问过
                if (!visited[nextX][nextY]) {
                    queue.offer(new int[]{nextX, nextY}); // 下一个节点入队
                    visited[nextX][nextY] = true; // 标记下一个节点已访问
                }
            }
        }
    }
}

```

## 岛屿问题
### 岛屿数量
#### DFS
- 如果没有访问过并且该节点为陆地，则以该节点为起点进行DFS，将该节点标记为已访问，并递归访问该节点的上下左右四个方向的节点。
- 在DFS过程中，遍历上下左右四个节点，如果没有被访问过并且是陆地，则继续DFS，直到所有陆地都被访问过。如果遇到边界或者水域，则跳过该次循环。
#### BFS
- 使用队列，参考广度优先搜索的代码，将当前节点加入队列，并标记为已访问。然后遍历当前节点的上下左右四个方向的节点，如果没有被访问过并且是陆地，则继续加入队列，并标记为已访问。直到所有陆地都被访问过。如果遇到边界或者水域，则跳过该次循环。
```java
class Solution {
    public static int[][] dir = {{0,1}, {1,0}, {-1,0}, {0,-1}};

    public int numIslands(char[][] grid) {
        if (grid == null || grid.length == 0) return 0;

        int m = grid.length;
        int n = grid[0].length;
        boolean[][] visited = new boolean[m][n];
        int count = 0;

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (!visited[i][j] && grid[i][j] == '1') {
                    dfs(grid, visited, i, j);
                    count++;
                }
            }
        }

        return count;
    }

    private void dfs(char[][] grid, boolean[][] visited, int x, int y) {
        for (int i = 0; i < 4; i++) {
            int nextX = x + dir[i][0];
            int nextY = y + dir[i][1];

            if (nextX < 0 || nextY < 0 || nextX >= grid.length || nextY >= grid[0].length)
                continue;

            if (!visited[nextX][nextY] && grid[nextX][nextY] == '1') {
                dfs(grid, visited, nextX, nextY);
                visited[nextX][nextY] = true;
            }
        }
    }

    private void bfs(char[][] grid, boolean[][] visited, int x, int y) {
        Queue<int[]> q = new LinkedList<>();
        q.offer(new int[]{x,y});
        visited[x][y] = true;

        while(!q.isEmpty()){
            int[] cur = q.poll();
            int curX = cur[0];
            int curY = cur[1];

            for(int[] d:dir){
                int nextX = curX + d[0];
                int nextY = curY + d[1];

                if(nextX < 0 || nextX >= grid.length || nextY < 0 || nextY >= grid[0].length){
                    continue;
                }

                if(!visited[nextX][nextY] && grid[nextX][nextY] == '1'){
                    q.offer(new int[]{nextX, nextY});
                    visited[nextX][nextY] = true;
                }

            }
        }
    }
}
```

### 岛屿最大面积
- 面积是指陆地数量
- 使用DFS，在DFS过程中，记录当前陆地数量，并更新最大面积。最后取max(当前陆地数量, 最大面积)

### 岛屿周长
- 两次for循环遍历，不需要DFS和BFS
- 陆地周边是水或者边界，则周长加1
```java
class Solution {
    public int islandPerimeter(int[][] grid) {
        int[][] dir = {{0,1}, {1,0}, {-1,0}, {0,-1}};
        int res = 0;
        for(int i=0;i<grid.length;i++){
            for(int j=0;j<grid[0].length;j++){
                if(grid[i][j] == 1){
                    for (int[] d:dir){
                        int nextI = i+d[0];
                        int nextJ = j+d[1];
                        if(nextI<0 || nextJ<0 || nextI>=grid.length || nextJ>=grid[0].length || grid[nextI][nextJ] == 0){ // 越界或者水域，则周长加1
                            res++;
                        } 
                    }
                }
            }
        }
        return res;
    }
}
```
### 孤岛总面积
- 四周都是水才算孤岛，如果四周有边界，则不算孤岛
- 思路：
  - 把地图边缘的陆地，以及他们相邻的陆地，全部变成水域0
  - 然后遍历地图，计算陆地数量


### 沉没孤岛
- 把孤岛变成水域，四周都是水才算孤岛
- 地图边缘的陆地不是孤岛
- 返回整个grid
- 思路：
  - 标记地图边缘的陆地，以及他们相邻的陆地，全部变成2
  - 遍历地图，把所有非0的地方减去1。2变成1，1变成0，0不变
  - 这样孤岛就变成了水域

### 水流问题 Pacific Atlantic Water Flow
- 从第一组边界上的节点 逆流而上，将遍历过的节点都标记上。
- 同样从第二组边界的边上节点 逆流而上，将遍历过的节点也标记上。
- 然后两方都标记过的节点就是既可以流向第一组边界也可以流向第二组边界的节点。

