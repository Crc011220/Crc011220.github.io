---
icon: pen-to-square
date: 2025-06-25
category:
  - Learning Records
tag:
  - Algorithm
---

# 贪心

## 跳跃游戏
```java
public boolean canJump(int[] nums) {
    if(nums.length ==1) return true;
    int coverRange = 0;
    for(int i=0; i<=coverRange; i++){ // 遍历coverRange，因为coverRange是当前可以跳跃的最大距离，所以遍历coverRange即可
        coverRange = Math.max(coverRange, i+nums[i]); // 站在第i个位置，最多可以跳nums[i]步
        if(coverRange >= nums.length-1) return true; // 如果coverRange >= nums.length-1（最后一个索引位置），则可以到达最后一个位置 
    }
    return false;
}
```

## 跳跃游戏II
```java
public int jump(int[] nums) {
    if(nums.length == 1) return 0;
    int current = 0; // 当前跳跃的步数
    int next = 0; // 下一步跳跃的最大距离
    int result = 0; // 结果

    for(int i = 0; i<nums.length-1;i++){
        next=Math.max(i+nums[i],next); // 站在第i个位置，最多可以跳nums[i]步
        if(i == current){ // 到达当前跳的边界，必须跳一次
            result ++; 
            current = next; // 更新当前边界到下一跳边界
            if(current >= nums.length - 1) break; // 已经能跳到最后，提前退出
        }
    }
    return result;
}
```

## 加油站
- 如果总油量小于总消耗量，则无法完成环路
```java
public int canCompleteCircuit(int[] gas, int[] cost) {
    int curSum = 0;       // 当前从起点到当前位置的净油量（局部判断）
    int totalSum = 0;     // 总体油量（全局判断）
    int index = 0;        // 可能的起始点

    for (int i = 0; i < gas.length; i++) {
        int gain = gas[i] - cost[i]; 
        curSum += gain;      // 当前路径净油
        totalSum += gain;    // 总体净油

        if (curSum < 0) { // 油不够了
            // 当前起点不行，说明从 index 到 i 之间都不能做起点
            index = i + 1;   // 更新起点为下一个
            curSum = 0;      // 重置局部净油
        }
    }
    // 如果总油量 < 总花费，无解，返回 -1。否则返回找到的起点。
    if (totalSum < 0) return -1;
    return index;
}
``` 

## 分发糖果
```java
/**
     分两个阶段
     1、起点下标1 从左往右，只要 右边 比 左边 大，右边的糖果=左边 + 1
     2、起点下标 ratings.length - 2 从右往左， 只要左边 比 右边 大，此时 左边的糖果应该 取本身的糖果数（符合比它左边大） 和 右边糖果数 + 1 二者的最大值，这样才符合 它比它左边的大，也比它右边大
*/
public int candy(int[] ratings) {
    int len = ratings.length;
    int[] candyVec = new int[len];
    candyVec[0] = 1;
    for (int i = 1; i < len; i++) {
        // 处理了「比左边高」的所有情况
        // 如果当前 ratings[i] > ratings[i - 1]，说明你比左边分高 → 糖果也得多：+1
        // 否则（等于或更小），给 1 就行
        candyVec[i] = (ratings[i] > ratings[i - 1]) ? candyVec[i - 1] + 1 : 1;
    }
    for (int i = len - 2; i >= 0; i--) { // len-2 是因为从倒数第二个开始处理 因为倒数第一个没有右边邻居
        // 处理了「比右边高」的所有情况
        // 注意：不能直接赋值为 candyVec[i + 1] + 1，因为可能左边也已经给了一个较大的值（从前面那一轮）
        // 所以取最大值：candyVec[i] = max(原有值, candyVec[i+1] + 1)
        if (ratings[i] > ratings[i + 1]) {
            candyVec[i] = Math.max(candyVec[i], candyVec[i + 1] + 1);
        }
    }
    int ans = 0;
    for (int num : candyVec) {
        ans += num;
    }
    return ans;
}
```