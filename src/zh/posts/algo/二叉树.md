---
icon: pen-to-square
date: 2025-05-27
category:
  - Learning Records
tag:
  - Algorithm
---
# 二叉树

## 二叉树的中序遍历
- 左中右
```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        inorder(root, result);
        return result;
    }

    private void inorder(TreeNode root, List<Integer> result) {
        if (root == null) {
            return;
        }
        inorder(root.left, result);
        result.add(root.val);
        inorder(root.right, result);
    }
}
```

## 验证BST
- 简单解法：中序遍历的结果放到一个新数组，看是不是单调递增，是的话就是BST
- 可以不用数组保存：
    - 用一个变量 prev 记录上一个访问过的节点的值
    - 每访问一个节点时，比较它的值是否比 prev 大（必须严格递增）
    - 如果发现不满足，直接返回 false
    - 如果遍历完所有节点都满足，则返回 true
```java
class Solution {
    private long prev = Long.MIN_VALUE;
    public boolean isValidBST(TreeNode root) {
        if (root == null) {
            return true;
        }
        if (!isValidBST(root.left)) {
            return false;
        }

        if (root.val <= prev) { // 遍历的前一个节点大于等于当前节点，无法满足BST。不能等于因为BST的节点值不能重复
            return false;
        }
        prev = root.val;

        return isValidBST(root.right);
    }
}
```

## 恢复BST
- BST刚好有两个节点被交换了，恢复BST
- 中序遍历的结果是单调递增的，所以如果发现两个节点不满足单调递增，就是被交换了
- 用两个变量记录这两个节点，然后交换它们的值
```java
class Solution {
    private TreeNode prev = null;
    private TreeNode first = null;
    private TreeNode second = null;
    public void recoverTree(TreeNode root) {
        recover(root);
        if (first != null && second != null) {
            int temp = first.val;
            first.val = second.val;
            second.val = temp;
        }
    }

    private void recover(TreeNode root){
        if (root == null) return;
        recover(root.left);
        // 当前节点值小于前一个节点值，说明出错了（中序遍历应该是升序）
        if(prev!=null && root.val<prev.val){
            // 第一次发现逆序对，记录前一个较大节点为 first，当前较小为 second
            if(first==null){
                first = prev;
                second = root;
                // 第二次逆序对更新 second（例如：两个错位节点不相邻）
            } else{
                second = root;
            }
        }
        prev = root;
        recover(root.right);
    }
}
```

## 判断两颗二叉树是否相同
- 前序遍历 中左右
```java
class Solution {
    public boolean isSameTree(TreeNode p, TreeNode q) {
        if (p == null && q == null) return true;
        if (p == null || q == null) return false; // 一个为空，一个不为空，false
        if (p.val != q.val) return false; // 值不相等，false
        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right); // 递归判断左右子树
    }
}
```

## 判断两颗二叉树是否对称
- 前序遍历 中右左
```java
class Solution {
    public boolean isSymmetric(TreeNode root) {
        if (root == null) return true;
        return preOrder(root.left, root.right);
    }
    private boolean preOrder(TreeNode left, TreeNode right){
        if (left == null && right == null) return true;
        if (left == null || right == null) return false;
        if(left.val != right.val) return false;
        return preOrder(left.left,right.right) && preOrder(left.right,right.left);
    }
}
```

## 二叉树层序遍历
- 广度优先遍历
- 需要借用一个辅助数据结构即队列来实现，队列先进先出，符合一层一层遍历的逻辑
- 每一层遍历完，需要将队列中的元素出队，并将其左右子节点入队
```java
class Solution {
    public List<List<Integer>> resList = new ArrayList<List<Integer>>();
    public List<List<Integer>> levelOrder(TreeNode root) {
        bfs(root);
        return resList;
    }
    //BFS--迭代方式--借助队列
    public void bfs(TreeNode node) {
        if (node == null) return;
        Queue<TreeNode> que = new LinkedList<TreeNode>(); 
        que.offer(node); // 根节点入队

        while (!que.isEmpty()) {
            List<Integer> itemList = new ArrayList<Integer>(); // 记录每层的节点值
            int len = que.size(); // 记录每层的节点数

            while (len > 0) { // 遍历当前层节点
                TreeNode tmpNode = que.poll(); // 当前层节点出队
                itemList.add(tmpNode.val); // 记录当前层节点值

                if (tmpNode.left != null) que.offer(tmpNode.left); // 下一层左子节点入队
                if (tmpNode.right != null) que.offer(tmpNode.right); // 下一层右子节点入队
                len--; // 当前层节点数减1
            }
            resList.add(itemList); // 记录当前层节点值
        }
    }
}
```

## 二叉树的右视图
- BFS层序遍历，然后找到每层最后一个节点
```java
class Solution {
    public List<Integer> resList = new ArrayList<>();
    public List<Integer> rightSideView(TreeNode root) {
        bfs(root);
        return resList;
    }
    public void bfs(TreeNode node){
        if (node == null) return;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(node);
        while (!queue.isEmpty()){
            int len = queue.size();
            while (len > 0){
                TreeNode tmpNode = queue.poll();
                if (tmpNode.left != null) queue.offer(tmpNode.left);
                if (tmpNode.right != null) queue.offer(tmpNode.right);
                len--;
                if (len == 0) resList.add(tmpNode.val); // 当前层最后一个节点
            }
        }
    }
}
```
## 二叉树的最近公共祖先 
- 自底向上查找就好了，这样就可以找到公共祖先了
- 后序遍历 左右中
```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root == null || root == p || root == q) return root; // 终止条件：遇到 null 或遇到 p/q 本身，直接返回

        TreeNode left = lowestCommonAncestor(root.left, p, q);
        TreeNode right = lowestCommonAncestor(root.right, p, q);
        if(left == null && right == null) { // 若未找到节点 p 或 q
            return null;
        }else if(left == null && right != null) { // 若找到一个节点 右子树
            return right;
        }else if(left != null && right == null) { // 若找到一个节点 左子树
            return left;
        }else { // 若找到两个节点
            return root;
        }
    }
}
```

## 二叉搜索树的最近公共祖先 
- 利用BST的性质，左子树的值都小于根节点，右子树的值都大于根节点
- 如果p和q的值都小于根节点，则它们的公共祖先在左子树
- 如果p和q的值都大于根节点，则它们的公共祖先在右子树
- 如果p和q的值一个大于根节点，一个小于根节点，则它们的公共祖先就是根节点
```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if (root == null) return null;
        if (root.val > p.val && root.val > q.val) {
            return lowestCommonAncestor(root.left, p, q);
        } else if (root.val < p.val && root.val < q.val) {
            return lowestCommonAncestor(root.right, p, q);
        } else {
            return root;
        }
    }
}
```

## 二叉树的最大深度
- max(left, right) + 1

## 翻转二叉树
```java
public TreeNode invertTree(TreeNode root) {
    if (root == null) return null;
    TreeNode left = invertTree(root.left);
    TreeNode right = invertTree(root.right);
    root.left = right;
    root.right = left;
    return root;
}
```

## 从前序与中序遍历序列构造二叉树
- 前序遍历的第一个元素 一定是整棵树的根
- 在中序遍历中，根左边的是左子树，右边的是右子树
- 所以前序确定“谁是根”，中序确定“左右子树范围”
```java
class Solution {
    private Map<Integer, Integer> indexMap;

    public TreeNode buildTree(int[] preorder, int[] inorder) {
        int n = preorder.length;
        // 构造哈希映射，帮助我们快速定位根节点
        indexMap = new HashMap<Integer, Integer>();
        for (int i = 0; i < n; i++) {
            indexMap.put(inorder[i], i); // 存放中序遍历的值和索引
        }
        return myBuildTree(preorder, inorder, 0, n - 1, 0, n - 1);
    }

    public TreeNode myBuildTree(int[] preorder, int[] inorder, int preorder_left, int preorder_right, int inorder_left, int inorder_right) {
        if (preorder_left > preorder_right) { // 当前递归范围内没有任何节点了，所以返回 null
            return null;
        }

        // 前序遍历中的第一个节点就是根节点
        int preorder_root = preorder_left;
        // 在中序遍历中定位根节点
        int inorder_root = indexMap.get(preorder[preorder_root]);
        
        // 先把根节点建立出来
        TreeNode root = new TreeNode(preorder[preorder_root]);
        // 得到左子树中的节点数目 用于划分前序遍历中的左右子树区间
        int size_left_subtree = inorder_root - inorder_left;

        // 递归地构造左子树，并连接到根节点
        // 先序遍历中「从 左边界+1 开始的 size_left_subtree」个元素就对应了中序遍历中「从 左边界 开始到 根节点定位-1」的元素
        root.left = myBuildTree(preorder, inorder, preorder_left + 1, preorder_left + size_left_subtree, inorder_left, inorder_root - 1);

        // 递归地构造右子树，并连接到根节点
        // 先序遍历中「从 左边界+1+左子树节点数目 开始到 右边界」的元素就对应了中序遍历中「从 根节点定位+1 到 右边界」的元素
        root.right = myBuildTree(preorder, inorder, preorder_left + size_left_subtree + 1, preorder_right, inorder_root + 1, inorder_right);

        return root;
    }
}
```
## 从中序与后序遍历序列构造二叉树
- 后序遍历的最后一个元素 一定是整棵树的根
- 在中序遍历中，根左边的是左子树，右边的是右子树
- 所以后序确定“谁是根”，中序确定“左右子树范围”
```java
class Solution {
    private Map<Integer, Integer> indexMap; // 用于快速查找中序中节点位置

    public TreeNode buildTree(int[] inorder, int[] postorder) {
        int n = inorder.length;
        indexMap = new HashMap<>();
        for (int i = 0; i < n; i++) {
            indexMap.put(inorder[i], i);
        }
        return build(inorder, postorder, 0, n - 1, 0, n - 1);
    }

    private TreeNode build(int[] inorder, int[] postorder,
                           int in_left, int in_right,
                           int post_left, int post_right) {
        if (in_left > in_right) { // 当前递归范围内没有任何节点了，所以返回 null
            return null;
        }

        // 后序遍历的最后一个节点是根节点
        int rootVal = postorder[post_right];
        TreeNode root = new TreeNode(rootVal);

        // 在中序遍历中定位根节点
        int index = indexMap.get(rootVal);

        // 左子树节点数
        int leftSize = index - in_left;

        // 构建左子树
        root.left = build(inorder, postorder,
                          in_left, index - 1,
                          post_left, post_left + leftSize - 1);

        // 构建右子树
        root.right = build(inorder, postorder,
                           index + 1, in_right,
                           post_left + leftSize, post_right - 1);

        return root;
    }
}
```

## 填充每个节点的下一个右侧节点指针II
- 第一种方法：队列层序遍历
- 第二种方法：用next指针遍历每一层 O(1)空间
    - `curr`：指向当前正在处理的一层的节点（从 root 开始）
    - `dummy`：一个假头节点，**用于构造下一层的链表**
    - `dummy.next`：每次处理完当前层后，这里就是“下一层的起始节点”
    - 外层 `while (curr != null)`：一层一层处理
    - 内层 `while (curr != null)`：处理当前层所有节点
```java
public Node connect(Node root) {
    Node dummy = new Node(0); // 每层起始点
    Node curr = root;         // 当前遍历层
    while (curr != null) {
        Node pre = dummy;     // “缝针”的指针，一开始从 dummy 开始
        dummy.next = null;    // 清空上一层构造的“下一层起始点
        
        while (curr != null) { // 遍历当前层节点
            if (curr.left != null) { // 连接左子节点
                pre.next = curr.left;
                pre = pre.next;
            }
            if (curr.right != null) { // 连接右子节点
                pre.next = curr.right;
                pre = pre.next;
            }
            curr = curr.next; // 同层右移
        }
        curr = dummy.next;    // 换到下一层
    }
    return root;
}
```

## 二叉树展开为链表
```java
public void flatten(TreeNode root) {
    TreeNode curr = root; // 当前节点
    while (curr != null) { // 遍历当前节点  
        if (curr.left != null) {
            TreeNode next = curr.left;
            TreeNode predecessor = next;
            while (predecessor.right != null) {
                predecessor = predecessor.right; // 找到左子树的最右节点
            }
            predecessor.right = curr.right; // 将右子树接到左子树的最右节点
            curr.left = null; // 断开左子树
            curr.right = next; // 将左子树接到当前节点
        }
        curr = curr.right;
    }
}
```

## 路经总和
```java
class Solution {
    public boolean hasPathSum(TreeNode root, int targetSum) {
        if (root == null) return false; // 如果当前节点为空，返回 false
        if (root.left == null && root.right == null) return root.val == targetSum; // 如果当前节点是叶子节点，判断路径和是否等于 targetSum
        return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val); // 递归判断左右子树
    }
}
```

## 求根节点到叶子节点数字之和
```java
public int sumNumbers(TreeNode root) {
    return dfs(root, 0);
}

public int dfs(TreeNode root, int prevSum) {
    if (root == null) return 0;  // 空节点不贡献数字，返回0
    int sum = prevSum * 10 + root.val;  // 计算当前路径数字（拼接数字）
    if (root.left == null && root.right == null) {  // 到叶子节点
        return sum;  // 返回这一条路径代表的数字
    } else {
        // 递归左子树和右子树路径和累加
        return dfs(root.left, sum) + dfs(root.right, sum);
    }
}
```

## 二叉树的最大路径和
```java
class Solution {
    int maxSum = Integer.MIN_VALUE;

    public int maxPathSum(TreeNode root) {
        maxGain(root);
        return maxSum;
    }

    public int maxGain(TreeNode node) {
        if (node == null) {
            return 0;
        }
        
        // 递归计算左右子节点的最大贡献值
        // 只有在最大贡献值大于 0 时，才会选取对应子节点
        int leftGain = Math.max(maxGain(node.left), 0);
        int rightGain = Math.max(maxGain(node.right), 0);

        // 节点的最大路径和取决于该节点的值与该节点的左右子节点的最大贡献值
        int priceNewpath = node.val + leftGain + rightGain;

        // 更新答案
        maxSum = Math.max(maxSum, priceNewpath);

        // 返回节点的最大贡献值
        // 递归 = 多层函数互相调用，每一层 return 给上层，上层继续。不是 return 一次就全部结束了。
        return node.val + Math.max(leftGain, rightGain);
    }
}
```