---
icon: pen-to-square
date: 2025-06-03
category:
  - Learning Records
tag:
  - Algorithm
---

# 数组

## 二分查找
- 明确区间，左闭右闭（包含left和right）还是左闭右开（不包含right）
- 左闭右闭：
    - 循环条件：left <= right
    - 更新条件：left = mid + 1, right = mid - 1
- 左闭右开：
    - 循环条件：left < right
    - 更新条件：left = mid + 1, right = mid

## 移除元素
- 快慢指针
- 快指针遍历数组，慢指针记录不重复的元素
- 快指针遍历完，慢指针就是不重复元素的个数
- 快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组
- 慢指针：指向更新 新数组下标的位置
- 返回慢指针
```java
public int removeElement(int[] nums, int val) {
    int slow = 0;
    for (int fast = 0; fast < nums.length; fast++) { // 如果是val，则只移动快指针
        if (nums[fast] != val) { // 不等于val，说明不是要移除的元素，同时移动快慢指针
            nums[slow] = nums[fast]; // 将不等于val的元素赋值给慢指针位置
            slow++;
        }
    }
    return slow; // 返回新数组的长度
}
```

## 有序数组的平方
- 双指针
- 从两端开始遍历，比较两端的平方大小，大的放在新数组末尾
- 最后返回新数组
```java
public int[] sortedSquares(int[] nums) {
    int left = 0;
    int right = nums.length - 1;
    int[] result = new int[nums.length];
    for (int i = nums.length - 1; i >= 0; i--) { // 从后往前遍历，因为平方最大的数在两端
        if (nums[left] * nums[left] > nums[right] * nums[right]) { // 如果左边的平方大于右边的平方
            result[i] = nums[left] * nums[left]; // 将平方最大的数赋值给新数组
            left++; // 左指针右移
        } else {
            result[i] = nums[right] * nums[right]; // 将平方最大的数赋值给新数组
            right--; // 右指针左移
        }
    }
    return result;
}
```

## 字母异位词分组
- 排序完后的异位词都会相等
- 使用map，key为排序后的字符串，value为异位词列表
- 遍历strs，将排序后的字符串作为key，将原字符串作为value，加入map
- 最后返回map的value列表
```java
    public List<List<String>> groupAnagrams(String[] strs) {
        Map<String, List<String>> map = new HashMap<String, List<String>>();
        for (String str : strs) {
            char[] array = str.toCharArray(); // 将字符串转换为字符数组
            Arrays.sort(array); // 对字符数组进行排序
            String key = new String(array); // 将字符数组转换为字符串
            List<String> list = map.getOrDefault(key, new ArrayList<String>()); // 获取key对应的value，如果key不存在，则返回new ArrayList<String>()
            list.add(str); // 将字符串加入value列表
            map.put(key, list); // 将key和value列表加入map
        }
        return new ArrayList<List<String>>(map.values()); // 返回map的value列表
    }
```

## 最长连续子序列
- 使用set，将nums中的元素加入set
- 如果set中存在nums[i] - 1，则跳过，否则从nums[i]开始，使用while循环，判断set中是否存在nums[i] + 1，如果存在，则继续循环，否则结束循环
- 记录最长连续子序列的长度
```java
public int longestConsecutive(int[] nums) {
    Set<Integer> set = new HashSet<Integer>(); // 将nums中的元素加入set
    for (int num : nums) {
        set.add(num); 
    }
    int longestStreak = 0; // 最长连续子序列长度
    for (int num : nums) {
        if (!set.contains(num - 1)) { // 如果set中不存在nums[i] - 1，则从nums[i]开始
            int currentNum = num; // 当前数字
            int currentStreak = 1; // 当前连续子序列长度
        }
        while (set.contains(currentNum + 1)) { // 如果set中存在nums[i] + 1，则继续循环
            currentNum += 1; // 当前数字加1
            currentStreak += 1; // 当前连续子序列长度加1
        }
        longestStreak = Math.max(longestStreak, currentStreak); // 更新最长连续子序列长度
    }
    return longestStreak; // 返回最长连续子序列长度
}
```

## 移动零
- 快慢指针
- 快指针遍历数组，慢指针在元素不为0时，将快指针指向的元素赋值给慢指针
- 快指针遍历完，slowIndex之后都是移除元素0的冗余元素，把这些元素都赋值为0就可以了。
```java
    public void moveZeroes(int[] nums) {
        int slow = 0; // 慢指针
        for (int fast = 0; fast < nums.length; fast++) { // 快指针遍历数组
            if (nums[fast] != 0) { // 如果快指针指向的元素不为0
                nums[slow] = nums[fast]; // 将快指针指向的元素赋值给慢指针
                slow++; // 慢指针右移
            }
        }
        // 后面的元素全变成 0
        for (int j = slow; j < nums.length; j++) { // 将慢指针之后的元素都赋值为0
            nums[j] = 0; // 将慢指针之后的元素都赋值为0
        }
    }
}
```

## 螺旋矩阵II
- 循环不变量：坚持左闭右开原则
- 循环圈数是n/2，n是矩阵的边长
- 如何n是奇数，则需要单独处理中心元素

```java
    public int[][] generateMatrix(int n) {
        int[][] nums = new int[n][n];
        int startX = 0, startY = 0;  // 每一圈的起始点
        int offset = 1; // 每一圈的偏移量
        int count = 1;  // 矩阵中需要填写的数字
        int loop = 1; // 记录当前的圈数
        int i, j; // j 代表列, i 代表行;

        while (loop <= n / 2) { // 循环圈数是n/2，n是矩阵的边长

            // 顶部
            // 左闭右开，所以判断循环结束时， j 不能等于 n - offset
            for (j = startY; j < n - offset; j++) {
                nums[startX][j] = count++;
            }

            // 右列
            // 左闭右开，所以判断循环结束时， i 不能等于 n - offset
            for (i = startX; i < n - offset; i++) {
                nums[i][j] = count++;
            }

            // 底部
            // 左闭右开，所以判断循环结束时， j != startY
            for (; j > startY; j--) {
                nums[i][j] = count++;
            }

            // 左列
            // 左闭右开，所以判断循环结束时， i != startX
            for (; i > startX; i--) {
                nums[i][j] = count++;
            }
            // 更新起始点 开始下一圈
            startX++;
            startY++;
            offset++;
            loop++;
        }
        if (n % 2 == 1) { // n 为奇数时，单独处理矩阵中心的值
            nums[startX][startY] = count;
        }
        return nums;
    }
```
## 螺旋矩阵
- 和上一题类似, 只是变成了读取矩阵的值
- 这里用的左闭右闭原则
``` java
public List<Integer> spiralOrder(int[][] matrix) {
    List<Integer> res = new ArrayList<>();
    if (matrix.length == 0) return res;

    int startRow = 0, endRow = matrix.length - 1;
    int startCol = 0, endCol = matrix[0].length - 1;

        while (startRow <= endRow && startCol <= endCol) { 
            // → 向右
            for (int col = startCol; col <= endCol; col++) {
                res.add(matrix[startRow][col]);
            }

            // ↓ 向下
            for (int row = startRow + 1; row <= endRow; row++) { // 从startRow + 1开始，因为startRow已经遍历过了
                res.add(matrix[row][endCol]);
            }

            // ← 向左（要确保不是同一行）
            if (startRow < endRow) {
                for (int col = endCol - 1; col >= startCol; col--) { // 从endCol - 1开始，因为endCol已经遍历过了
                    res.add(matrix[endRow][col]);
                }
            }

            // ↑ 向上（要确保不是同一列）
            if (startCol < endCol) {
                for (int row = endRow - 1; row > startRow; row--) { // 从endRow - 1开始，因为endRow已经遍历过了
                    res.add(matrix[row][startCol]);
                }
            }

            // 进入下一圈
            startRow++;
            endRow--;
            startCol++;
            endCol--;
        }

        return res;
    }
```
## 滑动窗口模版
```java
//外层循环扩展右边界，内层循环扩展左边界
for (int l = 0, r = 0 ; r < n ; r++) {
    //当前考虑的元素
    while (l <= r && check()) {//区间[left,right]不符合题意
        //扩展左边界
    }
    //区间[left,right]符合题意，统计相关信息
}
```


## 长度最小的子数组
- 滑动窗口
```java
public int minSubArrayLen(int s, int[] nums) {
    int left = 0;                      // 滑动窗口左边界
    int sum = 0;                       // 当前窗口的和
    int result = Integer.MAX_VALUE;    // 最小子数组长度，初始设为无限大

    for (int right = 0; right < nums.length; right++) { // 右指针代表的是终止位置
        sum += nums[right];           // 滑动窗口里元素的和

        // 只要窗口内的和 ≥ s，符合要求了，就收缩左边界以尝试得到更短的长度
        while (sum >= s) {
            result = Math.min(result, right - left + 1); // 更新最小长度 right - left + 1是当前窗口[left, right]的长度
            sum -= nums[left];                         // 收缩窗口
            left++; // 移动左指针
        }
    }

    // 如果 result 没被更新过，说明不存在满足条件的子数组
    return result == Integer.MAX_VALUE ? 0 : result;
}
```

## 无重复字符的最长子串
- 滑动窗口
- set负责快速判断和维护“当前窗口中字符的唯一性”
- 如果窗口内的字符重复，则移动左指针
- 如果窗口内的字符不重复，则移动右指针
- 返回最大长度
```java
public int lengthOfLongestSubstring(String s) {
    char[] ss = s.toCharArray(); // 将字符串转换为字符数组
    Set<Character> set = new HashSet<>(); // 使用set记录窗口内的字符
    int res = 0; //结果
    for(int left = 0, right = 0; right < s.length(); right++) {//每一轮右端点都扩一个
        char ch = ss[right];//right指向的元素，也是当前要考虑的元素
        while(set.contains(ch)) {//set中有ch，则缩短左边界，同时从set集合出元素
            set.remove(ss[left]); // 从set集合出元素
            left++; // 移动左指针
        }
        set.add(ss[right]);//将当前元素加入
        res = Math.max(res, right - left + 1);//计算当前不重复子串的长度
    }
    return res;
}
```

## 找到字符串中所有字母异位词
- 在s中找到所有p的异位词
- 因为字符串 p 的异位词的长度一定与字符串 p 的长度相同，所以我们可以在字符串 s 中构造一个长度为与字符串 p 的长度相同的滑动窗口，并在滑动中维护窗口中每种字母的数量
- 如果两个字符串中每种字母的数量相同，则称这两个字符串互为字母异位词
- ascii
    - 统计字符 'b' 的出现次数
    - `char c = 'b';`
    - `count[c - 'a']++;  // 等价于 count[1]++`
```java
public List<Integer> findAnagrams(String s, String p) {
    List<Integer> res = new ArrayList<>();
    int[] pCount = new int[26]; // 记录字符串 p 中每种字母的数量
    int[] sCount = new int[26]; // 记录字符串 s 中每种字母的数量
    for (char c : p.toCharArray()) { // 遍历字符串 p
        pCount[c - 'a']++; // 记录字符串 p 中每种字母的数量
    }
    for (int i = 0; i < s.length(); i++) { // 遍历字符串 s
        sCount[s.charAt(i) - 'a']++; // 记录字符串 s 中每种字母的数量
        if (i >= p.length()) { // 如果窗口大小大于字符串 p 的长度
            sCount[s.charAt(i - p.length()) - 'a']--; // 移除字符串 s 中第一个字母
        }
        if (Arrays.equals(pCount, sCount)) { // 如果两个字符串中每种字母的数量相同
            res.add(i - p.length() + 1); // 记录字符串 s 中第一个字母异位词的起始位置
        }
    }
    return res;
}
```
## 合并两个有序数组
- 双指针
- 从后往前遍历
- 比较两个数组末尾元素，大的放在新数组末尾
- 最后返回新数组
```java
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        int p1 = m - 1, p2 = n - 1;
        int tail = m + n - 1;
        int cur;
        while (p1 >= 0 || p2 >= 0) {
            if (p1 == -1) { // 如果p1已经遍历完了，则直接将p2的元素赋值给新数组
                cur = nums2[p2];
                p2--;
            } else if (p2 == -1) { // 如果p2已经遍历完了，则直接将p1的元素赋值给新数组
                cur = nums1[p1];
                p1--;
            } else if (nums1[p1] > nums2[p2]) { // 如果p1的元素大于p2的元素，则将p1的元素赋值给新数组
                cur = nums1[p1];
                p1--;
            } else { // 如果p1的元素小于p2的元素，则将p2的元素赋值给新数组
                cur = nums2[p2];
                p2--;
            }
            nums1[tail] = cur; // 将cur赋值给新数组
            tail--; // 新数组下标左移
        }
    }
}

```

## 删除排序数组中的重复项
```java
class Solution {
    public int removeDuplicates(int[] nums) {
        if(nums.length == 0) return 0;
        int slow = 0; // 慢指针用于记录不重复元素的最后位置合法值的索引
        for(int fast = 1; fast < nums.length; fast++){ // 快指针用于遍历数组
            if(nums[fast] != nums[fast-1]){ // 如果当前元素与前一个元素不同
                slow++; // 慢指针移动到下一个位置
                nums[slow] = nums[fast]; // 将当前元素放到慢指针的位置
            }
        }
        return slow + 1; // +1是因为slow是从0开始的 返回的是数组长度
    }
}
```

## 删除排序数组中的重复项II
- 快慢指针
- 慢指针表示处理出的数组的长度，快指针表示已经检查过的数组的长度
- 如果当前数 != slow-2 位置的数，就可以保留
- 返回慢指针
```java
class Solution {
    public int removeDuplicates(int[] nums) {
        if (nums.length <= 2) return nums.length;

        int slow = 2;
        for (int fast = 2; fast < nums.length; fast++) {
            // 如果当前数 != slow-2 位置的数，就可以保留
            if (nums[fast] != nums[slow - 2]) {
                nums[slow] = nums[fast];
                slow++;
            }
        }
        return slow;
    }
}
```

## 多数元素
- 摩尔投票法
- 初始化一个候选元素candidate，初始化一个计数器count
- 遍历数组，如果当前元素等于candidate，则count加1，否则count减1
- 如果count为0，则将当前元素赋值给candidate
- 最后返回candidate
```java
public int majorityElement(int[] nums) {
    int count = 0; // 候选元素的计数
    Integer candidate = null; // 当前候选多数元素
    for (int num : nums) {
        if (count == 0) { // 如果count为0，则将当前元素赋值给candidate
            candidate = num;
        }
        count += (num == candidate) ? 1 : -1; // 如果当前元素等于candidate，则count加1，否则count减1
    }
    return candidate;
}
```

## 旋转数组
- 创建一个新数组，将原数组中的元素按照旋转后的位置赋值给新数组
- 将新数组赋值给原数组
```java
class Solution {
    public void rotate(int[] nums, int k) {
        int n = nums.length;
        int[] newArr = new int[n];
        for (int i = 0; i < n; ++i) {
            newArr[(i + k) % n] = nums[i]; // %n是为了防止k大于n的情况
        }
        System.arraycopy(newArr, 0, nums, 0, n); // 参数1：源数组，参数2：源数组起始位置，参数3：目标数组，参数4：目标数组起始位置，参数5：复制长度
    }
}
```

## O(1) 时间插入、删除和获取随机元素
```java
class RandomizedSet {
    List<Integer> nums;
    Map<Integer, Integer> indices; // key: 元素值，value: 元素索引
    Random random;

    public RandomizedSet() {
        nums = new ArrayList<Integer>();
        indices = new HashMap<Integer, Integer>();
        random = new Random();
    }

    public boolean insert(int val) {
        if (indices.containsKey(val)) { // 如果val已经存在，则返回false
            return false;
        }
        int index = nums.size(); // 获取当前数组长度
        nums.add(val); // 将val添加到数组末尾
        indices.put(val, index); // 将val和index添加到map中
        return true;
    }

// 正常地从 ArrayList 中间删除元素，时间复杂度是 O(n)，因为它需要移动所有后面的元素。
// 但我们想要 O(1) 删除，于是就用这个技巧：
// 把要删除的元素用最后一个元素覆盖，再把最后一个删掉（反正顺序不重要）
    public boolean remove(int val) {
        if (!indices.containsKey(val)) { // 如果val不存在，则返回false
            return false;
        }
        int index = indices.get(val); // 获取val的索引
        int last = nums.get(nums.size() - 1); // 获取数组最后一个元素
        nums.set(index, last); // 将数组最后一个元素赋值给val的索引
        indices.put(last, index); // 将数组最后一个元素和val的索引添加到map中
        nums.remove(nums.size() - 1); // 删除数组最后一个元素
        indices.remove(val); // 删除val的索引
        return true;
    }

    public int getRandom() {
        int randomIndex = random.nextInt(nums.size()); // 获取随机索引
        return nums.get(randomIndex); // 返回随机索引的元素
    }
}
```