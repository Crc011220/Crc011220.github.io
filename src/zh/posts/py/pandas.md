---
icon: pen-to-square
date: 2025-11-06
category:
  - Python
tag:
  - Pandas
---

# Pandas

以下是 **Pandas 常见方法的完整梳理**，按“数据结构创建、数据查看与基础属性、数据选择与过滤、数据清洗、数据转换、分组与聚合、合并与拼接、时间序列处理、IO操作、高级功能”十大模块分类，附具体示例和说明，覆盖从基础到进阶的核心用法：


### 一、核心数据结构创建（Series 与 DataFrame）
Pandas的两大核心结构：`Series`（一维带标签数组）和`DataFrame`（二维表格，含行索引`index`和列名`columns`）。

| 数据结构 | 方法                | 功能描述                                  | 示例代码                                                                 | 输出结果（简化）                          |
|----------|---------------------|-------------------------------------------|--------------------------------------------------------------------------|-------------------------------------------|
| Series   | `pd.Series()`       | 创建一维序列，可指定索引`index`           | `pd.Series([10, 20, 30], index=['a', 'b', 'c'], name='数值列')`          | ```a    10<br>b    20<br>c    30<br>Name: 数值列, dtype: int64``` |
|          | `pd.Series(dict)`   | 从字典创建（键为索引，值为数据）          | `pd.Series({'a':1, 'b':2})`                                             | ```a    1<br>b    2<br>dtype: int64``` |
| DataFrame| `pd.DataFrame()`    | 从列表/字典创建二维表格                   | ```pd.DataFrame({<br>  '姓名': ['张三', '李四'],<br>  '年龄': [20, 25],<br>  '分数': [85.5, 92.0]<br>}, index=['s1', 's2'])``` | ```   姓名  年龄   分数<br>s1  张三  20  85.5<br>s2  李四  25  92.0``` |
|          | 从NumPy数组创建     | 利用`np.array`作为数据，指定列名          | `pd.DataFrame(np.arange(6).reshape(2,3), columns=['A','B','C'])`         | ```   A  B  C<br>0  0  1  2<br>1  3  4  5``` |


### 二、数据查看与基础属性（了解数据概貌）
快速获取数据的基本信息、统计特征和样本内容。

| 方法/属性       | 功能描述                                  | 示例（基于上述DataFrame `df`） | 输出结果（简化）                          |
|-----------------|-------------------------------------------|-------------------------------|-------------------------------------------|
| `shape`         | 查看表格形状（行数, 列数）                | `df.shape`                    | `(2, 3)`（2行3列）                        |
| `index`         | 查看行索引                                | `df.index`                    | `Index(['s1', 's2'], dtype='object')`      |
| `columns`       | 查看列名                                  | `df.columns`                  | `Index(['姓名', '年龄', '分数'], dtype='object')` |
| `dtypes`        | 查看各列数据类型                          | `df.dtypes`                   | ```姓名     object<br>年龄      int64<br>分数    float64``` |
| `info()`        | 详细信息（数据类型、非空值数量、内存）    | `df.info()`                   | 打印：RangeIndex: 2 entries, ... 内存占用等 |
| `head(n)`       | 查看前n行（默认5行）                      | `df.head(1)`                  | 显示第1行数据                             |
| `tail(n)`       | 查看后n行（默认5行）                      | `df.tail(1)`                  | 显示最后1行数据                           |
| `sample(n)`     | 随机查看n行样本                           | `df.sample(1)`                 | 随机返回1行数据                           |
| `describe()`    | 数值列的统计摘要（均值、标准差、分位数等）| `df.describe()`               | ```        年龄        分数<br>count   2.000000   2.000000<br>mean   22.500000  88.750000<br>std     3.535534   4.596194...``` |
| `value_counts()`| （Series方法）统计元素出现次数            | `df['年龄'].value_counts()`   | 按年龄值统计出现次数                       |


### 三、数据选择与过滤（提取指定数据）
灵活按标签、位置、条件筛选数据，类似Excel的筛选和定位。

| 操作类型          | 方法/语法                | 示例（基于`df`） | 输出结果（简化）                          |
|-------------------|--------------------------|------------------|-------------------------------------------|
| 1. 选择列         | 按列名直接选取           | `df['姓名']` 或 `df.姓名` | 返回“姓名”列的Series                      |
|                   | 选择多列                 | `df[['姓名', '分数']]` | 返回包含两列的DataFrame                    |
| 2. 选择行（按标签）| `loc[]` 按行索引标签     | `df.loc['s1']`   | 返回索引为`s1`的行（Series）               |
|                   | 选择多行多列             | `df.loc[['s1','s2'], ['年龄','分数']]` | 返回指定行和列的子表格                     |
| 3. 选择行（按位置）| `iloc[]` 按整数位置（从0开始） | `df.iloc[0]` | 返回第1行（Series）                       |
|                   | 位置切片                 | `df.iloc[0:2, 1:3]` | 返回前2行、第2-3列（位置1到2）             |
| 4. 条件筛选       | 单条件筛选               | `df[df['年龄'] > 22]` | 返回年龄>22的行（示例中为`s2`行）          |
|                   | 多条件筛选（`&`且, `|`或） | `df[(df['年龄'] > 20) & (df['分数'] > 90)]` | 年龄>20且分数>90的行                      |
|                   | `query()` 字符串条件     | `df.query("年龄 > 20 and 分数 > 85")` | 同上，语法更简洁                           |
| 5. 按元素筛选     | `isin()` 匹配列表中的值   | `df[df['姓名'].isin(['张三'])]` | 姓名为“张三”的行                           |


### 四、数据清洗（处理缺失值、重复值、格式问题）
数据预处理的核心步骤，确保数据质量。

| 操作类型          | 方法                | 示例（基于含缺失值的`df`） | 功能说明                                  |
|-------------------|---------------------|----------------------------|-------------------------------------------|
| 缺失值检测        | `isna()` / `isnull()` | `df.isna()`                | 返回布尔值表格，`True`表示缺失值          |
|                   | `notna()` / `notnull()` | `df.notna()`               | 与`isna()`相反，`True`表示非缺失值        |
| 缺失值处理        | `dropna()`          | `df.dropna(axis=0)`        | 删除含缺失值的行（`axis=1`删除列）         |
|                   | `fillna()`          | `df['分数'].fillna(df['分数'].mean())` | 用“分数”列的均值填充缺失值                |
|                   | `interpolate()`     | `df['年龄'].interpolate()` | 用插值法填充缺失值（适合有序数据）         |
| 重复值处理        | `duplicated()`      | `df.duplicated()`          | 返回布尔值Series，`True`表示重复行        |
|                   | `drop_duplicates()` | `df.drop_duplicates(subset=['姓名'], keep='first')` | 按“姓名”去重，保留第一次出现的行           |
| 数据类型转换      | `astype()`          | `df['年龄'].astype(float)` | 将“年龄”列从int转为float                   |
|                   | `pd.to_numeric()`   | `pd.to_numeric(df['分数'], errors='coerce')` | 强制转为数值型，错误值设为NaN              |
| 字符串处理        | `str` 访问器        | `df['姓名'].str.len()`     | 计算“姓名”列每个字符串的长度               |
|                   | `str.strip()`       | `df['姓名'].str.strip()`   | 去除字符串前后空格                         |
|                   | `str.replace()`     | `df['姓名'].str.replace('张', '章')` | 替换字符串中的字符                         |


### 五、数据转换（新增/修改列、排序、重命名）
调整数据结构以适应分析需求。

| 操作类型          | 方法                | 示例（基于`df`） | 输出结果（简化）                          |
|-------------------|---------------------|------------------|-------------------------------------------|
| 新增列            | 直接赋值            | `df['是否及格'] = df['分数'] >= 60` | 新增“是否及格”列（布尔值）                 |
|                   | `assign()` 链式新增 | `df.assign(总分=df['分数']*2, 等级=lambda x: x['分数']>=90)` | 新增“总分”和“等级”列，支持lambda表达式    |
| 修改列值          | 条件赋值            | `df.loc[df['分数'] < 60, '等级'] = '不及格'` | 对分数<60的行，设置“等级”为“不及格”       |
| 列重命名          | `rename()`          | `df.rename(columns={'分数': '成绩', '年龄': '岁数'})` | 列名从“分数”→“成绩”，“年龄”→“岁数”        |
| 行索引重命名      | `set_index()`       | `df.set_index('姓名')`     | 将“姓名”列设为新的行索引                   |
|                   | `reset_index()`     | `df.reset_index(drop=True)` | 重置行索引为默认整数（`drop=True`删除原索引） |
| 排序              | `sort_values()`     | `df.sort_values(by='分数', ascending=False)` | 按“分数”降序排序                          |
|                   | `sort_index()`      | `df.sort_index(ascending=True)` | 按行索引升序排序                           |
| 删除列/行         | `drop()`            | `df.drop(columns=['年龄'])` | 删除“年龄”列                               |
|                   | `df.drop(index=['s1'])` | 删除索引为`s1`的行                        |


### 六、分组与聚合（GroupBy，按类别分析数据）
类似Excel的数据透视表，按某列分组后计算统计量。

| 操作类型          | 方法                | 示例（假设`df`含“班级”列） | 功能说明                                  |
|-------------------|---------------------|----------------------------|-------------------------------------------|
| 基础分组          | `groupby()`         | `df.groupby('班级')`       | 按“班级”列分组，返回GroupBy对象            |
| 分组后聚合        | 单聚合函数          | `df.groupby('班级')['分数'].mean()` | 按班级计算“分数”的均值                     |
|                   | 多聚合函数          | `df.groupby('班级')['分数'].agg(['mean', 'max', 'min'])` | 同时计算均值、最大值、最小值               |
|                   | 自定义聚合函数      | `df.groupby('班级')['分数'].agg(lambda x: x.sum()/x.count())` | 用lambda自定义聚合（等价于均值）           |
| 多列分组          | `groupby([col1, col2])` | `df.groupby(['班级', '性别'])['分数'].sum()` | 先按班级、再按性别分组，计算分数总和       |
| 分组后过滤        | `filter()`          | `df.groupby('班级').filter(lambda x: x['分数'].mean() > 80)` | 保留“班级平均分>80”的所有行                |
| 分组后转换        | `transform()`       | `df.groupby('班级')['分数'].transform(lambda x: x - x.mean())` | 新增“分数减去班级均值”的列                 |


### 七、合并与拼接（多表关联，类似SQL）
将多个DataFrame组合为一个，支持多种连接方式。

| 操作类型          | 方法                | 示例（`df1`含“学号”“姓名”；`df2`含“学号”“成绩”） | 功能说明                                  |
|-------------------|---------------------|------------------------------------------------|-------------------------------------------|
| 纵向拼接（行合并）| `pd.concat()`       | `pd.concat([df1, df2], axis=0, ignore_index=True)` | 按行拼接（`axis=0`），重置索引            |
| 横向拼接（列合并）| `pd.concat()`       | `pd.concat([df1, df2], axis=1)`                | 按列拼接（`axis=1`），需行索引一致        |
| 内连接（交集）    | `merge()`           | `pd.merge(df1, df2, on='学号', how='inner')`   | 只保留两表中“学号”匹配的行                |
| 左连接（左表全保留）| `merge()`          | `pd.merge(df1, df2, on='学号', how='left')`    | 保留df1所有行，df2无匹配则填充NaN         |
| 右连接（右表全保留）| `merge()`          | `pd.merge(df1, df2, on='学号', how='right')`   | 保留df2所有行，df1无匹配则填充NaN         |
| 外连接（并集）    | `merge()`           | `pd.merge(df1, df2, on='学号', how='outer')`   | 保留两表所有行，无匹配则填充NaN           |
| 按索引连接        | `merge(index=True)` | `pd.merge(df1, df2, left_index=True, right_index=True)` | 按行索引而非列连接                        |


### 八、时间序列处理（针对日期时间数据）
Pandas对时间序列的支持远超基础库，适合分析时序数据（如股票价格、用户行为）。

| 操作类型          | 方法                | 示例代码                                                                 | 功能说明                                  |
|-------------------|---------------------|--------------------------------------------------------------------------|-------------------------------------------|
| 创建时间序列      | `pd.to_datetime()`  | `pd.to_datetime(['2023-01-01', '2023-01-02'])`                           | 将字符串转为`datetime64`类型               |
|                   | `pd.date_range()`   | `pd.date_range(start='2023-01-01', periods=5, freq='D')`                 | 生成连续日期（从1月1日起5天，频率`D`=天）  |
| 时间索引提取      | `dt` 访问器        | `ts = pd.Series(range(5), index=pd.date_range('2023-01-01', periods=5))`<br>`ts.dt.year` → 提取年份 | 提取年、月、日、小时等                     |
| 时间切片          | 按日期筛选          | `ts['2023-01-02':'2023-01-04']`                                         | 筛选指定日期范围内的数据                   |
| 重采样（频率转换）| `resample()`        | `ts.resample('2D').sum()`  # 按2天为周期求和                             | 将高频数据转为低频（如日→周、小时→天）     |
| 滚动窗口计算      | `rolling()`         | `ts.rolling(window=3).mean()`  # 3天滑动窗口的均值                        | 计算时序数据的滑动统计量（均值、标准差等） |


### 九、IO操作（读写文件，对接外部数据）
支持多种格式文件的读写，是数据输入输出的核心工具。

| 文件类型    | 读取方法                  | 写入方法                  | 关键参数（示例）                          |
|-------------|---------------------------|---------------------------|-------------------------------------------|
| CSV文件     | `pd.read_csv()`           | `df.to_csv()`             | `read_csv('data.csv', sep=',', header=0)`<br>`to_csv('out.csv', index=False)`（不保存索引） |
| Excel文件   | `pd.read_excel()`         | `df.to_excel()`           | `read_excel('data.xlsx', sheet_name='Sheet1')`<br>`to_excel('out.xlsx', sheet_name='结果')` |
| JSON文件    | `pd.read_json()`          | `df.to_json()`            | 支持读取JSON格式的表格数据                 |
| 数据库      | `pd.read_sql()`           | `df.to_sql()`             | 需配合数据库连接（如`sqlalchemy`），示例：<br>`pd.read_sql('SELECT * FROM table', conn)` |
| 剪贴板      | `pd.read_clipboard()`     | `df.to_clipboard()`       | 读取/写入系统剪贴板数据（方便粘贴到Excel） |


### 十、高级功能（提升效率与灵活性）
适合复杂分析场景的进阶用法。

| 功能类型          | 方法/工具                | 示例说明                                  |
|-------------------|--------------------------|-------------------------------------------|
| 批量处理元素      | `apply()`                | `df.apply(lambda x: x.max() - x.min(), axis=1)`  # 按行计算极差（最大值-最小值） |
| 高效遍历          | `itertuples()` / `iterrows()` | 遍历DataFrame的行（`itertuples`效率更高） |
| 透视表            | `pivot_table()`          | `pd.pivot_table(df, values='分数', index='班级', columns='性别', aggfunc='mean')`  # 生成班级×性别的分数均值透视表 |
| 交叉表            | `crosstab()`             | `pd.crosstab(df['班级'], df['是否及格'])`  # 统计各班级及格与不及格的人数 |
| 数据透视重塑      | `melt()`                 | `pd.melt(df, id_vars=['姓名'], value_vars=['年龄','分数'])`  # 将宽表转为长表（适合分组分析） |
| 内存优化          | `astype()` 转换类型      | 将`int64`转为`int32`、`object`转为`category`（低基数字符串），减少内存占用 |


### 核心总结：
Pandas的核心价值是**“结构化数据的高效处理”**——通过`Series`和`DataFrame`的标签化设计，结合丰富的内置方法，实现从数据读取、清洗、转换到分析的全流程操作，尤其适合表格型数据（如业务报表、日志数据）。掌握上述方法，可应对95%以上的数据分析场景。

如果需要某个方法的更详细示例（如`merge`的多键连接、`pivot_table`的多层索引），可以随时告诉我~