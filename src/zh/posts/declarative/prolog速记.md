---
icon: pen-to-square
date: 2025-06-14
category:
  - Learning Records
tag:
  - Declarative Programming
---

# Prolog å†…ç½®è°“è¯é€ŸæŸ¥è¡¨

| å‘½ä»¤                              | ä½œç”¨              |
| ------------------------------- | --------------- |
| `help(Name)`                    | æŸ¥çœ‹æŸä¸ªè°“è¯çš„ç”¨æ³•ç®€è¦è¯´æ˜   |
| `apropos(Keyword)`              | æœç´¢åŒ…å«æŸå…³é”®è¯çš„æ‰€æœ‰æ–‡æ¡£æ¡ç›® |
| `listing(Name/Arity)`           | æŸ¥çœ‹ç”¨æˆ·è‡ªå®šä¹‰è°“è¯å®šä¹‰     |
| `predicate_property(P,Prop)`    | æŸ¥è¯¢è°“è¯çš„å±æ€§         |
| `current_predicate(Name/Arity)` | æŸ¥çœ‹æ‰€æœ‰å½“å‰å­˜åœ¨çš„è°“è¯     |
| `trace.` / `notrace.`           | å¯ç”¨/ç¦ç”¨è°ƒè¯•         |

---

## ğŸ§° åŸºæœ¬è°“è¯ï¼ˆç»“æ„ã€åˆ¤æ–­ï¼‰

| è°“è¯          | è¯´æ˜             | ç¤ºä¾‹                               |
| ----------- | -------------- | -------------------------------- |
| `X = Y`     | ç»“æ„ç»Ÿä¸€           | `X = foo(Y)` â†’ `X = foo(Y)`      |
| `X \= Y`    | ç»“æ„æ— æ³•ç»Ÿä¸€         | `foo(a) \= foo(b)` â†’ `true`      |
| `X == Y`    | å®Œå…¨ç›¸åŒï¼ˆä¸è¯•å›¾ç»Ÿä¸€ï¼‰    | `X = a, Y = a, X == Y` â†’ `true`  |
| `X \== Y`   | ä¸å®Œå…¨ç›¸åŒ          | `X = a, Y = b, X \== Y` â†’ `true` |
| `X is Expr` | æ•°å€¼æ±‚å€¼ï¼ˆå³ä¾§æ˜¯ç®—æœ¯è¡¨è¾¾å¼ï¼‰ | `X is 2 + 3` â†’ `X = 5`           |
| `X =:= Y`   | æ•°å€¼ç­‰äº           | `2 + 3 =:= 5` â†’ `true`           |
| `X =\= Y`   | æ•°å€¼ä¸ç­‰           | `5 =\= 6` â†’ `true`               |
| `X @< Y`    | å­—å…¸åºå°äº          | `'apple' @< 'banana'` â†’ `true`   |
| `X @> Y`    | å­—å…¸åºå¤§äº          | `'zoo' @> 'apple'` â†’ `true`      |
| `\+`        | é€»è¾‘é             | `\+ true` â†’ `false`              |

var(Term) means Term is an unbound variable
nonvar(Term) means Term is not an unbound variable
ground(Term) means Term contains no unbound variables

---

## ğŸ”¢ æ•°å­—è¿ç®—  

| è°“è¯                  | è¯´æ˜                   | ç¤ºä¾‹                                        |
| ------------------- | -------------------- | ----------------------------------------- |
| `+`                 | åŠ æ³•                   | `2 + 3` â†’ `5`                             |
| `-`                 | å‡æ³•                   | `5 - 2` â†’ `3`                             |
| `*`                 | ä¹˜æ³•                   | `2 * 3` â†’ `6`                             |
| `/`                 | é™¤æ³•ï¼ˆæµ®ç‚¹æ•°ï¼‰           | `5 / 2` â†’ `2.5`                           |
| `div æˆ–è€… //`               | æ•´æ•°é™¤æ³•ï¼ˆå•†ï¼‰            | `5 div 2` â†’ `2`                           |
| `rem`               | å–ä½™ï¼ˆæ•´æ•°é™¤æ³•ä½™æ•°ï¼‰        | `5 rem 2` â†’ `1`                           |
| `abs`               | ç»å¯¹å€¼                 | `abs(-5)` â†’ `5`                          |
## ğŸ” æ§åˆ¶ç»“æ„

| è°“è¯                    | è¯´æ˜        | ç¤ºä¾‹                                     |
| --------------------- | --------- | -------------------------------------- |
| `(A, B)`              | åŒæ—¶æ»¡è¶³ï¼ˆANDï¼‰ | `(X = 1, Y = 2)` â†’ `X = 1, Y = 2`      |
| `(A ; B)`             | ä»»ä¸€æ»¡è¶³ï¼ˆORï¼‰  | `(X = 1 ; X = 2)` â†’ `X = 1 ; X = 2`    |
| `Cond -> Then ; Else` | æ¡ä»¶åˆ†æ”¯      | `(X > 0 -> Pos = yes ; Pos = no)`      |
| `fail`                | å¼ºåˆ¶å¤±è´¥      | `(write('hello'), fail)` â†’ è¾“å‡º helloï¼Œå¤±è´¥ |
| `true`                | æ€»æ˜¯æˆåŠŸ      | `true.` â†’ `true`                       |

---

## ğŸ“‹ åˆ—è¡¨å¤„ç†

| è°“è¯                 | è¯´æ˜                | ç¤ºä¾‹                                        |
| ------------------ | ----------------- | ----------------------------------------- |
| `member(X, L)`     | `X` æ˜¯ `L` ä¸­çš„æˆå‘˜    | `member(2, [1,2,3])` â†’ `true`             |
| `append(A,B,AB)`   | æ‹¼æ¥ï¼š`A ++ B = AB`  | `append([1,2],[3],R)` â†’ `R = [1,2,3]`     |
| `length(L, N)`     | æ±‚é•¿åº¦               | `length([a,b,c], N)` â†’ `N = 3`            |
| `reverse(L, R)`    | åˆ—è¡¨åè½¬              | `reverse([1,2,3], R)` â†’ `R = [3,2,1]`     |
| `select(X, L, R)`  | ç§»é™¤å…ƒç´  Xï¼Œè¿”å›æ–°åˆ—è¡¨ R    | `select(2, [1,2,3], R)` â†’ `R = [1,3]`     |
| `nth0(I, L, X)`    | ç¬¬ `I` ä¸ªå…ƒç´ ï¼ˆä» 0 å¼€å§‹ï¼‰ | `nth0(1, [a,b,c], X)` â†’ `X = b`           |
| `maplist(P, L)`    | å¯¹ L ä¸­æ¯ä¸ªå…ƒç´ åº”ç”¨ P     | `maplist(writeln, [a,b,c])` è¾“å‡º abc        |
| `include(P, L, R)` | ä¿ç•™æ»¡è¶³ P çš„å…ƒç´         | `include(even, [1,2,4], R)` â†’ `R = [2,4]` |
| `exclude(P, L, R)` | åˆ é™¤æ»¡è¶³ P çš„å…ƒç´         | `exclude(even, [1,2,4], R)` â†’ `R = [1]`   |

---

## ğŸ§  å…ƒç¼–ç¨‹ï¼ˆè°“è¯æ“ä½œï¼‰

| è°“è¯                 | è¯´æ˜                    | ç¤ºä¾‹                                                    |
| ------------------ | --------------------- | ----------------------------------------------------- |
| `findall(X, G, L)` | æ‰€æœ‰æ»¡è¶³ G çš„ X æ”¾è¿› Lï¼ˆé‡å¤ä¿ç•™ï¼‰ | `findall(X, member(X,[a,b]), L)` â†’ `L = [a,b]`        |
| `bagof(X, G, L)`   | åˆ†ç»„ç»“æœï¼ˆæŒ‰è‡ªç”±å˜é‡åˆ†ç»„ï¼‰         | `bagof(X, Y^member(X-Y, [a-1,a-2]), L)` â†’ `L = [a,a]` |
| `setof(æ¨¡æ¿, æ¡ä»¶, L)`   | æ‰¾å‡ºæ‰€æœ‰æ»¡è¶³â€œæ¡ä»¶â€çš„è§£ï¼Œç”¨â€œæ¨¡æ¿â€è¡¨ç¤ºå‡ºæ¥ï¼Œå¹¶å»é‡åæ”¾å…¥â€œç»“æœåˆ—è¡¨      | `setof(X, member(X,[b,a,b]), L)` â†’ `L = [a,b]`        |
| `call(P)`          | åŠ¨æ€è°ƒç”¨è°“è¯                | `P = member(X,[1,2]), call(P)` â†’ `X = 1 ; X = 2`      |
| `once(G)`          | åªå–ç¬¬ä¸€ä¸ªè§£                | `once(member(X,[a,b]))` â†’ `X = a`                     |
| `\+ Goal`          | `Goal` ä¸å¯æ»¡è¶³æ—¶æˆç«‹ï¼ˆé€»è¾‘éï¼‰   | `\+ member(3, [1,2])` â†’ `true`                        |
| `^`                | ç»‘å®šå˜é‡ï¼ˆå°†å˜é‡ç»‘å®šåˆ°å€¼ï¼‰        | `X^member(X,[1,2])` â†’ `X = 1 ; X = 2`                 |

---

## ğŸ“Š æ’åº & æ¯”è¾ƒ

| è°“è¯                  | è¯´æ˜                   | ç¤ºä¾‹                                        |
| ------------------- | -------------------- | ----------------------------------------- |
| `sort(L, R)`        | æ’åºå¹¶å»é‡                | `sort([3,1,2,1], R)` â†’ `R = [1,2,3]`      |
| `msort(L, R)`       | æ’åºä½†ä¿ç•™é‡å¤é¡¹             | `msort([3,1,2,1], R)` â†’ `R = [1,1,2,3]`   |
| `keysort(Pairs, R)` | æ ¹æ®é”®æ’åºï¼Œå¦‚ `K-V` ç»“æ„     | `keysort([2-b,1-a], R)` â†’ `R = [1-a,2-b]` |
| `compare(O, A, B)`  | æ¯”è¾ƒå­—å…¸é¡ºåºï¼Œå¾— `<`ã€`=`ã€`>` | `compare(R, apple, banana)` â†’ `R = <`     |

---


## ğŸ§ª è°ƒè¯•è¾…åŠ©

| è°“è¯                   | è¯´æ˜                  | ç¤ºä¾‹                                         |
| -------------------- | ------------------- | ------------------------------------------ |
| `trace`              | å¼€å¯é€æ­¥è°ƒè¯•              | `trace.` â†’ å¼€å§‹è¿½è¸ªæ‰§è¡Œ                          |
| `notrace`            | å…³é—­è°ƒè¯•                | `notrace.`                                 |
| `listing`            | æ˜¾ç¤ºå½“å‰å®šä¹‰çš„è°“è¯è§„åˆ™         | `listing(largest_city/2).`                 |
| `print_term(T, [O])` | ç¾åŒ–æ‰“å°ç»“æ„ä½“ï¼ˆSWI-Prologï¼‰ | `print_term(foo(bar,baz), [output(user)])` |

---

### CLP(FD)
:- use_module(library(clpfd)).

| è°“è¯                  | è¯´æ˜                   | ç¤ºä¾‹                                        |
| ------------------- | -------------------- | ----------------------------------------- |
| `X #= Y`            | æ•°å€¼ç›¸ç­‰               | `X #= 5` â†’ `X = 5`                        |
| `X #\= Y`           | æ•°å€¼ä¸ç­‰               | `X #\= 5` â†’ `X = 5`                       |
| `X #< Y`            | æ•°å€¼å°äº               | `X #< 5` â†’ `X = 5`                        |
| `X #> Y`            | æ•°å€¼å¤§äº               | `X #> 5` â†’ `X = 5`                        |
| `X #=< Y`           | æ•°å€¼å°äºç­‰äº           | `X #=< 5` â†’ `X = 5`                       |
| `X #>= Y`           | æ•°å€¼å¤§äºç­‰äº           | `X #>= 5` â†’ `X = 5`                       |
| `label(Vars)`        | çº¦æŸå˜é‡(å‘Šè¯‰ç³»ç»Ÿ â€œç°åœ¨è¯·å¼€å§‹éå†æ‰€æœ‰å¯èƒ½å€¼ï¼Œæ‰¾å‡ºæ»¡è¶³çš„ç»„åˆâ€)               | `label([X,Y])` â†’ `X = 5, Y = 5`            |


## å°¾é€’å½’

```prolog
%ç”¨ä¸€ä¸ªaccæ¥è®°å½•ç´¯åŠ å€¼

sum_list(List, Sum) :-
    sum_list_acc(List, 0, Sum).

sum_list_acc([], Acc, Acc).
sum_list_acc([X|Xs], Acc, Sum) :-
    Acc1 is Acc + X,
    sum_list_acc(Xs, Acc1, Sum).
```

## ç»ƒä¹ 
---


### 1. `take_while_not_space/3` â€” ä»å¤´å–è¿ç»­éç©ºæ ¼å­—ç¬¦ä½œä¸ºä¸€ä¸ªå•è¯

```prolog
% take_while_not_space(Line, Word, Rest)
% ä» Line ä¸­å–å‡ºå¼€å¤´è¿ç»­çš„éç©ºæ ¼å­—ç¬¦æ”¾åˆ° Wordï¼Œå‰©ä½™æ”¾åˆ° Restã€‚
take_while_not_space([], [], []).  % ç©ºåˆ—è¡¨ï¼ŒWord å’Œ Rest éƒ½ä¸ºç©º
take_while_not_space([C|Cs], [], [C|Cs]) :-
    C = 0' , !.  % å¦‚æœç¬¬ä¸€ä¸ªå­—ç¬¦æ˜¯ç©ºæ ¼ï¼ŒWord ç»“æŸä¸ºç©ºï¼ŒRest å°±æ˜¯åŸåˆ—è¡¨
take_while_not_space([C|Cs], [C|Word], Rest) :-
    C \= 0' ,                          % ä¸æ˜¯ç©ºæ ¼
    take_while_not_space(Cs, Word, Rest). % ç»§ç»­é€’å½’
```

---

### 2. `split_on_predicate/4` â€” æŒ‰æ»¡è¶³è°“è¯æ¡ä»¶çš„å­—ç¬¦åˆ†å‰²åˆ—è¡¨

```prolog
% split_on_predicate(List, Predicate, Prefix, Rest)
% æŠŠ List æŒ‰ç¬¬ä¸€ä¸ªæ»¡è¶³ Predicate çš„å…ƒç´ åˆ†å‰²ä¸º Prefix å’Œ Restã€‚
split_on_predicate([], _, [], []).  % ç©ºåˆ—è¡¨åˆ†å‰²ç»“æœéƒ½ç©º
split_on_predicate([H|T], Pred, [], [H|T]) :-
    call(Pred, H), !. % å¦‚æœå½“å‰å¤´å…ƒç´ æ»¡è¶³è°“è¯ï¼ŒPrefix ä¸ºç©ºï¼ŒRest æ˜¯æ•´ä¸ªåˆ—è¡¨
split_on_predicate([H|T], Pred, [H|Prefix], Rest) :-
    \+ call(Pred, H), % å¦‚æœä¸æ»¡è¶³è°“è¯ï¼ŒH åŠ å…¥ Prefix
    split_on_predicate(T, Pred, Prefix, Rest). % é€’å½’å¤„ç†å°¾éƒ¨
```

---

### 3. `compress_spaces/2` â€” åˆå¹¶å¤šä¸ªè¿ç»­ç©ºæ ¼æˆä¸€ä¸ªç©ºæ ¼

```prolog
% compress_spaces(Input, Output)
% æŠŠ Input å­—ç¬¦åˆ—è¡¨ä¸­çš„è¿ç»­ç©ºæ ¼åˆå¹¶æˆä¸€ä¸ªç©ºæ ¼è¾“å‡ºä¸º Outputã€‚
compress_spaces([], []).  % ç©ºåˆ—è¡¨å¯¹åº”ç©ºè¾“å‡º
compress_spaces([0' |T], [0'|R]) :- % å½“å‰å­—ç¬¦æ˜¯ç©ºæ ¼
    skip_spaces(T, T2),             % è·³è¿‡ Input ä¸­æ‰€æœ‰è¿ç»­ç©ºæ ¼
    compress_spaces(T2, R).         % ç»§ç»­å‹ç¼©å‰©ä½™éƒ¨åˆ†
compress_spaces([H|T], [H|R]) :-    % éç©ºæ ¼å­—ç¬¦æ­£å¸¸ä¿ç•™
    H \= 0' ,
    compress_spaces(T, R).

% skip_spaces(List, Rest)
% è·³è¿‡ List å¼€å¤´çš„æ‰€æœ‰ç©ºæ ¼ï¼Œè¿”å›å‰©ä½™ Restã€‚
skip_spaces([0'|T], R) :-
    skip_spaces(T, R).
skip_spaces(L, L).
```

---

### 4. `prefix/2` â€” åˆ¤æ–­ä¸€ä¸ªåˆ—è¡¨æ˜¯ä¸æ˜¯å¦ä¸€ä¸ªåˆ—è¡¨çš„å‰ç¼€

```prolog
% prefix(Prefix, List)
% åˆ¤æ–­ Prefix æ˜¯å¦æ˜¯ List çš„å‰ç¼€ã€‚
prefix([], _).              % ç©ºåˆ—è¡¨æ˜¯ä»»ä½•åˆ—è¡¨çš„å‰ç¼€
prefix([H|T1], [H|T2]) :-   % ä¸¤åˆ—è¡¨å¤´ç›¸åŒåˆ™é€’å½’æ¯”è¾ƒå°¾éƒ¨
    prefix(T1, T2).
```

---

### 5. `remove_duplicates/2` â€” åˆ é™¤åˆ—è¡¨ä¸­é‡å¤å…ƒç´ ï¼Œä¿ç•™é¡ºåº

```prolog
% remove_duplicates(List, Result)
% ä» List ä¸­åˆ é™¤é‡å¤å…ƒç´ ï¼Œä¿ç•™å‡ºç°é¡ºåºã€‚
remove_duplicates([], []).  % ç©ºåˆ—è¡¨å¯¹åº”ç©ºç»“æœ
remove_duplicates([H|T], Result) :-
    member(H, T), !,         % å¦‚æœ H åœ¨å°¾éƒ¨ T ä¸­å‡ºç°è¿‡ï¼Œè·³è¿‡ H
    remove_duplicates(T, Result).
remove_duplicates([H|T], [H|Result]) :- % å¦åˆ™ä¿ç•™ H
    remove_duplicates(T, Result).
```

---

### 6. `split_list/3` â€” æŒ‰é•¿åº¦åˆ†å‰²åˆ—è¡¨æˆä¸¤éƒ¨åˆ†

```prolog
% split_list(N, List, (Front, Back))
% ä» List ä¸­åˆ†å‡ºå‰ N ä¸ªå…ƒç´ ä¸º Frontï¼Œå‰©ä½™ä¸º Backã€‚
split_list(0, List, ([], List)).  % åˆ†å‰²é•¿åº¦ä¸º0ï¼ŒFront ç©ºï¼ŒBack æ˜¯æ•´ä¸ªåˆ—è¡¨
split_list(N, [H|T], ([H|Front], Back)) :-
    N > 0,
    N1 is N - 1,
    split_list(N1, T, (Front, Back)). % é€’å½’åˆ†å‰²å°¾éƒ¨
```

---