<!doctype html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.18" />
    <meta name="theme" content="VuePress Theme Hope 2.0.0-rc.59" />
    <style>
      :root {
        --vp-c-bg: #fff;
      }

      [data-theme="dark"] {
        --vp-c-bg: #1b1b1f;
      }

      html,
      body {
        background: var(--vp-c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.documentElement.setAttribute("data-theme", "dark");
      }
    </script>
    <meta property="og:url" content="https://crc011220.github.io/zh/posts/review/%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9.html"><meta property="og:site_name" content="Ruochen Chen"><meta property="og:title" content="面试要点"><meta property="og:description" content="面试要点 Java基础 1. equals() 和 == 的区别？如何正确重写 equals() 和 hashCode() 方法？为什么需要同时重写？ == 和 equals() 的区别 == 操作符：对于基本数据类型比较值，对于引用类型比较内存地址 equals() 方法：Object类默认实现是比较引用，String等类重写后比较内容 正确重写的五..."><meta property="og:type" content="article"><meta property="og:locale" content="zh-CN"><meta property="og:updated_time" content="2025-07-30T07:46:18.000Z"><meta property="article:tag" content="Review"><meta property="article:published_time" content="2025-07-27T00:00:00.000Z"><meta property="article:modified_time" content="2025-07-30T07:46:18.000Z"><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"面试要点","image":[""],"datePublished":"2025-07-27T00:00:00.000Z","dateModified":"2025-07-30T07:46:18.000Z","author":[{"@type":"Person","name":"Ruochen Chen"}]}</script><link rel="icon" href="/mac.ico"><title>面试要点 | Ruochen Chen</title><meta name="description" content="面试要点 Java基础 1. equals() 和 == 的区别？如何正确重写 equals() 和 hashCode() 方法？为什么需要同时重写？ == 和 equals() 的区别 == 操作符：对于基本数据类型比较值，对于引用类型比较内存地址 equals() 方法：Object类默认实现是比较引用，String等类重写后比较内容 正确重写的五...">
    <link rel="stylesheet" href="/assets/css/styles.563fed46.css">
    <link rel="preload" href="/assets/js/runtime~app.534f024b.js" as="script"><link rel="preload" href="/assets/css/styles.563fed46.css" as="style"><link rel="preload" href="/assets/js/6312.2d95f1ad.js" as="script"><link rel="preload" href="/assets/js/app.d934ba98.js" as="script">
    <link rel="prefetch" href="/assets/js/zh_posts_declarative_haskell.html.f219f509.js" as="script"><link rel="prefetch" href="/assets/js/zh_posts_java8_函数式编程.html.6406d92a.js" as="script"><link rel="prefetch" href="/assets/js/zh_posts_netty_Netty01-nio.html.6aaca557.js" as="script"><link rel="prefetch" href="/assets/js/zh_posts_netty_Netty04-优化与源码.html.8edea904.js" as="script"><link rel="prefetch" href="/assets/js/zh_posts_netty_Netty03-进阶.html.6b130a66.js" as="script"><link rel="prefetch" href="/assets/js/zh_posts_algo_数组.html.f410d20e.js" as="script"><link rel="prefetch" href="/assets/js/zh_posts_netty_Netty02-intro.html.48ff395e.js" as="script"><link rel="prefetch" href="/assets/js/zh_posts_algo_动态规划.html.338458cc.js" as="script"><link rel="prefetch" href="/assets/js/zh_posts_nginx_1.html.be9ccc3a.js" as="script"><link rel="prefetch" href="/assets/js/zh_posts_algo_二叉树.html.f39707ea.js" as="script"><link rel="prefetch" href="/assets/js/zh_posts_declarative_prolog.html.d10c8ca1.js" as="script"><link rel="prefetch" href="/assets/js/zh_posts_algo_链表.html.fdbcb853.js" as="script"><link rel="prefetch" href="/assets/js/posts_unimelb_COMP90024.html.c07eee32.js" as="script"><link rel="prefetch" href="/assets/js/zh_posts_algo_图.html.ae7133bf.js" as="script"><link rel="prefetch" href="/assets/js/zh_posts_hive_Hive-SQL语法大全.html.4ea325b1.js" as="script"><link rel="prefetch" href="/assets/js/posts_kubernetes_practices_14.html.91687ee1.js" as="script"><link rel="prefetch" href="/assets/js/zh_posts_declarative_haskell速记.html.0de6f0c8.js" as="script"><link rel="prefetch" href="/assets/js/zh_posts_algo_栈和队列.html.48986a9e.js" as="script"><link rel="prefetch" href="/assets/js/posts_unimelb_COMP90049.html.4b1c6d22.js" as="script"><link rel="prefetch" href="/assets/js/zh_posts_review_面试要点.html.5e8ed91a.js" as="script"><link rel="prefetch" href="/assets/js/posts_unimelb_COMP90050.html.4b5d3bee.js" as="script"><link rel="prefetch" href="/assets/js/posts_note_Coin-exchange-project-note.html.9c9c631c.js" as="script"><link rel="prefetch" href="/assets/js/zh_posts_algo_回溯.html.3a9cd825.js" as="script"><link rel="prefetch" href="/assets/js/posts_tailwind_summary.html.7c9f97e6.js" as="script"><link rel="prefetch" href="/assets/js/2664.0c0e265f.js" as="script"><link rel="prefetch" href="/assets/js/zh_posts_review_其他问题.html.a019e4d7.js" as="script"><link rel="prefetch" href="/assets/js/zh_posts_review_数据结构.html.1143a147.js" as="script"><link rel="prefetch" href="/assets/js/posts_typescript_1.html.adb4c039.js" as="script"><link rel="prefetch" href="/assets/js/posts_typescript_2.html.70e869a7.js" as="script"><link rel="prefetch" href="/assets/js/zh_posts_algo_其他.html.3faf5ae8.js" as="script"><link rel="prefetch" href="/assets/js/zh_posts_algo_贪心.html.0a8549f7.js" as="script"><link rel="prefetch" href="/assets/js/posts_aws-saa_1.html.12f65834.js" as="script"><link rel="prefetch" href="/assets/js/posts_unimelb_ml.html.930a6c4a.js" as="script"><link rel="prefetch" href="/assets/js/zh_posts_review_数据库.html.b80c36f1.js" as="script"><link rel="prefetch" href="/assets/js/zh_posts_review_计算机网络.html.4feba167.js" as="script"><link rel="prefetch" href="/assets/js/posts_unimelb_COMP90048.html.8968005c.js" as="script"><link rel="prefetch" href="/assets/js/zh_posts_review_计算机组成原理.html.1c8444d9.js" as="script"><link rel="prefetch" href="/assets/js/zh_posts_review_操作系统.html.7a2e9a3b.js" as="script"><link rel="prefetch" href="/assets/js/posts_nextjs_1.html.42f88b26.js" as="script"><link rel="prefetch" href="/assets/js/zh_posts_declarative_prolog速记.html.06d2d57f.js" as="script"><link rel="prefetch" href="/assets/js/8300.ef6ef338.js" as="script"><link rel="prefetch" href="/assets/js/posts_mybatis_2.html.5926ba81.js" as="script"><link rel="prefetch" href="/assets/js/posts_interview_7.html.d2987d20.js" as="script"><link rel="prefetch" href="/assets/js/posts_kubernetes_practices_4.html.d05f7970.js" as="script"><link rel="prefetch" href="/assets/js/posts_kubernetes_practices_5.html.74809557.js" as="script"><link rel="prefetch" href="/assets/js/posts_kubernetes_practices_8.html.48797aee.js" as="script"><link rel="prefetch" href="/assets/js/posts_cmb_2.html.5da88c74.js" as="script"><link rel="prefetch" href="/assets/js/posts_aws-saa_3.html.3976b1b1.js" as="script"><link rel="prefetch" href="/assets/js/posts_nginx_1.html.9d684d75.js" as="script"><link rel="prefetch" href="/assets/js/posts_unimelb_SWEN90016.html.240e6126.js" as="script"><link rel="prefetch" href="/assets/js/zh_posts_algo_双指针.html.7af7f076.js" as="script"><link rel="prefetch" href="/assets/js/zh_posts_algo_哈希.html.756f5c70.js" as="script"><link rel="prefetch" href="/assets/js/posts_spark_Spark-Core.html.d371024a.js" as="script"><link rel="prefetch" href="/assets/js/posts_kubernetes_practices_11.html.acf3feb6.js" as="script"><link rel="prefetch" href="/assets/js/posts_cliché_14.html.6ae00502.js" as="script"><link rel="prefetch" href="/assets/js/posts_interview_8.html.35609b90.js" as="script"><link rel="prefetch" href="/assets/js/posts_interview_4.html.76f297f5.js" as="script"><link rel="prefetch" href="/assets/js/posts_spark_Spark-Sql.html.1a76e157.js" as="script"><link rel="prefetch" href="/assets/js/posts_algorithm_21.html.5d38e92e.js" as="script"><link rel="prefetch" href="/assets/js/zh_posts_review_信息新技术.html.016ea36f.js" as="script"><link rel="prefetch" href="/assets/js/posts_algorithm_11.html.6ac0e485.js" as="script"><link rel="prefetch" href="/assets/js/posts_nextjs_5.html.d6b5776e.js" as="script"><link rel="prefetch" href="/assets/js/posts_nextjs_6.html.9f42e615.js" as="script"><link rel="prefetch" href="/assets/js/posts_kubernetes_practices_10.html.7cfe6b37.js" as="script"><link rel="prefetch" href="/assets/js/posts_kubernetes_practices_1.html.275b2472.js" as="script"><link rel="prefetch" href="/assets/js/posts_kubernetes_practices_6.html.b0bf65af.js" as="script"><link rel="prefetch" href="/assets/js/posts_cliché_4.html.bb865133.js" as="script"><link rel="prefetch" href="/assets/js/zh_posts_algo_单调栈.html.97d2a1c2.js" as="script"><link rel="prefetch" href="/assets/js/posts_cliché_15.html.6ad131ac.js" as="script"><link rel="prefetch" href="/assets/js/posts_aws-saa_2.html.19b4fc69.js" as="script"><link rel="prefetch" href="/assets/js/posts_algorithm_6.html.0ce6907d.js" as="script"><link rel="prefetch" href="/assets/js/posts_nextjs_3.html.07708648.js" as="script"><link rel="prefetch" href="/assets/js/posts_kubernetes_practices_12.html.33aac800.js" as="script"><link rel="prefetch" href="/assets/js/posts_algorithm_14.html.4487a39f.js" as="script"><link rel="prefetch" href="/assets/js/posts_algorithm_13.html.1600cb03.js" as="script"><link rel="prefetch" href="/assets/js/posts_ai_javaai.html.ddef5ab6.js" as="script"><link rel="prefetch" href="/assets/js/posts_algorithm_5.html.c674a286.js" as="script"><link rel="prefetch" href="/assets/js/posts_interview_6.html.c703f5fb.js" as="script"><link rel="prefetch" href="/assets/js/posts_interview_2.html.2012a517.js" as="script"><link rel="prefetch" href="/assets/js/posts_typescript_3.html.67716c58.js" as="script"><link rel="prefetch" href="/assets/js/posts_algorithm_2.html.3cb286a6.js" as="script"><link rel="prefetch" href="/assets/js/posts_algorithm_16.html.47a98467.js" as="script"><link rel="prefetch" href="/assets/js/posts_nextjs_2.html.2faaae84.js" as="script"><link rel="prefetch" href="/assets/js/posts_cliché_7.html.b7a17cf5.js" as="script"><link rel="prefetch" href="/assets/js/posts_interview_3.html.e6de0801.js" as="script"><link rel="prefetch" href="/assets/js/posts_algorithm_12.html.78a79e16.js" as="script"><link rel="prefetch" href="/assets/js/posts_algorithm_17.html.48e4e11f.js" as="script"><link rel="prefetch" href="/assets/js/zh_posts_algo_位运算.html.89a49729.js" as="script"><link rel="prefetch" href="/assets/js/posts_kubernetes_practices_13.html.1af16bb4.js" as="script"><link rel="prefetch" href="/assets/js/intro.html.94b9bc8e.js" as="script"><link rel="prefetch" href="/assets/js/posts_algorithm_9.html.c802974b.js" as="script"><link rel="prefetch" href="/assets/js/posts_algorithm_15.html.c14ce54d.js" as="script"><link rel="prefetch" href="/assets/js/posts_ai_create_mcp.html.7bbd9d99.js" as="script"><link rel="prefetch" href="/assets/js/posts_algorithm_18.html.6db3b8d0.js" as="script"><link rel="prefetch" href="/assets/js/posts_cmb_1.html.52e2c809.js" as="script"><link rel="prefetch" href="/assets/js/posts_ai_mcp.html.97488bfa.js" as="script"><link rel="prefetch" href="/assets/js/posts_mybatis_1.html.0715b7ed.js" as="script"><link rel="prefetch" href="/assets/js/posts_interview_1.html.b4be9a5c.js" as="script"><link rel="prefetch" href="/assets/js/posts_kubernetes_practices_7.html.391ad3ae.js" as="script"><link rel="prefetch" href="/assets/js/posts_istio_1.html.0402dff2.js" as="script"><link rel="prefetch" href="/assets/js/posts_algorithm_4.html.babb3186.js" as="script"><link rel="prefetch" href="/assets/js/posts_kubernetes_practices_15.html.1a066aec.js" as="script"><link rel="prefetch" href="/assets/js/posts_algorithm_10.html.a809572e.js" as="script"><link rel="prefetch" href="/assets/js/posts_algorithm_1.html.3f7ea202.js" as="script"><link rel="prefetch" href="/assets/js/zh_intro.html.4f0fc279.js" as="script"><link rel="prefetch" href="/assets/js/posts_spark_Spark-Intro.html.ccd5e5dd.js" as="script"><link rel="prefetch" href="/assets/js/posts_interview_5.html.e4df8be3.js" as="script"><link rel="prefetch" href="/assets/js/posts_algorithm_19.html.f4de2c0a.js" as="script"><link rel="prefetch" href="/assets/js/posts_kubernetes_concepts_7.html.be9d15e1.js" as="script"><link rel="prefetch" href="/assets/js/posts_algorithm_3.html.1db9eef8.js" as="script"><link rel="prefetch" href="/assets/js/posts_algorithm_7.html.95a6d006.js" as="script"><link rel="prefetch" href="/assets/js/posts_nextjs_8.html.bf7de1dc.js" as="script"><link rel="prefetch" href="/assets/js/zh_posts_algo_字符串.html.7bb4b0c9.js" as="script"><link rel="prefetch" href="/assets/js/posts_algorithm_index.html.964e7b71.js" as="script"><link rel="prefetch" href="/assets/js/posts_cmb_3.html.b6b4d014.js" as="script"><link rel="prefetch" href="/assets/js/posts_hadoop_Hive.html.0678d205.js" as="script"><link rel="prefetch" href="/assets/js/posts_cmb_7.html.97e8c4ab.js" as="script"><link rel="prefetch" href="/assets/js/posts_kubernetes_practices_9.html.daf44b98.js" as="script"><link rel="prefetch" href="/assets/js/posts_hadoop_HDFS.html.bc68b1b5.js" as="script"><link rel="prefetch" href="/assets/js/posts_cliché_index.html.969cd922.js" as="script"><link rel="prefetch" href="/assets/js/posts_kubernetes_practices_2.html.03f4e466.js" as="script"><link rel="prefetch" href="/assets/js/posts_algorithm_8.html.266a2255.js" as="script"><link rel="prefetch" href="/assets/js/posts_nextjs_4.html.f53cce1e.js" as="script"><link rel="prefetch" href="/assets/js/posts_jd_note.html.d14373ad.js" as="script"><link rel="prefetch" href="/assets/js/posts_cliché_5.html.4cdca3c2.js" as="script"><link rel="prefetch" href="/assets/js/posts_kubernetes_concepts_3.html.47cad464.js" as="script"><link rel="prefetch" href="/assets/js/posts_docker_1.html.fb8facad.js" as="script"><link rel="prefetch" href="/assets/js/posts_cliché_11.html.ce50e313.js" as="script"><link rel="prefetch" href="/assets/js/posts_kubernetes_microsvc_1.html.2fe97c3c.js" as="script"><link rel="prefetch" href="/assets/js/posts_kubernetes_practices_index.html.8bdb826b.js" as="script"><link rel="prefetch" href="/assets/js/posts_algorithm_summary.html.dcef505d.js" as="script"><link rel="prefetch" href="/assets/js/posts_cmb_6.html.b6472eba.js" as="script"><link rel="prefetch" href="/assets/js/posts_cliché_6.html.02cce475.js" as="script"><link rel="prefetch" href="/assets/js/zh_posts_review_数学.html.dfdf15d8.js" as="script"><link rel="prefetch" href="/assets/js/posts_cliché_3.html.e8a57164.js" as="script"><link rel="prefetch" href="/assets/js/posts_kubernetes_concepts_6.html.0c46208c.js" as="script"><link rel="prefetch" href="/assets/js/posts_nextjs_7.html.34e04d11.js" as="script"><link rel="prefetch" href="/assets/js/posts_cliché_8.html.ae4c64a3.js" as="script"><link rel="prefetch" href="/assets/js/posts_cmb_4.html.a8ec1263.js" as="script"><link rel="prefetch" href="/assets/js/posts_elasticsearch_query-dsl.html.c10df9f4.js" as="script"><link rel="prefetch" href="/assets/js/posts_cliché_cloudflare.html.8d90577a.js" as="script"><link rel="prefetch" href="/assets/js/posts_algorithm_20.html.490f1029.js" as="script"><link rel="prefetch" href="/assets/js/posts_kubernetes_concepts_1.html.0cac3363.js" as="script"><link rel="prefetch" href="/assets/js/posts_kubernetes_concepts_5.html.a42942da.js" as="script"><link rel="prefetch" href="/assets/js/posts_cliché_2.html.1499c365.js" as="script"><link rel="prefetch" href="/assets/js/posts_cliché_10.html.156d0fc8.js" as="script"><link rel="prefetch" href="/assets/js/posts_cliché_16.html.94f2539e.js" as="script"><link rel="prefetch" href="/assets/js/posts_kubernetes_practices_3.html.2d055dbe.js" as="script"><link rel="prefetch" href="/assets/js/posts_cliché_tools.html.4cf9b015.js" as="script"><link rel="prefetch" href="/assets/js/posts_elasticsearch_1.html.55fea42c.js" as="script"><link rel="prefetch" href="/assets/js/posts_kubernetes_concepts_2.html.4fddb7fe.js" as="script"><link rel="prefetch" href="/assets/js/posts_kubernetes_concepts_index.html.9f6e664a.js" as="script"><link rel="prefetch" href="/assets/js/posts_dubbo_1.html.1f23a627.js" as="script"><link rel="prefetch" href="/assets/js/posts_kubernetes_concepts_4.html.1c4ee376.js" as="script"><link rel="prefetch" href="/assets/js/posts_cliché_9.html.132d4ce9.js" as="script"><link rel="prefetch" href="/assets/js/posts_interview_index.html.3644a432.js" as="script"><link rel="prefetch" href="/assets/js/posts_nextjs_index.html.b114f681.js" as="script"><link rel="prefetch" href="/assets/js/posts_interview_9.html.a3039a5a.js" as="script"><link rel="prefetch" href="/assets/js/posts_cmb_index.html.6e477592.js" as="script"><link rel="prefetch" href="/assets/js/posts_cliché_1.html.ea5597b0.js" as="script"><link rel="prefetch" href="/assets/js/posts_cmb_8.html.bc2310ff.js" as="script"><link rel="prefetch" href="/assets/js/posts_elasticsearch_2.html.965ea244.js" as="script"><link rel="prefetch" href="/assets/js/zh_posts_genesis.html.b92085d2.js" as="script"><link rel="prefetch" href="/assets/js/posts_cmb_5.html.4cfebd9b.js" as="script"><link rel="prefetch" href="/assets/js/posts_unimelb_index.html.77a0d6fd.js" as="script"><link rel="prefetch" href="/assets/js/posts_hadoop_MapReduce.html.66b74478.js" as="script"><link rel="prefetch" href="/assets/js/posts_genesis.html.f2dcbd5d.js" as="script"><link rel="prefetch" href="/assets/js/posts_cliché_12.html.6f85b8a6.js" as="script"><link rel="prefetch" href="/assets/js/posts_cliché_sealos.html.2f8ff09a.js" as="script"><link rel="prefetch" href="/assets/js/posts_hadoop_index.html.30eae38c.js" as="script"><link rel="prefetch" href="/assets/js/posts_dubbo_2.html.4153924b.js" as="script"><link rel="prefetch" href="/assets/js/posts_cliché_13.html.9f0ab2c4.js" as="script"><link rel="prefetch" href="/assets/js/posts_aws-saa_index.html.91a04274.js" as="script"><link rel="prefetch" href="/assets/js/posts_typescript_index.html.3113541a.js" as="script"><link rel="prefetch" href="/assets/js/posts_elasticsearch_index.html.4152a6b9.js" as="script"><link rel="prefetch" href="/assets/js/posts_kubernetes_index.html.c927a97d.js" as="script"><link rel="prefetch" href="/assets/js/index.html.8b8ff801.js" as="script"><link rel="prefetch" href="/assets/js/posts_dubbo_index.html.6c52fb32.js" as="script"><link rel="prefetch" href="/assets/js/posts_hadoop_Yarn.html.94f37571.js" as="script"><link rel="prefetch" href="/assets/js/posts_nginx_index.html.75cc2b5d.js" as="script"><link rel="prefetch" href="/assets/js/posts_ai_index.html.6d4a62d9.js" as="script"><link rel="prefetch" href="/assets/js/posts_mybatis_index.html.f1a73719.js" as="script"><link rel="prefetch" href="/assets/js/posts_spark_index.html.434a7834.js" as="script"><link rel="prefetch" href="/assets/js/posts_kubernetes_microsvc_index.html.7ac9796f.js" as="script"><link rel="prefetch" href="/assets/js/posts_cmb_9.html.e9ae3067.js" as="script"><link rel="prefetch" href="/assets/js/posts_nginx_2.html.61b94ab9.js" as="script"><link rel="prefetch" href="/assets/js/zh_index.html.b526dd8b.js" as="script"><link rel="prefetch" href="/assets/js/posts_tailwind_index.html.a3b1860b.js" as="script"><link rel="prefetch" href="/assets/js/posts_docker_index.html.915fb03b.js" as="script"><link rel="prefetch" href="/assets/js/posts_istio_index.html.d4b67811.js" as="script"><link rel="prefetch" href="/assets/js/posts_note_index.html.79ea061a.js" as="script"><link rel="prefetch" href="/assets/js/category_learning-records_index.html.f32ee64d.js" as="script"><link rel="prefetch" href="/assets/js/tag_nginx_index.html.0fa6f2ea.js" as="script"><link rel="prefetch" href="/assets/js/zh_tag_declarative-programming_index.html.6ae8ae47.js" as="script"><link rel="prefetch" href="/assets/js/category_index.html.50e2e1bc.js" as="script"><link rel="prefetch" href="/assets/js/timeline_index.html.a204d771.js" as="script"><link rel="prefetch" href="/assets/js/article_index.html.ffcd7938.js" as="script"><link rel="prefetch" href="/assets/js/zh_category_学习笔记_index.html.12546e3e.js" as="script"><link rel="prefetch" href="/assets/js/category_internship-journal_index.html.4b3fa613.js" as="script"><link rel="prefetch" href="/assets/js/zh_category_learning-records_index.html.af6fedad.js" as="script"><link rel="prefetch" href="/assets/js/tag_index.html.dbf647b4.js" as="script"><link rel="prefetch" href="/assets/js/star_index.html.7f8a9df9.js" as="script"><link rel="prefetch" href="/assets/js/tag_programmer-cliché_index.html.120cca1a.js" as="script"><link rel="prefetch" href="/assets/js/tag_algorithm-practices_index.html.d975dd18.js" as="script"><link rel="prefetch" href="/assets/js/tag_china-merchant-bank_index.html.de8b373f.js" as="script"><link rel="prefetch" href="/assets/js/tag_technical-interview_index.html.acf61e6f.js" as="script"><link rel="prefetch" href="/assets/js/posts_index.html.c7f3157a.js" as="script"><link rel="prefetch" href="/assets/js/zh_category_开始_index.html.29cb4412.js" as="script"><link rel="prefetch" href="/assets/js/tag_tailwind-css_index.html.7b3e36e9.js" as="script"><link rel="prefetch" href="/assets/js/zh_tag_旅程_index.html.151709c9.js" as="script"><link rel="prefetch" href="/assets/js/zh_tag_简历_index.html.96ae735a.js" as="script"><link rel="prefetch" href="/assets/js/zh_tag_algorithm_index.html.5a457b02.js" as="script"><link rel="prefetch" href="/assets/js/category_genesis_index.html.66947f9e.js" as="script"><link rel="prefetch" href="/assets/js/tag_javascript_index.html.266dcd48.js" as="script"><link rel="prefetch" href="/assets/js/tag_kubernetes_index.html.2b919c53.js" as="script"><link rel="prefetch" href="/assets/js/tag_typescript_index.html.ab5e1572.js" as="script"><link rel="prefetch" href="/assets/js/zh_tag_review_index.html.9bc60916.js" as="script"><link rel="prefetch" href="/assets/js/tag_leetcode_index.html.6b98bbdb.js" as="script"><link rel="prefetch" href="/assets/js/zh_tag_java8_index.html.5b1186ee.js" as="script"><link rel="prefetch" href="/assets/js/zh_tag_netty_index.html.3ede65fb.js" as="script"><link rel="prefetch" href="/assets/js/zh_tag_nginx_index.html.c21f0432.js" as="script"><link rel="prefetch" href="/assets/js/tag_aws-saa_index.html.01a20249.js" as="script"><link rel="prefetch" href="/assets/js/tag_mybatis_index.html.bdbe6d2a.js" as="script"><link rel="prefetch" href="/assets/js/tag_unimelb_index.html.d4bafe83.js" as="script"><link rel="prefetch" href="/assets/js/zh_tag_hive_index.html.fab4d732.js" as="script"><link rel="prefetch" href="/assets/js/tag_docker_index.html.b7d4cbf8.js" as="script"><link rel="prefetch" href="/assets/js/tag_hadoop_index.html.39a6a55f.js" as="script"><link rel="prefetch" href="/assets/js/tag_nextjs_index.html.581d2c34.js" as="script"><link rel="prefetch" href="/assets/js/tag_resume_index.html.c4e4c327.js" as="script"><link rel="prefetch" href="/assets/js/zh_tag_nio_index.html.0a4acee3.js" as="script"><link rel="prefetch" href="/assets/js/tag_dubbo_index.html.90f9e5c2.js" as="script"><link rel="prefetch" href="/assets/js/tag_index_index.html.ee3192d7.js" as="script"><link rel="prefetch" href="/assets/js/tag_istio_index.html.cb329abb.js" as="script"><link rel="prefetch" href="/assets/js/tag_notes_index.html.075779e3.js" as="script"><link rel="prefetch" href="/assets/js/tag_react_index.html.49ec34fb.js" as="script"><link rel="prefetch" href="/assets/js/tag_spark_index.html.287e8a9c.js" as="script"><link rel="prefetch" href="/assets/js/404.html.15229e01.js" as="script"><link rel="prefetch" href="/assets/js/zh_timeline_index.html.3a7839f4.js" as="script"><link rel="prefetch" href="/assets/js/tag_ai_index.html.3120c8b4.js" as="script"><link rel="prefetch" href="/assets/js/tag_es_index.html.8f0f4273.js" as="script"><link rel="prefetch" href="/assets/js/tag_jd_index.html.6c64e177.js" as="script"><link rel="prefetch" href="/assets/js/zh_category_index.html.e65aefca.js" as="script"><link rel="prefetch" href="/assets/js/zh_posts_declarative_index.html.6759320d.js" as="script"><link rel="prefetch" href="/assets/js/zh_article_index.html.2c545722.js" as="script"><link rel="prefetch" href="/assets/js/zh_tag_index.html.6a5580f0.js" as="script"><link rel="prefetch" href="/assets/js/zh_star_index.html.698b9149.js" as="script"><link rel="prefetch" href="/assets/js/zh_posts_review_index.html.6b5498be.js" as="script"><link rel="prefetch" href="/assets/js/zh_posts_java8_index.html.245580da.js" as="script"><link rel="prefetch" href="/assets/js/zh_posts_netty_index.html.9e91bcfd.js" as="script"><link rel="prefetch" href="/assets/js/zh_posts_nginx_index.html.6deedd0e.js" as="script"><link rel="prefetch" href="/assets/js/zh_posts_algo_index.html.d664c5ec.js" as="script"><link rel="prefetch" href="/assets/js/zh_posts_hive_index.html.e3d7d626.js" as="script"><link rel="prefetch" href="/assets/js/zh_posts_index.html.46dc1fe4.js" as="script"><link rel="prefetch" href="/assets/js/posts_jd_index.html.7a8d7890.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="vp-skip-link sr-only">跳至主要內容</a><!--]--><div class="theme-container external-link-icon has-toc" vp-container><!--[--><header id="navbar" class="vp-navbar" vp-navbar><div class="vp-navbar-start"><button type="button" class="vp-toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!----><!--[--><a class="route-link vp-brand" href="/zh/" aria-label="带我回家"><img class="vp-nav-logo" src="/bubu.jpg" alt><!----><span class="vp-site-name hide-in-pad">Ruochen Chen</span></a><!--]--><!----></div><div class="vp-navbar-center"><!----><!--[--><nav class="vp-nav-links"><div class="vp-nav-item hide-in-mobile"><a class="route-link auto-link" href="/zh/" aria-label="主页"><!--[--><span class="font-icon icon fa-fw fa-sm fas fa-home" style=""></span><!--]-->主页<!----></a></div><div class="vp-nav-item hide-in-mobile"><div class="vp-dropdown-wrapper"><button type="button" class="vp-dropdown-title" aria-label="笔记"><!--[--><span class="font-icon icon fa-fw fa-sm fas fa-pen-to-square" style=""></span>笔记<!--]--><span class="arrow"></span><ul class="vp-dropdown"><li class="vp-dropdown-item"><h4 class="vp-dropdown-subtitle">Hive</h4><ul class="vp-dropdown-subitems"><li class="vp-dropdown-subitem"><a class="route-link auto-link" href="/zh/posts/hive/Hive-SQL%E8%AF%AD%E6%B3%95%E5%A4%A7%E5%85%A8.html" aria-label="Hive语法大全"><!--[--><span class="font-icon icon fa-fw fa-sm fas fa-pen-to-square" style=""></span><!--]-->Hive语法大全<!----></a></li></ul></li><li class="vp-dropdown-item"><h4 class="vp-dropdown-subtitle">Java8特性</h4><ul class="vp-dropdown-subitems"><li class="vp-dropdown-subitem"><a class="route-link auto-link" href="/zh/posts/java8/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B.html" aria-label="函数式编程"><!--[--><span class="font-icon icon fa-fw fa-sm fas fa-pen-to-square" style=""></span><!--]-->函数式编程<!----></a></li></ul></li><li class="vp-dropdown-item"><h4 class="vp-dropdown-subtitle">Netty</h4><ul class="vp-dropdown-subitems"><li class="vp-dropdown-subitem"><a class="route-link auto-link" href="/zh/posts/netty/Netty01-nio.html" aria-label="Nio介绍"><!--[--><span class="font-icon icon fa-fw fa-sm fas fa-pen-to-square" style=""></span><!--]-->Nio介绍<!----></a></li><li class="vp-dropdown-subitem"><a class="route-link auto-link" href="/zh/posts/netty/Netty02-intro.html" aria-label="Netty入门"><!--[--><span class="font-icon icon fa-fw fa-sm fas fa-pen-to-square" style=""></span><!--]-->Netty入门<!----></a></li><li class="vp-dropdown-subitem"><a class="route-link auto-link" href="/zh/posts/netty/Netty03-%E8%BF%9B%E9%98%B6.html" aria-label="Netty进阶"><!--[--><span class="font-icon icon fa-fw fa-sm fas fa-pen-to-square" style=""></span><!--]-->Netty进阶<!----></a></li><li class="vp-dropdown-subitem"><a class="route-link auto-link" href="/zh/posts/netty/Netty04-%E4%BC%98%E5%8C%96%E4%B8%8E%E6%BA%90%E7%A0%81.html" aria-label="Netty优化"><!--[--><span class="font-icon icon fa-fw fa-sm fas fa-pen-to-square" style=""></span><!--]-->Netty优化<!----></a></li></ul></li><li class="vp-dropdown-item"><h4 class="vp-dropdown-subtitle">NGINX</h4><ul class="vp-dropdown-subitems"><li class="vp-dropdown-subitem"><a class="route-link auto-link" href="/zh/posts/nginx/1.html" aria-label="NGINX 高级"><!--[--><span class="font-icon icon fa-fw fa-sm fas fa-pen-to-square" style=""></span><!--]-->NGINX 高级<!----></a></li></ul></li></ul></button></div></div></nav><!--]--><!----></div><div class="vp-navbar-end"><!----><!--[--><div class="vp-nav-item"><div class="vp-dropdown-wrapper"><button type="button" class="vp-dropdown-title" aria-label="选择语言"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon i18n-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="i18n icon" name="i18n" style="width:1rem;height:1rem;vertical-align:middle;"><path d="M379.392 460.8 494.08 575.488l-42.496 102.4L307.2 532.48 138.24 701.44l-71.68-72.704L234.496 460.8l-45.056-45.056c-27.136-27.136-51.2-66.56-66.56-108.544h112.64c7.68 14.336 16.896 27.136 26.112 35.84l45.568 46.08 45.056-45.056C382.976 312.32 409.6 247.808 409.6 204.8H0V102.4h256V0h102.4v102.4h256v102.4H512c0 70.144-37.888 161.28-87.04 210.944L378.88 460.8zM576 870.4 512 1024H409.6l256-614.4H768l256 614.4H921.6l-64-153.6H576zM618.496 768h196.608L716.8 532.48 618.496 768z"></path></svg><!--]--><span class="arrow"></span><ul class="vp-dropdown"><li class="vp-dropdown-item"><a class="route-link auto-link" href="/" aria-label="English"><!---->English<!----></a></li><li class="vp-dropdown-item"><a class="route-link route-link-active auto-link" href="/zh/posts/review/%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9.html" aria-label="简体中文"><!---->简体中文<!----></a></li></ul></button></div></div><div class="vp-nav-item vp-action"><a class="vp-action-link" href="https://github.com/Crc011220/Crc011220.github.io" target="_blank" rel="noopener noreferrer" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="github icon" name="github" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></svg></a></div><div class="vp-nav-item hide-in-mobile"><button type="button" class="vp-outlook-button" tabindex="-1" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" class="icon outlook-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="outlook icon" name="outlook"><path d="M224 800c0 9.6 3.2 44.8 6.4 54.4 6.4 48-48 76.8-48 76.8s80 41.6 147.2 0 134.4-134.4 38.4-195.2c-22.4-12.8-41.6-19.2-57.6-19.2C259.2 716.8 227.2 761.6 224 800zM560 675.2l-32 51.2c-51.2 51.2-83.2 32-83.2 32 25.6 67.2 0 112-12.8 128 25.6 6.4 51.2 9.6 80 9.6 54.4 0 102.4-9.6 150.4-32l0 0c3.2 0 3.2-3.2 3.2-3.2 22.4-16 12.8-35.2 6.4-44.8-9.6-12.8-12.8-25.6-12.8-41.6 0-54.4 60.8-99.2 137.6-99.2 6.4 0 12.8 0 22.4 0 12.8 0 38.4 9.6 48-25.6 0-3.2 0-3.2 3.2-6.4 0-3.2 3.2-6.4 3.2-6.4 6.4-16 6.4-16 6.4-19.2 9.6-35.2 16-73.6 16-115.2 0-105.6-41.6-198.4-108.8-268.8C704 396.8 560 675.2 560 675.2zM224 419.2c0-28.8 22.4-51.2 51.2-51.2 28.8 0 51.2 22.4 51.2 51.2 0 28.8-22.4 51.2-51.2 51.2C246.4 470.4 224 448 224 419.2zM320 284.8c0-22.4 19.2-41.6 41.6-41.6 22.4 0 41.6 19.2 41.6 41.6 0 22.4-19.2 41.6-41.6 41.6C339.2 326.4 320 307.2 320 284.8zM457.6 208c0-12.8 12.8-25.6 25.6-25.6 12.8 0 25.6 12.8 25.6 25.6 0 12.8-12.8 25.6-25.6 25.6C470.4 233.6 457.6 220.8 457.6 208zM128 505.6C128 592 153.6 672 201.6 736c28.8-60.8 112-60.8 124.8-60.8-16-51.2 16-99.2 16-99.2l316.8-422.4c-48-19.2-99.2-32-150.4-32C297.6 118.4 128 291.2 128 505.6zM764.8 86.4c-22.4 19.2-390.4 518.4-390.4 518.4-22.4 28.8-12.8 76.8 22.4 99.2l9.6 6.4c35.2 22.4 80 12.8 99.2-25.6 0 0 6.4-12.8 9.6-19.2 54.4-105.6 275.2-524.8 288-553.6 6.4-19.2-3.2-32-19.2-32C777.6 76.8 771.2 80 764.8 86.4z"></path></svg><div class="vp-outlook-dropdown"><!----></div></button></div><!--[--><div id="docsearch-container" style="display:none;"></div><div><button type="button" class="DocSearch DocSearch-Button" aria-label="搜索文档"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">搜索文档</span></span><span class="DocSearch-Button-Keys"><kbd class="DocSearch-Button-Key"><svg width="15" height="15" class="DocSearch-Control-Key-Icon"><path d="M4.505 4.496h2M5.505 5.496v5M8.216 4.496l.055 5.993M10 7.5c.333.333.5.667.5 1v2M12.326 4.5v5.996M8.384 4.496c1.674 0 2.116 0 2.116 1.5s-.442 1.5-2.116 1.5M3.205 9.303c-.09.448-.277 1.21-1.241 1.203C1 10.5.5 9.513.5 8V7c0-1.57.5-2.5 1.464-2.494.964.006 1.134.598 1.24 1.342M12.553 10.5h1.953" stroke-width="1.2" stroke="currentColor" fill="none" stroke-linecap="square"></path></svg></kbd><kbd class="DocSearch-Button-Key">K</kbd></span></button></div><!--]--><!--]--><!----><button type="button" class="vp-toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span><span class="vp-top"></span><span class="vp-middle"></span><span class="vp-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow start"></span></div><aside id="sidebar" class="vp-sidebar" vp-sidebar><!----><ul class="vp-sidebar-links"><li><a class="route-link auto-link vp-sidebar-link" href="/zh/" aria-label="主页"><!--[--><span class="font-icon icon fa-fw fa-sm fas fa-home" style=""></span><!--]-->主页<!----></a></li><li><section class="vp-sidebar-group"><p class="vp-sidebar-header active"><span class="font-icon icon fa-fw fa-sm fas fa-book" style=""></span><span class="vp-sidebar-title">笔记</span><!----></p><ul class="vp-sidebar-links"><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">Algo</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">Declarative</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">Hive</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">Java8</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">Netty</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">Nginx</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable active" type="button"><!----><span class="vp-sidebar-title">Review</span><span class="vp-arrow down"></span></button><ul class="vp-sidebar-links"><li><a class="route-link auto-link vp-sidebar-link" href="/zh/posts/review/%E4%BF%A1%E6%81%AF%E6%96%B0%E6%8A%80%E6%9C%AF.html" aria-label="信息新技术"><!--[--><span class="font-icon icon fa-fw fa-sm fas fa-pen-to-square" style=""></span><!--]-->信息新技术<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/zh/posts/review/%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98.html" aria-label="其他问题"><!--[--><span class="font-icon icon fa-fw fa-sm fas fa-pen-to-square" style=""></span><!--]-->其他问题<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/zh/posts/review/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html" aria-label="操作系统"><!--[--><span class="font-icon icon fa-fw fa-sm fas fa-pen-to-square" style=""></span><!--]-->操作系统<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/zh/posts/review/%E6%95%B0%E5%AD%A6.html" aria-label="数学"><!--[--><span class="font-icon icon fa-fw fa-sm fas fa-pen-to-square" style=""></span><!--]-->数学<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/zh/posts/review/%E6%95%B0%E6%8D%AE%E5%BA%93.html" aria-label="数据库"><!--[--><span class="font-icon icon fa-fw fa-sm fas fa-pen-to-square" style=""></span><!--]-->数据库<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/zh/posts/review/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html" aria-label="数据结构"><!--[--><span class="font-icon icon fa-fw fa-sm fas fa-pen-to-square" style=""></span><!--]-->数据结构<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/zh/posts/review/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.html" aria-label="计算机组成原理"><!--[--><span class="font-icon icon fa-fw fa-sm fas fa-pen-to-square" style=""></span><!--]-->计算机组成原理<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/zh/posts/review/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.html" aria-label="计算机网络"><!--[--><span class="font-icon icon fa-fw fa-sm fas fa-pen-to-square" style=""></span><!--]-->计算机网络<!----></a></li><li><a class="route-link route-link-active auto-link vp-sidebar-link active" href="/zh/posts/review/%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9.html" aria-label="面试要点"><!--[--><span class="font-icon icon fa-fw fa-sm fas fa-pen-to-square" style=""></span><!--]-->面试要点<!----></a></li></ul></section></li><li><a class="route-link auto-link vp-sidebar-link" href="/zh/posts/genesis.html" aria-label="开始"><!--[--><span class="font-icon icon fa-fw fa-sm fas fa-pen-to-square" style=""></span><!--]-->开始<!----></a></li></ul></section></li><li><a class="route-link auto-link vp-sidebar-link" href="/zh/intro.html" aria-label="关于我"><!--[--><span class="font-icon icon fa-fw fa-sm fas fa-circle-info" style=""></span><!--]-->关于我<!----></a></li></ul><!----></aside><!--[--><main id="main-content" class="vp-page"><!--[--><!----><!----><nav class="vp-breadcrumb disable"></nav><div class="vp-page-title"><h1><span class="font-icon icon fa-fw fa-sm fas fa-pen-to-square" style=""></span>面试要点</h1><div class="page-info"><span class="page-author-info" aria-label="作者🖊" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="author icon" name="author"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><span class="page-author-item">Ruochen Chen</span></span><span property="author" content="Ruochen Chen"></span></span><!----><span class="page-date-info" aria-label="写作日期📅" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon" name="calendar"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span data-allow-mismatch="text">2025年7月27日</span><meta property="datePublished" content="2025-07-27T00:00:00.000Z"></span><!----><span class="page-reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon" name="timer"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 67 分钟</span><meta property="timeRequired" content="PT67M"></span><span class="page-category-info" aria-label="分类🌈" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon category-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="category icon" name="category"><path d="M148.41 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H148.41c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.311-40.31zM147.556 553.478H429.73c22.263 0 40.311 18.048 40.311 40.31v282.176c0 22.263-18.048 40.312-40.31 40.312H147.555c-22.263 0-40.311-18.049-40.311-40.312V593.79c0-22.263 18.048-40.311 40.31-40.311zM593.927 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H593.927c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.31-40.31zM730.22 920.502H623.926c-40.925 0-74.22-33.388-74.22-74.425V623.992c0-41.038 33.387-74.424 74.425-74.424h222.085c41.038 0 74.424 33.226 74.424 74.067v114.233c0 10.244-8.304 18.548-18.547 18.548s-18.548-8.304-18.548-18.548V623.635c0-20.388-16.746-36.974-37.33-36.974H624.13c-20.585 0-37.331 16.747-37.331 37.33v222.086c0 20.585 16.654 37.331 37.126 37.331H730.22c10.243 0 18.547 8.304 18.547 18.547 0 10.244-8.304 18.547-18.547 18.547z"></path></svg><!--[--><span class="page-category-item color5 clickable" role="navigation">Learning Records</span><!--]--><meta property="articleSection" content="Learning Records"></span><span class="page-tag-info" aria-label="标签🏷" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon tag-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="tag icon" name="tag"><path d="M939.902 458.563L910.17 144.567c-1.507-16.272-14.465-29.13-30.737-30.737L565.438 84.098h-.402c-3.215 0-5.726 1.005-7.634 2.913l-470.39 470.39a10.004 10.004 0 000 14.164l365.423 365.424c1.909 1.908 4.42 2.913 7.132 2.913s5.223-1.005 7.132-2.913l470.39-470.39c2.01-2.11 3.014-5.023 2.813-8.036zm-240.067-72.121c-35.458 0-64.286-28.828-64.286-64.286s28.828-64.285 64.286-64.285 64.286 28.828 64.286 64.285-28.829 64.286-64.286 64.286z"></path></svg><!--[--><span class="page-tag-item color0 clickable" role="navigation">Review</span><!--]--><meta property="keywords" content="Review"></span></div><hr></div><div class="vp-toc-placeholder"><aside id="toc" vp-toc><!----><div class="vp-toc-header">此页内容<button type="button" class="print-button" title="打印"><svg xmlns="http://www.w3.org/2000/svg" class="icon print-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="print icon" name="print"><path d="M819.2 364.8h-44.8V128c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v236.8h-44.8C145.067 364.8 96 413.867 96 473.6v192c0 59.733 49.067 108.8 108.8 108.8h44.8V896c0 17.067 14.933 32 32 32h460.8c17.067 0 32-14.933 32-32V774.4h44.8c59.733 0 108.8-49.067 108.8-108.8v-192c0-59.733-49.067-108.8-108.8-108.8zM313.6 160h396.8v204.8H313.6V160zm396.8 704H313.6V620.8h396.8V864zM864 665.6c0 25.6-19.2 44.8-44.8 44.8h-44.8V588.8c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v121.6h-44.8c-25.6 0-44.8-19.2-44.8-44.8v-192c0-25.6 19.2-44.8 44.8-44.8h614.4c25.6 0 44.8 19.2 44.8 44.8v192z"></path></svg></button><div class="arrow end"></div></div><div class="vp-toc-wrapper"><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#java基础">Java基础</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_1-equals-和-的区别-如何正确重写-equals-和-hashcode-方法-为什么需要同时重写">1. equals() 和 == 的区别？如何正确重写 equals() 和 hashCode() 方法？为什么需要同时重写？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_2-接口和抽象类的区别-何时用接口-何时用抽象类">2. 接口和抽象类的区别？何时用接口？何时用抽象类？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_3-string-vs-stringbuffer-vs-stringbuilder">3. String vs StringBuffer vs StringBuilder</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_4-自动装箱与拆箱原理及潜在问题">4. 自动装箱与拆箱原理及潜在问题</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_5-bio、nio、aio的区别">5. BIO、NIO、AIO的区别？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_6-select、poll、epoll的区别">6. Select、Poll、Epoll的区别</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#集合">集合</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_1-hashmap-的实现原理-jdk-1-7和1-8的区别-hash-方法的作用-如何处理哈希冲突">1. HashMap 的实现原理？JDK 1.7和1.8的区别？hash()方法的作用？如何处理哈希冲突？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_2-concurrenthashmap-如何实现线程安全">2. ConcurrentHashMap 如何实现线程安全？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_3-arraylist-和-linkedlist-的底层实现、时间复杂度">3. ArrayList 和 LinkedList 的底层实现、时间复杂度？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_4-iterator-和-listiterator-的区别-fail-fast-和-fail-safe-机制">4. Iterator 和 ListIterator 的区别？fail-fast 和 fail-safe 机制？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_5-如何保证集合的线程安全">5. 如何保证集合的线程安全？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_6-comparable-和-comparator-接口的区别">6. Comparable 和 Comparator 接口的区别？</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#多线程">多线程</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_1-进程和线程的区别-创建线程的几种方式-哪种更推荐">1. 进程和线程的区别？创建线程的几种方式？哪种更推荐？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_2-sleep-wait-yield-join-方法的区别">2. sleep(), wait(), yield(), join() 方法的区别？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_3-上下文切换是什么-开销在哪里">3. 上下文切换是什么？开销在哪里？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_4-什么是线程安全-如何理解原子性、可见性、有序性">4. 什么是线程安全？如何理解原子性、可见性、有序性？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_5-synchronized-关键字的原理-使用方式-锁升级过程">5. synchronized 关键字的原理？使用方式？锁升级过程？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_6-volatile-关键字的语义-原理-能保证原子性吗-适用场景">6. volatile 关键字的语义？原理？能保证原子性吗？适用场景？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_7-synchronized-和-volatile-的区别">7. synchronized 和 volatile 的区别？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_8-cas-操作的原理-atomic类实现-aba问题及解决方案">8. CAS 操作的原理？Atomic类实现？ABA问题及解决方案？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_9-threadlocal-的原理-使用场景-内存泄漏问题及如何避免">9. ThreadLocal 的原理？使用场景？内存泄漏问题及如何避免？</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#数据库">数据库</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_1-sql基础语法-ddl-dml-dql-dcl-常用函数">1. SQL基础语法（DDL, DML, DQL, DCL）？常用函数？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_2-mysql核心区别-事务、锁、外键、索引结构">2. MySQL核心区别（事务、锁、外键、索引结构）？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_3-索引-什么是索引-为什么能提高查询效率-索引的优缺点">3. 索引：什么是索引？为什么能提高查询效率？索引的优缺点？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_4-b-树索引结构-为什么mysql使用b-树而不是b树或哈希表">4. B+树索引结构？为什么MySQL使用B+树而不是B树或哈希表？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_5-聚集索引和非聚集索引的区别-innodb的主键索引结构">5. 聚集索引和非聚集索引的区别？InnoDB的主键索引结构？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_6-索引类型分类">6. 索引类型分类？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_7-索引失效的常见场景">7. 索引失效的常见场景？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_8-explain命令的作用-关键字段的含义">8. EXPLAIN命令的作用？关键字段的含义？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_9-锁-innodb的行锁、间隙锁、临键锁-mvcc的原理-如何解决幻读">9. 锁：InnoDB的行锁、间隙锁、临键锁？MVCC的原理？如何解决幻读？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_10-事务隔离级别-mysql默认级别-不同级别解决的问题">10. 事务隔离级别？MySQL默认级别？不同级别解决的问题？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_11-如何优化慢查询">11. 如何优化慢查询？</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#redis">Redis</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_1-redis是什么-常用数据类型及其底层实现和典型应用场景">1. Redis是什么？常用数据类型及其底层实现和典型应用场景？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_2-redis为什么快">2. Redis为什么快？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_3-redis的持久化机制-优缺点-如何选择">3. Redis的持久化机制？优缺点？如何选择？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_4-redis的过期键删除策略">4. Redis的过期键删除策略？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_5-内存淘汰策略">5. 内存淘汰策略？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_6-如何保证redis的高可用-redis-cluster的槽分配原理">6. 如何保证Redis的高可用？Redis Cluster的槽分配原理？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_7-缓存穿透、缓存击穿、缓存雪崩的概念、原因及解决方案">7. 缓存穿透、缓存击穿、缓存雪崩的概念、原因及解决方案？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_8-如何设计一个分布式锁-watch-dog机制">8. 如何设计一个分布式锁？Watch Dog机制？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_9-redis哨兵的原理-如何实现故障转移">9. Redis哨兵的原理？如何实现故障转移？</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#分布式">分布式</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_1-cap理论-base理论">1. CAP理论？BASE理论？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_2-分布式事务的解决方案">2. 分布式事务的解决方案？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_3-分布式锁的实现">3. 分布式锁的实现？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_4-分布式id生成方案">4. 分布式ID生成方案？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_5-负载均衡算法">5. 负载均衡算法？</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#微服务">微服务</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_1-微服务的优势和挑战">1. 微服务的优势和挑战？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_2-服务注册与发现-原理-常用组件-比较">2. 服务注册与发现：原理？常用组件？比较？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_3-服务调用-restful-api-和-rpc-dubbo-grpc-比较">3. 服务调用：RESTful API 和 RPC (Dubbo, gRPC)？比较？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_4-服务网关-api-gateway-作用-常用组件">4. 服务网关 (API Gateway)：作用？常用组件？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_5-配置中心-作用-常用组件">5. 配置中心：作用？常用组件？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_6-服务容错-熔断、降级、限流-令牌桶、漏桶-sentinel和hystrix">6. 服务容错：熔断、降级、限流 (令牌桶、漏桶)，Sentinel和Hystrix？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_7-链路追踪-目的-原理-常用组件-zipkin-skywalking">7. 链路追踪：目的？原理？常用组件 (Zipkin, SkyWalking)？</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#消息队列">消息队列</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_1-消息队列的作用-解耦、异步、削峰填谷">1. 消息队列的作用？（解耦、异步、削峰填谷）</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_2-消息模型-点对点queue和发布-订阅topic">2. 消息模型？（点对点Queue和发布/订阅Topic）</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_3-如何保证消息不丢失">3. 如何保证消息不丢失？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_4-如何保证消息不被重复消费-幂等性">4. 如何保证消息不被重复消费（幂等性）？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_5-如何保证消息的顺序性">5. 如何保证消息的顺序性？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_6-常用消息队列比较-kafka、rabbitmq、rocketmq">6. 常用消息队列比较？（Kafka、RabbitMQ、RocketMQ）</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#主流框架、系统设计、编码能力">主流框架、系统设计、编码能力</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_1-spring方向-ioc-控制反转-di-依赖注入-aop-面向切面编程">1. Spring方向 - (IoC - 控制反转 / DI - 依赖注入, AOP - 面向切面编程)</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_2-aop-面向切面编程">2. AOP (面向切面编程)</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_3-spring事务管理">3. Spring事务管理</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_4-spring-mvc的工作原理-核心组件-处理请求的流程">4. Spring MVC的工作原理？核心组件？处理请求的流程？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_5-1-一级缓存和二级缓存的区别">5.1 一级缓存和二级缓存的区别？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_5-2-resultmap-和-resulttype-的区别">5.2 ResultMap 和 ResultType 的区别？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_5-3-延迟加载-懒加载-的原理和配置">5.3 延迟加载（懒加载）的原理和配置？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_5-4-如何实现分页">5.4 如何实现分页？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_6-设计一个秒杀系统">6. 设计一个秒杀系统</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_7-各类主流算法">7. 各类主流算法</a></li><!----><!--]--></ul></li><!--]--></ul><div class="vp-toc-marker" style="top:-1.7rem;"></div></div><!----></aside></div><!----><div class="theme-hope-content" vp-content><h1 id="面试要点" tabindex="-1"><a class="header-anchor" href="#面试要点"><span>面试要点</span></a></h1><h2 id="java基础" tabindex="-1"><a class="header-anchor" href="#java基础"><span>Java基础</span></a></h2><h3 id="_1-equals-和-的区别-如何正确重写-equals-和-hashcode-方法-为什么需要同时重写" tabindex="-1"><a class="header-anchor" href="#_1-equals-和-的区别-如何正确重写-equals-和-hashcode-方法-为什么需要同时重写"><span>1. equals() 和 == 的区别？如何正确重写 equals() 和 hashCode() 方法？为什么需要同时重写？</span></a></h3><h4 id="和-equals-的区别" tabindex="-1"><a class="header-anchor" href="#和-equals-的区别"><span>== 和 equals() 的区别</span></a></h4><ul><li><strong>== 操作符</strong>：对于基本数据类型比较值，对于引用类型比较内存地址</li><li><strong>equals() 方法</strong>：Object类默认实现是比较引用，String等类重写后比较内容</li></ul><h4 id="正确重写的五个原则" tabindex="-1"><a class="header-anchor" href="#正确重写的五个原则"><span>正确重写的五个原则</span></a></h4><ol><li><strong>自反性</strong>：x.equals(x) 必须返回 true</li><li><strong>对称性</strong>：x.equals(y) 和 y.equals(x) 结果相同</li><li><strong>传递性</strong>：如果 x.equals(y) 且 y.equals(z)，则 x.equals(z)</li><li><strong>一致性</strong>：多次调用结果一致</li><li><strong>非空性</strong>：x.equals(null) 返回 false</li></ol><h4 id="为什么要同时重写" tabindex="-1"><a class="header-anchor" href="#为什么要同时重写"><span>为什么要同时重写？</span></a></h4><p>因为HashMap/HashSet的工作机制：先用hashCode()确定存储位置，再用equals()处理哈希冲突。如果不同时重写会导致相等对象无法在HashMap中正确查找。Java约定：如果两个对象equals()返回true，它们的hashCode()必须相同。</p><ul><li>equals 方法判断两个对象是相等的，那这两个对象的 hashCode 值也要相等。</li><li>两个对象有相同的 hashCode 值，他们也不一定是相等的（哈希碰撞）。</li></ul><table><thead><tr><th>问题</th><th>结论</th></tr></thead><tbody><tr><td><code>equals()</code> 比较什么？</td><td>值是否相等</td></tr><tr><td><code>hashCode()</code> 用来干嘛？</td><td>快速查找桶</td></tr><tr><td>为什么要同时重写？</td><td>保证集合类正常工作，避免逻辑错误</td></tr><tr><td>不重写会怎样？</td><td>数据重复、查找失败、逻辑异常</td></tr></tbody></table><h3 id="_2-接口和抽象类的区别-何时用接口-何时用抽象类" tabindex="-1"><a class="header-anchor" href="#_2-接口和抽象类的区别-何时用接口-何时用抽象类"><span>2. 接口和抽象类的区别？何时用接口？何时用抽象类？</span></a></h3><h4 id="主要区别" tabindex="-1"><a class="header-anchor" href="#主要区别"><span>主要区别</span></a></h4><ul><li><strong>继承关系</strong>：接口支持多实现，抽象类只能单继承</li><li><strong>方法</strong>：接口Java8前只有抽象方法，抽象类可以有具体实现</li><li><strong>成员变量</strong>：接口只能有常量，抽象类可以有各种成员变量</li><li><strong>构造方法</strong>：接口不能有，抽象类可以有</li></ul><h4 id="使用场景" tabindex="-1"><a class="header-anchor" href="#使用场景"><span>使用场景</span></a></h4><ul><li><strong>接口</strong>：定义契约规范、实现多重&quot;继承&quot;、强调&quot;能做什么&quot;（can-do关系）</li><li><strong>抽象类</strong>：代码复用、提供部分实现、强调&quot;是什么&quot;（is-a关系）、需要有状态</li></ul><table><thead><tr><th>特性</th><th>接口</th><th>抽象类</th></tr></thead><tbody><tr><td>继承关系</td><td>可实现多个</td><td>只能继承一个</td></tr><tr><td>方法实现</td><td>抽象方法+默认方法（Java8+）</td><td>抽象方法+具体方法</td></tr><tr><td>成员变量</td><td>只能有常量</td><td>可以有各种类型变量</td></tr><tr><td>构造方法</td><td>不能有</td><td>可以有</td></tr><tr><td>关系类型</td><td>can-do（能做什么）</td><td>is-a（是什么）</td></tr><tr><td>使用场景</td><td>定义规范、多重继承</td><td>代码复用、部分实现、有状态</td></tr></tbody></table><h3 id="_3-string-vs-stringbuffer-vs-stringbuilder" tabindex="-1"><a class="header-anchor" href="#_3-string-vs-stringbuffer-vs-stringbuilder"><span>3. String vs StringBuffer vs StringBuilder</span></a></h3><h4 id="特性对比" tabindex="-1"><a class="header-anchor" href="#特性对比"><span>特性对比</span></a></h4><ul><li><strong>String</strong>：不可变，线程安全，频繁操作性能差，会创建大量临时对象</li><li><strong>StringBuffer</strong>：可变，线程安全（synchronized），适合多线程环境</li><li><strong>StringBuilder</strong>：可变，线程不安全，单线程环境性能最佳</li></ul><h4 id="选择原则" tabindex="-1"><a class="header-anchor" href="#选择原则"><span>选择原则</span></a></h4><ul><li><strong>String</strong>：字符串很少改变的情况</li><li><strong>StringBuffer</strong>：多线程环境下的字符串频繁操作</li><li><strong>StringBuilder</strong>：单线程环境下的字符串频繁操作</li></ul><table><thead><tr><th>特性</th><th>String</th><th>StringBuffer</th><th>StringBuilder</th></tr></thead><tbody><tr><td>可变性</td><td>不可变</td><td>可变</td><td>可变</td></tr><tr><td>线程安全</td><td>安全（不可变）</td><td>安全（同步）</td><td>不安全</td></tr><tr><td>性能</td><td>频繁操作差</td><td>中等</td><td>最佳</td></tr><tr><td>内存使用</td><td>创建新对象</td><td>内部缓冲区</td><td>内部缓冲区</td></tr><tr><td>适用场景</td><td>少量操作</td><td>多线程字符串操作</td><td>单线程字符串操作</td></tr></tbody></table><h3 id="_4-自动装箱与拆箱原理及潜在问题" tabindex="-1"><a class="header-anchor" href="#_4-自动装箱与拆箱原理及潜在问题"><span>4. 自动装箱与拆箱原理及潜在问题</span></a></h3><h4 id="基本概念" tabindex="-1"><a class="header-anchor" href="#基本概念"><span>基本概念</span></a></h4><ul><li><strong>自动装箱</strong>：基本类型自动转换为包装类型（如int→Integer）</li><li><strong>自动拆箱</strong>：包装类型自动转换为基本类型</li><li><strong>实现原理</strong>：编译器自动插入valueOf()和xxxValue()方法调用</li></ul><h4 id="四大潜在问题" tabindex="-1"><a class="header-anchor" href="#四大潜在问题"><span>四大潜在问题</span></a></h4><ol><li><strong>缓存范围问题</strong>：-128到127范围内的Integer对象会被缓存复用，超出范围会创建新对象</li><li><strong>性能问题</strong>：频繁装箱拆箱会影响性能，特别是在循环中</li><li><strong>NullPointerException</strong>：null的包装类型拆箱时会抛NPE</li><li><strong>三目运算符陷阱</strong>：类型不一致时编译器会自动拆箱，可能导致NPE</li></ol><h4 id="最佳实践" tabindex="-1"><a class="header-anchor" href="#最佳实践"><span>最佳实践</span></a></h4><p>尽量使用基本类型、比较包装类型用equals()、避免循环中频繁装箱拆箱、注意缓存范围、小心null值拆箱</p><table><thead><tr><th>问题类型</th><th>具体表现</th><th>解决方案</th></tr></thead><tbody><tr><td>缓存范围问题</td><td>-128~127外用==比较结果为false</td><td>用equals()比较</td></tr><tr><td>性能问题</td><td>循环中频繁装箱拆箱</td><td>使用基本类型</td></tr><tr><td>NPE问题</td><td>null包装类型拆箱时抛异常</td><td>判空或使用基本类型</td></tr><tr><td>三目运算符陷阱</td><td>类型不一致导致自动拆箱NPE</td><td>保证两边类型一致</td></tr><tr><td>最佳实践</td><td>什么时候用包装类型？</td><td>需要null值或泛型时才用</td></tr></tbody></table><h3 id="_5-bio、nio、aio的区别" tabindex="-1"><a class="header-anchor" href="#_5-bio、nio、aio的区别"><span>5. BIO、NIO、AIO的区别？</span></a></h3><h4 id="i-o模型核心概念" tabindex="-1"><a class="header-anchor" href="#i-o模型核心概念"><span>I/O模型核心概念</span></a></h4><p><strong>BIO、NIO、AIO三种I/O模型对比：</strong></p><table><thead><tr><th>特性</th><th>BIO（同步阻塞）</th><th>NIO（同步非阻塞）</th><th>AIO（异步非阻塞）</th></tr></thead><tbody><tr><td>全称</td><td>Blocking I/O</td><td>Non-blocking I/O</td><td>Asynchronous I/O</td></tr><tr><td>阻塞性</td><td>阻塞</td><td>非阻塞</td><td>异步</td></tr><tr><td>同步性</td><td>同步</td><td>同步</td><td>异步</td></tr><tr><td>线程模型</td><td>一线程一连接</td><td>一线程处理多连接</td><td>一线程处理多连接</td></tr><tr><td>API复杂度</td><td>简单</td><td>复杂</td><td>复杂</td></tr><tr><td>适用场景</td><td>连接数少、并发度低</td><td>连接数多、并发度高</td><td>连接数多、并发度高</td></tr></tbody></table><h4 id="工作原理对比" tabindex="-1"><a class="header-anchor" href="#工作原理对比"><span>工作原理对比</span></a></h4><table><thead><tr><th>I/O模型</th><th>工作原理</th><th>线程利用率</th><th>内存消耗</th><th>CPU利用率</th></tr></thead><tbody><tr><td>BIO</td><td>每个连接创建一个线程，线程阻塞等待I/O完成</td><td>低</td><td>高</td><td>低</td></tr><tr><td>NIO</td><td>一个线程通过Selector轮询多个Channel</td><td>高</td><td>中</td><td>高</td></tr><tr><td>AIO</td><td>操作系统完成I/O后通知应用程序</td><td>高</td><td>低</td><td>中</td></tr></tbody></table><h4 id="性能特性对比" tabindex="-1"><a class="header-anchor" href="#性能特性对比"><span>性能特性对比</span></a></h4><table><thead><tr><th>性能指标</th><th>BIO</th><th>NIO</th><th>AIO</th></tr></thead><tbody><tr><td>吞吐量</td><td>低（受线程数限制）</td><td>高</td><td>高</td></tr><tr><td>延迟</td><td>中等</td><td>低</td><td>最低</td></tr><tr><td>内存占用</td><td>高（大量线程栈）</td><td>中等</td><td>低</td></tr><tr><td>CPU消耗</td><td>低（大量阻塞等待）</td><td>中等</td><td>低</td></tr><tr><td>可扩展性</td><td>差</td><td>好</td><td>最好</td></tr></tbody></table><h4 id="编程模型对比" tabindex="-1"><a class="header-anchor" href="#编程模型对比"><span>编程模型对比</span></a></h4><table><thead><tr><th>模型</th><th>编程模型</th><th>事件处理</th><th>错误处理</th><th>学习成本</th></tr></thead><tbody><tr><td>BIO</td><td>顺序编程，符合人类思维</td><td>同步处理</td><td>try-catch</td><td>低</td></tr><tr><td>NIO</td><td>事件驱动，需要状态机管理</td><td>事件循环</td><td>复杂</td><td>高</td></tr><tr><td>AIO</td><td>回调驱动，异步编程</td><td>回调函数</td><td>回调地狱</td><td>高</td></tr></tbody></table><h4 id="实际应用场景选择" tabindex="-1"><a class="header-anchor" href="#实际应用场景选择"><span>实际应用场景选择</span></a></h4><table><thead><tr><th>应用场景</th><th>推荐模型</th><th>选择理由</th><th>注意事项</th></tr></thead><tbody><tr><td>Web服务器</td><td>NIO</td><td>大量连接，请求处理时间短</td><td>需要处理粘包拆包问题</td></tr><tr><td>文件服务器</td><td>BIO</td><td>文件I/O多为顺序操作，编程简单</td><td>控制并发连接数</td></tr><tr><td>即时通讯</td><td>NIO</td><td>长连接，需要高并发</td><td>心跳检测，连接管理</td></tr><tr><td>游戏服务器</td><td>AIO</td><td>实时性要求高，性能敏感</td><td>回调处理复杂</td></tr><tr><td>数据库连接池</td><td>BIO</td><td>连接数可控，操作多为短连接</td><td>连接复用</td></tr><tr><td>大数据传输</td><td>AIO</td><td>大文件传输，异步处理效率高</td><td>需要处理传输中断</td></tr></tbody></table><h4 id="技术选型决策" tabindex="-1"><a class="header-anchor" href="#技术选型决策"><span>技术选型决策</span></a></h4><table><thead><tr><th>考虑因素</th><th>权重</th><th>BIO评分</th><th>NIO评分</th><th>AIO评分</th><th>说明</th></tr></thead><tbody><tr><td>开发难度（20%）</td><td>20%</td><td>9</td><td>6</td><td>5</td><td>BIO最简单</td></tr><tr><td>性能表现（30%）</td><td>30%</td><td>4</td><td>8</td><td>9</td><td>AIO性能最好</td></tr><tr><td>并发能力（25%）</td><td>25%</td><td>3</td><td>8</td><td>9</td><td>NIO/AIO并发能力强</td></tr><tr><td>稳定性（15%）</td><td>15%</td><td>9</td><td>7</td><td>6</td><td>BIO最稳定</td></tr><tr><td>生态成熟度（10%）</td><td>10%</td><td>10</td><td>8</td><td>5</td><td>BIO生态最成熟</td></tr><tr><td><strong>加权总分</strong></td><td></td><td><strong>5.9</strong></td><td><strong>7.3</strong></td><td><strong>7.4</strong></td><td>AIO综合评分略高</td></tr></tbody></table><h3 id="_6-select、poll、epoll的区别" tabindex="-1"><a class="header-anchor" href="#_6-select、poll、epoll的区别"><span>6. Select、Poll、Epoll的区别</span></a></h3><p><strong>I/O多路复用机制对比：</strong></p><table><thead><tr><th>特性</th><th>Select</th><th>Poll</th><th>Epoll</th></tr></thead><tbody><tr><td>操作系统支持</td><td>几乎所有Unix/Linux</td><td>Unix/Linux</td><td>仅Linux</td></tr><tr><td>文件描述符限制</td><td>有限制（通常1024）</td><td>无硬性限制</td><td>无限制</td></tr><tr><td>数据结构</td><td>bitmap位图</td><td>链表</td><td>红黑树+双链表</td></tr><tr><td>时间复杂度</td><td>O(n)</td><td>O(n)</td><td>O(1)</td></tr><tr><td>内存拷贝</td><td>每次调用都要拷贝</td><td>每次调用都要拷贝</td><td>使用mmap减少拷贝</td></tr><tr><td>工作模式</td><td>水平触发</td><td>水平触发</td><td>水平触发+边缘触发</td></tr></tbody></table><p><strong>工作原理对比：</strong></p><table><thead><tr><th>机制</th><th>工作流程</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>Select</td><td>轮询所有fd，返回就绪的fd集合</td><td>跨平台兼容性好</td><td>性能差、fd数量限制</td></tr><tr><td>Poll</td><td>与select类似，但使用链表存储fd</td><td>没有fd数量限制</td><td>性能仍然较差</td></tr><tr><td>Epoll</td><td>基于事件通知，只返回活跃的fd</td><td>高性能、支持大量连接</td><td>仅支持Linux</td></tr></tbody></table><p><strong>适用场景选择：</strong></p><table><thead><tr><th>应用场景</th><th>推荐方案</th><th>选择理由</th></tr></thead><tbody><tr><td>跨平台开发</td><td>Select</td><td>兼容性最好</td></tr><tr><td>中等并发量</td><td>Poll</td><td>无fd限制，实现简单</td></tr><tr><td>高并发服务器</td><td>Epoll</td><td>性能最优，支持大量连接</td></tr><tr><td>实时性要求高</td><td>Epoll+ET</td><td>边缘触发减少系统调用</td></tr><tr><td>传统网络编程</td><td>Select/Poll</td><td>编程模型简单，易于理解</td></tr></tbody></table><p><strong>最佳实践建议：</strong></p><table><thead><tr><th>实践建议</th><th>具体做法</th><th>预期效果</th></tr></thead><tbody><tr><td>根据平台选择技术</td><td>Linux优选Epoll，其他平台用Poll</td><td>最大化性能收益</td></tr><tr><td>合理设置事件模式</td><td>高性能场景使用ET模式</td><td>减少系统调用开销</td></tr><tr><td>注意内存管理</td><td>Epoll需要合理管理事件结构体</td><td>避免内存泄漏</td></tr><tr><td>错误处理要完善</td><td>特别是EAGAIN、EINTR等错误</td><td>提高程序健壮性</td></tr><tr><td>结合线程池使用</td><td>I/O多路复用+工作线程池</td><td>平衡并发能力和资源消耗</td></tr></tbody></table><h2 id="集合" tabindex="-1"><a class="header-anchor" href="#集合"><span>集合</span></a></h2><h3 id="_1-hashmap-的实现原理-jdk-1-7和1-8的区别-hash-方法的作用-如何处理哈希冲突" tabindex="-1"><a class="header-anchor" href="#_1-hashmap-的实现原理-jdk-1-7和1-8的区别-hash-方法的作用-如何处理哈希冲突"><span>1. HashMap 的实现原理？JDK 1.7和1.8的区别？hash()方法的作用？如何处理哈希冲突？</span></a></h3><h4 id="实现原理" tabindex="-1"><a class="header-anchor" href="#实现原理"><span>实现原理</span></a></h4><p>HashMap基于数组+链表/红黑树的数据结构，通过hash算法将key映射到数组索引位置。</p><h4 id="jdk-1-7-vs-1-8-主要区别" tabindex="-1"><a class="header-anchor" href="#jdk-1-7-vs-1-8-主要区别"><span>JDK 1.7 vs 1.8 主要区别</span></a></h4><ul><li><strong>数据结构</strong>：1.7是数组+链表，1.8是数组+链表+红黑树</li><li><strong>插入方式</strong>：1.7头插法（并发环境可能死循环），1.8尾插法</li><li><strong>扩容时机</strong>：1.7先扩容再插入，1.8先插入再扩容</li><li><strong>hash算法</strong>：1.8优化了hash算法，减少碰撞</li></ul><h4 id="hash-方法作用" tabindex="-1"><a class="header-anchor" href="#hash-方法作用"><span>hash()方法作用</span></a></h4><p>将key的hashCode进行二次hash，让hash值更均匀分布，减少哈希冲突。</p><h4 id="哈希冲突处理" tabindex="-1"><a class="header-anchor" href="#哈希冲突处理"><span>哈希冲突处理</span></a></h4><ol><li><strong>链表法</strong>：相同hash值的元素用链表连接</li><li><strong>红黑树优化</strong>：当链表长度≥8且数组长度≥64时，链表转红黑树。当红黑树节点数小于6时，转回链表</li><li><strong>扩容机制</strong>：负载因子超过0.75时，数组容量翻倍</li></ol><table><thead><tr><th>版本对比</th><th>JDK 1.7</th><th>JDK 1.8</th></tr></thead><tbody><tr><td>数据结构</td><td>数组+链表</td><td>数组+链表+红黑树</td></tr><tr><td>插入方式</td><td>头插法</td><td>尾插法</td></tr><tr><td>链表转树</td><td>无</td><td>链表长度≥8且数组长度≥64时</td></tr><tr><td>扩容时机</td><td>先扩容再插入</td><td>先插入再扩容</td></tr><tr><td>并发问题</td><td>可能死循环</td><td>避免了死循环</td></tr></tbody></table><h3 id="_2-concurrenthashmap-如何实现线程安全" tabindex="-1"><a class="header-anchor" href="#_2-concurrenthashmap-如何实现线程安全"><span>2. ConcurrentHashMap 如何实现线程安全？</span></a></h3><h4 id="jdk-1-7-分段锁机制" tabindex="-1"><a class="header-anchor" href="#jdk-1-7-分段锁机制"><span>JDK 1.7：分段锁机制</span></a></h4><ul><li><strong>Segment数组</strong>：将HashMap分成多个段，每个段有独立的锁</li><li><strong>锁粒度</strong>：只锁需要操作的段，其他段可并发访问</li><li><strong>并发度</strong>：默认16个段，最多支持16个线程同时写入</li></ul><h4 id="jdk-1-8-cas-synchronized" tabindex="-1"><a class="header-anchor" href="#jdk-1-8-cas-synchronized"><span>JDK 1.8：CAS + synchronized</span></a></h4><ul><li><strong>取消Segment</strong>：直接在Node节点上加锁</li><li><strong>CAS操作</strong>：数组元素为空时用CAS插入</li><li><strong>synchronized</strong>：发生冲突时锁住链表/红黑树的头节点</li><li><strong>更细粒度</strong>：锁的是具体的hash桶，并发性能更好</li></ul><table><thead><tr><th>版本</th><th>JDK 1.7</th><th>JDK 1.8</th></tr></thead><tbody><tr><td>锁机制</td><td>分段锁（Segment）</td><td>CAS + synchronized</td></tr><tr><td>锁粒度</td><td>段级别</td><td>节点级别</td></tr><tr><td>并发度</td><td>最多16个写线程</td><td>理论上无限制</td></tr><tr><td>内存占用</td><td>Segment额外开销</td><td>更少的内存开销</td></tr><tr><td>性能</td><td>读写分离，性能较好</td><td>读写性能都更优</td></tr></tbody></table><h3 id="_3-arraylist-和-linkedlist-的底层实现、时间复杂度" tabindex="-1"><a class="header-anchor" href="#_3-arraylist-和-linkedlist-的底层实现、时间复杂度"><span>3. ArrayList 和 LinkedList 的底层实现、时间复杂度？</span></a></h3><h4 id="底层实现" tabindex="-1"><a class="header-anchor" href="#底层实现"><span>底层实现</span></a></h4><ul><li><strong>ArrayList</strong>：动态数组，连续内存空间存储</li><li><strong>LinkedList</strong>：双向链表，节点包含data、prev、next指针</li></ul><h4 id="时间复杂度对比" tabindex="-1"><a class="header-anchor" href="#时间复杂度对比"><span>时间复杂度对比</span></a></h4><table><thead><tr><th>操作</th><th>ArrayList</th><th>LinkedList</th></tr></thead><tbody><tr><td>随机访问</td><td>O(1)</td><td>O(n)</td></tr><tr><td>头部插入</td><td>O(n)</td><td>O(1)</td></tr><tr><td>尾部插入</td><td>O(1)</td><td>O(1)</td></tr><tr><td>中间插入</td><td>O(n)</td><td>O(1)*</td></tr><tr><td>头部删除</td><td>O(n)</td><td>O(1)</td></tr><tr><td>尾部删除</td><td>O(1)</td><td>O(1)</td></tr><tr><td>中间删除</td><td>O(n)</td><td>O(1)*</td></tr></tbody></table><p>*注：LinkedList中间插入/删除的O(1)是指已知节点位置的情况，查找节点仍需O(n)</p><h4 id="使用场景-1" tabindex="-1"><a class="header-anchor" href="#使用场景-1"><span>使用场景</span></a></h4><ul><li><strong>ArrayList</strong>：频繁随机访问、少量插入删除</li><li><strong>LinkedList</strong>：频繁插入删除、顺序访问</li></ul><h3 id="_4-iterator-和-listiterator-的区别-fail-fast-和-fail-safe-机制" tabindex="-1"><a class="header-anchor" href="#_4-iterator-和-listiterator-的区别-fail-fast-和-fail-safe-机制"><span>4. Iterator 和 ListIterator 的区别？fail-fast 和 fail-safe 机制？</span></a></h3><h4 id="iterator-vs-listiterator" tabindex="-1"><a class="header-anchor" href="#iterator-vs-listiterator"><span>Iterator vs ListIterator</span></a></h4><table><thead><tr><th>特性</th><th>Iterator</th><th>ListIterator</th></tr></thead><tbody><tr><td>适用范围</td><td>所有Collection</td><td>只适用于List</td></tr><tr><td>遍历方向</td><td>单向（向前）</td><td>双向（前进+后退）</td></tr><tr><td>操作能力</td><td>只能删除</td><td>增删改查都支持</td></tr><tr><td>索引访问</td><td>不支持</td><td>支持获取当前索引</td></tr><tr><td>起始位置</td><td>只能从头开始</td><td>可以从任意位置开始</td></tr></tbody></table><h4 id="fail-fast-vs-fail-safe" tabindex="-1"><a class="header-anchor" href="#fail-fast-vs-fail-safe"><span>fail-fast vs fail-safe</span></a></h4><p><strong>fail-fast（快速失败）：</strong></p><ul><li><strong>机制</strong>：检测到并发修改立即抛ConcurrentModificationException</li><li><strong>实现</strong>：通过modCount计数器检测结构性修改</li><li><strong>代表</strong>：ArrayList、HashMap的迭代器</li></ul><p><strong>fail-safe（安全失败）：</strong></p><ul><li><strong>机制</strong>：在副本上迭代，不会抛异常但可能读到过期数据</li><li><strong>实现</strong>：复制一份数据进行迭代</li><li><strong>代表</strong>：CopyOnWriteArrayList、ConcurrentHashMap</li></ul><table><thead><tr><th>机制</th><th>fail-fast</th><th>fail-safe</th></tr></thead><tbody><tr><td>异常处理</td><td>立即抛异常</td><td>不抛异常</td></tr><tr><td>数据一致性</td><td>强一致性</td><td>可能读到过期数据</td></tr><tr><td>性能开销</td><td>低</td><td>高（需要复制）</td></tr><tr><td>内存使用</td><td>少</td><td>多（额外副本）</td></tr><tr><td>适用场景</td><td>单线程环境</td><td>多线程环境</td></tr></tbody></table><h3 id="_5-如何保证集合的线程安全" tabindex="-1"><a class="header-anchor" href="#_5-如何保证集合的线程安全"><span>5. 如何保证集合的线程安全？</span></a></h3><h4 id="五种解决方案" tabindex="-1"><a class="header-anchor" href="#五种解决方案"><span>五种解决方案</span></a></h4><p><strong>1. Collections.synchronizedXXX()</strong></p><ul><li><strong>原理</strong>：为每个方法加synchronized关键字</li><li><strong>缺点</strong>：性能较差，复合操作仍不安全</li></ul><p><strong>2. Vector、Hashtable</strong></p><ul><li><strong>原理</strong>：方法级别的synchronized</li><li><strong>缺点</strong>：过时的重量级同步，性能差</li></ul><p><strong>3. CopyOnWriteArrayList</strong></p><ul><li><strong>原理</strong>：写时复制，读写分离</li><li><strong>适用</strong>：读多写少的场景</li></ul><p><strong>4. ConcurrentHashMap</strong></p><ul><li><strong>原理</strong>：分段锁/CAS+synchronized</li><li><strong>优点</strong>：高并发性能好</li></ul><p><strong>5. 外部加锁</strong></p><ul><li><strong>原理</strong>：使用外部锁控制访问</li><li><strong>灵活性</strong>：可控制锁的粒度</li></ul><table><thead><tr><th>方案</th><th>性能</th><th>适用场景</th><th>缺点</th></tr></thead><tbody><tr><td>Collections.synchronized</td><td>差</td><td>简单场景</td><td>复合操作不安全</td></tr><tr><td>Vector/Hashtable</td><td>差</td><td>遗留代码</td><td>重量级同步</td></tr><tr><td>CopyOnWriteArrayList</td><td>读快</td><td>读多写少</td><td>写操作开销大</td></tr><tr><td>ConcurrentHashMap</td><td>优</td><td>高并发Map操作</td><td>只适用于Map</td></tr><tr><td>外部加锁</td><td>中</td><td>复杂业务逻辑</td><td>需要小心死锁</td></tr></tbody></table><h3 id="_6-comparable-和-comparator-接口的区别" tabindex="-1"><a class="header-anchor" href="#_6-comparable-和-comparator-接口的区别"><span>6. Comparable 和 Comparator 接口的区别？</span></a></h3><h4 id="核心区别" tabindex="-1"><a class="header-anchor" href="#核心区别"><span>核心区别</span></a></h4><ul><li><strong>Comparable</strong>：内部比较器，对象自己定义排序规则</li><li><strong>Comparator</strong>：外部比较器，第三方定义排序规则</li></ul><h4 id="详细对比" tabindex="-1"><a class="header-anchor" href="#详细对比"><span>详细对比</span></a></h4><p><strong>Comparable接口：</strong></p><ul><li><strong>方法</strong>：compareTo(T o)</li><li><strong>实现位置</strong>：在被比较的类内部实现</li><li><strong>排序规则</strong>：固定的，类的自然排序</li><li><strong>使用方式</strong>：Collections.sort(list)</li></ul><p><strong>Comparator接口：</strong></p><ul><li><strong>方法</strong>：compare(T o1, T o2)</li><li><strong>实现位置</strong>：可以在任何地方实现</li><li><strong>排序规则</strong>：灵活的，可以有多种排序方式</li><li><strong>使用方式</strong>：Collections.sort(list, comparator)</li></ul><table><thead><tr><th>特性</th><th>Comparable</th><th>Comparator</th></tr></thead><tbody><tr><td>位置</td><td>类内部实现</td><td>外部实现</td></tr><tr><td>方法</td><td>compareTo()</td><td>compare()</td></tr><tr><td>排序规则</td><td>单一固定</td><td>多样化灵活</td></tr><tr><td>修改成本</td><td>需要修改原类</td><td>不需要修改原类</td></tr><tr><td>使用场景</td><td>类有明确的自然排序</td><td>需要多种排序方式或无法修改原类</td></tr><tr><td>实现数量</td><td>一个类只能有一种</td><td>可以有多个不同的实现</td></tr></tbody></table><h2 id="多线程" tabindex="-1"><a class="header-anchor" href="#多线程"><span>多线程</span></a></h2><h3 id="_1-进程和线程的区别-创建线程的几种方式-哪种更推荐" tabindex="-1"><a class="header-anchor" href="#_1-进程和线程的区别-创建线程的几种方式-哪种更推荐"><span>1. 进程和线程的区别？创建线程的几种方式？哪种更推荐？</span></a></h3><p><strong>进程 vs 线程：</strong></p><ul><li><strong>进程</strong>：操作系统资源分配的基本单位，拥有独立的内存空间</li><li><strong>线程</strong>：CPU调度的基本单位，同一进程内的线程共享内存空间</li></ul><table><thead><tr><th>特性</th><th>进程</th><th>线程</th></tr></thead><tbody><tr><td>资源占用</td><td>独立内存空间</td><td>共享进程内存空间</td></tr><tr><td>创建开销</td><td>大</td><td>小</td></tr><tr><td>通信方式</td><td>IPC（管道、消息队列）</td><td>共享内存、同步机制</td></tr><tr><td>崩溃影响</td><td>不影响其他进程</td><td>可能影响整个进程</td></tr><tr><td>切换开销</td><td>大</td><td>小</td></tr></tbody></table><p><strong>创建线程的方式：</strong></p><table><thead><tr><th>方式</th><th>特点</th><th>推荐度</th><th>使用场景</th></tr></thead><tbody><tr><td>继承Thread类</td><td>简单，但Java单继承限制</td><td>⭐⭐</td><td>简单场景，不推荐</td></tr><tr><td>实现Runnable接口</td><td>可多继承，推荐</td><td>⭐⭐⭐</td><td>一般异步任务</td></tr><tr><td>实现Callable+FutureTask</td><td>有返回值，可抛异常</td><td>⭐⭐⭐</td><td>需要返回结果的任务</td></tr><tr><td>线程池</td><td>复用线程，性能好，资源可控</td><td>⭐⭐⭐⭐⭐</td><td>生产环境，高并发场景</td></tr></tbody></table><p><strong>最推荐</strong>：线程池方式，因为可以避免频繁创建销毁线程的开销，更好地控制并发数量。</p><h3 id="_2-sleep-wait-yield-join-方法的区别" tabindex="-1"><a class="header-anchor" href="#_2-sleep-wait-yield-join-方法的区别"><span>2. sleep(), wait(), yield(), join() 方法的区别？</span></a></h3><table><thead><tr><th>方法</th><th>所属类</th><th>锁状态</th><th>使用场景</th><th>唤醒方式</th></tr></thead><tbody><tr><td>sleep()</td><td>Thread</td><td>不释放锁</td><td>暂停指定时间</td><td>时间到自动唤醒</td></tr><tr><td>wait()</td><td>Object</td><td>释放锁</td><td>等待条件满足</td><td>notify/notifyAll</td></tr><tr><td>yield()</td><td>Thread</td><td>不释放锁</td><td>让出CPU给同优先级线程</td><td>立即重新参与调度</td></tr><tr><td>join()</td><td>Thread</td><td>不释放锁</td><td>等待线程执行完毕</td><td>目标线程执行完毕</td></tr></tbody></table><p><strong>核心区别：</strong></p><ul><li><strong>sleep()和wait()的最大区别</strong>：sleep不释放锁，wait释放锁</li><li><strong>yield()作用</strong>：暂停当前线程，让同优先级线程有机会执行，但实际是否让出 CPU 要看调度器。</li><li><strong>join()用途</strong>：主线程等待子线程执行完毕后再继续</li></ul><h3 id="_3-上下文切换是什么-开销在哪里" tabindex="-1"><a class="header-anchor" href="#_3-上下文切换是什么-开销在哪里"><span>3. 上下文切换是什么？开销在哪里？</span></a></h3><p><strong>上下文切换</strong>：CPU从一个线程切换到另一个线程时，需要保存当前线程状态并加载新线程状态的过程。</p><p><strong>开销构成：</strong></p><ol><li><strong>保存现场</strong>：寄存器、程序计数器、栈指针等</li><li><strong>加载新现场</strong>：新线程的执行环境</li><li><strong>内存缓存失效</strong>：CPU缓存可能失效，需要重新加载</li><li><strong>内核态切换</strong>：用户态到内核态的切换开销</li></ol><table><thead><tr><th>开销类型</th><th>具体内容</th><th>影响程度</th></tr></thead><tbody><tr><td>寄存器保存</td><td>CPU寄存器状态保存/恢复</td><td>中等</td></tr><tr><td>内存访问</td><td>栈、堆内存访问模式变化</td><td>高</td></tr><tr><td>缓存失效</td><td>CPU缓存、TLB失效</td><td>高</td></tr><tr><td>系统调用</td><td>用户态/内核态切换</td><td>中等</td></tr></tbody></table><h3 id="_4-什么是线程安全-如何理解原子性、可见性、有序性" tabindex="-1"><a class="header-anchor" href="#_4-什么是线程安全-如何理解原子性、可见性、有序性"><span>4. 什么是线程安全？如何理解原子性、可见性、有序性？</span></a></h3><p><strong>线程安全</strong>：多个线程同时访问共享资源时，不会产生数据不一致或其他非预期的结果。</p><p><strong>并发编程三大特性：</strong></p><table><thead><tr><th>特性</th><th>定义</th><th>问题表现</th><th>解决方案</th></tr></thead><tbody><tr><td>原子性</td><td>操作不可被中断，要么全部成功要么全部失败</td><td>数据不一致</td><td>synchronized、CAS</td></tr><tr><td>可见性</td><td>一个线程修改共享变量，其他线程能立即看到</td><td>读取到过期数据</td><td>volatile、synchronized</td></tr><tr><td>有序性</td><td>程序执行顺序与代码顺序一致</td><td>指令重排序导致逻辑错误</td><td>volatile、synchronized</td></tr></tbody></table><h3 id="_5-synchronized-关键字的原理-使用方式-锁升级过程" tabindex="-1"><a class="header-anchor" href="#_5-synchronized-关键字的原理-使用方式-锁升级过程"><span>5. synchronized 关键字的原理？使用方式？锁升级过程？</span></a></h3><p><strong>使用方式：</strong></p><ul><li><strong>修饰实例方法</strong>：锁的是当前实例对象</li><li><strong>修饰静态方法</strong>：锁的是Class对象</li><li><strong>修饰代码块</strong>：锁的是指定对象</li></ul><p><strong>锁升级过程（JDK1.6+）：</strong></p><table><thead><tr><th>锁状态</th><th>特点</th><th>适用场景</th><th>性能</th></tr></thead><tbody><tr><td>无锁</td><td>没有锁竞争</td><td>单线程访问</td><td>最高</td></tr><tr><td>偏向锁</td><td>偏向第一个获得锁的线程</td><td>基本没有竞争</td><td>高</td></tr><tr><td>轻量级锁</td><td>CAS自旋获取锁</td><td>竞争不激烈，持锁时间短</td><td>中等</td></tr><tr><td>重量级锁</td><td>操作系统互斥锁</td><td>竞争激烈，持锁时间长</td><td>低</td></tr></tbody></table><p><strong>升级路径</strong>：无锁 → 偏向锁 → 轻量级锁 → 重量级锁（不可逆）</p><h3 id="_6-volatile-关键字的语义-原理-能保证原子性吗-适用场景" tabindex="-1"><a class="header-anchor" href="#_6-volatile-关键字的语义-原理-能保证原子性吗-适用场景"><span>6. volatile 关键字的语义？原理？能保证原子性吗？适用场景？</span></a></h3><p><strong>volatile的两大语义：</strong></p><ol><li><strong>保证可见性</strong>：修改立即刷新到主内存，读取直接从主内存读</li><li><strong>保证有序性</strong>：禁止指令重排序</li></ol><p><strong>实现原理：</strong></p><ul><li><strong>内存屏障</strong>：编译器在volatile变量前后插入内存屏障指令</li><li><strong>缓存一致性协议</strong>：MESI协议确保缓存一致性</li></ul><p><strong>不能保证原子性</strong>：volatile不能保证复合操作的原子性，如 i++ 操作。</p><table><thead><tr><th>特性</th><th>volatile</th><th>synchronized</th></tr></thead><tbody><tr><td>原子性</td><td>❌</td><td>✅</td></tr><tr><td>可见性</td><td>✅</td><td>✅</td></tr><tr><td>有序性</td><td>✅</td><td>✅</td></tr><tr><td>阻塞性</td><td>不阻塞</td><td>可能阻塞</td></tr><tr><td>性能</td><td>高</td><td>相对较低</td></tr></tbody></table><p><strong>适用场景：</strong></p><ul><li>状态标记（如停止标志）</li><li>双重检查锁定模式</li><li>单例模式中的实例变量</li></ul><h3 id="_7-synchronized-和-volatile-的区别" tabindex="-1"><a class="header-anchor" href="#_7-synchronized-和-volatile-的区别"><span>7. synchronized 和 volatile 的区别？</span></a></h3><table><thead><tr><th>对比维度</th><th>synchronized</th><th>volatile</th></tr></thead><tbody><tr><td>作用对象</td><td>方法、代码块</td><td>变量</td></tr><tr><td>原子性</td><td>保证</td><td>不保证</td></tr><tr><td>可见性</td><td>保证</td><td>保证</td></tr><tr><td>有序性</td><td>保证</td><td>保证</td></tr><tr><td>阻塞特性</td><td>可能阻塞</td><td>不阻塞</td></tr><tr><td>锁机制</td><td>互斥锁</td><td>无锁</td></tr><tr><td>性能开销</td><td>较高</td><td>较低</td></tr><tr><td>适用场景</td><td>复合操作、临界区</td><td>状态标记、简单赋值</td></tr></tbody></table><h3 id="_8-cas-操作的原理-atomic类实现-aba问题及解决方案" tabindex="-1"><a class="header-anchor" href="#_8-cas-操作的原理-atomic类实现-aba问题及解决方案"><span>8. CAS 操作的原理？Atomic类实现？ABA问题及解决方案？</span></a></h3><p><strong>CAS（Compare-And-Swap）原理：</strong> 比较内存位置的值与期望值，如果相同则更新为新值，整个操作是原子的。</p><p><strong>三个操作数：</strong></p><ul><li><strong>内存位置V</strong>：要更新的变量</li><li><strong>预期值A</strong>：期望的当前值</li><li><strong>新值B</strong>：要设置的新值</li></ul><p><strong>Atomic类实现：</strong> 基于CAS + volatile，通过无锁算法实现线程安全。</p><p><strong>ABA问题：</strong> 值从A变成B再变回A，CAS检测不到中间的变化过程。</p><table><thead><tr><th>问题</th><th>表现</th><th>解决方案</th></tr></thead><tbody><tr><td>ABA问题</td><td>值变化后又变回原值，CAS误判为未变化</td><td>AtomicStampedReference</td></tr><tr><td>性能问题</td><td>高竞争时自旋消耗CPU</td><td>结合synchronized</td></tr><tr><td>只能保证单变量</td><td>多个变量的原子性无法保证</td><td>AtomicReference包装对象</td></tr></tbody></table><h3 id="_9-threadlocal-的原理-使用场景-内存泄漏问题及如何避免" tabindex="-1"><a class="header-anchor" href="#_9-threadlocal-的原理-使用场景-内存泄漏问题及如何避免"><span>9. ThreadLocal 的原理？使用场景？内存泄漏问题及如何避免？</span></a></h3><p><strong>原理：</strong> 每个线程都有一个ThreadLocalMap，以ThreadLocal为key存储线程私有数据。</p><p><strong>数据结构：</strong> Thread → ThreadLocalMap → Entry(ThreadLocal, Value)</p><p><strong>使用场景：</strong></p><ul><li><strong>数据库连接管理</strong>：每个线程独立的连接</li><li><strong>用户会话信息</strong>：Web请求中的用户信息</li><li><strong>数据格式化</strong>：SimpleDateFormat等非线程安全类</li></ul><p><strong>内存泄漏问题：</strong></p><table><thead><tr><th>问题原因</th><th>后果</th><th>解决方案</th></tr></thead><tbody><tr><td>ThreadLocal被回收</td><td>key为null</td><td>手动调用remove()</td></tr><tr><td>线程长期存活</td><td>value无法回收</td><td>使用完毕立即remove()</td></tr><tr><td>强引用链</td><td>整个对象无法回收</td><td>避免在线程池中使用静态ThreadLocal</td></tr></tbody></table><p><strong>最佳实践：</strong></p><ol><li>使用完毕后立即调用 <code>remove()</code></li><li>使用 <code>try-finally</code> 确保清理</li><li>避免在线程池中使用静态ThreadLocal</li></ol><h2 id="数据库" tabindex="-1"><a class="header-anchor" href="#数据库"><span>数据库</span></a></h2><h3 id="_1-sql基础语法-ddl-dml-dql-dcl-常用函数" tabindex="-1"><a class="header-anchor" href="#_1-sql基础语法-ddl-dml-dql-dcl-常用函数"><span>1. SQL基础语法（DDL, DML, DQL, DCL）？常用函数？</span></a></h3><p><strong>SQL语言分类：</strong></p><table><thead><tr><th>类型</th><th>全称</th><th>作用</th><th>常用语句</th></tr></thead><tbody><tr><td>DDL</td><td>Data Definition Language</td><td>数据定义语言</td><td>CREATE、ALTER、DROP</td></tr><tr><td>DML</td><td>Data Manipulation Language</td><td>数据操作语言</td><td>INSERT、UPDATE、DELETE</td></tr><tr><td>DQL</td><td>Data Query Language</td><td>数据查询语言</td><td>SELECT</td></tr><tr><td>DCL</td><td>Data Control Language</td><td>数据控制语言</td><td>GRANT、REVOKE、COMMIT、ROLLBACK</td></tr></tbody></table><p><strong>常用函数分类：</strong></p><table><thead><tr><th>函数类型</th><th>常用函数</th><th>作用</th></tr></thead><tbody><tr><td>聚合函数</td><td>COUNT、SUM、AVG、MAX、MIN</td><td>统计计算</td></tr><tr><td>字符串函数</td><td>CONCAT、SUBSTRING、LENGTH、UPPER、LOWER</td><td>字符串处理</td></tr><tr><td>日期函数</td><td>NOW、CURDATE、DATE_FORMAT、DATEDIFF</td><td>日期时间处理</td></tr><tr><td>数学函数</td><td>ROUND、CEIL、FLOOR、ABS、MOD</td><td>数值计算</td></tr><tr><td>条件函数</td><td>IF、CASE WHEN、IFNULL、NULLIF</td><td>条件判断</td></tr></tbody></table><h3 id="_2-mysql核心区别-事务、锁、外键、索引结构" tabindex="-1"><a class="header-anchor" href="#_2-mysql核心区别-事务、锁、外键、索引结构"><span>2. MySQL核心区别（事务、锁、外键、索引结构）？</span></a></h3><p><strong>存储引擎对比：</strong></p><table><thead><tr><th>特性</th><th>InnoDB</th><th>MyISAM</th><th>Memory</th></tr></thead><tbody><tr><td>事务支持</td><td>✅支持ACID</td><td>❌不支持</td><td>❌不支持</td></tr><tr><td>锁级别</td><td>行级锁</td><td>表级锁</td><td>表级锁</td></tr><tr><td>外键支持</td><td>✅支持</td><td>❌不支持</td><td>❌不支持</td></tr><tr><td>索引结构</td><td>B+树聚集索引</td><td>B+树非聚集索引</td><td>Hash索引</td></tr><tr><td>崩溃恢复</td><td>✅支持</td><td>❌不支持</td><td>❌不支持</td></tr><tr><td>适用场景</td><td>事务处理、高并发写入</td><td>只读、数据仓库</td><td>临时表、缓存</td></tr></tbody></table><h3 id="_3-索引-什么是索引-为什么能提高查询效率-索引的优缺点" tabindex="-1"><a class="header-anchor" href="#_3-索引-什么是索引-为什么能提高查询效率-索引的优缺点"><span>3. 索引：什么是索引？为什么能提高查询效率？索引的优缺点？</span></a></h3><p><strong>索引定义：</strong> 索引是数据库表中一个或多个列的值排序的数据结构，类似书的目录，用于快速定位数据。</p><p><strong>提高效率原理：</strong></p><ul><li><strong>减少扫描行数</strong>：从全表扫描变为索引查找</li><li><strong>有序存储</strong>：B+树结构保证数据有序，支持范围查询</li><li><strong>减少I/O操作</strong>：索引通常比数据小，能缓存在内存中</li></ul><p><strong>索引优缺点：</strong></p><table><thead><tr><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>大幅提高查询速度</td><td>占用额外存储空间</td></tr><tr><td>加速表连接</td><td>降低写操作性能（增删改）</td></tr><tr><td>减少分组和排序时间</td><td>维护索引需要额外开销</td></tr><tr><td>唯一索引保证数据唯一性</td><td>过多索引影响优化器选择</td></tr></tbody></table><h3 id="_4-b-树索引结构-为什么mysql使用b-树而不是b树或哈希表" tabindex="-1"><a class="header-anchor" href="#_4-b-树索引结构-为什么mysql使用b-树而不是b树或哈希表"><span>4. B+树索引结构？为什么MySQL使用B+树而不是B树或哈希表？</span></a></h3><p><strong>B+树特点：</strong></p><ul><li><strong>所有数据在叶子节点</strong>：非叶子节点只存储键值</li><li><strong>叶子节点连接</strong>：叶子节点通过指针连接，支持范围查询</li><li><strong>更高的扇出比</strong>：非叶子节点可存储更多键值</li></ul><p><strong>选择B+树的原因：</strong></p><table><thead><tr><th>对比项</th><th>B+树</th><th>B树</th><th>哈希表</th></tr></thead><tbody><tr><td>范围查询</td><td>✅优秀</td><td>❌较差</td><td>❌不支持</td></tr><tr><td>顺序访问</td><td>✅优秀</td><td>❌一般</td><td>❌不支持</td></tr><tr><td>磁盘I/O</td><td>✅少</td><td>❌多</td><td>✅少</td></tr><tr><td>内存利用率</td><td>✅高</td><td>❌低</td><td>✅高</td></tr><tr><td>等值查询</td><td>✅快</td><td>✅快</td><td>✅最快</td></tr><tr><td>数据有序性</td><td>✅有序</td><td>✅有序</td><td>❌无序</td></tr></tbody></table><h3 id="_5-聚集索引和非聚集索引的区别-innodb的主键索引结构" tabindex="-1"><a class="header-anchor" href="#_5-聚集索引和非聚集索引的区别-innodb的主键索引结构"><span>5. 聚集索引和非聚集索引的区别？InnoDB的主键索引结构？</span></a></h3><p><strong>聚集索引 vs 非聚集索引：</strong></p><table><thead><tr><th>特性</th><th>聚集索引（主键索引）</th><th>非聚集索引（辅助索引）</th></tr></thead><tbody><tr><td>数据存储</td><td>叶子节点存储完整行数据</td><td>叶子节点存储主键值</td></tr><tr><td>数据排序</td><td>数据按索引键物理排序</td><td>数据排序与索引无关</td></tr><tr><td>查询性能</td><td>一次查询获取所有数据</td><td>可能需要回表查询</td></tr><tr><td>每表数量</td><td>最多一个</td><td>可以有多个</td></tr><tr><td>存储开销</td><td>无额外开销</td><td>需要额外存储空间</td></tr></tbody></table><p><strong>InnoDB主键索引结构：</strong></p><ul><li><strong>主键索引</strong>：聚集索引，叶子节点存储完整行数据</li><li><strong>辅助索引</strong>：非聚集索引，叶子节点存储主键值</li><li><strong>回表查询</strong>：通过辅助索引查询时，需要根据主键值再查主键索引</li></ul><h3 id="_6-索引类型分类" tabindex="-1"><a class="header-anchor" href="#_6-索引类型分类"><span>6. 索引类型分类？</span></a></h3><p><strong>按功能分类：</strong></p><table><thead><tr><th>索引类型</th><th>特点</th><th>使用场景</th><th>示例</th></tr></thead><tbody><tr><td>主键索引</td><td>唯一+非空，自动创建聚集索引</td><td>主键字段</td><td>PRIMARY KEY</td></tr><tr><td>唯一索引</td><td>值唯一，允许一个NULL</td><td>身份证号、邮箱</td><td>UNIQUE</td></tr><tr><td>普通索引</td><td>无唯一性限制，提高查询速度</td><td>查询频繁的字段</td><td>INDEX</td></tr><tr><td>组合索引</td><td>多列联合索引，遵循最左前缀原则</td><td>多条件查询</td><td>(name, age, city)</td></tr><tr><td>全文索引</td><td>文本关键词搜索</td><td>文章内容搜索</td><td>FULLTEXT</td></tr></tbody></table><h3 id="_7-索引失效的常见场景" tabindex="-1"><a class="header-anchor" href="#_7-索引失效的常见场景"><span>7. 索引失效的常见场景？</span></a></h3><p><strong>索引失效情况：</strong></p><table><thead><tr><th>失效场景</th><th>示例</th><th>原因</th></tr></thead><tbody><tr><td>函数操作</td><td>WHERE YEAR(date) = 2023</td><td>对索引列使用函数</td></tr><tr><td>隐式类型转换</td><td>WHERE age = &#39;18&#39;</td><td>数据类型不匹配</td></tr><tr><td>LIKE以%开头</td><td>WHERE name LIKE &#39;%张&#39;</td><td>无法利用索引的有序性</td></tr><tr><td>OR条件</td><td>WHERE a = 1 OR b = 2</td><td>其中一个条件没有索引</td></tr><tr><td>组合索引不满足最左前缀</td><td>INDEX(a,b,c) WHERE b = 1</td><td>违反最左前缀原则</td></tr><tr><td>不等于操作</td><td>WHERE age != 18</td><td>范围太大，优化器选择全表扫描</td></tr><tr><td>IS NULL判断</td><td>WHERE name IS NULL</td><td>NULL值不存储在索引中</td></tr></tbody></table><h3 id="_8-explain命令的作用-关键字段的含义" tabindex="-1"><a class="header-anchor" href="#_8-explain命令的作用-关键字段的含义"><span>8. EXPLAIN命令的作用？关键字段的含义？</span></a></h3><p><strong>EXPLAIN作用：</strong> 分析SQL语句执行计划，帮助优化查询性能。</p><p><strong>关键字段含义：</strong></p><table><thead><tr><th>字段</th><th>含义</th><th>重要值</th></tr></thead><tbody><tr><td>type</td><td>访问类型</td><td>system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL</td></tr><tr><td>key</td><td>实际使用的索引</td><td>NULL表示未使用索引</td></tr><tr><td>rows</td><td>预估扫描行数</td><td>数值越小越好</td></tr><tr><td>Extra</td><td>额外信息</td><td>Using index &gt; Using where &gt; Using filesort</td></tr></tbody></table><p><strong>type字段详解：</strong></p><table><thead><tr><th>type值</th><th>性能</th><th>说明</th></tr></thead><tbody><tr><td>system</td><td>最优</td><td>表只有一行</td></tr><tr><td>const</td><td>优</td><td>主键或唯一索引等值查询</td></tr><tr><td>eq_ref</td><td>优</td><td>主键或唯一索引关联</td></tr><tr><td>ref</td><td>良</td><td>非唯一索引等值查询</td></tr><tr><td>range</td><td>中</td><td>范围查询</td></tr><tr><td>index</td><td>差</td><td>索引全扫描</td></tr><tr><td>ALL</td><td>最差</td><td>全表扫描</td></tr></tbody></table><h3 id="_9-锁-innodb的行锁、间隙锁、临键锁-mvcc的原理-如何解决幻读" tabindex="-1"><a class="header-anchor" href="#_9-锁-innodb的行锁、间隙锁、临键锁-mvcc的原理-如何解决幻读"><span>9. 锁：InnoDB的行锁、间隙锁、临键锁？MVCC的原理？如何解决幻读？</span></a></h3><p><strong>InnoDB锁类型：</strong></p><table><thead><tr><th>锁类型</th><th>锁范围</th><th>作用</th><th>示例场景</th></tr></thead><tbody><tr><td>行锁</td><td>锁定具体的行</td><td>防止并发修改同一行数据</td><td>UPDATE具体记录</td></tr><tr><td>间隙锁</td><td>锁定索引记录之间的间隙</td><td>防止在间隙中插入新记录</td><td>防止幻读</td></tr><tr><td>临键锁</td><td>行锁+间隙锁的组合</td><td>既锁记录又锁间隙</td><td>范围查询时使用</td></tr><tr><td>意向锁</td><td>表级锁，表示事务的加锁意图</td><td>提高表锁检测效率</td><td>加行锁时自动加意向锁</td></tr></tbody></table><p><strong>MVCC（多版本并发控制）原理：</strong></p><ul><li><strong>版本链</strong>：每行记录维护多个版本</li><li><strong>ReadView</strong>：事务开始时创建的一致性视图</li><li><strong>undo log</strong>：存储历史版本数据</li><li><strong>实现隔离</strong>：不同事务看到不同版本的数据</li></ul><p><strong>解决幻读：</strong></p><ul><li><strong>快照读</strong>：通过MVCC，读取事务开始时的数据快照 <ul><li>快照读：默认的 SELECT 查询，在事务里读的是事务开始时的快照，不会加锁，也不会被其他事务影响。</li></ul></li><li><strong>当前读</strong>：通过临键锁，锁定查询范围防止插入新数据 <ul><li>当前读：会加锁防止别的事务插入/更新你正在看的范围，用来保证一致性或做更新。</li></ul></li></ul><h3 id="_10-事务隔离级别-mysql默认级别-不同级别解决的问题" tabindex="-1"><a class="header-anchor" href="#_10-事务隔离级别-mysql默认级别-不同级别解决的问题"><span>10. 事务隔离级别？MySQL默认级别？不同级别解决的问题？</span></a></h3><p><strong>四大隔离级别：</strong></p><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th><th>实现方式</th><th>性能</th></tr></thead><tbody><tr><td>读未提交（READ UNCOMMITTED）</td><td>❌</td><td>❌</td><td>❌</td><td>无锁</td><td>最高</td></tr><tr><td>读已提交（READ COMMITTED）</td><td>✅</td><td>❌</td><td>❌</td><td>行锁+MVCC</td><td>高</td></tr><tr><td>可重复读（REPEATABLE READ）</td><td>✅</td><td>✅</td><td>部分解决</td><td>临键锁+MVCC</td><td>中</td></tr><tr><td>串行化（SERIALIZABLE）</td><td>✅</td><td>✅</td><td>✅</td><td>表锁</td><td>低</td></tr></tbody></table><p>**MySQL默认隔离级别：**可重复读（REPEATABLE READ）</p><p><strong>问题说明：</strong></p><ul><li><strong>脏读</strong>：读到其他事务未提交的数据</li><li><strong>不可重复读</strong>：同一事务中多次读取同一数据结果不同</li><li><strong>幻读</strong>：同一事务中多次查询记录数量不同</li></ul><h3 id="_11-如何优化慢查询" tabindex="-1"><a class="header-anchor" href="#_11-如何优化慢查询"><span>11. 如何优化慢查询？</span></a></h3><p><strong>优化策略：</strong></p><table><thead><tr><th>优化方向</th><th>具体方法</th><th>效果评估</th></tr></thead><tbody><tr><td>索引优化</td><td>添加合适索引、优化索引使用</td><td>⭐⭐⭐⭐⭐</td></tr><tr><td>SQL语句优化</td><td>避免SELECT *、减少子查询</td><td>⭐⭐⭐⭐</td></tr><tr><td>分库分表</td><td>水平/垂直分割减少单表数据量</td><td>⭐⭐⭐⭐⭐</td></tr><tr><td>读写分离</td><td>主库写、从库读，减少主库压力</td><td>⭐⭐⭐⭐</td></tr></tbody></table><p><strong>具体优化手段：</strong></p><table><thead><tr><th>方法</th><th>说明</th><th>适用场景</th></tr></thead><tbody><tr><td>添加索引</td><td>为WHERE、ORDER BY字段添加索引</td><td>查询频繁的字段</td></tr><tr><td>优化JOIN</td><td>使用小表驱动大表</td><td>多表关联查询</td></tr><tr><td>避免函数计算</td><td>不在WHERE条件中使用函数</td><td>所有查询</td></tr><tr><td>分页优化</td><td>使用索引+偏移量代替LIMIT大偏移</td><td>深度分页查询</td></tr><tr><td>垂直分表</td><td>将大字段拆分到独立表</td><td>表字段过多</td></tr><tr><td>水平分表</td><td>按规则将数据分散到多个表</td><td>单表数据量过大</td></tr><tr><td>使用缓存</td><td>Redis缓存热点数据</td><td>读多写少场景</td></tr><tr><td>连接池优化</td><td>合理设置连接池参数</td><td>高并发场景</td></tr></tbody></table><h2 id="redis" tabindex="-1"><a class="header-anchor" href="#redis"><span>Redis</span></a></h2><h3 id="_1-redis是什么-常用数据类型及其底层实现和典型应用场景" tabindex="-1"><a class="header-anchor" href="#_1-redis是什么-常用数据类型及其底层实现和典型应用场景"><span>1. Redis是什么？常用数据类型及其底层实现和典型应用场景？</span></a></h3><p><strong>Redis定义：</strong> Redis是一个开源的内存数据结构存储系统，可用作数据库、缓存和消息代理。</p><p><strong>常用数据类型：</strong></p><table><thead><tr><th>数据类型</th><th>底层实现</th><th>典型应用场景</th><th>常用命令</th></tr></thead><tbody><tr><td>String</td><td>SDS（简单动态字符串）</td><td>缓存、计数器、分布式锁</td><td>SET、GET、INCR</td></tr><tr><td>Hash</td><td>压缩列表/哈希表</td><td>用户信息、商品信息</td><td>HSET、HGET、HMGET</td></tr><tr><td>List</td><td>压缩列表/双向链表</td><td>消息队列、最新消息列表</td><td>LPUSH、RPOP、LRANGE</td></tr><tr><td>Set</td><td>整数集合/哈希表</td><td>标签、好友关系、唯一性统计</td><td>SADD、SMEMBERS、SINTER</td></tr><tr><td>Sorted Set</td><td>压缩列表/跳跃表</td><td>排行榜、延时队列</td><td>ZADD、ZRANGE、ZRANK</td></tr><tr><td>HyperLogLog</td><td>基数估算算法</td><td>UV统计、独立访客统计</td><td>PFADD、PFCOUNT</td></tr><tr><td>Bitmap</td><td>位数组</td><td>用户签到、在线状态</td><td>SETBIT、GETBIT、BITCOUNT</td></tr><tr><td>Geospatial</td><td>Sorted Set + GeoHash</td><td>地理位置、附近的人</td><td>GEOADD、GEORADIUS</td></tr><tr><td>Stream</td><td>Radix Tree + Listpack</td><td>消息流、日志收集</td><td>XADD、XREAD、XGROUP</td></tr></tbody></table><h3 id="_2-redis为什么快" tabindex="-1"><a class="header-anchor" href="#_2-redis为什么快"><span>2. Redis为什么快？</span></a></h3><p><strong>性能优势分析：</strong></p><table><thead><tr><th>优势</th><th>具体表现</th><th>性能影响</th></tr></thead><tbody><tr><td>内存存储</td><td>数据存储在内存中，避免磁盘I/O</td><td>⭐⭐⭐⭐⭐</td></tr><tr><td>单线程模型</td><td>避免线程切换和锁竞争开销</td><td>⭐⭐⭐⭐</td></tr><tr><td>I/O多路复用</td><td>epoll机制处理并发连接</td><td>⭐⭐⭐⭐</td></tr><tr><td>高效数据结构</td><td>针对不同场景优化的数据结构</td><td>⭐⭐⭐</td></tr><tr><td>简单协议</td><td>RESP协议简单，解析开销小</td><td>⭐⭐⭐</td></tr></tbody></table><p><strong>核心原因：</strong></p><ul><li><strong>纯内存操作</strong>：避免磁盘I/O，速度快10000倍</li><li><strong>单线程避免竞争</strong>：无锁设计，减少上下文切换</li><li><strong>非阻塞I/O</strong>：高效处理大量并发连接</li></ul><h3 id="_3-redis的持久化机制-优缺点-如何选择" tabindex="-1"><a class="header-anchor" href="#_3-redis的持久化机制-优缺点-如何选择"><span>3. Redis的持久化机制？优缺点？如何选择？</span></a></h3><p><strong>两种持久化方式：</strong></p><table><thead><tr><th>特性</th><th>RDB快照</th><th>AOF日志</th></tr></thead><tbody><tr><td>持久化方式</td><td>定期生成数据快照</td><td>记录每个写操作命令</td></tr><tr><td>文件大小</td><td>紧凑，文件小</td><td>较大，包含所有操作</td></tr><tr><td>恢复速度</td><td>快</td><td>慢</td></tr><tr><td>数据完整性</td><td>可能丢失最后一次快照后的数据</td><td>根据同步策略，丢失较少</td></tr><tr><td>性能影响</td><td>fork子进程时有短暂阻塞</td><td>持续写入，影响相对较小</td></tr><tr><td>适用场景</td><td>对数据丢失不敏感的场景</td><td>对数据完整性要求高的场景</td></tr></tbody></table><p><strong>选择策略：</strong></p><table><thead><tr><th>场景</th><th>推荐方案</th><th>原因</th></tr></thead><tbody><tr><td>缓存场景</td><td>仅RDB</td><td>数据可重新计算，性能优先</td></tr><tr><td>重要数据存储</td><td>RDB + AOF</td><td>双重保障，确保数据安全</td></tr><tr><td>高写入量场景</td><td>仅RDB</td><td>避免AOF写入影响性能</td></tr><tr><td>数据完整性要求极高的场景</td><td>AOF</td><td>最大程度保证数据不丢失</td></tr></tbody></table><h3 id="_4-redis的过期键删除策略" tabindex="-1"><a class="header-anchor" href="#_4-redis的过期键删除策略"><span>4. Redis的过期键删除策略？</span></a></h3><p><strong>三种删除策略：</strong></p><table><thead><tr><th>策略</th><th>触发时机</th><th>优点</th><th>缺点</th><th>CPU消耗</th><th>内存消耗</th></tr></thead><tbody><tr><td>定时删除</td><td>设置定时器</td><td>内存友好</td><td>CPU消耗大</td><td>高</td><td>低</td></tr><tr><td>惰性删除</td><td>访问时检查</td><td>CPU友好</td><td>内存不友好</td><td>低</td><td>高</td></tr><tr><td>定期删除</td><td>定期随机抽查</td><td>平衡CPU和内存</td><td>可能有漏网之鱼</td><td>中</td><td>中</td></tr></tbody></table><p><strong>Redis实际策略：</strong> 惰性删除 + 定期删除的组合方式</p><h3 id="_5-内存淘汰策略" tabindex="-1"><a class="header-anchor" href="#_5-内存淘汰策略"><span>5. 内存淘汰策略？</span></a></h3><p><strong>8种淘汰策略：</strong></p><table><thead><tr><th>策略</th><th>作用范围</th><th>淘汰算法</th><th>适用场景</th></tr></thead><tbody><tr><td>noeviction</td><td>无</td><td>不淘汰</td><td>内存足够，不希望数据丢失</td></tr><tr><td>allkeys-lru</td><td>所有key</td><td>LRU最近最少使用</td><td>通用缓存，访问有热点</td></tr><tr><td>volatile-lru</td><td>有过期时间的key</td><td>LRU</td><td>只淘汰临时数据</td></tr><tr><td>allkeys-random</td><td>所有key</td><td>随机</td><td>访问模式均匀</td></tr><tr><td>volatile-random</td><td>有过期时间的key</td><td>随机</td><td>临时数据访问均匀</td></tr><tr><td>volatile-ttl</td><td>有过期时间的key</td><td>TTL最短优先</td><td>希望快到期的数据先删除</td></tr><tr><td>allkeys-lfu</td><td>所有key</td><td>LFU最少使用频率</td><td>访问频率差异明显</td></tr><tr><td>volatile-lfu</td><td>有过期时间的key</td><td>LFU</td><td>临时数据访问频率差异明显</td></tr></tbody></table><p><strong>推荐选择：</strong></p><ul><li><strong>通用场景</strong>：allkeys-lru（最常用）</li><li><strong>只缓存场景</strong>：volatile-lru</li><li><strong>混合数据</strong>：volatile-ttl</li></ul><h3 id="_6-如何保证redis的高可用-redis-cluster的槽分配原理" tabindex="-1"><a class="header-anchor" href="#_6-如何保证redis的高可用-redis-cluster的槽分配原理"><span>6. 如何保证Redis的高可用？Redis Cluster的槽分配原理？</span></a></h3><p><strong>高可用方案：</strong></p><table><thead><tr><th>方案</th><th>特点</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>主从复制</td><td>一主多从，读写分离</td><td>简单，读性能好</td><td>主节点单点故障</td><td>读多写少</td></tr><tr><td>哨兵模式</td><td>自动故障转移</td><td>高可用，自动切换</td><td>配置复杂</td><td>中小型应用</td></tr><tr><td>Redis Cluster</td><td>分布式，无中心节点</td><td>高可用+高性能</td><td>运维复杂</td><td>大型分布式应用</td></tr></tbody></table><p><strong>Redis Cluster槽分配：</strong></p><ul><li><strong>总槽数</strong>：16384个槽（0-16383）</li><li><strong>分配原理</strong>：CRC16(key) % 16384</li><li><strong>槽分布</strong>：平均分配到各个主节点</li><li><strong>数据分片</strong>：根据key计算槽位，找到对应节点</li></ul><table><thead><tr><th>集群规模</th><th>节点配置</th><th>槽分配示例</th></tr></thead><tbody><tr><td>3主3从</td><td>每主1从</td><td>0-5460, 5461-10922, 10923-16383</td></tr><tr><td>6主6从</td><td>每主1从</td><td>每个主节点约2730个槽</td></tr><tr><td>9主9从</td><td>每主1从</td><td>每个主节点约1820个槽</td></tr></tbody></table><h3 id="_7-缓存穿透、缓存击穿、缓存雪崩的概念、原因及解决方案" tabindex="-1"><a class="header-anchor" href="#_7-缓存穿透、缓存击穿、缓存雪崩的概念、原因及解决方案"><span>7. 缓存穿透、缓存击穿、缓存雪崩的概念、原因及解决方案？</span></a></h3><p><strong>三大缓存问题对比：</strong></p><table><thead><tr><th>问题类型</th><th>定义</th><th>原因分析</th><th>解决方案</th></tr></thead><tbody><tr><td>缓存穿透</td><td>查询不存在的数据，缓存和数据库都没有</td><td>恶意攻击、业务逻辑错误</td><td>布隆过滤器、空值缓存、参数校验</td></tr><tr><td>缓存击穿</td><td>热点数据过期，大量请求同时访问数据库</td><td>热点key过期</td><td>互斥锁、热点数据永不过期、提前更新</td></tr><tr><td>缓存雪崩</td><td>大量缓存同时过期，数据库压力剧增</td><td>缓存集中过期、Redis宕机</td><td>过期时间随机化、熔断降级、多级缓存、集群部署</td></tr></tbody></table><p><strong>详细解决方案：</strong></p><table><thead><tr><th>解决方案</th><th>实现方式</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>布隆过滤器</td><td>位数组+多个hash函数</td><td>内存占用小，查询快</td><td>存在误判，不支持删除</td></tr><tr><td>空值缓存</td><td>对空结果设置较短过期时间</td><td>简单有效</td><td>占用内存</td></tr><tr><td>互斥锁</td><td>只允许一个线程查询数据库</td><td>避免重复查询</td><td>可能造成阻塞</td></tr><tr><td>熔断降级</td><td>失败率超过阈值时停止访问</td><td>保护系统</td><td>可能影响用户体验</td></tr></tbody></table><h3 id="_8-如何设计一个分布式锁-watch-dog机制" tabindex="-1"><a class="header-anchor" href="#_8-如何设计一个分布式锁-watch-dog机制"><span>8. 如何设计一个分布式锁？Watch Dog机制？</span></a></h3><p><strong>分布式锁实现要点：</strong></p><table><thead><tr><th>要求</th><th>Redis实现方式</th><th>说明</th></tr></thead><tbody><tr><td>互斥性</td><td>SET key value NX EX</td><td>NX确保原子性设置</td></tr><tr><td>防死锁</td><td>设置过期时间</td><td>避免持锁进程崩溃导致死锁</td></tr><tr><td>防误删</td><td>删除时校验value</td><td>确保只能删除自己的锁</td></tr><tr><td>可重入</td><td>记录线程ID和重入次数</td><td>支持同一线程多次获取锁</td></tr><tr><td>阻塞等待</td><td>循环尝试获取锁</td><td>获取失败时等待重试</td></tr></tbody></table><p><strong>Watch Dog机制：</strong></p><table><thead><tr><th>特性</th><th>实现原理</th><th>作用</th></tr></thead><tbody><tr><td>自动续期</td><td>定时任务延长锁过期时间</td><td>防止业务执行时间超过锁过期时间</td></tr><tr><td>续期条件</td><td>锁仍被当前线程持有</td><td>避免给其他线程的锁续期</td></tr><tr><td>续期时间</td><td>通常为锁过期时间的1/3</td><td>保证在锁过期前完成续期</td></tr><tr><td>停止条件</td><td>锁被释放或线程结束</td><td>避免无限续期</td></tr></tbody></table><p><strong>完整分布式锁方案：</strong></p><div class="language-lua line-numbers-mode" data-highlighter="shiki" data-ext="lua" data-title="lua" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 加锁Lua脚本</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">if</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> redis</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">call</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;set&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">KEYS</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">], </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">ARGV</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">], </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;nx&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;ex&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">ARGV</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">]) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">then</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">else</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">end</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 解锁Lua脚本  </span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">if</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> redis</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">call</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;get&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">KEYS</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">]) == </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">ARGV</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">] </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">then</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> redis</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">call</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;del&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">KEYS</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">])</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">else</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">end</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>方案对比：</strong></p><table><thead><tr><th>实现方案</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>单Redis节点</td><td>简单，性能好</td><td>单点故障</td><td>对可用性要求不高</td></tr><tr><td>Redis集群</td><td>高可用</td><td>脑裂时可能出现多个锁</td><td>一般业务场景</td></tr><tr><td>Redlock算法</td><td>更高的安全性</td><td>复杂，性能较差</td><td>对数据一致性要求极高</td></tr><tr><td>ZooKeeper</td><td>强一致性，自动续期</td><td>性能较差，依赖ZK集群</td><td>强一致性要求</td></tr></tbody></table><h3 id="_9-redis哨兵的原理-如何实现故障转移" tabindex="-1"><a class="header-anchor" href="#_9-redis哨兵的原理-如何实现故障转移"><span>9. Redis哨兵的原理？如何实现故障转移？</span></a></h3><p><strong>Redis哨兵定义：</strong> Redis Sentinel是Redis官方提供的高可用解决方案，用于监控Redis主从复制集群，并在主节点故障时自动进行故障转移。</p><p><strong>核心功能：</strong></p><table><thead><tr><th>功能</th><th>描述</th><th>作用</th><th>实现方式</th></tr></thead><tbody><tr><td>监控</td><td>持续监控主从节点的健康状态</td><td>及时发现节点故障</td><td>定期发送PING命令</td></tr><tr><td>通知</td><td>当节点状态发生变化时通知管理员</td><td>提供故障告警</td><td>发布订阅机制</td></tr><tr><td>自动故障转移</td><td>主节点故障时自动选举新的主节点</td><td>保证服务持续可用</td><td>选举算法+配置更新</td></tr><tr><td>配置提供</td><td>为客户端提供当前主节点信息</td><td>客户端自动连接到正确的主节点</td><td>服务发现机制</td></tr></tbody></table><p><strong>哨兵工作原理：</strong></p><table><thead><tr><th>阶段</th><th>工作内容</th><th>判断条件</th><th>处理方式</th></tr></thead><tbody><tr><td>主观下线</td><td>单个哨兵认为主节点不可用</td><td>超过down-after-milliseconds时间未响应</td><td>标记为SDOWN</td></tr><tr><td>客观下线</td><td>多个哨兵确认主节点不可用</td><td>达到quorum数量的哨兵确认主观下线</td><td>标记为ODOWN并开始故障转移</td></tr><tr><td>领导者选举</td><td>选出负责故障转移的哨兵</td><td>Raft算法选举</td><td>获得majority票数的哨兵成为领导者</td></tr><tr><td>故障转移</td><td>将从节点提升为新的主节点</td><td>领导者哨兵执行转移流程</td><td>更新配置并通知所有节点</td></tr></tbody></table><p><strong>故障转移详细流程：</strong></p><table><thead><tr><th>步骤</th><th>操作</th><th>目的</th><th>注意事项</th></tr></thead><tbody><tr><td>1</td><td>从从节点中选择新的主节点</td><td>选出最适合的节点</td><td>考虑优先级、复制偏移量、运行ID</td></tr><tr><td>2</td><td>向选中的从节点发送SLAVEOF NO ONE</td><td>将从节点提升为主节点</td><td>确保命令执行成功</td></tr><tr><td>3</td><td>向其他从节点发送SLAVEOF命令</td><td>让其他从节点跟随新主节点</td><td>更新主从关系</td></tr><tr><td>4</td><td>更新哨兵配置文件</td><td>记录新的主节点信息</td><td>持久化配置变更</td></tr><tr><td>5</td><td>向客户端发布新主节点信息</td><td>通知客户端连接新主节点</td><td>通过发布订阅机制</td></tr></tbody></table><p><strong>从节点选择策略：</strong></p><table><thead><tr><th>优先级</th><th>选择条件</th><th>权重</th><th>说明</th></tr></thead><tbody><tr><td>第一优先级</td><td>slave-priority最高</td><td>最高</td><td>手动设置的优先级</td></tr><tr><td>第二优先级</td><td>复制偏移量最大</td><td>高</td><td>数据最新的从节点</td></tr><tr><td>第三优先级</td><td>运行ID最小</td><td>中</td><td>启动时间最早的从节点</td></tr><tr><td>排除条件</td><td>主观下线、断线时间过长、INFO_REPL响应异常</td><td>无</td><td>不健康的节点不参与选举</td></tr></tbody></table><p><strong>哨兵配置示例：</strong></p><table><thead><tr><th>配置项</th><th>示例值</th><th>说明</th></tr></thead><tbody><tr><td>sentinel monitor</td><td>mymaster 127.0.0.1 6379 2</td><td>监控主节点，quorum为2</td></tr><tr><td>sentinel down-after-milliseconds</td><td>mymaster 30000</td><td>30秒无响应判定为主观下线</td></tr><tr><td>sentinel parallel-syncs</td><td>mymaster 1</td><td>故障转移时同时同步的从节点数量</td></tr><tr><td>sentinel failover-timeout</td><td>mymaster 180000</td><td>故障转移超时时间</td></tr><tr><td>sentinel auth-pass</td><td>mymaster mypassword</td><td>连接密码</td></tr></tbody></table><p><strong>优缺点对比：</strong></p><table><thead><tr><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>自动故障转移</td><td>配置相对复杂</td><td>中小型应用</td></tr><tr><td>高可用性</td><td>脑裂问题</td><td>对可用性要求高的系统</td></tr><tr><td>支持多个从节点</td><td>数据可能短暂不一致</td><td>读多写少的业务</td></tr><tr><td>客户端透明</td><td>需要至少3个哨兵节点</td><td>单机房部署</td></tr><tr><td>成熟稳定</td><td>不支持数据分片</td><td>数据量不是特别大的场景</td></tr></tbody></table><p><strong>与其他方案对比：</strong></p><table><thead><tr><th>特性</th><th>Redis哨兵</th><th>Redis Cluster</th><th>主从复制</th></tr></thead><tbody><tr><td>高可用性</td><td>自动故障转移</td><td>自动故障转移</td><td>手动故障转移</td></tr><tr><td>数据分片</td><td>不支持</td><td>支持</td><td>不支持</td></tr><tr><td>配置复杂度</td><td>中等</td><td>高</td><td>低</td></tr><tr><td>客户端支持</td><td>需要支持哨兵协议</td><td>需要支持集群协议</td><td>标准Redis协议</td></tr><tr><td>适用规模</td><td>中小型</td><td>大型</td><td>小型</td></tr><tr><td>数据一致性</td><td>最终一致性</td><td>最终一致性</td><td>最终一致性</td></tr></tbody></table><p><strong>最佳实践：</strong></p><table><thead><tr><th>实践建议</th><th>具体做法</th><th>原因</th></tr></thead><tbody><tr><td>奇数个哨兵节点</td><td>部署3个或5个哨兵</td><td>避免脑裂，确保能选出领导者</td></tr><tr><td>分布式部署</td><td>哨兵部署在不同的物理机器上</td><td>提高容灾能力</td></tr><tr><td>合理设置quorum</td><td>一般设置为哨兵数量的一半+1</td><td>平衡误判和可用性</td></tr><tr><td>监控哨兵状态</td><td>监控哨兵进程和日志</td><td>确保哨兵本身的可用性</td></tr><tr><td>客户端连接池配置</td><td>配置哨兵地址而非直接连接Redis</td><td>实现自动故障转移</td></tr></tbody></table><h2 id="分布式" tabindex="-1"><a class="header-anchor" href="#分布式"><span>分布式</span></a></h2><h3 id="_1-cap理论-base理论" tabindex="-1"><a class="header-anchor" href="#_1-cap理论-base理论"><span>1. CAP理论？BASE理论？</span></a></h3><p><strong>CAP理论（布鲁尔定理）：</strong> 分布式系统不可能同时满足一致性（Consistency）、可用性（Availability）、分区容错性（Partition tolerance）三个特性。</p><table><thead><tr><th>特性</th><th>定义</th><th>说明</th></tr></thead><tbody><tr><td>一致性（C）</td><td>所有节点同时看到相同的数据</td><td>数据在所有节点保持同步</td></tr><tr><td>可用性（A）</td><td>系统持续可用，快速响应</td><td>系统不会因为部分节点故障而停止服务</td></tr><tr><td>分区容错性（P）</td><td>系统在网络分区故障时仍能继续运行</td><td>网络故障不会导致整个系统不可用</td></tr></tbody></table><p><strong>CAP组合选择：</strong></p><table><thead><tr><th>组合</th><th>特点</th><th>典型应用</th><th>使用场景</th></tr></thead><tbody><tr><td>CA</td><td>一致性+可用性</td><td>传统关系型数据库</td><td>单机或局域网环境</td></tr><tr><td>CP</td><td>一致性+分区容错性</td><td>MongoDB、Redis</td><td>数据一致性要求高</td></tr><tr><td>AP</td><td>可用性+分区容错性</td><td>DNS、CDN</td><td>高可用性要求，允许数据延迟</td></tr></tbody></table><p><strong>BASE理论：</strong> 作为CAP理论的延伸，提供了一种在分布式系统中实现高可用的方式。</p><table><thead><tr><th>特性</th><th>全称</th><th>含义</th></tr></thead><tbody><tr><td>基本可用（BA）</td><td>Basically Available</td><td>系统基本可用，允许损失部分功能</td></tr><tr><td>软状态（S）</td><td>Soft State</td><td>允许系统中数据存在中间状态</td></tr><tr><td>最终一致性（E）</td><td>Eventually Consistent</td><td>系统中数据最终达到一致状态</td></tr></tbody></table><h3 id="_2-分布式事务的解决方案" tabindex="-1"><a class="header-anchor" href="#_2-分布式事务的解决方案"><span>2. 分布式事务的解决方案？</span></a></h3><p><strong>分布式事务挑战：</strong> 跨多个服务或数据库的事务操作，需要保证ACID特性。</p><p><strong>解决方案对比：</strong></p><table><thead><tr><th>方案</th><th>实现原理</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>2PC</td><td>两阶段提交</td><td>强一致性</td><td>阻塞、单点故障</td><td>强一致性要求</td></tr><tr><td>3PC</td><td>三阶段提交</td><td>减少阻塞时间</td><td>复杂度高、网络分区问题</td><td>对2PC的改进</td></tr><tr><td>TCC</td><td>Try-Confirm-Cancel</td><td>业务无侵入</td><td>实现复杂、补偿逻辑</td><td>业务逻辑相对简单</td></tr><tr><td>Saga</td><td>长事务拆分+补偿</td><td>高性能、最终一致性</td><td>补偿逻辑复杂</td><td>长流程业务</td></tr><tr><td>消息事务</td><td>消息队列保证最终一致性</td><td>异步高性能</td><td>最终一致性、消息重复</td><td>异步处理场景</td></tr><tr><td>最大努力通知</td><td>定期重试+人工介入</td><td>简单易实现</td><td>可能不一致</td><td>对一致性要求不严格</td></tr></tbody></table><p><strong>详细方案分析：</strong></p><table><thead><tr><th>方案特点</th><th>2PC</th><th>TCC</th><th>Saga</th></tr></thead><tbody><tr><td>一致性</td><td>强一致性</td><td>最终一致性</td><td>最终一致性</td></tr><tr><td>性能</td><td>较差</td><td>好</td><td>好</td></tr><tr><td>复杂度</td><td>简单</td><td>中等</td><td>复杂</td></tr><tr><td>业务侵入性</td><td>无</td><td>中等</td><td>高</td></tr><tr><td>故障恢复</td><td>困难</td><td>相对容易</td><td>容易</td></tr></tbody></table><h3 id="_3-分布式锁的实现" tabindex="-1"><a class="header-anchor" href="#_3-分布式锁的实现"><span>3. 分布式锁的实现？</span></a></h3><p><strong>实现方案对比：</strong></p><table><thead><tr><th>实现方案</th><th>原理</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>数据库锁</td><td>基于数据库唯一索引</td><td>简单易理解</td><td>性能差、单点故障</td><td>简单场景</td></tr><tr><td>Redis分布式锁</td><td>SET NX EX命令</td><td>性能好、支持过期</td><td>可能出现锁丢失</td><td>一般业务场景</td></tr><tr><td>ZooKeeper临时节点</td><td>临时有序节点</td><td>强一致性、自动释放</td><td>性能相对较差</td><td>强一致性要求</td></tr><tr><td>Etcd</td><td>基于Raft算法的分布式锁</td><td>强一致性、高可用</td><td>依赖额外组件</td><td>微服务架构</td></tr></tbody></table><p><strong>各方案详细对比：</strong></p><table><thead><tr><th>对比维度</th><th>Redis</th><th>ZooKeeper</th><th>数据库</th><th>Etcd</th></tr></thead><tbody><tr><td>性能</td><td>高</td><td>中</td><td>低</td><td>中</td></tr><tr><td>可靠性</td><td>中</td><td>高</td><td>中</td><td>高</td></tr><tr><td>复杂度</td><td>低</td><td>中</td><td>低</td><td>中</td></tr><tr><td>运维成本</td><td>低</td><td>中</td><td>低</td><td>中</td></tr><tr><td>社区支持</td><td>好</td><td>好</td><td>好</td><td>好</td></tr></tbody></table><h3 id="_4-分布式id生成方案" tabindex="-1"><a class="header-anchor" href="#_4-分布式id生成方案"><span>4. 分布式ID生成方案？</span></a></h3><p><strong>ID生成方案对比：</strong></p><table><thead><tr><th>方案</th><th>实现原理</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>UUID</td><td>随机生成128位标识符</td><td>简单、本地生成</td><td>无序、占用空间大</td><td>对顺序无要求的场景</td></tr><tr><td>数据库自增ID</td><td>数据库AUTO_INCREMENT</td><td>简单、有序</td><td>性能瓶颈、单点故障</td><td>单机应用</td></tr><tr><td>号段模式</td><td>批量获取ID段</td><td>高性能、减少数据库访问</td><td>浪费ID、重启丢失</td><td>高并发场景</td></tr><tr><td>雪花算法</td><td>时间戳+机器ID+序列号</td><td>有序、高性能、分布式</td><td>时钟回拨问题</td><td>分布式高并发</td></tr><tr><td>美团Leaf</td><td>号段模式+雪花算法优化</td><td>高可用、性能好</td><td>复杂度较高</td><td>大规模分布式系统</td></tr><tr><td>百度UidGenerator</td><td>雪花算法优化</td><td>解决时钟回拨、高性能</td><td>依赖机器时间</td><td>对顺序性要求高的场景</td></tr></tbody></table><p><strong>雪花算法详解：</strong></p><table><thead><tr><th>组成部分</th><th>位数</th><th>说明</th><th>取值范围</th></tr></thead><tbody><tr><td>符号位</td><td>1位</td><td>固定为0</td><td>0</td></tr><tr><td>时间戳</td><td>41位</td><td>相对于某个起始时间的毫秒数</td><td>69年</td></tr><tr><td>机器ID</td><td>10位</td><td>数据中心ID(5位)+机器ID(5位)</td><td>1024台机器</td></tr><tr><td>序列号</td><td>12位</td><td>毫秒内的序列号</td><td>4096个序列号</td></tr></tbody></table><p><strong>雪花算法时钟回拨问题及解决方案：</strong></p><p><strong>问题产生原因：</strong></p><ul><li>系统时钟被人为调整（向后调整）</li><li>NTP时间同步导致时钟回退</li><li>虚拟机时钟漂移</li><li>闰秒调整</li></ul><p><strong>解决方案对比：</strong></p><table><thead><tr><th>解决方案</th><th>实现原理</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>抛出异常</td><td>检测到回拨立即抛异常</td><td>简单，保证ID不重复</td><td>服务不可用</td><td>对一致性要求极高</td></tr><tr><td>等待时钟追上</td><td>阻塞等待直到时钟超过上次时间戳</td><td>ID绝对不重复</td><td>可能长时间阻塞</td><td>回拨时间较短</td></tr><tr><td>使用备用方案</td><td>回拨时切换到其他ID生成方式</td><td>服务持续可用</td><td>需要维护多套方案</td><td>高可用要求</td></tr><tr><td>容忍小幅回拨</td><td>允许小范围（如5秒内）回拨</td><td>性能好，可用性高</td><td>可能产生重复ID</td><td>一般业务场景</td></tr><tr><td>机器位扩展</td><td>增加机器位，减少时间戳位数</td><td>减少时钟依赖</td><td>ID长度可能增加</td><td>集群规模大</td></tr></tbody></table><p><strong>详细实现方案：</strong></p><table><thead><tr><th>方案类型</th><th>具体实现</th><th>代码逻辑</th><th>注意事项</th></tr></thead><tbody><tr><td>异常处理</td><td>检测当前时间 &lt; 上次时间，抛TimeBackException</td><td>if(current &lt; lastTime) throw</td><td>需要上层调用处理异常</td></tr><tr><td>自旋等待</td><td>while循环等待时钟追上</td><td>while(current &lt;= lastTime)</td><td>可能长时间占用CPU</td></tr><tr><td>序列号预留</td><td>预留部分序列号给回拨时使用</td><td>正常时使用0-2047，回拨时使用2048-4095</td><td>需要合理分配序列号空间</td></tr><tr><td>时间戳缓存</td><td>缓存最近的时间戳，回拨时使用缓存值</td><td>维护时间戳队列</td><td>需要考虑缓存大小和过期策略</td></tr></tbody></table><p><strong>方案选择建议：</strong></p><table><thead><tr><th>场景需求</th><th>推荐方案</th><th>原因</th></tr></thead><tbody><tr><td>对性能要求不高</td><td>UUID</td><td>实现简单</td></tr><tr><td>需要有序ID</td><td>雪花算法</td><td>趋势递增、性能好</td></tr><tr><td>超高并发</td><td>号段模式</td><td>批量获取、减少竞争</td></tr><tr><td>对可用性要求极高</td><td>美团Leaf/百度UidGenerator</td><td>双buffer、解决时钟回拨问题</td></tr></tbody></table><h3 id="_5-负载均衡算法" tabindex="-1"><a class="header-anchor" href="#_5-负载均衡算法"><span>5. 负载均衡算法？</span></a></h3><p><strong>负载均衡算法对比：</strong></p><table><thead><tr><th>算法</th><th>实现原理</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>轮询</td><td>依次分配请求到每个服务器</td><td>简单、分布均匀</td><td>不考虑服务器性能差异</td><td>服务器性能相近</td></tr><tr><td>加权轮询</td><td>根据权重分配请求</td><td>考虑服务器性能差异</td><td>静态权重、不能动态调整</td><td>服务器性能差异已知</td></tr><tr><td>最少连接</td><td>分配到连接数最少的服务器</td><td>考虑服务器当前负载</td><td>需要维护连接数统计</td><td>长连接场景</td></tr><tr><td>加权最少连接</td><td>结合权重和连接数</td><td>综合考虑性能和负载</td><td>计算复杂度高</td><td>复杂负载场景</td></tr><tr><td>随机</td><td>随机选择服务器</td><td>实现简单</td><td>可能分布不均匀</td><td>服务器数量多</td></tr><tr><td>加权随机</td><td>根据权重随机选择</td><td>简单、考虑性能差异</td><td>短期可能不均匀</td><td>一般业务场景</td></tr><tr><td>IP Hash</td><td>根据客户端IP哈希选择</td><td>相同IP访问同一服务器</td><td>可能负载不均</td><td>需要会话保持</td></tr><tr><td>最短响应时间</td><td>选择响应时间最短的服务器</td><td>考虑服务器实际性能</td><td>需要监控响应时间</td><td>对延迟敏感的应用</td></tr></tbody></table><p><strong>算法适用场景详解：</strong></p><table><thead><tr><th>业务特点</th><th>推荐算法</th><th>原因</th></tr></thead><tbody><tr><td>无状态服务</td><td>轮询/随机</td><td>简单高效，分布均匀</td></tr><tr><td>有状态服务</td><td>IP Hash</td><td>保证同一用户访问同一服务器</td></tr><tr><td>服务器性能差异大</td><td>加权轮询/加权随机</td><td>根据性能分配不同权重</td></tr><tr><td>长连接场景</td><td>最少连接</td><td>避免连接过度集中</td></tr><tr><td>对延迟敏感</td><td>最短响应时间</td><td>选择响应最快的服务器</td></tr><tr><td>高并发场景</td><td>一致性哈希</td><td>避免服务器变化时大量请求重新分配</td></tr></tbody></table><ul><li>一致性哈希：一致性哈希是一种分布式哈希算法，主要用于将数据均匀且稳定地分布到多个节点上，减少节点变动时数据重新分配的开销。将所有的节点和数据都映射到一个虚拟的哈希环（0 到 2³²-1 的范围）上。数据根据哈希值顺时针找到第一个节点并存储在该节点上。当新增或移除节点时，仅需重新分配该节点顺时针邻居范围内的数据，避免了数据大规模迁移，提高了系统的可扩展性和稳定性。</li></ul><p><strong>实现层级对比：</strong></p><table><thead><tr><th>实现层级</th><th>特点</th><th>代表产品</th><th>优势</th><th>劣势</th></tr></thead><tbody><tr><td>4层负载均衡</td><td>基于IP和端口进行负载均衡</td><td>LVS、F5</td><td>性能高、透明</td><td>功能相对简单</td></tr><tr><td>7层负载均衡</td><td>基于应用层内容进行负载均衡</td><td>Nginx、HAProxy</td><td>功能丰富、灵活</td><td>性能相对较低</td></tr><tr><td>DNS负载均衡</td><td>通过DNS解析实现负载均衡</td><td>云解析</td><td>简单、分布式</td><td>精度不高、缓存问题</td></tr></tbody></table><h2 id="微服务" tabindex="-1"><a class="header-anchor" href="#微服务"><span>微服务</span></a></h2><h3 id="_1-微服务的优势和挑战" tabindex="-1"><a class="header-anchor" href="#_1-微服务的优势和挑战"><span>1. 微服务的优势和挑战？</span></a></h3><p><strong>微服务定义：</strong> 将单一应用程序拆分为一组小型服务，每个服务运行在独立进程中，通过轻量级通信机制协作。</p><p><strong>优势 vs 挑战对比：</strong></p><table><thead><tr><th>维度</th><th>优势</th><th>挑战</th></tr></thead><tbody><tr><td>开发维护</td><td>代码库小、团队独立开发、技术栈灵活</td><td>服务间协调复杂、版本管理困难</td></tr><tr><td>部署运维</td><td>独立部署、故障隔离、弹性伸缩</td><td>运维复杂度高、监控困难</td></tr><tr><td>性能扩展</td><td>按需扩展、资源利用率高</td><td>网络延迟、分布式事务复杂</td></tr><tr><td>团队协作</td><td>团队自治、并行开发</td><td>服务边界划分难、团队沟通成本高</td></tr><tr><td>系统稳定性</td><td>单点故障影响范围小</td><td>服务间依赖复杂、调试困难</td></tr></tbody></table><p><strong>适用场景判断：</strong></p><table><thead><tr><th>项目特征</th><th>单体架构</th><th>微服务架构</th><th>推荐理由</th></tr></thead><tbody><tr><td>团队规模</td><td>&lt; 10人</td><td>&gt; 10人</td><td>微服务需要足够的团队支撑</td></tr><tr><td>业务复杂度</td><td>简单</td><td>复杂</td><td>复杂业务适合拆分独立维护</td></tr><tr><td>技术栈要求</td><td>统一</td><td>多样化</td><td>微服务支持不同技术栈</td></tr><tr><td>部署频率</td><td>低</td><td>高</td><td>微服务支持独立快速部署</td></tr><tr><td>扩展性要求</td><td>一般</td><td>高</td><td>微服务支持按需精确扩展</td></tr></tbody></table><h3 id="_2-服务注册与发现-原理-常用组件-比较" tabindex="-1"><a class="header-anchor" href="#_2-服务注册与发现-原理-常用组件-比较"><span>2. 服务注册与发现：原理？常用组件？比较？</span></a></h3><p><strong>服务发现原理：</strong> 解决微服务环境下服务实例动态变化时的相互发现和调用问题。</p><p><strong>实现模式对比：</strong></p><table><thead><tr><th>模式</th><th>原理</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>客户端发现</td><td>客户端查询注册中心获取服务实例列表</td><td>性能好、负载均衡灵活</td><td>客户端逻辑复杂、语言绑定</td><td>性能要求高</td></tr><tr><td>服务端发现</td><td>通过负载均衡器代理访问服务</td><td>客户端简单、语言无关</td><td>负载均衡器成为瓶颈</td><td>多语言环境</td></tr><tr><td>服务网格</td><td>基础设施层处理服务通信</td><td>业务无感知、功能丰富</td><td>架构复杂、性能开销</td><td>大规模微服务</td></tr></tbody></table><p><strong>主流组件对比：</strong></p><table><thead><tr><th>组件</th><th>类型</th><th>一致性算法</th><th>多数据中心</th><th>健康检查</th><th>负载均衡</th><th>适用场景</th></tr></thead><tbody><tr><td>Eureka</td><td>AP</td><td>无</td><td>支持</td><td>支持</td><td>客户端</td><td>Spring Cloud</td></tr><tr><td>Consul</td><td>CP</td><td>Raft</td><td>支持</td><td>支持</td><td>支持</td><td>多语言环境</td></tr><tr><td>Zookeeper</td><td>CP</td><td>ZAB</td><td>支持</td><td>支持</td><td>不支持</td><td>Dubbo生态</td></tr><tr><td>Nacos</td><td>AP/CP</td><td>Raft</td><td>支持</td><td>支持</td><td>支持</td><td>阿里云生态</td></tr><tr><td>Etcd</td><td>CP</td><td>Raft</td><td>支持</td><td>支持</td><td>不支持</td><td>Kubernetes</td></tr></tbody></table><h3 id="_3-服务调用-restful-api-和-rpc-dubbo-grpc-比较" tabindex="-1"><a class="header-anchor" href="#_3-服务调用-restful-api-和-rpc-dubbo-grpc-比较"><span>3. 服务调用：RESTful API 和 RPC (Dubbo, gRPC)？比较？</span></a></h3><p><strong>调用方式对比：</strong></p><table><thead><tr><th>特性</th><th>RESTful API</th><th>RPC (Dubbo)</th><th>RPC (gRPC)</th></tr></thead><tbody><tr><td>协议</td><td>HTTP/HTTPS</td><td>TCP/HTTP</td><td>HTTP/2</td></tr><tr><td>序列化</td><td>JSON/XML</td><td>Hessian/Kryo</td><td>Protocol Buffers</td></tr><tr><td>性能</td><td>中等</td><td>高</td><td>高</td></tr><tr><td>跨语言支持</td><td>优秀</td><td>Java生态</td><td>优秀</td></tr><tr><td>学习成本</td><td>低</td><td>中等</td><td>中等</td></tr><tr><td>生态完整性</td><td>丰富</td><td>Java生态丰富</td><td>快速发展中</td></tr><tr><td>适用场景</td><td>Web服务、对外API</td><td>Java微服务</td><td>多语言微服务</td></tr></tbody></table><p><strong>技术选型建议：</strong></p><table><thead><tr><th>场景需求</th><th>推荐方案</th><th>原因</th></tr></thead><tbody><tr><td>对外开放API</td><td>RESTful API</td><td>标准化、易于集成</td></tr><tr><td>内部服务高性能调用</td><td>Dubbo/gRPC</td><td>性能好、功能丰富</td></tr><tr><td>多语言团队</td><td>gRPC</td><td>跨语言支持好</td></tr><tr><td>Spring Boot项目</td><td>RESTful API</td><td>生态集成度高</td></tr><tr><td>大数据量传输</td><td>gRPC</td><td>二进制序列化、HTTP/2协议</td></tr><tr><td>快速原型开发</td><td>RESTful API</td><td>开发简单、调试方便</td></tr></tbody></table><h3 id="_4-服务网关-api-gateway-作用-常用组件" tabindex="-1"><a class="header-anchor" href="#_4-服务网关-api-gateway-作用-常用组件"><span>4. 服务网关 (API Gateway)：作用？常用组件？</span></a></h3><p><strong>API网关作用：</strong> 作为所有客户端请求的统一入口，提供路由、认证、限流、监控等功能。</p><p><strong>核心功能对比：</strong></p><table><thead><tr><th>功能类别</th><th>具体功能</th><th>价值</th><th>实现方式</th></tr></thead><tbody><tr><td>请求路由</td><td>动态路由、负载均衡</td><td>请求分发到正确服务</td><td>规则配置、服务发现</td></tr><tr><td>安全认证</td><td>身份验证、权限控制</td><td>统一安全策略</td><td>JWT、OAuth2</td></tr><tr><td>流量控制</td><td>限流、熔断、降级</td><td>保护后端服务</td><td>令牌桶、熔断器</td></tr><tr><td>协议转换</td><td>HTTP/WebSocket等</td><td>协议统一</td><td>协议适配器</td></tr><tr><td>监控运维</td><td>日志、监控、链路追踪</td><td>可观测性</td><td>APM集成</td></tr></tbody></table><p><strong>主流网关对比：</strong></p><table><thead><tr><th>网关</th><th>类型</th><th>性能</th><th>功能丰富度</th><th>生态集成</th><th>学习成本</th><th>适用场景</th></tr></thead><tbody><tr><td>Spring Cloud Gateway</td><td>响应式</td><td>高</td><td>丰富</td><td>Spring</td><td>中等</td><td>Spring Cloud项目</td></tr><tr><td>Zuul</td><td>阻塞式</td><td>中</td><td>基础</td><td>Spring</td><td>低</td><td>简单场景</td></tr><tr><td>Kong</td><td>高性能</td><td>很高</td><td>极丰富</td><td>开放</td><td>高</td><td>企业级应用</td></tr><tr><td>Nginx Plus</td><td>反向代理</td><td>极高</td><td>丰富</td><td>广泛</td><td>中等</td><td>高并发场景</td></tr><tr><td>Envoy</td><td>代理</td><td>高</td><td>丰富</td><td>云原生</td><td>高</td><td>服务网格</td></tr></tbody></table><h3 id="_5-配置中心-作用-常用组件" tabindex="-1"><a class="header-anchor" href="#_5-配置中心-作用-常用组件"><span>5. 配置中心：作用？常用组件？</span></a></h3><p><strong>配置中心价值：</strong> 集中管理微服务配置，支持动态更新，避免重启服务。</p><p><strong>核心能力对比：</strong></p><table><thead><tr><th>能力</th><th>传统配置文件</th><th>配置中心</th><th>提升效果</th></tr></thead><tbody><tr><td>配置管理</td><td>散落在各个服务</td><td>集中统一管理</td><td>管理效率提升90%</td></tr><tr><td>动态更新</td><td>需要重启服务</td><td>实时推送更新</td><td>变更速度提升10倍</td></tr><tr><td>环境隔离</td><td>手动维护多套配置</td><td>自动环境区分</td><td>错误率降低80%</td></tr><tr><td>权限控制</td><td>无权限控制</td><td>细粒度权限管理</td><td>安全性大幅提升</td></tr><tr><td>版本管理</td><td>手动备份</td><td>自动版本控制和回滚</td><td>可靠性提升</td></tr></tbody></table><p><strong>主流配置中心对比：</strong></p><table><thead><tr><th>组件</th><th>数据存储</th><th>动态推送</th><th>多环境</th><th>权限控制</th><th>可视化界面</th><th>生态集成</th></tr></thead><tbody><tr><td>Spring Cloud Config</td><td>Git/SVN</td><td>需结合Bus</td><td>支持</td><td>基础</td><td>基础</td><td>Spring生态</td></tr><tr><td>Apollo</td><td>MySQL</td><td>支持</td><td>支持</td><td>完善</td><td>优秀</td><td>多语言</td></tr><tr><td>Nacos</td><td>内置数据库</td><td>支持</td><td>支持</td><td>支持</td><td>优秀</td><td>阿里云生态</td></tr><tr><td>Consul</td><td>KV存储</td><td>支持</td><td>支持</td><td>支持</td><td>基础</td><td>HashiCorp生态</td></tr></tbody></table><h3 id="_6-服务容错-熔断、降级、限流-令牌桶、漏桶-sentinel和hystrix" tabindex="-1"><a class="header-anchor" href="#_6-服务容错-熔断、降级、限流-令牌桶、漏桶-sentinel和hystrix"><span>6. 服务容错：熔断、降级、限流 (令牌桶、漏桶)，Sentinel和Hystrix？</span></a></h3><p><strong>容错机制对比：</strong></p><table><thead><tr><th>机制</th><th>目的</th><th>触发条件</th><th>恢复机制</th><th>适用场景</th></tr></thead><tbody><tr><td>熔断</td><td>避免连锁故障</td><td>错误率/响应时间超阈值</td><td>半开状态探测</td><td>依赖服务不稳定</td></tr><tr><td>降级</td><td>保证核心功能可用</td><td>系统负载过高</td><td>手动或自动恢复</td><td>非核心功能可牺牲</td></tr><tr><td>限流</td><td>保护系统不被压垮</td><td>请求量超过系统处理能力</td><td>拒绝或排队等待</td><td>高并发场景</td></tr></tbody></table><p><strong>限流算法对比：</strong></p><table><thead><tr><th>算法</th><th>原理</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>令牌桶</td><td>固定速率产生令牌，请求消耗令牌</td><td>允许突发流量</td><td>实现相对复杂</td><td>允许突发的业务场景</td></tr><tr><td>漏桶</td><td>请求以固定速率处理</td><td>流量平滑</td><td>不能处理突发流量</td><td>需要平滑处理的场景</td></tr><tr><td>固定窗口</td><td>固定时间窗口内限制请求数量</td><td>实现简单</td><td>临界问题</td><td>简单限流场景</td></tr><tr><td>滑动窗口</td><td>动态时间窗口统计</td><td>更精确的限流</td><td>内存占用大</td><td>精确限流需求</td></tr></tbody></table><p><strong>Sentinel vs Hystrix：</strong></p><table><thead><tr><th>对比维度</th><th>Sentinel</th><th>Hystrix</th></tr></thead><tbody><tr><td>开发状态</td><td>活跃开发</td><td>停止维护</td></tr><tr><td>性能</td><td>更优</td><td>较好</td></tr><tr><td>功能丰富度</td><td>全面（熔断+限流+降级+系统保护）</td><td>主要专注熔断降级</td></tr><tr><td>控制台</td><td>功能强大的实时监控</td><td>基础监控</td></tr><tr><td>规则配置</td><td>支持多种数据源动态配置</td><td>主要基于注解和配置文件</td></tr><tr><td>生态集成</td><td>Spring Cloud Alibaba</td><td>Spring Cloud Netflix</td></tr><tr><td>学习成本</td><td>中等</td><td>较低</td></tr></tbody></table><h3 id="_7-链路追踪-目的-原理-常用组件-zipkin-skywalking" tabindex="-1"><a class="header-anchor" href="#_7-链路追踪-目的-原理-常用组件-zipkin-skywalking"><span>7. 链路追踪：目的？原理？常用组件 (Zipkin, SkyWalking)？</span></a></h3><p><strong>链路追踪目的：</strong> 在分布式系统中追踪请求的完整调用链路，快速定位性能瓶颈和故障根因。</p><p><strong>核心概念：</strong></p><table><thead><tr><th>概念</th><th>定义</th><th>作用</th></tr></thead><tbody><tr><td>Trace</td><td>一次完整的请求调用链路</td><td>代表一次业务请求的全链路</td></tr><tr><td>Span</td><td>链路中的一个操作单元</td><td>代表一次服务调用或操作</td></tr><tr><td>SpanId</td><td>Span的唯一标识</td><td>标识具体的操作单元</td></tr><tr><td>TraceId</td><td>Trace的唯一标识</td><td>串联整个调用链路</td></tr><tr><td>采样率</td><td>采集链路数据的比例</td><td>平衡性能和可观测性</td></tr></tbody></table><p><strong>实现原理：</strong></p><ol><li><strong>埋点收集</strong>：在应用中插入追踪代码收集调用信息</li><li><strong>传递TraceId</strong>：通过HTTP头或RPC上下文传递追踪标识</li><li><strong>数据上报</strong>：异步上报链路数据到追踪系统</li><li><strong>存储分析</strong>：存储并分析链路数据，提供查询界面</li></ol><p><strong>主流组件对比：</strong></p><table><thead><tr><th>组件</th><th>开发者</th><th>语言支持</th><th>存储支持</th><th>性能开销</th><th>界面友好度</th><th>生态集成</th></tr></thead><tbody><tr><td>Zipkin</td><td>Twitter</td><td>多语言</td><td>多种存储后端</td><td>低</td><td>一般</td><td>广泛</td></tr><tr><td>SkyWalking</td><td>Apache</td><td>Java为主</td><td>ES/H2/MySQL</td><td>低</td><td>优秀</td><td>Java生态</td></tr><tr><td>Jaeger</td><td>Uber</td><td>多语言</td><td>多种存储后端</td><td>低</td><td>良好</td><td>云原生</td></tr><tr><td>Pinpoint</td><td>Naver</td><td>Java</td><td>HBase</td><td>中等</td><td>优秀</td><td>Java专用</td></tr></tbody></table><p><strong>技术选型建议：</strong></p><table><thead><tr><th>场景需求</th><th>推荐方案</th><th>选择理由</th></tr></thead><tbody><tr><td>Java微服务</td><td>SkyWalking</td><td>无侵入、功能全面、界面友好</td></tr><tr><td>多语言环境</td><td>Zipkin/Jaeger</td><td>语言支持广泛</td></tr><tr><td>云原生架构</td><td>Jaeger</td><td>CNCF项目，K8s集成好</td></tr><tr><td>性能敏感应用</td><td>自研或轻量级方案</td><td>减少性能开销</td></tr><tr><td>大数据量场景</td><td>SkyWalking</td><td>支持采样和聚合分析</td></tr><tr><td>快速上手</td><td>Zipkin</td><td>简单易用，社区资源丰富</td></tr></tbody></table><h2 id="消息队列" tabindex="-1"><a class="header-anchor" href="#消息队列"><span>消息队列</span></a></h2><h3 id="_1-消息队列的作用-解耦、异步、削峰填谷" tabindex="-1"><a class="header-anchor" href="#_1-消息队列的作用-解耦、异步、削峰填谷"><span>1. 消息队列的作用？（解耦、异步、削峰填谷）</span></a></h3><p><strong>消息队列定义：</strong> 在分布式系统中用于服务间通信的中间件，实现消息的异步传递和处理。</p><p><strong>三大核心作用：</strong></p><table><thead><tr><th>作用</th><th>定义</th><th>解决问题</th><th>应用场景</th><th>效果评估</th></tr></thead><tbody><tr><td>解耦</td><td>消息发送者和接收者不直接依赖</td><td>系统间强耦合</td><td>订单系统通知库存、支付、物流系统</td><td>耦合度降低80%</td></tr><tr><td>异步</td><td>发送消息后立即返回，不等待处理结果</td><td>同步调用响应时间长</td><td>用户注册后发送邮件、短信</td><td>响应时间减少70%</td></tr><tr><td>削峰填谷</td><td>缓冲高并发请求，平滑处理</td><td>瞬时高并发冲击</td><td>秒杀活动、双11促销</td><td>系统稳定性提升</td></tr></tbody></table><p><strong>使用前后对比：</strong></p><table><thead><tr><th>场景</th><th>不使用消息队列</th><th>使用消息队列</th><th>改善效果</th></tr></thead><tbody><tr><td>订单处理</td><td>同步调用库存、支付、物流，响应时间3秒</td><td>异步通知，响应时间500ms</td><td>响应速度提升6倍</td></tr><tr><td>系统故障</td><td>一个服务故障导致整个链路失败</td><td>服务故障不影响消息发送，具备容错能力</td><td>可用性从95%提升到99.9%</td></tr><tr><td>促销活动</td><td>瞬时流量冲垮系统</td><td>消息队列缓冲，平稳处理</td><td>系统零宕机</td></tr></tbody></table><h3 id="_2-消息模型-点对点queue和发布-订阅topic" tabindex="-1"><a class="header-anchor" href="#_2-消息模型-点对点queue和发布-订阅topic"><span>2. 消息模型？（点对点Queue和发布/订阅Topic）</span></a></h3><p><strong>两种消息模型对比：</strong></p><table><thead><tr><th>特性</th><th>点对点模型（Queue）</th><th>发布/订阅模型（Topic）</th></tr></thead><tbody><tr><td>消息消费</td><td>一条消息只能被一个消费者消费</td><td>一条消息可以被多个消费者消费</td></tr><tr><td>消费者关系</td><td>竞争关系</td><td>独立关系</td></tr><tr><td>消息持久化</td><td>消费后从队列删除</td><td>根据配置决定是否删除</td></tr><tr><td>扩展性</td><td>通过增加消费者实现负载均衡</td><td>通过增加订阅者实现广播</td></tr><tr><td>应用场景</td><td>任务分发、负载均衡</td><td>事件通知、数据同步</td></tr><tr><td>典型例子</td><td>订单处理队列</td><td>用户注册事件广播</td></tr></tbody></table><p><strong>使用场景选择：</strong></p><table><thead><tr><th>业务需求</th><th>推荐模型</th><th>原因</th><th>典型应用</th></tr></thead><tbody><tr><td>任务处理</td><td>Queue</td><td>确保每个任务只被处理一次</td><td>邮件发送、文件处理</td></tr><tr><td>事件广播</td><td>Topic</td><td>多个系统需要响应同一事件</td><td>用户注册、订单状态变更</td></tr><tr><td>负载均衡</td><td>Queue</td><td>多个消费者竞争处理消息</td><td>并发订单处理</td></tr><tr><td>数据同步</td><td>Topic</td><td>多个下游系统需要同步数据</td><td>数据仓库同步、缓存更新</td></tr><tr><td>日志收集</td><td>Topic</td><td>多个监控系统需要收集日志</td><td>ELK日志分析</td></tr></tbody></table><h3 id="_3-如何保证消息不丢失" tabindex="-1"><a class="header-anchor" href="#_3-如何保证消息不丢失"><span>3. 如何保证消息不丢失？</span></a></h3><p><strong>消息丢失的三个阶段：</strong></p><table><thead><tr><th>阶段</th><th>丢失场景</th><th>解决方案</th><th>实现方式</th></tr></thead><tbody><tr><td>生产者阶段</td><td>网络故障、Broker宕机</td><td>生产者确认机制</td><td>同步发送、异步回调确认</td></tr><tr><td>Broker阶段</td><td>消息未持久化到磁盘</td><td>消息持久化</td><td>同步刷盘、主从复制</td></tr><tr><td>消费者阶段</td><td>消费者宕机、处理失败</td><td>手动ACK</td><td>消费成功后再确认</td></tr></tbody></table><p><strong>详细保障机制：</strong></p><table><thead><tr><th>保障机制</th><th>实现原理</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>生产者确认</td><td>Producer等待Broker确认</td><td>确保消息到达Broker</td><td>性能略有下降</td><td>重要业务消息</td></tr><tr><td>同步刷盘</td><td>消息写入磁盘后返回确认</td><td>数据安全性高</td><td>性能影响大</td><td>金融级别可靠性</td></tr><tr><td>异步刷盘</td><td>消息先写入内存，异步写入磁盘</td><td>性能好</td><td>极端情况可能丢失消息</td><td>一般业务场景</td></tr><tr><td>主从复制</td><td>主节点同步消息到从节点</td><td>高可用</td><td>网络开销</td><td>高可用要求</td></tr><tr><td>手动ACK</td><td>消费者处理完业务逻辑后手动确认</td><td>确保消息被正确处理</td><td>需要处理重复消息</td><td>所有重要业务</td></tr></tbody></table><ul><li>刷盘：把内存中的数据写入磁盘文件，确保数据真正持久化到硬盘。</li></ul><h3 id="_4-如何保证消息不被重复消费-幂等性" tabindex="-1"><a class="header-anchor" href="#_4-如何保证消息不被重复消费-幂等性"><span>4. 如何保证消息不被重复消费（幂等性）？</span></a></h3><p><strong>重复消费产生原因：</strong></p><ul><li>网络抖动导致ACK丢失</li><li>消费者重启导致消息重新投递</li><li>Broker故障恢复后重新发送消息</li></ul><p><strong>幂等性保障方案：</strong></p><table><thead><tr><th>方案</th><th>实现原理</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>唯一ID去重</td><td>每条消息携带唯一标识</td><td>简单有效</td><td>需要存储已处理ID</td><td>通用场景</td></tr><tr><td>数据库唯一约束</td><td>利用数据库唯一索引</td><td>实现简单</td><td>依赖数据库</td><td>数据库操作为主的业务</td></tr><tr><td>Redis去重</td><td>使用Redis存储消息ID</td><td>性能好</td><td>需要额外的Redis实例</td><td>高性能要求</td></tr><tr><td>状态机控制</td><td>通过业务状态判断是否已处理</td><td>业务语义明确</td><td>业务逻辑复杂</td><td>有明确状态的业务流程</td></tr><tr><td>业务逻辑幂等</td><td>设计天然幂等的业务逻辑</td><td>无额外开销</td><td>并非所有业务都能实现</td><td>查询类操作</td></tr></tbody></table><p><strong>实现示例对比：</strong></p><table><thead><tr><th>业务场景</th><th>推荐方案</th><th>实现方式</th><th>注意事项</th></tr></thead><tbody><tr><td>账户扣款</td><td>数据库唯一约束</td><td>订单号作为唯一约束</td><td>避免重复扣款</td></tr><tr><td>发送邮件</td><td>Redis去重</td><td>消息ID作为Redis key</td><td>设置合理的过期时间</td></tr><tr><td>数据同步</td><td>状态机控制</td><td>检查目标数据是否已存在</td><td>处理并发更新问题</td></tr><tr><td>积分增加</td><td>业务逻辑幂等</td><td>使用CAS操作更新积分</td><td>处理ABA问题</td></tr></tbody></table><h3 id="_5-如何保证消息的顺序性" tabindex="-1"><a class="header-anchor" href="#_5-如何保证消息的顺序性"><span>5. 如何保证消息的顺序性？</span></a></h3><p><strong>顺序性需求分析：</strong></p><table><thead><tr><th>顺序性类型</th><th>定义</th><th>实现难度</th><th>性能影响</th><th>适用场景</th></tr></thead><tbody><tr><td>全局有序</td><td>所有消息严格按时间顺序处理</td><td>高</td><td>大</td><td>金融交易、账务流水</td></tr><tr><td>分区有序</td><td>同一分区内消息有序</td><td>中</td><td>小</td><td>同一用户的操作序列</td></tr><tr><td>局部有序</td><td>特定业务场景下的消息有序</td><td>低</td><td>无</td><td>单个订单的状态变更流程</td></tr></tbody></table><p><strong>实现方案对比：</strong></p><table><thead><tr><th>方案</th><th>实现方式</th><th>优点</th><th>缺点</th><th>性能影响</th></tr></thead><tbody><tr><td>单队列单消费者</td><td>只使用一个队列和一个消费者</td><td>严格有序</td><td>性能瓶颈、无法扩展</td><td>性能最差</td></tr><tr><td>分区有序</td><td>相同Key的消息发送到同一分区</td><td>平衡性能与顺序</td><td>分区内有序、全局无序</td><td>性能较好</td></tr><tr><td>消息队列顺序</td><td>业务层面保证同类消息的顺序处理</td><td>业务灵活性高</td><td>实现复杂</td><td>性能影响小</td></tr><tr><td>时间戳排序</td><td>消费者根据时间戳重新排序</td><td>全局有序</td><td>延迟高、内存占用大</td><td>延迟增加</td></tr></tbody></table><p><strong>技术选型建议：</strong></p><table><thead><tr><th>业务场景</th><th>推荐方案</th><th>理由</th><th>实现要点</th></tr></thead><tbody><tr><td>股票交易</td><td>单队列单消费者</td><td>严格时序要求</td><td>可以牺牲性能保证正确性</td></tr><tr><td>用户操作日志</td><td>分区有序</td><td>同一用户操作需要有序</td><td>以用户ID作为分区Key</td></tr><tr><td>订单状态流转</td><td>消息队列顺序</td><td>只需要同一订单内有序</td><td>以订单ID作为分组</td></tr><tr><td>系统日志收集</td><td>无需严格顺序</td><td>日志分析不严格依赖顺序</td><td>优先考虑性能和吞吐量</td></tr></tbody></table><h3 id="_6-常用消息队列比较-kafka、rabbitmq、rocketmq" tabindex="-1"><a class="header-anchor" href="#_6-常用消息队列比较-kafka、rabbitmq、rocketmq"><span>6. 常用消息队列比较？（Kafka、RabbitMQ、RocketMQ）</span></a></h3><p><strong>核心特性对比：</strong></p><table><thead><tr><th>特性</th><th>Kafka</th><th>RabbitMQ</th><th>RocketMQ</th></tr></thead><tbody><tr><td>开发语言</td><td>Scala/Java</td><td>Erlang</td><td>Java</td></tr><tr><td>性能</td><td>极高（百万级/秒）</td><td>高（万级/秒）</td><td>高（十万级/秒）</td></tr><tr><td>可靠性</td><td>高</td><td>极高</td><td>高</td></tr><tr><td>功能丰富度</td><td>基础</td><td>丰富</td><td>丰富</td></tr><tr><td>运维复杂度</td><td>中等</td><td>简单</td><td>中等</td></tr><tr><td>社区活跃度</td><td>极高</td><td>高</td><td>中等</td></tr><tr><td>企业支持</td><td>Apache基金会</td><td>VMware</td><td>阿里巴巴</td></tr></tbody></table><p><strong>详细功能对比：</strong></p><table><thead><tr><th>功能</th><th>Kafka</th><th>RabbitMQ</th><th>RocketMQ</th></tr></thead><tbody><tr><td>消息顺序性</td><td>分区有序</td><td>队列有序</td><td>分区有序</td></tr><tr><td>消息路由</td><td>简单</td><td>灵活强大</td><td>丰富</td></tr><tr><td>消息过滤</td><td>不支持</td><td>支持</td><td>支持</td></tr><tr><td>死信队列</td><td>不支持</td><td>支持</td><td>支持</td></tr><tr><td>延时消息</td><td>不支持</td><td>插件支持</td><td>原生支持</td></tr><tr><td>事务消息</td><td>0.11版本后支持</td><td>支持</td><td>支持</td></tr><tr><td>消息重试</td><td>不支持</td><td>支持</td><td>支持</td></tr><tr><td>集群部署</td><td>原生支持</td><td>支持</td><td>支持</td></tr></tbody></table><p><strong>适用场景推荐：</strong></p><table><thead><tr><th>使用场景</th><th>推荐MQ</th><th>选择理由</th><th>注意事项</th></tr></thead><tbody><tr><td>日志收集、大数据处理</td><td>Kafka</td><td>超高吞吐量、水平扩展能力强</td><td>功能相对简单，需要自己实现一些特性</td></tr><tr><td>企业级应用、复杂路由</td><td>RabbitMQ</td><td>功能丰富、可靠性高、运维简单</td><td>性能相对较低</td></tr><tr><td>电商、金融等业务系统</td><td>RocketMQ</td><td>功能全面、性能好、专门为业务场景设计</td><td>社区相对较小</td></tr><tr><td>微服务间通信</td><td>RabbitMQ</td><td>消息路由灵活、支持多种协议</td><td>需要考虑消息积压问题</td></tr><tr><td>实时数据流处理</td><td>Kafka</td><td>低延迟、高吞吐、与大数据生态集成好</td><td>不适合复杂的业务逻辑处理</td></tr><tr><td>订单处理、支付系统</td><td>RocketMQ</td><td>事务消息、顺序消息、高可靠性</td><td>运维复杂度相对较高</td></tr></tbody></table><p><strong>技术选型决策矩阵：</strong></p><table><thead><tr><th>权重因子</th><th>Kafka</th><th>RabbitMQ</th><th>RocketMQ</th><th>说明</th></tr></thead><tbody><tr><td>性能要求（30%）</td><td>10</td><td>7</td><td>8</td><td>Kafka性能最强</td></tr><tr><td>功能丰富度（25%）</td><td>6</td><td>9</td><td>9</td><td>RabbitMQ功能最全</td></tr><tr><td>可靠性（20%）</td><td>8</td><td>10</td><td>9</td><td>RabbitMQ可靠性最佳</td></tr><tr><td>运维难度（15%）</td><td>7</td><td>9</td><td>7</td><td>RabbitMQ最易运维</td></tr><tr><td>社区支持（10%）</td><td>10</td><td>8</td><td>6</td><td>Kafka社区最活跃</td></tr><tr><td><strong>总分</strong></td><td><strong>8.1</strong></td><td><strong>8.6</strong></td><td><strong>8.0</strong></td><td>RabbitMQ综合评分最高</td></tr></tbody></table><h2 id="主流框架、系统设计、编码能力" tabindex="-1"><a class="header-anchor" href="#主流框架、系统设计、编码能力"><span>主流框架、系统设计、编码能力</span></a></h2><h3 id="_1-spring方向-ioc-控制反转-di-依赖注入-aop-面向切面编程" tabindex="-1"><a class="header-anchor" href="#_1-spring方向-ioc-控制反转-di-依赖注入-aop-面向切面编程"><span>1. Spring方向 - (IoC - 控制反转 / DI - 依赖注入, AOP - 面向切面编程)</span></a></h3><p><strong>IoC（控制反转）核心概念：</strong></p><table><thead><tr><th>概念</th><th>定义</th><th>传统方式</th><th>IoC方式</th><th>优势</th></tr></thead><tbody><tr><td>控制反转</td><td>对象创建控制权从程序代码转移到外部容器</td><td>程序主动创建依赖对象</td><td>容器创建并注入对象</td><td>降低耦合度、提高可测试性</td></tr><tr><td>依赖注入</td><td>容器负责将依赖的对象注入到需要的地方</td><td>new 关键字创建对象</td><td>@Autowired等注解注入</td><td>自动装配、配置灵活</td></tr><tr><td>容器管理</td><td>Spring容器负责对象的生命周期管理</td><td>手动管理对象生命周期</td><td>容器自动管理</td><td>减少内存泄漏、提高性能</td></tr></tbody></table><p><strong>DI依赖注入方式对比：</strong></p><table><thead><tr><th>注入方式</th><th>实现方式</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>构造器注入</td><td>通过构造函数参数注入</td><td>强制依赖、不可变对象</td><td>构造函数参数可能过多</td><td>必需依赖</td></tr><tr><td>Setter注入</td><td>通过setter方法注入</td><td>可选依赖、灵活配置</td><td>可能忘记注入某些依赖</td><td>可选依赖</td></tr><tr><td>字段注入</td><td>直接在字段上使用@Autowired</td><td>代码简洁</td><td>难以测试、违反封装性</td><td>快速开发</td></tr></tbody></table><h3 id="_2-aop-面向切面编程" tabindex="-1"><a class="header-anchor" href="#_2-aop-面向切面编程"><span>2. AOP (面向切面编程)</span></a></h3><p><strong>AOP核心概念：</strong></p><table><thead><tr><th>概念</th><th>定义</th><th>作用</th><th>示例</th></tr></thead><tbody><tr><td>切面(Aspect)</td><td>横切关注点的模块化</td><td>封装横切逻辑</td><td>日志切面、事务切面</td></tr><tr><td>连接点(JoinPoint)</td><td>程序执行过程中能够插入切面的点</td><td>定义切入位置</td><td>方法调用、异常抛出</td></tr><tr><td>切入点(Pointcut)</td><td>匹配连接点的表达式</td><td>定义在哪些地方切入</td><td>execution(* com.<em>.</em>(..))</td></tr><tr><td>通知(Advice)</td><td>在切入点执行的代码</td><td>定义切入后做什么</td><td>@Before、@After</td></tr><tr><td>织入(Weaving)</td><td>将切面应用到目标对象的过程</td><td>实现AOP功能</td><td>编译时、类加载时、运行时</td></tr></tbody></table><p><strong>Spring AOP实现方式：</strong></p><table><thead><tr><th>实现方式</th><th>原理</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>JDK动态代理</td><td>基于接口的代理</td><td>标准JDK实现</td><td>只能代理接口</td><td>有接口的类</td></tr><tr><td>CGLIB代理</td><td>基于继承的代理</td><td>可以代理普通类</td><td>不能代理final类和方法</td><td>没有接口的类</td></tr></tbody></table><p><strong>常用通知类型：</strong></p><table><thead><tr><th>通知类型</th><th>执行时机</th><th>使用场景</th><th>示例代码</th></tr></thead><tbody><tr><td>@Before</td><td>方法执行前</td><td>参数校验、权限检查</td><td>记录方法调用参数</td></tr><tr><td>@After</td><td>方法执行后</td><td>资源清理、日志记录</td><td>记录方法执行时间</td></tr><tr><td>@AfterReturning</td><td>方法正常返回后</td><td>结果处理、成功日志</td><td>记录方法返回值</td></tr><tr><td>@AfterThrowing</td><td>方法抛异常后</td><td>异常处理、错误日志</td><td>记录异常信息</td></tr><tr><td>@Around</td><td>方法执行前后</td><td>性能监控、事务控制</td><td>计算方法执行时间</td></tr></tbody></table><h3 id="_3-spring事务管理" tabindex="-1"><a class="header-anchor" href="#_3-spring事务管理"><span>3. Spring事务管理</span></a></h3><p><strong>事务传播行为：</strong></p><table><thead><tr><th>传播行为</th><th>行为描述</th><th>使用场景</th><th>风险提示</th></tr></thead><tbody><tr><td>REQUIRED</td><td>有事务就加入，没有就新建</td><td>最常用的传播行为</td><td>无</td></tr><tr><td>REQUIRES_NEW</td><td>总是新建事务</td><td>需要独立事务的操作</td><td>可能导致死锁</td></tr><tr><td>SUPPORTS</td><td>有事务就加入，没有就非事务执行</td><td>查询操作</td><td>数据一致性问题</td></tr><tr><td>NOT_SUPPORTED</td><td>总是非事务执行</td><td>纯查询操作</td><td>不支持事务回滚</td></tr><tr><td>MANDATORY</td><td>必须在事务中执行</td><td>强制事务的业务逻辑</td><td>没有事务会抛异常</td></tr><tr><td>NEVER</td><td>不能在事务中执行</td><td>不能有事务的操作</td><td>有事务会抛异常</td></tr><tr><td>NESTED</td><td>嵌套事务</td><td>部分回滚场景</td><td>依赖数据库支持</td></tr></tbody></table><p><strong>事务隔离级别：</strong></p><table><thead><tr><th>隔离级别</th><th>Spring常量</th><th>解决问题</th><th>性能影响</th><th>适用场景</th></tr></thead><tbody><tr><td>READ_UNCOMMITTED</td><td>ISOLATION_READ_UNCOMMITTED</td><td>无</td><td>最高</td><td>对一致性要求极低</td></tr><tr><td>READ_COMMITTED</td><td>ISOLATION_READ_COMMITTED</td><td>脏读</td><td>高</td><td>一般业务场景</td></tr><tr><td>REPEATABLE_READ</td><td>ISOLATION_REPEATABLE_READ</td><td>脏读、不可重复读</td><td>中</td><td>默认级别，推荐使用</td></tr><tr><td>SERIALIZABLE</td><td>ISOLATION_SERIALIZABLE</td><td>脏读、不可重复读、幻读</td><td>最低</td><td>对一致性要求极高</td></tr></tbody></table><h3 id="_4-spring-mvc的工作原理-核心组件-处理请求的流程" tabindex="-1"><a class="header-anchor" href="#_4-spring-mvc的工作原理-核心组件-处理请求的流程"><span>4. Spring MVC的工作原理？核心组件？处理请求的流程？</span></a></h3><p><strong>Spring MVC核心组件：</strong></p><table><thead><tr><th>组件</th><th>作用</th><th>核心功能</th><th>配置方式</th></tr></thead><tbody><tr><td>DispatcherServlet</td><td>前端控制器，统一调度请求</td><td>请求分发、异常处理、视图渲染</td><td>web.xml或Java配置</td></tr><tr><td>HandlerMapping</td><td>处理器映射器，找到处理请求的Controller</td><td>URL映射、RESTful路由</td><td>@RequestMapping</td></tr><tr><td>HandlerAdapter</td><td>处理器适配器，调用具体的处理方法</td><td>参数解析、返回值处理</td><td>自动配置</td></tr><tr><td>ViewResolver</td><td>视图解析器，解析逻辑视图名</td><td>视图路径解析、模板引擎集成</td><td>配置文件</td></tr></tbody></table><p><strong>请求处理流程：</strong></p><table><thead><tr><th>步骤</th><th>组件</th><th>具体操作</th><th>数据流转</th></tr></thead><tbody><tr><td>1</td><td>DispatcherServlet</td><td>接收HTTP请求</td><td>HttpServletRequest</td></tr><tr><td>2</td><td>HandlerMapping</td><td>根据URL找到对应的Controller和方法</td><td>HandlerExecutionChain</td></tr><tr><td>3</td><td>HandlerAdapter</td><td>调用Controller方法，处理业务逻辑</td><td>ModelAndView</td></tr><tr><td>4</td><td>ViewResolver</td><td>解析逻辑视图名，找到具体视图模板</td><td>View对象</td></tr><tr><td>5</td><td>View</td><td>渲染视图，生成HTML响应</td><td>HttpServletResponse</td></tr></tbody></table><h3 id="_5-1-一级缓存和二级缓存的区别" tabindex="-1"><a class="header-anchor" href="#_5-1-一级缓存和二级缓存的区别"><span>5.1 一级缓存和二级缓存的区别？</span></a></h3><p><strong>缓存级别对比：</strong></p><table><thead><tr><th>特性</th><th>一级缓存（SqlSession级别）</th><th>二级缓存（Mapper级别）</th></tr></thead><tbody><tr><td>作用域</td><td>单个SqlSession</td><td>同一个Mapper的所有SqlSession</td></tr><tr><td>生命周期</td><td>SqlSession关闭时失效</td><td>应用程序关闭时失效</td></tr><tr><td>默认开启</td><td>默认开启</td><td>需要手动开启</td></tr><tr><td>共享性</td><td>不共享</td><td>多个SqlSession共享</td></tr><tr><td>清空时机</td><td>commit/rollback/close</td><td>手动清空或配置自动清空</td></tr><tr><td>存储位置</td><td>SqlSession内存</td><td>可配置多种存储方式</td></tr></tbody></table><p><strong>缓存配置和使用：</strong></p><table><thead><tr><th>配置项目</th><th>一级缓存</th><th>二级缓存</th></tr></thead><tbody><tr><td>开启方式</td><td>无需配置，默认开启</td><td><code>@CacheNamespace</code>或<code>&lt;cache&gt;</code></td></tr><tr><td>失效策略</td><td>自动失效</td><td>LRU、FIFO、SOFT、WEAK</td></tr><tr><td>刷新策略</td><td>增删改操作自动清空</td><td>可配置flushInterval</td></tr><tr><td>序列化要求</td><td>无</td><td>实体类需实现Serializable接口</td></tr></tbody></table><h3 id="_5-2-resultmap-和-resulttype-的区别" tabindex="-1"><a class="header-anchor" href="#_5-2-resultmap-和-resulttype-的区别"><span>5.2 ResultMap 和 ResultType 的区别？</span></a></h3><p><strong>使用场景对比：</strong></p><table><thead><tr><th>特性</th><th>ResultType</th><th>ResultMap</th></tr></thead><tbody><tr><td>适用场景</td><td>简单映射、字段名一致</td><td>复杂映射、字段名不一致、关联查询</td></tr><tr><td>配置复杂度</td><td>简单</td><td>复杂</td></tr><tr><td>映射方式</td><td>自动映射</td><td>手动配置映射关系</td></tr><tr><td>性能</td><td>较好</td><td>略差（需要解析配置）</td></tr><tr><td>功能</td><td>基础功能</td><td>支持嵌套、关联、继承等高级功能</td></tr><tr><td>维护成本</td><td>低</td><td>高</td></tr></tbody></table><p><strong>选择建议：</strong></p><table><thead><tr><th>场景</th><th>推荐方案</th><th>原因</th></tr></thead><tbody><tr><td>简单POJO映射</td><td>ResultType</td><td>配置简单，性能好</td></tr><tr><td>字段名与属性名不一致</td><td>ResultMap</td><td>需要手动映射</td></tr><tr><td>一对一、一对多关联查询</td><td>ResultMap</td><td>支持嵌套映射</td></tr><tr><td>需要类型转换</td><td>ResultMap</td><td>支持TypeHandler</td></tr><tr><td>继承关系映射</td><td>ResultMap</td><td>支持继承和多态</td></tr></tbody></table><h3 id="_5-3-延迟加载-懒加载-的原理和配置" tabindex="-1"><a class="header-anchor" href="#_5-3-延迟加载-懒加载-的原理和配置"><span>5.3 延迟加载（懒加载）的原理和配置？</span></a></h3><p><strong>延迟加载机制：</strong></p><table><thead><tr><th>概念</th><th>定义</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>延迟加载</td><td>关联对象在真正使用时才加载</td><td>提高性能、减少内存占用</td><td>可能产生N+1问题</td><td>大对象关联</td></tr><tr><td>立即加载</td><td>查询时一次性加载所有关联对象</td><td>减少数据库访问次数</td><td>可能加载不需要的数据</td><td>小对象关联</td></tr></tbody></table><p><strong>配置方式：</strong></p><table><thead><tr><th>配置级别</th><th>配置位置</th><th>配置项</th><th>说明</th></tr></thead><tbody><tr><td>全局配置</td><td>mybatis-config.xml</td><td>lazyLoadingEnabled=true</td><td>全局开启延迟加载</td></tr><tr><td>局部配置</td><td>ResultMap</td><td>fetchType=&quot;lazy/eager&quot;</td><td>针对特定关联配置</td></tr><tr><td>方法级配置</td><td>@Select等注解</td><td>fetchType属性</td><td>注解方式配置</td></tr></tbody></table><h3 id="_5-4-如何实现分页" tabindex="-1"><a class="header-anchor" href="#_5-4-如何实现分页"><span>5.4 如何实现分页？</span></a></h3><p><strong>分页实现方案对比：</strong></p><table><thead><tr><th>方案</th><th>实现原理</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>RowBounds内存分页</td><td>查询所有数据后在内存中分页</td><td>实现简单</td><td>性能差、内存占用大</td><td>小数据量</td></tr><tr><td>PageHelper物理分页</td><td>自动改写SQL添加LIMIT</td><td>性能好、使用简单</td><td>依赖插件</td><td>大数据量、生产环境</td></tr><tr><td>手写SQL分页</td><td>手动编写带LIMIT的SQL</td><td>性能最好、可控性强</td><td>开发复杂、维护成本高</td><td>复杂查询场景</td></tr></tbody></table><p><strong>PageHelper使用示例：</strong></p><table><thead><tr><th>使用方式</th><th>代码示例</th><th>说明</th></tr></thead><tbody><tr><td>方法调用</td><td><code>PageHelper.startPage(1, 10)</code></td><td>在查询前调用</td></tr><tr><td>注解方式</td><td><code>@Select + @Options</code></td><td>注解配置分页参数</td></tr><tr><td>参数传递</td><td><code>PageInfo&lt;User&gt; pageInfo</code></td><td>封装分页结果</td></tr></tbody></table><h3 id="_6-设计一个秒杀系统" tabindex="-1"><a class="header-anchor" href="#_6-设计一个秒杀系统"><span>6. 设计一个秒杀系统</span></a></h3><p><strong>系统架构设计：</strong></p><table><thead><tr><th>层次</th><th>组件</th><th>作用</th><th>技术选型</th><th>关键指标</th></tr></thead><tbody><tr><td>接入层</td><td>CDN + 负载均衡</td><td>静态资源加速、流量分发</td><td>Nginx、LVS</td><td>QPS: 10万+</td></tr><tr><td>应用层</td><td>微服务集群</td><td>业务逻辑处理</td><td>Spring Boot集群</td><td>响应时间: &lt;100ms</td></tr><tr><td>缓存层</td><td>Redis集群</td><td>热点数据缓存</td><td>Redis Cluster</td><td>命中率: &gt;95%</td></tr><tr><td>数据层</td><td>MySQL主从</td><td>数据持久化</td><td>MySQL 8.0</td><td>TPS: 1万+</td></tr><tr><td>消息层</td><td>消息队列</td><td>异步处理、削峰填谷</td><td>RocketMQ</td><td>吞吐量: 10万条/秒</td></tr></tbody></table><p><strong>核心技术方案：</strong></p><table><thead><tr><th>技术挑战</th><th>解决方案</th><th>实现方式</th><th>效果评估</th></tr></thead><tbody><tr><td>高并发读</td><td>多级缓存 + CDN</td><td>Redis + 本地缓存 + CDN静态化</td><td>减少99%数据库访问</td></tr><tr><td>库存扣减</td><td>Redis Lua脚本</td><td>原子性操作，避免超卖</td><td>100%准确性</td></tr><tr><td>流量削峰</td><td>消息队列异步处理</td><td>秒杀请求先入队，异步处理订单</td><td>削峰90%</td></tr><tr><td>限流保护</td><td>令牌桶 + 熔断降级</td><td>Sentinel限流，超限返回友好提示</td><td>系统稳定性99.9%</td></tr><tr><td>数据一致性</td><td>分布式事务</td><td>Seata分布式事务，保证最终一致性</td><td>数据准确性100%</td></tr></tbody></table><p><strong>Redis Lua脚本示例：</strong></p><table><thead><tr><th>功能</th><th>脚本逻辑</th><th>优势</th></tr></thead><tbody><tr><td>库存扣减</td><td>检查库存 → 扣减库存 → 记录用户购买</td><td>原子性操作，避免超卖</td></tr><tr><td>防重复购买</td><td>检查用户购买记录 → 执行购买逻辑</td><td>避免重复下单</td></tr><tr><td>限流控制</td><td>检查请求频率 → 更新计数器</td><td>精确限流</td></tr></tbody></table><h3 id="_7-各类主流算法" tabindex="-1"><a class="header-anchor" href="#_7-各类主流算法"><span>7. 各类主流算法</span></a></h3><p><strong>算法分类和重要性：</strong></p><table><thead><tr><th>算法类型</th><th>重要算法</th><th>面试频率</th><th>难度等级</th><th>应用场景</th></tr></thead><tbody><tr><td>排序算法</td><td>快排、归并、堆排序</td><td>⭐⭐⭐⭐⭐</td><td>中等</td><td>数据排序、TopK问题</td></tr><tr><td>查找算法</td><td>二分查找、哈希查找</td><td>⭐⭐⭐⭐⭐</td><td>简单</td><td>数据检索、去重</td></tr><tr><td>动态规划</td><td>背包、最长子序列、路径问题</td><td>⭐⭐⭐⭐</td><td>困难</td><td>优化问题、计数问题</td></tr><tr><td>图算法</td><td>DFS、BFS、最短路径</td><td>⭐⭐⭐</td><td>中等</td><td>社交网络、路径规划</td></tr><tr><td>树算法</td><td>二叉树遍历、平衡树、字典树</td><td>⭐⭐⭐⭐</td><td>中等</td><td>数据结构、搜索引擎</td></tr><tr><td>贪心算法</td><td>区间调度、最小生成树</td><td>⭐⭐⭐</td><td>中等</td><td>资源分配、网络优化</td></tr></tbody></table><p><strong>面试常考算法题型：</strong></p><table><thead><tr><th>题型</th><th>典型例题</th><th>解题思路</th><th>时间复杂度</th></tr></thead><tbody><tr><td>数组双指针</td><td>两数之和、三数之和</td><td>排序+双指针移动</td><td>O(n) - O(n²)</td></tr><tr><td>链表操作</td><td>反转链表、环形链表检测</td><td>快慢指针、递归</td><td>O(n)</td></tr><tr><td>二叉树递归</td><td>最大深度、路径和</td><td>递归分治</td><td>O(n)</td></tr><tr><td>动态规划</td><td>爬楼梯、最大子数组和</td><td>状态转移方程</td><td>O(n) - O(n²)</td></tr><tr><td>回溯算法</td><td>全排列、N皇后问题</td><td>递归+回溯</td><td>O(n!)</td></tr><tr><td>滑动窗口</td><td>最长无重复子串</td><td>窗口扩展和收缩</td><td>O(n)</td></tr></tbody></table></div><!----><footer class="vp-page-meta"><div class="vp-meta-item edit-link"><a class="auto-link external-link vp-meta-label" href="https://github.com/Crc011220/Crc011220.github.io/edit/main/src/zh/posts/review/面试要点.md" aria-label="在 GitHub 上编辑此页" rel="noopener noreferrer" target="_blank"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="edit icon" name="edit"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->在 GitHub 上编辑此页<!----></a></div><div class="vp-meta-item git-info"><div class="update-time"><span class="vp-meta-label">上次编辑于: </span><span class="vp-meta-info" data-allow-mismatch="text">2025/7/30 07:46:18</span></div><div class="contributors"><span class="vp-meta-label">贡献者: </span><!--[--><!--[--><span class="vp-meta-info" title="email: ruocchen1220@gmail.com">Ruochen Chen</span><!--]--><!--]--></div></div></footer><nav class="vp-page-nav"><a class="route-link auto-link prev" href="/zh/posts/review/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.html" aria-label="计算机网络"><div class="hint"><span class="arrow start"></span>上一页</div><div class="link"><span class="font-icon icon fa-fw fa-sm fas fa-pen-to-square" style=""></span>计算机网络</div></a><!----></nav><!----><!----><!--]--></main><!--]--><footer class="vp-footer-wrapper" vp-footer><div class="vp-footer">学海无涯</div><div class="vp-copyright">Copyright © 2025 Ruochen Chen </div></footer></div><!--]--><!--[--><!----><!--[--><!--]--><!--]--><!--]--></div>
    <script src="/assets/js/runtime~app.534f024b.js" defer></script><script src="/assets/js/6312.2d95f1ad.js" defer></script><script src="/assets/js/app.d934ba98.js" defer></script>
  </body>
</html>
