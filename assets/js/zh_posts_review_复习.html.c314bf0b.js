"use strict";(self.webpackChunkpersonalweb=self.webpackChunkpersonalweb||[]).push([[4069],{6262:(i,s)=>{s.A=(i,s)=>{const l=i.__vccOpts||i;for(const[i,n]of s)l[i]=n;return l}},9204:(i,s,l)=>{l.r(s),l.d(s,{comp:()=>e,data:()=>t});var n=l(641);const a={},e=(0,l(6262).A)(a,[["render",function(i,s){return(0,n.uX)(),(0,n.CE)("div",null,s[0]||(s[0]=[(0,n.Fv)('<h1 id="简历" tabindex="-1"><a class="header-anchor" href="#简历"><span>简历</span></a></h1><h2 id="京东项目-分布式调度引擎" tabindex="-1"><a class="header-anchor" href="#京东项目-分布式调度引擎"><span>京东项目 - 分布式调度引擎</span></a></h2><h3 id="_1-架构设计相关问题" tabindex="-1"><a class="header-anchor" href="#_1-架构设计相关问题"><span>1. 架构设计相关问题</span></a></h3><p><strong>Q1: 项目中碰到了哪些困难？架构层面和开发层面？</strong></p><h4 id="架构层面" tabindex="-1"><a class="header-anchor" href="#架构层面"><span>架构层面</span></a></h4><ol><li>高可用架构设计困难</li></ol><ul><li>问题：如何保证系统的高可用性</li><li>挑战：需要设计无单点故障的架构</li><li>解决方案： <ul><li>应用层：Spring Boot集群部署（3个实例），Nginx轮询分发请求到应用层</li><li>调度器：XXL-JOB调度中心（1个+热备），XXL-JOB执行器（3个）</li><li>数据库层：MySQL主从复制（1主2从），ProxySQL读写分离（1个，待优化）</li><li>缓存层：Redis哨兵模式（3哨兵+1主2从），Redis缓存热点数据</li><li>监控：集成Spring Boot Actuator（监控 CPU、JVM、MySQL、Redis状态）</li></ul></li></ul><ol start="2"><li>分布式一致性难题</li></ol><ul><li>问题：多节点环境下如何保证数据一致性</li><li>挑战：任务状态同步、分布式锁实现</li><li>解决方案：</li></ul><p>我们采用&quot;XXL-JOB + 分布式锁 + 补偿机制&quot;的组合方案来解决分布式一致性问题。XXL-JOB负责任务调度和去重，分布式锁保证并发安全，补偿机制处理跨服务数据不一致。三者各司其职、互补性强，实现了完整的分布式一致性保证。</p><h4 id="任务调度层面-xxl-job" tabindex="-1"><a class="header-anchor" href="#任务调度层面-xxl-job"><span>任务调度层面（XXL-JOB）</span></a></h4><p><strong>XXL-JOB的架构设计和职责划分</strong></p><ul><li>A. 项目系统负责： <ul><li>脚本管理 - 上传、存储、编辑脚本文件</li><li>任务管理 - 创建、配置、管理定时任务</li><li>用户管理 - 权限控制、用户认证</li><li>监控界面 - 执行状态、日志查看、统计分析</li></ul></li><li>B. XXL-JOB负责： <ul><li>定时调度 - 按Cron表达式触发任务执行</li><li>分布式执行 - 多实例负载均衡和故障转移</li><li>执行监控 - 任务执行状态跟踪</li><li>日志记录 - 详细的执行日志和错误信息</li></ul></li><li>XXL-JOB调度中心的热备不是自动集群，而是主备模式： <ul><li>主调度中心：正常工作，处理所有调度</li><li>备调度中心：待命状态，共享同一数据库</li><li>手动/半自动切换：主挂了，人工或脚本启用备用</li></ul></li></ul><p><strong>XXL-JOB调度中心已解决的分布式一致性问题</strong></p><ul><li>任务重复执行防护 <ul><li>通过数据库唯一约束防止同一任务被重复调度</li><li>执行器通过任务ID去重，避免重复执行</li></ul></li><li>任务状态一致性 <ul><li>调度中心统一管理任务状态（待执行、执行中、执行完成、执行失败）</li><li>执行器定期心跳上报，保持状态同步</li></ul></li><li>分布式锁机制 <ul><li>调度中心通过数据库行锁保证任务分配的原子性</li><li>避免多个调度中心同时分配同一任务</li></ul></li><li>任务执行结果一致性 <ul><li>执行器执行完成后统一回调调度中心</li><li>调度中心记录执行结果，保证数据一致性</li></ul></li></ul><p><strong>项目解决的分布式一致性问题</strong> XXL-JOB虽然能解决任务重复执行的问题，但在我们的分布式调度引擎中，还有很多跨服务的数据一致性问题它无法解决：</p><ol><li>脚本文件与任务配置的一致性</li><li>任务状态与XXL-JOB执行状态的一致性</li><li>用户权限变更与任务执行的一致性</li><li>系统配置与任务行为的一致性</li></ol><p>所以我们采用了&quot;<strong>XXL-JOB + 分布式锁 + 补偿机制</strong>&quot;的组合方案：XXL-JOB负责任务调度和去重，分布式锁保证并发安全，补偿机制处理跨服务数据不一致，这样就能实现完整的分布式一致性保证。</p><p><strong>saga：本地一致+补偿机制</strong> 补偿机制通过<strong>消息队列</strong>实现，主要处理部分成果、跨服务数据不一致的问题。</p><p>例子：补偿机制的具体处理流程是：</p><ol><li>脚本上传成功 ✅</li><li>任务配置创建成功 ✅</li><li>XXL-JOB注册失败 ❌</li></ol><p>补偿机制会从最后一步开始，倒序清理已成功的操作。</p><p>第一步：系统检测到XXL-JOB注册失败，立即发送补偿消息到消息队列</p><ul><li>消息类型：TASK_CREATION_FAILED</li><li>包含数据：脚本路径、任务ID、失败原因等</li></ul><p>第二步：补偿处理器消费消息，执行倒序清理</p><ul><li>清理XXL-JOB相关数据（如果有部分注册成功）</li><li>删除已创建的任务配置</li><li>清理已上传的脚本文件</li></ul><p>第三步：更新任务状态为&quot;创建失败&quot;，记录补偿日志</p><p>采用了Saga&quot;本地事务+补偿机制&quot;的组合方案：</p><ol><li><strong>本地事务</strong>：保证每个服务内部的数据一致性</li></ol><ul><li>脚本服务：文件上传的原子性</li><li>任务服务：任务配置的原子性</li><li>XXL-JOB服务：任务注册的原子性</li></ul><ol start="2"><li><strong>补偿机制</strong>：处理跨服务的不一致问题</li></ol><ul><li>当某个服务失败时，自动清理其他服务已成功的操作</li><li>通过消息队列异步处理，不影响主流程性能</li><li>实现最终一致性，而不是强一致性</li></ul><p>这样既保持了微服务的独立性，又解决了跨服务的一致性问题。</p><p><strong>分布式锁</strong> 保证高并发场景下的安全，锁粒度是：</p><ul><li>用户级别：按用户ID加锁，不同用户可以并发操作</li><li>资源级别：按资源ID加锁，不同资源可以并发操作</li><li>时间级别：设置合理的锁过期时间，防止死锁</li></ul><p>我们选择Redisson实现分布式锁，主要考虑它的专业性和可靠性：</p><ol><li>自动续期机制：Redisson支持锁的自动续期，避免业务执行时间过长导致锁过期</li><li>可重入锁支持：同一个线程可以多次获取同一个锁，避免死锁</li><li>公平锁实现：支持公平锁，保证锁的获取顺序</li><li>看门狗机制：自动监控锁的状态，异常情况下自动释放锁</li></ol><p>这样既保证了并发安全，又不会过度影响系统的并发性能。</p><h4 id="数据库层面-proxysql" tabindex="-1"><a class="header-anchor" href="#数据库层面-proxysql"><span>数据库层面（ProxySQL）</span></a></h4><ul><li>数据库主从切换时的数据同步 <ul><li>主从复制通过binlog机制（写入中继日志，然后从库重放）实现数据同步，ProxySQL在此基础上提供读写分离和故障切换。</li></ul></li><li>数据库读写分离 <ul><li>使用ProxySQL实现读写分离，根据请求类型（读/写）自动路由到主库或从库</li><li>第一步，定义服务器组。 我们创建了读写分离组，写组ID是10，读组ID是20，这样ProxySQL就知道哪些是主库哪些是从库。</li><li>第二步，配置服务器。 把主库IP加入写组10，从库IP加入读组20，每个服务器都要设置状态为ONLINE。</li><li>第三步，配置路由规则。 写操作（INSERT/UPDATE/DELETE）自动路由到写组，读操作（SELECT）自动路由到读组。</li></ul></li><li>数据库主库宕机后，如何自动切换（ProxySQL） <ul><li>自动检测 - 每200ms ping一次主库，检测连接状态</li><li>故障判断 - 连续失败达到阈值（如3次）后，自动标记主库为OFFLINE</li><li>智能路由 - 写请求自动路由到新的主库，读请求分散到所有可用从库</li><li>透明切换 - 应用层无需感知，连接ProxySQL即可，底层切换完全透明</li></ul></li><li>数据库主库宕机恢复后 <ul><li>ProxySQL持续ping宕机的主库</li><li>主库恢复后，ping成功</li><li>连续成功达到阈值后，标记主库为ONLINE</li><li>写操作：自动路由回主库（因为主库在写组且状态为ONLINE）</li><li>读操作：继续分散到所有可用节点（包括恢复的主库）</li><li>数据一致性：确保主库数据与从库同步后再恢复写路由，同步方法是通过MySQL主从复制机制，ProxySQL监控复制延迟，只有当从库延迟小于设定阈值时才恢复主库写操作。</li></ul></li><li>备用降级方案 <ul><li>如果ProxySQL宕机，会集群部署ProxySQL或使用AOP来切换到备用数据库，保证服务不中断（待优化，现在是单台ProxySQL）</li></ul></li></ul><p><strong>架构图：</strong></p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>应用1 ──┐</span></span>\n<span class="line"><span>         ├──→ ProxySQL ──→ 主库MySQL</span></span>\n<span class="line"><span>应用2 ──┘              └──→ 从库MySQL</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>具体连接方式：</strong></p><p><strong>1. 应用层配置：</strong></p><div class="language-yaml line-numbers-mode" data-highlighter="shiki" data-ext="yaml" data-title="yaml" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># application.yml</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">spring</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">:</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">  datasource</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">:</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">    url</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">jdbc:mysql://ProxySQL_IP:6033/数据库名</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">    username</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">用户名</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">    password</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">密码</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>2. ProxySQL配置：</strong></p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 配置后端MySQL服务器</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">INSERT INTO</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> mysql_servers </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">VALUES</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;192.168.1.10&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">3306</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">10</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;ONLINE&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2000</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2000</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">); </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 主库</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">INSERT INTO</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> mysql_servers </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">VALUES</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;192.168.1.11&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">3306</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">20</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;ONLINE&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2000</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2000</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">); </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 从库</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>3. 工作流程：</strong></p><ul><li><strong>应用1和应用2</strong>：都连接ProxySQL的6033端口</li><li><strong>ProxySQL</strong>：根据SQL类型自动路由到主库或从库</li><li><strong>应用感知不到</strong>：底层是主库还是从库对应用完全透明</li></ul><p><strong>优势：</strong></p><ul><li><strong>统一入口</strong>：所有应用都连接ProxySQL</li><li><strong>自动路由</strong>：写操作自动走主库，读操作自动走从库</li><li><strong>故障切换</strong>：主库宕机时自动切换到从库</li></ul><h4 id="redis层面-redis哨兵" tabindex="-1"><a class="header-anchor" href="#redis层面-redis哨兵"><span>Redis层面（Redis哨兵）</span></a></h4><ul><li>Redis缓存了什么业务数据？ <ul><li>JWT Token管理、在线用户监控、用户权限数据缓存、仪表板统计数据缓存</li></ul></li></ul><p><strong>双写一致性</strong> 我们采用&quot;先更新数据库，再删除缓存&quot;的策略来保证双写一致性，具体实现是：</p><ol><li><strong>写操作流程</strong>：先更新数据库，成功后再删除Redis缓存</li><li><strong>读操作流程</strong>：先查Redis，没有则查数据库并回填缓存</li><li><strong>异常处理</strong>：如果删除缓存失败，通过消息队列异步重试</li><li><strong>最终一致性</strong>：通过延迟双删和重试机制保证最终一致性</li></ol><p>也可以采用的阿里的Canal组件实现数据同步：不需要更改业务代码，只需部署一个Canal服务。Canal服务把自己伪装成mysql的一个从节点。当mysql数据更新以后，Canal会读取binlog数据，然后再通过Canal的客户端获取到数据，并更新缓存即可。</p><h5 id="开发层面" tabindex="-1"><a class="header-anchor" href="#开发层面"><span>开发层面</span></a></h5><ol><li>XXL-JOB集成和配置困难</li></ol><ul><li>问题：XXL-JOB的配置比较复杂，需要深入理解其架构</li><li>挑战：调度中心和执行器的配置、网络通信、任务注册</li><li>解决方案： <ul><li>仔细阅读官方文档和源码</li><li>搭建测试环境进行调试</li><li>编写详细的配置文档</li></ul></li></ul><ol start="2"><li>Docker容器化部署问题</li></ol><ul><li>问题：Docker配置错误导致服务无法正常启动</li><li>挑战：容器网络配置、端口映射、数据卷挂载</li><li>解决方案： <ul><li>使用docker-compose简化部署</li><li>编写详细的部署脚本</li><li>添加健康检查和日志监控</li></ul></li></ul><ol start="3"><li>权限管理系统开发困难</li></ol><ul><li>问题：RBAC权限管理需要细粒度的权限控制</li><li>挑战：用户-角色-权限的复杂关系、动态权限验证</li><li>解决方案： <ul><li>设计清晰的权限模型</li><li>使用Spring Security实现权限控制</li><li>通过注解实现细粒度权限验证</li></ul></li></ul><ol start="4"><li>监控系统开发挑战</li></ol><ul><li>问题：需要实时监控任务执行状态和系统性能</li><li>挑战：数据采集、实时展示、告警机制</li><li>解决方案： <ul><li>使用WebSocket实现实时数据推送</li><li>实现自定义的告警规则</li></ul></li></ul><h2 id="招行项目-excel处理框架" tabindex="-1"><a class="header-anchor" href="#招行项目-excel处理框架"><span>招行项目 - Excel处理框架</span></a></h2><h3 id="_1-架构设计相关问题-1" tabindex="-1"><a class="header-anchor" href="#_1-架构设计相关问题-1"><span>1. 架构设计相关问题</span></a></h3><p><strong>Q1: Excel处理框架的整体架构是什么？</strong></p><h5 id="架构层面-1" tabindex="-1"><a class="header-anchor" href="#架构层面-1"><span>架构层面</span></a></h5><ol><li>大数据处理内存溢出问题</li></ol><ul><li>问题：处理10万级数据时出现OOM（Out of Memory）</li><li>挑战：Excel文件无法一次性加载到内存</li><li>解决方案： <ul><li>采用分片处理策略，每片处理1万行数据</li><li>使用流式读取，边读边处理</li><li>优化内存使用，及时释放无用对象</li></ul></li></ul><ol start="2"><li>系统架构如何做的？</li></ol><ul><li>单体架构部署，部署在招行内部API云市场中</li><li>使用Spring Boot框架开发</li><li>使用Redis缓存热点数据（如任务状态和进度信息，校验规则，业务配置数据，分片处理锁）</li><li>使用线程池控制并发数量</li><li>使用异步处理，立即返回任务ID</li></ul><ol start="3"><li>数据一致性保证：</li></ol><ul><li>问题：并发处理时数据一致性和完整性</li><li>挑战：多线程环境下的数据同步和事务管理</li><li>解决方案：使用分布式锁+数据库事务+结果验证</li></ul><h5 id="开发层面-1" tabindex="-1"><a class="header-anchor" href="#开发层面-1"><span>开发层面</span></a></h5><ol><li>Excel文件格式兼容性问题</li></ol><ul><li>问题：不同版本的Excel文件格式差异较大</li><li>挑战：.xls和.xlsx格式的兼容性、特殊字符处理</li><li>解决方案： <ul><li>使用Apache POI库处理多种格式：HSSFWorkbook和XSSFWorkbook来处理xls和xlsx格式</li><li>实现格式检测和自动转换</li><li>添加特殊字符过滤和编码处理</li><li>编写详细的格式验证规则</li></ul></li></ul><ol start="2"><li>异步处理状态跟踪困难</li></ol><ul><li>问题：如何准确跟踪异步任务的执行状态</li><li>挑战：任务进度实时更新、异常状态处理</li><li>解决方案： <ul><li>使用Redis存储任务状态和进度</li><li>实现定时任务更新进度信息</li><li>添加任务超时和重试机制</li><li>设计完善的异常处理流程</li></ul></li></ul><ol start="3"><li>缓存策略设计复杂</li></ol><ul><li>问题：如何设计高效的缓存策略</li><li>挑战：缓存更新、缓存失效、内存管理</li><li>解决方案： <ul><li>使用Redis Hash结构存储复杂数据</li><li>实现缓存预热和更新策略</li><li>设置合理的缓存过期时间</li><li>添加缓存监控和告警</li></ul></li></ul><h3 id="_2-具体业务逻辑是什么" tabindex="-1"><a class="header-anchor" href="#_2-具体业务逻辑是什么"><span>2. 具体业务逻辑是什么？</span></a></h3><h4 id="客户信息批量导入业务逻辑" tabindex="-1"><a class="header-anchor" href="#客户信息批量导入业务逻辑"><span>客户信息批量导入业务逻辑</span></a></h4><p><strong>面试回答：</strong></p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>这个项目主要处理招行各分行的客户信息（支持不同版本，比如基础信息，业务信息等不同表头）批量导入。客户经理上传Excel文件后，系统会智能识别表头结构（支持多级表头），然后按1万行一个分片进行异步处理。每个分片会进行业务规则校验（身份证号格式、手机号格式、业务合规性等），数据清洗转换（格式标准化、去重补全），最后批量入库，也可以根据需求转成像json这类的结构。整个过程支持断点续传，如果某条记录校验失败，会单独导出供客户经理修正。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h4 id="线程池异步分片的原因" tabindex="-1"><a class="header-anchor" href="#线程池异步分片的原因"><span>线程池异步分片的原因</span></a></h4><p><strong>面试回答：</strong></p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>使用线程池异步分片主要解决两个问题：</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>第一，内存溢出问题。招行的客户数据量很大，一个Excel文件可能有几十万行，如果一次性加载到内存会直接OOM。通过分片处理，每次只处理1万行数据，有效控制内存使用。</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>第二，性能瓶颈问题。单线程处理大文件会很慢，用户等待时间长。使用线程池可以同时处理多个分片，比如10个线程并行处理，处理速度能提升5-10倍。</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>第三，用户体验问题。异步处理让用户可以立即得到任务ID，然后通过进度条实时查看处理进度，而不是一直等待到处理完成。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="redis缓存的原因" tabindex="-1"><a class="header-anchor" href="#redis缓存的原因"><span>Redis缓存的原因</span></a></h4><p><strong>面试回答：</strong></p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>Redis缓存主要解决三个问题：</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>第一，处理进度跟踪。每个分片的处理状态、进度百分比、错误信息都需要实时更新，Redis的Hash结构非常适合存储这种键值对数据，支持实时查询和更新。</span></span>\n<span class="line"><span>Redis的hash大概长这样：Key → { field1: value1, field2: value2, field3: value3, ... }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Key: task_progress:{taskId} Value: { &quot;total_chunks&quot;: 10, &quot;completed_chunks&quot;: 3, &quot;current_chunk&quot;: 4, &quot;status&quot;: &quot;PROCESSING&quot;, &quot;start_time&quot;: 1699123456 }</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>第二，断点续传支持。如果系统重启或某个分片失败，可以从Redis中恢复处理状态，不需要重新开始整个任务，这对用户体验很重要。</span></span>\n<span class="line"><span>  - 不是真正的&quot;断点&quot;： 而是通过记录处理位置实现&quot;从哪里继续&quot;</span></span>\n<span class="line"><span>  - 定期保存： 不是每处理一行都保存，而是批量保存，平衡性能和可靠性</span></span>\n<span class="line"><span>  - 状态完整性： 需要记录分片状态、处理进度、错误信息等完整信息 </span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>第三，配置数据缓存。客户类型、风险等级、行业分类等配置信息变化不频繁，但查询频率很高。缓存到Redis可以减少数据库查询，提升其他接口的响应速度。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="redis选择hash结构的原因" tabindex="-1"><a class="header-anchor" href="#redis选择hash结构的原因"><span>Redis选择Hash结构的原因</span></a></h4><table><thead><tr><th>优势</th><th>具体表现</th><th>业务价值</th></tr></thead><tbody><tr><td><strong>天然适合键值对数据</strong></td><td>专门为存储对象设计，包含多个field-value对</td><td>完美匹配错误信息和状态数据结构</td></tr><tr><td><strong>原子性操作支持</strong></td><td>支持原子性的字段操作，多线程更新不冲突</td><td>保证数据一致性，避免并发问题</td></tr><tr><td><strong>部分更新效率高</strong></td><td>只需更新变化字段，无需重写整个对象</td><td>提升性能，避免不必要的序列化开销</td></tr><tr><td><strong>查询灵活</strong></td><td>支持单字段、多字段、全字段查询</td><td>满足不同查询需求，提升开发灵活性</td></tr><tr><td><strong>内存效率高</strong></td><td>比多个独立String key更节省内存</td><td>减少Redis内存开销，提升系统性能</td></tr><tr><td><strong>批量操作支持</strong></td><td>支持批量设置和获取多个字段</td><td>提升操作效率，减少网络往返</td></tr><tr><td><strong>适合分片处理场景</strong></td><td>天然适合管理多字段的结构化数据</td><td>完美契合分片处理的状态管理需求</td></tr></tbody></table><p><strong>核心价值：</strong> Hash结构在Redis中处理对象数据时，提供了原子性、高效性、灵活性和内存效率的完美平衡，是存储分片处理状态信息的最佳选择。</p><h4 id="技术架构的优势" tabindex="-1"><a class="header-anchor" href="#技术架构的优势"><span>技术架构的优势</span></a></h4><p><strong>面试回答：</strong></p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>这个架构的优势是：</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>可扩展性强：可以通过增加线程池大小来提升并发处理能力，通过增加Redis集群来提升缓存性能。</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>容错性好：单个分片失败不影响其他分片，Redis的持久化机制保证数据不丢失。</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>监控友好：可以实时监控每个分片的处理状态，快速定位性能瓶颈和错误原因。</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>资源利用率高：线程池避免了频繁创建销毁线程的开销，Redis缓存实现了进度监控和断点续传。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>总结回答：</strong></p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>所以选择线程池异步分片+Redis缓存，是因为这个组合能够有效解决大数据量处理的内存问题、性能问题和用户体验问题，同时提供了良好的可扩展性和容错性。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h2 id="招行项目-消息通知服务" tabindex="-1"><a class="header-anchor" href="#招行项目-消息通知服务"><span>招行项目 - 消息通知服务</span></a></h2><h3 id="项目背景" tabindex="-1"><a class="header-anchor" href="#项目背景"><span>项目背景</span></a></h3><p><strong>面试官问：&quot;这个项目主要做什么？&quot;</strong></p><p><strong>你的回答：</strong></p><p>这是招行的统一消息通知服务，主要功能是封装邮件、短信、应用消息等不同类型的消息发送功能，为上游业务系统提供统一的消息发送接口。系统需要支持动态扩展，提升系统间消息统一性与可维护性。</p><p><strong>直接调用的问题</strong></p><ol><li>业务系统需要了解每个服务商的API细节</li><li>无法统一处理重试、监控、限流等通用逻辑</li><li>代码重复，维护成本高、</li></ol><p>除了封装，添加了哪些<strong>新功能</strong>？</p><ol><li>修改源代码，让用户可以自定义行内不同的机器人发送者</li><li>原来的接口没有重试功能，如果网络抖动导致发送失败，用户需要手动重试。</li></ol><p>我们封装后添加了智能重试：</p><ul><li>网络错误自动重试3次，每次间隔递增（1秒、2秒、4秒）</li><li>参数错误不重试（如手机号格式错误）</li><li>重试过程中实时更新状态，用户可以看到&quot;正在重试第2次&quot;</li><li>最终失败后，提供详细的失败原因和重试建议</li></ul><p>这样大大提升了发送成功率，用户体验也更好。</p><h3 id="❌-碰到的主要困难" tabindex="-1"><a class="header-anchor" href="#❌-碰到的主要困难"><span>❌ 碰到的主要困难</span></a></h3><p>主要碰到了两个核心困难：</p><ol><li><p><strong>消息类型扩展困难</strong>：初期硬编码了邮件、短信等发送逻辑，每次新增消息类型都需要修改核心代码，违反了开闭原则。</p></li><li><p><strong>接口不统一问题</strong>：API接口多，业务系统调用时需要了解具体的实现细节才能放入代码，增加了使用复杂度。</p></li></ol><p><strong>代码耦合度高</strong>：消息发送逻辑与业务逻辑混在一起，修改消息类型会影响业务代码。</p><p><strong>扩展性差</strong>：新增消息类型需要修改现有代码，容易引入bug，测试成本高。</p><p><strong>维护困难</strong>：不同消息类型的实现逻辑分散在各个地方，难以统一管理和优化。</p><p><strong>接口不一致</strong>：业务系统需要调用不同的接口，增加了集成难度。</p><h3 id="🛠️-解决方案-策略-工厂模式" tabindex="-1"><a class="header-anchor" href="#🛠️-解决方案-策略-工厂模式"><span>🛠️ 解决方案：策略+工厂模式</span></a></h3><p>我使用策略模式+工厂模式来解决这些问题：</p><p><strong>策略模式的应用：</strong></p><ul><li>定义统一的消息发送接口<code>MessageSender</code></li><li>为每种消息类型实现具体的策略类： <ul><li><code>EmailSender</code>：处理邮件发送</li><li><code>SmsSender</code>：处理短信发送</li><li><code>AppMessageSender</code>：处理应用内消息推送</li></ul></li></ul><p><strong>工厂模式的应用：</strong></p><ul><li>创建<code>MessageSenderFactory</code>工厂类</li><li>根据消息类型动态创建对应的发送器实例</li><li>支持运行时配置，无需重启服务</li></ul><p><strong>简单工厂模式的应用：</strong></p><ul><li>创建<code>MessageSenderFactory</code>工厂类</li><li>根据消息类型字符串（如&quot;email&quot;、&quot;sms&quot;、&quot;app&quot;）动态创建对应的发送器实例</li><li>但是 违反开闭原则：新增策略需要修改工厂代码 后续优化-》Spring容器管理 <ul><li>完全符合开闭原则：新增策略无需修改工厂代码</li><li>自动注入：Spring自动管理策略实例，无需手动管理</li><li>支持热更新：可以通过配置中心动态调整</li><li>易于测试：可以轻松Mock策略类</li></ul></li></ul><h3 id="具体实现优势" tabindex="-1"><a class="header-anchor" href="#具体实现优势"><span>具体实现优势</span></a></h3><p>这种设计带来的优势：</p><ol><li><strong>开闭原则</strong>：新增消息类型只需实现新策略，无需修改现有代码</li><li><strong>单一职责</strong>：每个策略类只负责一种消息类型的发送逻辑</li><li><strong>依赖倒置</strong>：业务代码依赖抽象接口，不依赖具体实现</li><li><strong>易于测试</strong>：每个策略可以独立测试，提高测试覆盖率</li><li><strong>配置灵活</strong>：通过Nacos配置中心动态调整消息策略</li></ol><h2 id="大学项目-云平台数据分析" tabindex="-1"><a class="header-anchor" href="#大学项目-云平台数据分析"><span>大学项目 - 云平台数据分析</span></a></h2><h3 id="_1-es如何优化的" tabindex="-1"><a class="header-anchor" href="#_1-es如何优化的"><span>1. ES如何优化的</span></a></h3><h4 id="集群" tabindex="-1"><a class="header-anchor" href="#集群"><span>集群</span></a></h4><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐</span></span>\n<span class="line"><span>│   K8s Node 1   │    │   K8s Node 2   │    │   K8s Node 3   │</span></span>\n<span class="line"><span>│                 │    │                 │    │                 │</span></span>\n<span class="line"><span>│  ┌───────────┐  │    │  ┌───────────┐  │    │  ┌───────────┐  │</span></span>\n<span class="line"><span>│  │ ES实例1   │  │    │  │ ES实例2   │  │    │  │ ES实例3   │  │</span></span>\n<span class="line"><span>│  │           │  │    │  │           │  │    │  │           │  │</span></span>\n<span class="line"><span>│  │ 主分片1   │  │    │  │ 主分片2   │  │    │  │ 主分片3   │  │</span></span>\n<span class="line"><span>│  │ 副本分片3 │  │    │  │ 副本分片1 │  │    │  │ 副本分片2 │  │</span></span>\n<span class="line"><span>│  └───────────┘  │    │  └───────────┘  │    │  └───────────┘  │</span></span>\n<span class="line"><span>└─────────────────┘    └─────────────────┘    └─────────────────┘</span></span>\n<span class="line"><span>         │                       │                       │</span></span>\n<span class="line"><span>         └───────────────────────┼───────────────────────┘</span></span>\n<span class="line"><span>                                 │</span></span>\n<span class="line"><span>                    ┌─────────────────┐</span></span>\n<span class="line"><span>                    │   ES集群协调    │</span></span>\n<span class="line"><span>                    │                 │</span></span>\n<span class="line"><span>                    │  - 分片路由     │</span></span>\n<span class="line"><span>                    │  - 负载均衡     │</span></span>\n<span class="line"><span>                    │  - 故障转移     │</span></span>\n<span class="line"><span>                    └─────────────────┘</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="定时写入优化" tabindex="-1"><a class="header-anchor" href="#定时写入优化"><span>定时写入优化</span></a></h4><ul><li><strong>批量写入策略</strong>：Fission CronJob写入时，设置合适的批量大小（1000-5000条），减少ES写入频率</li><li><strong>刷新间隔调整</strong>：写入期间将refresh_interval设置为60秒，写入完成后恢复为1秒，平衡写入性能和查询实时性</li></ul><h4 id="索引设计优化" tabindex="-1"><a class="header-anchor" href="#索引设计优化"><span>索引设计优化</span></a></h4><ul><li><strong>时间分片策略</strong>：按天或按周创建索引，避免单个索引过大，提升查询性能</li><li><strong>字段映射优化</strong>：社交媒体数据的关键字段（用户ID(keyword)、内容(text)、时间戳(date)）使用合适的类型，避免不必要的分词</li></ul><h4 id="查询性能优化" tabindex="-1"><a class="header-anchor" href="#查询性能优化"><span>查询性能优化</span></a></h4><ul><li><strong>查询缓存</strong>：Python服务频繁查询的数据设置查询缓存，减少重复计算（根据慢日志、查询频率统计、业务场景判断）</li><li><strong>聚合优化</strong>：数据分析常用的聚合查询（如按时间统计、按平台统计）预计算并缓存结果</li><li><strong>分页查询优化</strong>：支持深度分页的search_after机制，避免深度分页的性能问题</li></ul><h4 id="监控和调优" tabindex="-1"><a class="header-anchor" href="#监控和调优"><span>监控和调优</span></a></h4><ul><li><strong>性能监控</strong>：监控写入延迟、查询响应时间、集群资源使用率等关键指标</li><li><strong>慢查询分析</strong>：开启慢查询日志，识别性能瓶颈并进行优化</li><li><strong>资源调优</strong>：根据实际使用情况，动态调整ES集群配置</li></ul><h2 id="加密货币交易平台" tabindex="-1"><a class="header-anchor" href="#加密货币交易平台"><span>加密货币交易平台</span></a></h2><h3 id="_1-困难和解决" tabindex="-1"><a class="header-anchor" href="#_1-困难和解决"><span>1. 困难和解决</span></a></h3><h4 id="架构层面困难" tabindex="-1"><a class="header-anchor" href="#架构层面困难"><span>架构层面困难</span></a></h4><p><strong>1. 高并发撮合引擎设计挑战</strong></p><ul><li><strong>问题</strong>：如何设计支持10万+ TPS的订单撮合系统</li><li><strong>挑战</strong>：订单匹配算法复杂度高，需要保证公平性和实时性</li><li><strong>解决方案</strong>： <ul><li>采用RabbitMQ + Disruptor异步架构，实现订单队列化处理</li><li>设计高效的撮合算法，按价格优先、时间优先原则排序</li><li>使用内存数据结构优化订单匹配性能</li></ul></li></ul><p><strong>2. 微服务架构复杂性管理</strong></p><ul><li><strong>问题</strong>：多个微服务间的协调和通信复杂性（比如订单服务、撮合服务、财务服务、会员服务等）</li><li><strong>挑战</strong>：服务发现、配置管理、负载均衡的统一管理</li><li><strong>解决方案</strong>： <ul><li>基于Nacos实现服务注册发现和配置中心</li><li>使用LoadBalancer实现智能负载均衡</li><li>设计服务间通信的标准化接口</li></ul></li></ul><p><strong>3. 分布式系统一致性保证</strong></p><ul><li><strong>问题</strong>：多服务环境下如何保证数据一致性</li><li><strong>挑战</strong>：订单状态同步、账户余额一致性、分布式事务</li><li><strong>解决方案</strong>： <ul><li>使用JetCache + Redis实现分布式锁</li><li>设计最终一致性的事务模型</li><li>实现补偿机制处理异常情况</li></ul></li></ul><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>举个具体例子：用户下单买比特币，系统先冻结余额（本地事务），然后发送订单到撮合引擎。如果撮合失败，补偿机制会自动解冻余额并取消订单；如果撮合成功但扣减余额失败，补偿机制会取消撮合结果并解冻余额。这样保证了无论哪个环节失败，用户资金都不会丢失，最终达到数据一致性。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h4 id="_2-开发层面困难" tabindex="-1"><a class="header-anchor" href="#_2-开发层面困难"><span>2. 开发层面困难</span></a></h4><p><strong>1. 实时行情推送性能优化</strong></p><ul><li><strong>问题</strong>：WebSocket连接数激增导致性能下降</li><li><strong>挑战</strong>：大量并发连接、消息广播效率、连接管理</li><li><strong>解决方案</strong>： <ul><li>实现连接池管理，复用WebSocket连接</li><li>使用消息压缩减少网络传输</li><li>设计分层推送策略，避免无效推送</li></ul></li></ul><p><strong>2. 分布式ID生成系统设计</strong></p><ul><li><strong>问题</strong>：如何在高并发环境下生成全局唯一ID</li><li><strong>挑战</strong>：ID唯一性、性能要求、时钟回拨问题</li><li><strong>解决方案</strong>： <ul><li>使用Snowflake算法，结合机器ID和序列号</li><li>处理时钟回拨问题，确保ID单调递增</li><li>优化ID生成性能，支持批量生成</li></ul></li></ul><p><strong>3. 安全认证体系实现</strong></p><ul><li><strong>问题</strong>：如何设计跨服务的统一认证授权</li><li><strong>挑战</strong>：JWT令牌管理、权限验证、安全防护</li><li><strong>解决方案</strong>： <ul><li>实现OAuth2 + JWT认证流程</li><li>设计令牌刷新和失效机制</li><li>添加防重放攻击和XSS防护</li></ul></li></ul><p><strong>4. 云原生部署复杂性</strong></p><ul><li><strong>问题</strong>：Docker容器化部署和运维管理</li><li><strong>挑战</strong>：容器编排、服务发现、监控告警</li><li><strong>解决方案</strong>： <ul><li>使用Docker Compose简化多服务部署</li><li>实现健康检查和自动重启机制</li><li>集成监控系统，实时监控服务状态</li></ul></li></ul>',163)]))}]]),t=JSON.parse('{"path":"/zh/posts/review/%E5%A4%8D%E4%B9%A0.html","title":"简历","lang":"zh-CN","frontmatter":{"icon":"pen-to-square","date":"2025-07-13T00:00:00.000Z","category":["Learning Records"],"tag":["Review"],"description":"简历 京东项目 - 分布式调度引擎 1. 架构设计相关问题 Q1: 项目中碰到了哪些困难？架构层面和开发层面？ 架构层面 高可用架构设计困难 问题：如何保证系统的高可用性 挑战：需要设计无单点故障的架构 解决方案： 应用层：Spring Boot集群部署（3个实例），Nginx轮询分发请求到应用层 调度器：XXL-JOB调度中心（1个+热备），XXL-...","head":[["meta",{"property":"og:url","content":"https://crc011220.github.io/zh/posts/review/%E5%A4%8D%E4%B9%A0.html"}],["meta",{"property":"og:site_name","content":"Ruochen Chen"}],["meta",{"property":"og:title","content":"简历"}],["meta",{"property":"og:description","content":"简历 京东项目 - 分布式调度引擎 1. 架构设计相关问题 Q1: 项目中碰到了哪些困难？架构层面和开发层面？ 架构层面 高可用架构设计困难 问题：如何保证系统的高可用性 挑战：需要设计无单点故障的架构 解决方案： 应用层：Spring Boot集群部署（3个实例），Nginx轮询分发请求到应用层 调度器：XXL-JOB调度中心（1个+热备），XXL-..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-13T07:46:31.000Z"}],["meta",{"property":"article:tag","content":"Review"}],["meta",{"property":"article:published_time","content":"2025-07-13T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-13T07:46:31.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"简历\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-07-13T00:00:00.000Z\\",\\"dateModified\\":\\"2025-08-13T07:46:31.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Ruochen Chen\\"}]}"]]},"headers":[{"level":2,"title":"京东项目 - 分布式调度引擎","slug":"京东项目-分布式调度引擎","link":"#京东项目-分布式调度引擎","children":[{"level":3,"title":"1. 架构设计相关问题","slug":"_1-架构设计相关问题","link":"#_1-架构设计相关问题","children":[]}]},{"level":2,"title":"招行项目 - Excel处理框架","slug":"招行项目-excel处理框架","link":"#招行项目-excel处理框架","children":[{"level":3,"title":"1. 架构设计相关问题","slug":"_1-架构设计相关问题-1","link":"#_1-架构设计相关问题-1","children":[]},{"level":3,"title":"2. 具体业务逻辑是什么？","slug":"_2-具体业务逻辑是什么","link":"#_2-具体业务逻辑是什么","children":[]}]},{"level":2,"title":"招行项目 - 消息通知服务","slug":"招行项目-消息通知服务","link":"#招行项目-消息通知服务","children":[{"level":3,"title":"项目背景","slug":"项目背景","link":"#项目背景","children":[]},{"level":3,"title":"❌ 碰到的主要困难","slug":"❌-碰到的主要困难","link":"#❌-碰到的主要困难","children":[]},{"level":3,"title":"🛠️ 解决方案：策略+工厂模式","slug":"🛠️-解决方案-策略-工厂模式","link":"#🛠️-解决方案-策略-工厂模式","children":[]},{"level":3,"title":"具体实现优势","slug":"具体实现优势","link":"#具体实现优势","children":[]}]},{"level":2,"title":"大学项目 - 云平台数据分析","slug":"大学项目-云平台数据分析","link":"#大学项目-云平台数据分析","children":[{"level":3,"title":"1. ES如何优化的","slug":"_1-es如何优化的","link":"#_1-es如何优化的","children":[]}]},{"level":2,"title":"加密货币交易平台","slug":"加密货币交易平台","link":"#加密货币交易平台","children":[{"level":3,"title":"1. 困难和解决","slug":"_1-困难和解决","link":"#_1-困难和解决","children":[]}]}],"git":{"createdTime":1755071191000,"updatedTime":1755071191000,"contributors":[{"name":"Ruochen Chen","email":"ruocchen1220@gmail.com","commits":1}]},"readingTime":{"minutes":22.89,"words":6867},"filePathRelative":"zh/posts/review/复习.md","localizedDate":"2025年7月13日","excerpt":"\\n<h2>京东项目 - 分布式调度引擎</h2>\\n<h3>1. 架构设计相关问题</h3>\\n<p><strong>Q1: 项目中碰到了哪些困难？架构层面和开发层面？</strong></p>\\n<h4>架构层面</h4>\\n<ol>\\n<li>高可用架构设计困难</li>\\n</ol>\\n<ul>\\n<li>问题：如何保证系统的高可用性</li>\\n<li>挑战：需要设计无单点故障的架构</li>\\n<li>解决方案：\\n<ul>\\n<li>应用层：Spring Boot集群部署（3个实例），Nginx轮询分发请求到应用层</li>\\n<li>调度器：XXL-JOB调度中心（1个+热备），XXL-JOB执行器（3个）</li>\\n<li>数据库层：MySQL主从复制（1主2从），ProxySQL读写分离（1个，待优化）</li>\\n<li>缓存层：Redis哨兵模式（3哨兵+1主2从），Redis缓存热点数据</li>\\n<li>监控：集成Spring Boot Actuator（监控 CPU、JVM、MySQL、Redis状态）</li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true}')}}]);