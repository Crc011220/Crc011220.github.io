"use strict";(self.webpackChunkpersonalweb=self.webpackChunkpersonalweb||[]).push([[4069],{2820:(i,s,l)=>{l.r(s),l.d(s,{comp:()=>e,data:()=>t});var a=l(641);const n={},e=(0,l(6262).A)(n,[["render",function(i,s){return(0,a.uX)(),(0,a.CE)("div",null,s[0]||(s[0]=[(0,a.Fv)('<h1 id="复习" tabindex="-1"><a class="header-anchor" href="#复习"><span>复习</span></a></h1><h2 id="京东项目-分布式调度引擎" tabindex="-1"><a class="header-anchor" href="#京东项目-分布式调度引擎"><span>京东项目 - 分布式调度引擎</span></a></h2><h3 id="_1-架构设计相关问题" tabindex="-1"><a class="header-anchor" href="#_1-架构设计相关问题"><span>1. 架构设计相关问题</span></a></h3><p><strong>Q1: 项目中碰到了哪些困难？架构层面和开发层面？</strong></p><h4 id="架构层面" tabindex="-1"><a class="header-anchor" href="#架构层面"><span>架构层面</span></a></h4><ol><li>高可用架构设计困难</li></ol><ul><li>问题：如何保证系统的高可用性</li><li>挑战：需要设计无单点故障的架构</li><li>解决方案： <ul><li>应用层：Spring Boot集群部署（3个实例），Nginx轮询分发请求到应用层</li><li>调度器：XXL-JOB调度中心（1个+热备），XXL-JOB执行器（3个）</li><li>数据库层：MySQL主从复制（1主2从），ProxySQL读写分离（1个，待优化）</li><li>缓存层：Redis哨兵模式（3哨兵+1主2从），Redis缓存热点数据</li><li>监控：集成Spring Boot Actuator（监控 CPU、JVM、MySQL、Redis状态）</li></ul></li></ul><ol start="2"><li>分布式一致性难题</li></ol><ul><li>问题：多节点环境下如何保证数据一致性</li><li>挑战：任务状态同步、分布式锁实现</li><li>解决方案：</li></ul><p>我们采用&quot;XXL-JOB + 分布式锁 + 补偿机制&quot;的组合方案来解决分布式一致性问题。XXL-JOB负责任务调度和去重，分布式锁保证并发安全，补偿机制处理跨服务数据不一致。三者各司其职、互补性强，实现了完整的分布式一致性保证。</p><h4 id="任务调度层面-xxl-job" tabindex="-1"><a class="header-anchor" href="#任务调度层面-xxl-job"><span>任务调度层面（XXL-JOB）</span></a></h4><p><strong>XXL-JOB的架构设计和职责划分</strong></p><ul><li>A. 项目系统负责： <ul><li>脚本管理 - 上传、存储、编辑脚本文件</li><li>任务管理 - 创建、配置、管理定时任务</li><li>用户管理 - 权限控制、用户认证</li><li>监控界面 - 执行状态、日志查看、统计分析</li></ul></li><li>B. XXL-JOB负责： <ul><li>定时调度 - 按Cron表达式触发任务执行</li><li>分布式执行 - 多实例负载均衡和故障转移</li><li>执行监控 - 任务执行状态跟踪</li><li>日志记录 - 详细的执行日志和错误信息</li></ul></li><li>XXL-JOB调度中心的热备不是自动集群，而是主备模式： <ul><li>主调度中心：正常工作，处理所有调度</li><li>备调度中心：待命状态，共享同一数据库</li><li>手动/半自动切换：主挂了，人工或脚本启用备用</li></ul></li></ul><p><strong>XXL-JOB调度中心已解决的分布式一致性问题</strong></p><ul><li>任务重复执行防护 <ul><li>通过数据库唯一约束防止同一任务被重复调度</li><li>执行器通过任务ID去重，避免重复执行</li></ul></li><li>任务状态一致性 <ul><li>调度中心统一管理任务状态（待执行、执行中、执行完成、执行失败）</li><li>执行器定期心跳上报，保持状态同步</li></ul></li><li>分布式锁机制 <ul><li>调度中心通过数据库行锁保证任务分配的原子性</li><li>避免多个调度中心同时分配同一任务</li></ul></li><li>任务执行结果一致性 <ul><li>执行器执行完成后统一回调调度中心</li><li>调度中心记录执行结果，保证数据一致性</li></ul></li></ul><p><strong>项目解决的分布式一致性问题</strong> XXL-JOB虽然能解决任务重复执行的问题，但在我们的分布式调度引擎中，还有很多跨服务的数据一致性问题它无法解决：</p><ol><li>脚本文件与任务配置的一致性</li><li>任务状态与XXL-JOB执行状态的一致性</li><li>用户权限变更与任务执行的一致性</li><li>系统配置与任务行为的一致性</li></ol><p>所以我们采用了&quot;<strong>XXL-JOB + 分布式锁 + 补偿机制</strong>&quot;的组合方案：XXL-JOB负责任务调度和去重，分布式锁保证并发安全，补偿机制处理跨服务数据不一致，这样就能实现完整的分布式一致性保证。</p><p><strong>saga：本地一致+补偿机制</strong> 补偿机制通过<strong>消息队列</strong>实现，主要处理部分成果、跨服务数据不一致的问题。</p><p>例子：补偿机制的具体处理流程是：</p><ol><li>脚本上传成功 ✅</li><li>任务配置创建成功 ✅</li><li>XXL-JOB注册失败 ❌</li></ol><p>补偿机制会从最后一步开始，倒序清理已成功的操作。</p><p>第一步：系统检测到XXL-JOB注册失败，立即发送补偿消息到消息队列</p><ul><li>消息类型：TASK_CREATION_FAILED</li><li>包含数据：脚本路径、任务ID、失败原因等</li></ul><p>第二步：补偿处理器消费消息，执行倒序清理</p><ul><li>清理XXL-JOB相关数据（如果有部分注册成功）</li><li>删除已创建的任务配置</li><li>清理已上传的脚本文件</li></ul><p>第三步：更新任务状态为&quot;创建失败&quot;，记录补偿日志</p><p>采用了Saga&quot;本地事务+补偿机制&quot;的组合方案：</p><ol><li><strong>本地事务</strong>：保证每个服务内部的数据一致性</li></ol><ul><li>脚本服务：文件上传的原子性</li><li>任务服务：任务配置的原子性</li><li>XXL-JOB服务：任务注册的原子性</li></ul><ol start="2"><li><strong>补偿机制</strong>：处理跨服务的不一致问题</li></ol><ul><li>当某个服务失败时，自动清理其他服务已成功的操作</li><li>通过消息队列异步处理，不影响主流程性能</li><li>实现最终一致性，而不是强一致性</li></ul><p>这样既保持了微服务的独立性，又解决了跨服务的一致性问题。</p><p><strong>分布式锁</strong> 保证高并发场景下的安全，锁粒度是：</p><ul><li>用户级别：按用户ID加锁，不同用户可以并发操作</li><li>资源级别：按资源ID加锁，不同资源可以并发操作</li><li>时间级别：设置合理的锁过期时间，防止死锁</li></ul><p>我们选择Redisson实现分布式锁，主要考虑它的专业性和可靠性：</p><ol><li>自动续期机制：Redisson支持锁的自动续期，避免业务执行时间过长导致锁过期</li><li>可重入锁支持：同一个线程可以多次获取同一个锁，避免死锁</li><li>公平锁实现：支持公平锁，保证锁的获取顺序</li><li>看门狗机制：自动监控锁的状态，异常情况下自动释放锁</li></ol><p>这样既保证了并发安全，又不会过度影响系统的并发性能。</p><h4 id="数据库层面-proxysql" tabindex="-1"><a class="header-anchor" href="#数据库层面-proxysql"><span>数据库层面（ProxySQL）</span></a></h4><ul><li>数据库主从切换时的数据同步 <ul><li>主从复制通过binlog机制（写入中继日志，然后从库重放）实现数据同步，ProxySQL在此基础上提供读写分离和故障切换。</li></ul></li><li>数据库读写分离 <ul><li>使用ProxySQL实现读写分离，根据请求类型（读/写）自动路由到主库或从库</li><li>第一步，定义服务器组。 我们创建了读写分离组，写组ID是10，读组ID是20，这样ProxySQL就知道哪些是主库哪些是从库。</li><li>第二步，配置服务器。 把主库IP加入写组10，从库IP加入读组20，每个服务器都要设置状态为ONLINE。</li><li>第三步，配置路由规则。 写操作（INSERT/UPDATE/DELETE）自动路由到写组，读操作（SELECT）自动路由到读组。</li></ul></li><li>数据库主库宕机后，如何自动切换（ProxySQL） <ul><li>自动检测 - 每200ms ping一次主库，检测连接状态</li><li>故障判断 - 连续失败达到阈值（如3次）后，自动标记主库为OFFLINE</li><li>智能路由 - 写请求自动路由到新的主库，读请求分散到所有可用从库</li><li>透明切换 - 应用层无需感知，连接ProxySQL即可，底层切换完全透明</li></ul></li><li>数据库主库宕机恢复后 <ul><li>ProxySQL持续ping宕机的主库</li><li>主库恢复后，ping成功</li><li>连续成功达到阈值后，标记主库为ONLINE</li><li>写操作：自动路由回主库（因为主库在写组且状态为ONLINE）</li><li>读操作：继续分散到所有可用节点（包括恢复的主库）</li><li>数据一致性：确保主库数据与从库同步后再恢复写路由，同步方法是通过MySQL主从复制机制，ProxySQL监控复制延迟，只有当从库延迟小于设定阈值时才恢复主库写操作。</li></ul></li><li>备用降级方案 <ul><li>如果ProxySQL宕机，会集群部署ProxySQL或使用AOP来切换到备用数据库，保证服务不中断（待优化，现在是单台ProxySQL）</li></ul></li></ul><p><strong>架构图：</strong></p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>应用1 ──┐</span></span>\n<span class="line"><span>         ├──→ ProxySQL ──→ 主库MySQL</span></span>\n<span class="line"><span>应用2 ──┘              └──→ 从库MySQL</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>具体连接方式：</strong></p><p><strong>1. 应用层配置：</strong></p><div class="language-yaml line-numbers-mode" data-highlighter="shiki" data-ext="yaml" data-title="yaml" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># application.yml</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">spring</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">:</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">  datasource</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">:</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">    url</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">jdbc:mysql://ProxySQL_IP:6033/数据库名</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">    username</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">用户名</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">    password</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">密码</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>2. ProxySQL配置：</strong></p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 配置后端MySQL服务器</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">INSERT INTO</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> mysql_servers </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">VALUES</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;192.168.1.10&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">3306</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">10</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;ONLINE&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2000</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2000</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">); </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 主库</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">INSERT INTO</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> mysql_servers </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">VALUES</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;192.168.1.11&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">3306</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">20</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;ONLINE&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2000</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2000</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">); </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 从库</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>3. 工作流程：</strong></p><ul><li><strong>应用1和应用2</strong>：都连接ProxySQL的6033端口</li><li><strong>ProxySQL</strong>：根据SQL类型自动路由到主库或从库</li><li><strong>应用感知不到</strong>：底层是主库还是从库对应用完全透明</li></ul><p><strong>优势：</strong></p><ul><li><strong>统一入口</strong>：所有应用都连接ProxySQL</li><li><strong>自动路由</strong>：写操作自动走主库，读操作自动走从库</li><li><strong>故障切换</strong>：主库宕机时自动切换到从库</li></ul><h4 id="redis层面-redis哨兵" tabindex="-1"><a class="header-anchor" href="#redis层面-redis哨兵"><span>Redis层面（Redis哨兵）</span></a></h4><ul><li>Redis缓存了什么业务数据？ <ul><li>JWT Token管理、在线用户监控、用户权限数据缓存、仪表板统计数据缓存</li></ul></li></ul><p><strong>双写一致性</strong> 我们采用&quot;先更新数据库，再删除缓存&quot;的策略来保证双写一致性，具体实现是：</p><ol><li><strong>写操作流程</strong>：先更新数据库，成功后再删除Redis缓存</li><li><strong>读操作流程</strong>：先查Redis，没有则查数据库并回填缓存</li><li><strong>异常处理</strong>：如果删除缓存失败，通过消息队列异步重试</li><li><strong>最终一致性</strong>：通过延迟双删和重试机制保证最终一致性</li></ol><p>也可以采用的阿里的Canal组件实现数据同步：不需要更改业务代码，只需部署一个Canal服务。Canal服务把自己伪装成mysql的一个从节点。当mysql数据更新以后，Canal会读取binlog数据，然后再通过Canal的客户端获取到数据，并更新缓存即可。</p><h4 id="开发层面" tabindex="-1"><a class="header-anchor" href="#开发层面"><span>开发层面</span></a></h4><ol><li>XXL-JOB集成和配置困难</li></ol><ul><li>问题：XXL-JOB的配置比较复杂，需要深入理解其架构</li><li>挑战：调度中心和执行器的配置、网络通信、任务注册</li><li>解决方案： <ul><li>仔细阅读官方文档和源码</li><li>搭建测试环境进行调试</li><li>编写详细的配置文档</li></ul></li></ul><ol start="2"><li>Docker容器化部署问题</li></ol><ul><li>问题：Docker配置错误导致服务无法正常启动</li><li>挑战：容器网络配置、端口映射、数据卷挂载</li><li>解决方案： <ul><li>使用docker-compose简化部署</li><li>编写详细的部署脚本</li><li>添加健康检查和日志监控</li></ul></li></ul><ol start="3"><li>权限管理系统开发困难</li></ol><ul><li>问题：RBAC权限管理需要细粒度的权限控制</li><li>挑战：用户-角色-权限的复杂关系、动态权限验证</li><li>解决方案： <ul><li>设计清晰的权限模型</li><li>使用Spring Security实现权限控制</li><li>通过注解实现细粒度权限验证</li></ul></li></ul><ol start="4"><li>监控系统开发挑战</li></ol><ul><li>问题：需要实时监控任务执行状态和系统性能</li><li>挑战：数据采集、实时展示、告警机制</li><li>解决方案： <ul><li>使用WebSocket实现实时数据推送</li><li>实现自定义的告警规则</li></ul></li></ul><h2 id="招行项目-excel处理框架" tabindex="-1"><a class="header-anchor" href="#招行项目-excel处理框架"><span>招行项目 - Excel处理框架</span></a></h2><h3 id="_1-架构设计相关问题-1" tabindex="-1"><a class="header-anchor" href="#_1-架构设计相关问题-1"><span>1. 架构设计相关问题</span></a></h3><p><strong>Q1: Excel处理框架的整体架构是什么？</strong></p><h4 id="架构层面-1" tabindex="-1"><a class="header-anchor" href="#架构层面-1"><span>架构层面</span></a></h4><ol><li>大数据处理内存溢出问题</li></ol><ul><li>问题：处理10万级数据时出现OOM（Out of Memory）</li><li>挑战：Excel文件无法一次性加载到内存</li><li>解决方案： <ul><li>采用分片处理策略，每片处理1万行数据</li><li>使用流式读取，边读边处理</li><li>优化内存使用，及时释放无用对象</li></ul></li></ul><ol start="2"><li>系统架构如何做的？</li></ol><ul><li>单体架构部署，部署在招行内部API云市场中</li><li>使用Spring Boot框架开发</li><li>使用Redis缓存热点数据（如任务状态和进度信息，校验规则，业务配置数据，分片处理锁）</li><li>使用线程池控制并发数量</li><li>使用异步处理，立即返回任务ID</li></ul><ol start="3"><li>数据一致性保证：</li></ol><ul><li>问题：并发处理时数据一致性和完整性</li><li>挑战：多线程环境下的数据同步和事务管理</li><li>解决方案：使用分布式锁+数据库事务+结果验证</li></ul><h4 id="开发层面-1" tabindex="-1"><a class="header-anchor" href="#开发层面-1"><span>开发层面</span></a></h4><ol><li>Excel文件格式兼容性问题</li></ol><ul><li>问题：不同版本的Excel文件格式差异较大</li><li>挑战：.xls和.xlsx格式的兼容性、特殊字符处理</li><li>解决方案： <ul><li>使用Apache POI库处理多种格式：HSSFWorkbook和XSSFWorkbook来处理xls和xlsx格式</li><li>实现格式检测和自动转换</li><li>添加特殊字符过滤和编码处理</li><li>编写详细的格式验证规则</li></ul></li></ul><ol start="2"><li>异步处理状态跟踪困难</li></ol><ul><li>问题：如何准确跟踪异步任务的执行状态</li><li>挑战：任务进度实时更新、异常状态处理</li><li>解决方案： <ul><li>使用Redis存储任务状态和进度</li><li>实现定时任务更新进度信息</li><li>添加任务超时和重试机制</li><li>设计完善的异常处理流程</li></ul></li></ul><ol start="3"><li>缓存策略设计复杂</li></ol><ul><li>问题：如何设计高效的缓存策略</li><li>挑战：缓存更新、缓存失效、内存管理</li><li>解决方案： <ul><li>使用Redis Hash结构存储复杂数据</li><li>实现缓存预热和更新策略</li><li>设置合理的缓存过期时间</li><li>添加缓存监控和告警</li></ul></li></ul><h3 id="_2-具体业务逻辑是什么" tabindex="-1"><a class="header-anchor" href="#_2-具体业务逻辑是什么"><span>2. 具体业务逻辑是什么？</span></a></h3><h4 id="客户信息批量导入业务逻辑" tabindex="-1"><a class="header-anchor" href="#客户信息批量导入业务逻辑"><span>客户信息批量导入业务逻辑</span></a></h4><p><strong>面试回答：</strong></p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>这个项目主要处理招行各分行的客户信息（支持不同版本，比如基础信息，业务信息等不同表头）批量导入。客户经理上传Excel文件后，系统会智能识别表头结构（支持多级表头），然后按1万行一个分片进行异步处理。每个分片会进行业务规则校验（身份证号格式、手机号格式、业务合规性等），数据清洗转换（格式标准化、去重补全），最后批量入库，也可以根据需求转成像json这类的结构。整个过程支持断点续传，如果某条记录校验失败，会单独导出供客户经理修正。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h4 id="线程池异步分片的原因" tabindex="-1"><a class="header-anchor" href="#线程池异步分片的原因"><span>线程池异步分片的原因</span></a></h4><p><strong>面试回答：</strong></p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>使用线程池异步分片主要解决两个问题：</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>第一，内存溢出问题。招行的客户数据量很大，一个Excel文件可能有几十万行，如果一次性加载到内存会直接OOM。通过分片处理，每次只处理1万行数据，有效控制内存使用。</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>第二，性能瓶颈问题。单线程处理大文件会很慢，用户等待时间长。使用线程池可以同时处理多个分片，比如10个线程并行处理，处理速度能提升5-10倍。</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>第三，用户体验问题。异步处理让用户可以立即得到任务ID，然后通过进度条实时查看处理进度，而不是一直等待到处理完成。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="redis缓存的原因" tabindex="-1"><a class="header-anchor" href="#redis缓存的原因"><span>Redis缓存的原因</span></a></h4><p><strong>面试回答：</strong></p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>Redis缓存主要解决三个问题：</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>第一，处理进度跟踪。每个分片的处理状态、进度百分比、错误信息都需要实时更新，Redis的Hash结构非常适合存储这种键值对数据，支持实时查询和更新。</span></span>\n<span class="line"><span>Redis的hash大概长这样：Key → { field1: value1, field2: value2, field3: value3, ... }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Key: task_progress:{taskId} Value: { &quot;total_chunks&quot;: 10, &quot;completed_chunks&quot;: 3, &quot;current_chunk&quot;: 4, &quot;status&quot;: &quot;PROCESSING&quot;, &quot;start_time&quot;: 1699123456 }</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>第二，断点续传支持。如果系统重启或某个分片失败，可以从Redis中恢复处理状态，不需要重新开始整个任务，这对用户体验很重要。</span></span>\n<span class="line"><span>  - 不是真正的&quot;断点&quot;： 而是通过记录处理位置实现&quot;从哪里继续&quot;</span></span>\n<span class="line"><span>  - 定期保存： 不是每处理一行都保存，而是批量保存，平衡性能和可靠性</span></span>\n<span class="line"><span>  - 状态完整性： 需要记录分片状态、处理进度、错误信息等完整信息 </span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>第三，配置数据缓存。客户类型、风险等级、行业分类等配置信息变化不频繁，但查询频率很高。缓存到Redis可以减少数据库查询，提升其他接口的响应速度。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="redis选择hash结构的原因" tabindex="-1"><a class="header-anchor" href="#redis选择hash结构的原因"><span>Redis选择Hash结构的原因</span></a></h4><table><thead><tr><th>优势</th><th>具体表现</th><th>业务价值</th></tr></thead><tbody><tr><td><strong>天然适合键值对数据</strong></td><td>专门为存储对象设计，包含多个field-value对</td><td>完美匹配错误信息和状态数据结构</td></tr><tr><td><strong>原子性操作支持</strong></td><td>支持原子性的字段操作，多线程更新不冲突</td><td>保证数据一致性，避免并发问题</td></tr><tr><td><strong>部分更新效率高</strong></td><td>只需更新变化字段，无需重写整个对象</td><td>提升性能，避免不必要的序列化开销</td></tr><tr><td><strong>查询灵活</strong></td><td>支持单字段、多字段、全字段查询</td><td>满足不同查询需求，提升开发灵活性</td></tr><tr><td><strong>内存效率高</strong></td><td>比多个独立String key更节省内存</td><td>减少Redis内存开销，提升系统性能</td></tr><tr><td><strong>批量操作支持</strong></td><td>支持批量设置和获取多个字段</td><td>提升操作效率，减少网络往返</td></tr><tr><td><strong>适合分片处理场景</strong></td><td>天然适合管理多字段的结构化数据</td><td>完美契合分片处理的状态管理需求</td></tr></tbody></table><p><strong>核心价值：</strong> Hash结构在Redis中处理对象数据时，提供了原子性、高效性、灵活性和内存效率的完美平衡，是存储分片处理状态信息的最佳选择。</p><h4 id="技术架构的优势" tabindex="-1"><a class="header-anchor" href="#技术架构的优势"><span>技术架构的优势</span></a></h4><p><strong>面试回答：</strong></p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>这个架构的优势是：</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>可扩展性强：可以通过增加线程池大小来提升并发处理能力，通过增加Redis集群来提升缓存性能。</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>容错性好：单个分片失败不影响其他分片，Redis的持久化机制保证数据不丢失。</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>监控友好：可以实时监控每个分片的处理状态，快速定位性能瓶颈和错误原因。</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>资源利用率高：线程池避免了频繁创建销毁线程的开销，Redis缓存实现了进度监控和断点续传。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>总结回答：</strong></p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>所以选择线程池异步分片+Redis缓存，是因为这个组合能够有效解决大数据量处理的内存问题、性能问题和用户体验问题，同时提供了良好的可扩展性和容错性。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h2 id="招行项目-消息通知服务" tabindex="-1"><a class="header-anchor" href="#招行项目-消息通知服务"><span>招行项目 - 消息通知服务</span></a></h2><h3 id="项目背景" tabindex="-1"><a class="header-anchor" href="#项目背景"><span>项目背景</span></a></h3><p><strong>面试官问：&quot;这个项目主要做什么？&quot;</strong></p><p><strong>你的回答：</strong></p><p>这是招行的统一消息通知服务，主要功能是封装邮件、短信、应用消息等不同类型的消息发送功能，为上游业务系统提供统一的消息发送接口。系统需要支持动态扩展，提升系统间消息统一性与可维护性。</p><p><strong>直接调用的问题</strong></p><ol><li>业务系统需要了解每个服务商的API细节</li><li>无法统一处理重试、监控、限流等通用逻辑</li><li>代码重复，维护成本高、</li></ol><p>除了封装，添加了哪些<strong>新功能</strong>？</p><ol><li>修改源代码，让用户可以自定义行内不同的机器人发送者</li><li>原来的接口没有重试功能，如果网络抖动导致发送失败，用户需要手动重试。</li></ol><p>我们封装后添加了智能重试：</p><ul><li>网络错误自动重试3次，每次间隔递增（1秒、2秒、4秒）</li><li>参数错误不重试（如手机号格式错误）</li><li>重试过程中实时更新状态，用户可以看到&quot;正在重试第2次&quot;</li><li>最终失败后，提供详细的失败原因和重试建议</li></ul><p>这样大大提升了发送成功率，用户体验也更好。</p><h3 id="❌-碰到的主要困难" tabindex="-1"><a class="header-anchor" href="#❌-碰到的主要困难"><span>❌ 碰到的主要困难</span></a></h3><p>主要碰到了两个核心困难：</p><ol><li><p><strong>消息类型扩展困难</strong>：初期硬编码了邮件、短信等发送逻辑，每次新增消息类型都需要修改核心代码，违反了开闭原则。</p></li><li><p><strong>接口不统一问题</strong>：API接口多，业务系统调用时需要了解具体的实现细节才能放入代码，增加了使用复杂度。</p></li></ol><p><strong>代码耦合度高</strong>：消息发送逻辑与业务逻辑混在一起，修改消息类型会影响业务代码。</p><p><strong>扩展性差</strong>：新增消息类型需要修改现有代码，容易引入bug，测试成本高。</p><p><strong>维护困难</strong>：不同消息类型的实现逻辑分散在各个地方，难以统一管理和优化。</p><p><strong>接口不一致</strong>：业务系统需要调用不同的接口，增加了集成难度。</p><h3 id="🛠️-解决方案-策略-工厂模式" tabindex="-1"><a class="header-anchor" href="#🛠️-解决方案-策略-工厂模式"><span>🛠️ 解决方案：策略+工厂模式</span></a></h3><p>我使用策略模式+工厂模式来解决这些问题：</p><p><strong>策略模式的应用：</strong></p><ul><li>定义统一的消息发送接口<code>MessageSender</code></li><li>为每种消息类型实现具体的策略类： <ul><li><code>EmailSender</code>：处理邮件发送</li><li><code>SmsSender</code>：处理短信发送</li><li><code>AppMessageSender</code>：处理应用内消息推送</li></ul></li></ul><p><strong>工厂模式的应用：</strong></p><ul><li>创建<code>MessageSenderFactory</code>工厂类</li><li>根据消息类型动态创建对应的发送器实例</li><li>支持运行时配置，无需重启服务</li></ul><p><strong>简单工厂模式的应用：</strong></p><ul><li>创建<code>MessageSenderFactory</code>工厂类</li><li>根据消息类型字符串（如&quot;email&quot;、&quot;sms&quot;、&quot;app&quot;）动态创建对应的发送器实例</li><li>但是 违反开闭原则：新增策略需要修改工厂代码 后续优化-》Spring容器管理 <ul><li>完全符合开闭原则：新增策略无需修改工厂代码</li><li>自动注入：Spring自动管理策略实例，无需手动管理</li><li>支持热更新：可以通过配置中心动态调整</li><li>易于测试：可以轻松Mock策略类</li></ul></li></ul><h3 id="具体实现优势" tabindex="-1"><a class="header-anchor" href="#具体实现优势"><span>具体实现优势</span></a></h3><p>这种设计带来的优势：</p><ol><li><strong>开闭原则</strong>：新增消息类型只需实现新策略，无需修改现有代码</li><li><strong>单一职责</strong>：每个策略类只负责一种消息类型的发送逻辑</li><li><strong>依赖倒置</strong>：业务代码依赖抽象接口，不依赖具体实现</li><li><strong>易于测试</strong>：每个策略可以独立测试，提高测试覆盖率</li><li><strong>配置灵活</strong>：通过Nacos配置中心动态调整消息策略</li></ol><h2 id="大学项目-云平台数据分析" tabindex="-1"><a class="header-anchor" href="#大学项目-云平台数据分析"><span>大学项目 - 云平台数据分析</span></a></h2><h3 id="_1-es如何优化的" tabindex="-1"><a class="header-anchor" href="#_1-es如何优化的"><span>1. ES如何优化的</span></a></h3><h4 id="集群" tabindex="-1"><a class="header-anchor" href="#集群"><span>集群</span></a></h4><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐</span></span>\n<span class="line"><span>│   K8s Node 1   │    │   K8s Node 2   │    │   K8s Node 3   │</span></span>\n<span class="line"><span>│                 │    │                 │    │                 │</span></span>\n<span class="line"><span>│  ┌───────────┐  │    │  ┌───────────┐  │    │  ┌───────────┐  │</span></span>\n<span class="line"><span>│  │ ES实例1   │  │    │  │ ES实例2   │  │    │  │ ES实例3   │  │</span></span>\n<span class="line"><span>│  │           │  │    │  │           │  │    │  │           │  │</span></span>\n<span class="line"><span>│  │ 主分片1   │  │    │  │ 主分片2   │  │    │  │ 主分片3   │  │</span></span>\n<span class="line"><span>│  │ 副本分片3 │  │    │  │ 副本分片1 │  │    │  │ 副本分片2 │  │</span></span>\n<span class="line"><span>│  └───────────┘  │    │  └───────────┘  │    │  └───────────┘  │</span></span>\n<span class="line"><span>└─────────────────┘    └─────────────────┘    └─────────────────┘</span></span>\n<span class="line"><span>         │                       │                       │</span></span>\n<span class="line"><span>         └───────────────────────┼───────────────────────┘</span></span>\n<span class="line"><span>                                 │</span></span>\n<span class="line"><span>                    ┌─────────────────┐</span></span>\n<span class="line"><span>                    │   ES集群协调    │</span></span>\n<span class="line"><span>                    │                 │</span></span>\n<span class="line"><span>                    │  - 分片路由     │</span></span>\n<span class="line"><span>                    │  - 负载均衡     │</span></span>\n<span class="line"><span>                    │  - 故障转移     │</span></span>\n<span class="line"><span>                    └─────────────────┘</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="定时写入优化" tabindex="-1"><a class="header-anchor" href="#定时写入优化"><span>定时写入优化</span></a></h4><ul><li><strong>批量写入策略</strong>：Fission CronJob写入时，设置合适的批量大小（1000-5000条），减少ES写入频率</li><li><strong>刷新间隔调整</strong>：写入期间将refresh_interval设置为60秒，写入完成后恢复为1秒，平衡写入性能和查询实时性</li></ul><h4 id="索引设计优化" tabindex="-1"><a class="header-anchor" href="#索引设计优化"><span>索引设计优化</span></a></h4><ul><li><strong>时间分片策略</strong>：按天或按周创建索引，避免单个索引过大，提升查询性能</li><li><strong>字段映射优化</strong>：社交媒体数据的关键字段（用户ID(keyword)、内容(text)、时间戳(date)）使用合适的类型，避免不必要的分词</li></ul><h4 id="查询性能优化" tabindex="-1"><a class="header-anchor" href="#查询性能优化"><span>查询性能优化</span></a></h4><ul><li><strong>查询缓存</strong>：Python服务频繁查询的数据设置查询缓存，减少重复计算（根据慢日志、查询频率统计、业务场景判断）</li><li><strong>聚合优化</strong>：数据分析常用的聚合查询（如按时间统计、按平台统计）预计算并缓存结果</li><li><strong>分页查询优化</strong>：支持深度分页的search_after机制，避免深度分页的性能问题</li></ul><h4 id="监控和调优" tabindex="-1"><a class="header-anchor" href="#监控和调优"><span>监控和调优</span></a></h4><ul><li><strong>性能监控</strong>：监控写入延迟、查询响应时间、集群资源使用率等关键指标</li><li><strong>慢查询分析</strong>：开启慢查询日志，识别性能瓶颈并进行优化</li><li><strong>资源调优</strong>：根据实际使用情况，动态调整ES集群配置</li></ul><h2 id="加密货币交易平台" tabindex="-1"><a class="header-anchor" href="#加密货币交易平台"><span>加密货币交易平台</span></a></h2><h3 id="_1-困难和解决" tabindex="-1"><a class="header-anchor" href="#_1-困难和解决"><span>1. 困难和解决</span></a></h3><h4 id="架构层面困难" tabindex="-1"><a class="header-anchor" href="#架构层面困难"><span>架构层面困难</span></a></h4><p><strong>1. 高并发撮合引擎设计挑战</strong></p><ul><li><strong>问题</strong>：如何设计支持10万+ TPS的订单撮合系统</li><li><strong>挑战</strong>：订单匹配算法复杂度高，需要保证公平性和实时性</li><li><strong>解决方案</strong>： <ul><li>采用RabbitMQ + Disruptor异步架构，实现订单队列化处理</li><li>设计高效的撮合算法，按价格优先、时间优先原则排序</li><li>使用内存数据结构优化订单匹配性能</li></ul></li></ul><p><strong>2. 微服务架构复杂性管理</strong></p><ul><li><strong>问题</strong>：多个微服务间的协调和通信复杂性（比如订单服务、撮合服务、财务服务、会员服务等）</li><li><strong>挑战</strong>：服务发现、配置管理、负载均衡的统一管理</li><li><strong>解决方案</strong>： <ul><li>基于Nacos实现服务注册发现和配置中心</li><li>使用LoadBalancer实现智能负载均衡</li><li>设计服务间通信的标准化接口</li></ul></li></ul><p><strong>3. 分布式系统一致性保证</strong></p><ul><li><strong>问题</strong>：多服务环境下如何保证数据一致性</li><li><strong>挑战</strong>：订单状态同步、账户余额一致性、分布式事务</li><li><strong>解决方案</strong>： <ul><li>使用JetCache + Redis实现分布式锁</li><li>设计最终一致性的事务模型</li><li>实现补偿机制处理异常情况</li></ul></li></ul><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>举个具体例子：用户下单买比特币，系统先冻结余额（本地事务），然后发送订单到撮合引擎。如果撮合失败，补偿机制会自动解冻余额并取消订单；如果撮合成功但扣减余额失败，补偿机制会取消撮合结果并解冻余额。这样保证了无论哪个环节失败，用户资金都不会丢失，最终达到数据一致性。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h4 id="_2-开发层面困难" tabindex="-1"><a class="header-anchor" href="#_2-开发层面困难"><span>2. 开发层面困难</span></a></h4><p><strong>1. 实时行情推送性能优化</strong></p><ul><li><strong>问题</strong>：WebSocket连接数激增导致性能下降</li><li><strong>挑战</strong>：大量并发连接、消息广播效率、连接管理</li><li><strong>解决方案</strong>： <ul><li>实现连接池管理，复用WebSocket连接</li><li>使用消息压缩减少网络传输</li><li>设计分层推送策略，避免无效推送</li></ul></li></ul><p><strong>2. 分布式ID生成系统设计</strong></p><ul><li><strong>问题</strong>：如何在高并发环境下生成全局唯一ID</li><li><strong>挑战</strong>：ID唯一性、性能要求、时钟回拨问题</li><li><strong>解决方案</strong>： <ul><li>使用Snowflake算法，结合机器ID和序列号</li><li>处理时钟回拨问题，确保ID单调递增</li><li>优化ID生成性能，支持批量生成</li></ul></li></ul><p><strong>3. 安全认证体系实现</strong></p><ul><li><strong>问题</strong>：如何设计跨服务的统一认证授权</li><li><strong>挑战</strong>：JWT令牌管理、权限验证、安全防护</li><li><strong>解决方案</strong>： <ul><li>实现OAuth2 + JWT认证流程</li><li>设计令牌刷新和失效机制</li><li>添加防重放攻击和XSS防护</li></ul></li></ul><p><strong>4. 云原生部署复杂性</strong></p><ul><li><strong>问题</strong>：Docker容器化部署和运维管理</li><li><strong>挑战</strong>：容器编排、服务发现、监控告警</li><li><strong>解决方案</strong>： <ul><li>使用Docker Compose简化多服务部署</li><li>实现健康检查和自动重启机制</li><li>集成监控系统，实时监控服务状态</li></ul></li></ul><h2 id="🚨-面试官挖坑应对方案" tabindex="-1"><a class="header-anchor" href="#🚨-面试官挖坑应对方案"><span>🚨 面试官挖坑应对方案</span></a></h2><h3 id="_1-分布式一致性方案深度解析" tabindex="-1"><a class="header-anchor" href="#_1-分布式一致性方案深度解析"><span>1. 分布式一致性方案深度解析</span></a></h3><h4 id="补偿机制失败处理方案" tabindex="-1"><a class="header-anchor" href="#补偿机制失败处理方案"><span>补偿机制失败处理方案</span></a></h4><p><strong>Q: 补偿机制失败怎么办？如何保证补偿的幂等性？</strong></p><p><strong>A: 我们设计了多层保障机制：</strong></p><ol><li><strong>幂等性保证</strong><ul><li>每个补偿操作都有唯一的操作ID（UUID + 时间戳）</li><li>补偿前先查询操作记录表，避免重复执行</li><li>使用Redis分布式锁确保同一操作ID只能执行一次</li></ul></li></ol><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Transactional</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> executeCompensation</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> operationId</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> CompensationContext</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> context) {</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 1. 检查是否已执行过</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">compensationRecordService</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">isExecuted</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(operationId)</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        log</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">info</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;补偿操作已执行，跳过: {}&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, operationId);</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    </span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 2. 获取分布式锁</span></span>\n<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">    RLock</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> lock </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> redissonClient</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getLock</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;compensation:&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> +</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> operationId);</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">!</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">lock</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">tryLock</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">30</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">10</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">TimeUnit</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">SECONDS</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        throw</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> RuntimeException</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;获取补偿锁失败&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    </span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    try</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> {</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 3. 执行补偿逻辑</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        compensationExecutor</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">execute</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(context);</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">        </span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 4. 记录执行状态</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        compensationRecordService</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">recordSuccess</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(operationId, context);</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    } </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">finally</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> {</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        lock</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">unlock</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li><p><strong>失败重试机制</strong></p><ul><li>补偿失败时，消息重新入队，延迟重试</li><li>重试次数限制（最多3次），避免无限重试</li><li>重试间隔递增：1分钟、5分钟、15分钟</li></ul></li><li><p><strong>人工干预机制</strong></p><ul><li>补偿失败超过重试次数后，进入人工处理队列</li><li>提供补偿操作的可视化界面，支持手动重试</li><li>记录详细的失败日志，便于问题排查</li></ul></li></ol><h4 id="消息队列宕机处理" tabindex="-1"><a class="header-anchor" href="#消息队列宕机处理"><span>消息队列宕机处理</span></a></h4><p><strong>Q: 消息队列宕机时如何处理？</strong></p><p><strong>A: 我们实现了多级降级方案：</strong></p><ol><li><p><strong>本地存储降级</strong></p><ul><li>消息队列不可用时，补偿消息存储到本地数据库</li><li>使用定时任务扫描本地存储，执行补偿操作</li><li>消息队列恢复后，批量同步本地存储的消息</li></ul></li><li><p><strong>同步补偿降级</strong></p><ul><li>紧急情况下，直接同步执行补偿逻辑</li><li>牺牲性能保证数据一致性</li><li>提供开关控制是否启用同步补偿</li></ul></li><li><p><strong>监控告警机制</strong></p><ul><li>实时监控消息队列状态</li><li>队列异常时立即告警，通知运维人员</li><li>提供队列健康检查接口</li></ul></li></ol><h4 id="补偿消息顺序性保证" tabindex="-1"><a class="header-anchor" href="#补偿消息顺序性保证"><span>补偿消息顺序性保证</span></a></h4><p><strong>Q: 补偿消息的顺序性如何保证？</strong></p><p><strong>A: 我们使用分区队列和顺序消费：</strong></p><ol><li><p><strong>分区策略</strong></p><ul><li>按业务ID（如任务ID）进行消息分区</li><li>同一业务ID的消息发送到同一分区</li><li>保证同一业务的消息顺序性</li></ul></li><li><p><strong>顺序消费</strong></p><ul><li>每个分区只分配一个消费者</li><li>使用消息的序号字段保证顺序</li><li>消费失败时，消息重新入队到分区末尾</li></ul></li></ol><h3 id="_2-proxysql故障切换深度解析" tabindex="-1"><a class="header-anchor" href="#_2-proxysql故障切换深度解析"><span>2. ProxySQL故障切换深度解析</span></a></h3><h4 id="ping频率优化" tabindex="-1"><a class="header-anchor" href="#ping频率优化"><span>Ping频率优化</span></a></h4><p><strong>Q: 200ms的ping频率是如何确定的？为什么不是100ms或500ms？</strong></p><p><strong>A: 我们通过性能测试和业务需求确定：</strong></p><ol><li><p><strong>性能测试结果</strong></p><ul><li>100ms：检测延迟低，但网络开销大（增加30%）</li><li>200ms：检测延迟适中，网络开销可接受（增加15%）</li><li>500ms：网络开销小，但故障检测延迟高（增加2-3秒）</li></ul></li><li><p><strong>业务容忍度分析</strong></p><ul><li>我们的业务对数据延迟容忍度是5秒</li><li>200ms × 3次失败 = 600ms检测时间</li><li>加上切换时间，总延迟控制在2秒内</li></ul></li><li><p><strong>动态调整机制</strong></p><ul><li>根据网络质量动态调整ping频率</li><li>网络稳定时使用500ms，不稳定时使用200ms</li><li>通过配置中心实时调整</li></ul></li></ol><h4 id="网络抖动处理" tabindex="-1"><a class="header-anchor" href="#网络抖动处理"><span>网络抖动处理</span></a></h4><p><strong>Q: 网络抖动导致的误判如何处理？</strong></p><p><strong>A: 我们实现了智能故障检测算法：</strong></p><ol><li><p><strong>多维度检测</strong></p><ul><li>连接检测：TCP连接状态</li><li>响应时间检测：ping响应时间</li><li>业务检测：简单SQL查询响应</li></ul></li><li><p><strong>滑动窗口算法</strong></p><ul><li>使用10次检测的滑动窗口</li><li>失败率超过70%才判定为故障</li><li>避免偶发性网络抖动误判</li></ul></li><li><p><strong>故障确认机制</strong></p><ul><li>初步检测到故障后，进行二次确认</li><li>连续3次确认失败才执行切换</li><li>提供手动确认开关</li></ul></li></ol><h4 id="主从切换数据一致性" tabindex="-1"><a class="header-anchor" href="#主从切换数据一致性"><span>主从切换数据一致性</span></a></h4><p><strong>Q: 主从切换过程中的数据一致性如何保证？</strong></p><p><strong>A: 我们使用多阶段切换策略：</strong></p><ol><li><p><strong>切换前准备</strong></p><ul><li>检查从库复制延迟，确保延迟小于1秒</li><li>暂停写操作，等待所有事务完成</li><li>记录当前binlog位置</li></ul></li><li><p><strong>切换执行</strong></p><ul><li>将新主库标记为ONLINE</li><li>更新路由规则，写请求路由到新主库</li><li>等待所有连接切换到新主库</li></ul></li><li><p><strong>切换后验证</strong></p><ul><li>验证新主库数据完整性</li><li>检查复制状态，确保从库同步正常</li><li>恢复写操作</li></ul></li></ol><h3 id="_3-redis双写一致性深度解析" tabindex="-1"><a class="header-anchor" href="#_3-redis双写一致性深度解析"><span>3. Redis双写一致性深度解析</span></a></h3><h4 id="缓存穿透解决方案" tabindex="-1"><a class="header-anchor" href="#缓存穿透解决方案"><span>缓存穿透解决方案</span></a></h4><p><strong>Q: 缓存穿透问题如何解决？</strong></p><p><strong>A: 我们实现了多层防护：</strong></p><ol><li><p><strong>布隆过滤器</strong></p><ul><li>在Redis前增加布隆过滤器层</li><li>过滤掉不存在的key，避免无效查询</li><li>误判率控制在0.1%以内</li></ul></li><li><p><strong>空值缓存</strong></p><ul><li>查询结果为空的key也缓存到Redis</li><li>设置较短的过期时间（如5分钟）</li><li>避免重复查询数据库</li></ul></li><li><p><strong>参数校验</strong></p><ul><li>在应用层进行参数格式校验</li><li>过滤掉明显无效的查询请求</li><li>减少无效请求到达缓存层</li></ul></li></ol><h4 id="缓存雪崩解决方案" tabindex="-1"><a class="header-anchor" href="#缓存雪崩解决方案"><span>缓存雪崩解决方案</span></a></h4><p><strong>Q: 热点数据失效时如何避免缓存雪崩？</strong></p><p><strong>A: 我们使用多种策略组合：</strong></p><ol><li><p><strong>过期时间随机化</strong></p><ul><li>基础过期时间 + 随机偏移量（±300秒）</li><li>避免大量key同时失效</li><li>分散缓存重建压力</li></ul></li><li><p><strong>热点数据永不过期</strong></p><ul><li>识别热点数据（访问频率 &gt; 1000次/分钟）</li><li>设置永不过期，通过后台任务更新</li><li>避免热点数据失效导致的雪崩</li></ul></li><li><p><strong>熔断机制</strong></p><ul><li>当缓存命中率低于50%时，启用熔断</li><li>直接返回降级数据，避免数据库压力</li><li>提供开关控制熔断策略</li></ul></li></ol><h4 id="延迟双删实现细节" tabindex="-1"><a class="header-anchor" href="#延迟双删实现细节"><span>延迟双删实现细节</span></a></h4><p><strong>Q: 延迟双删的具体实现细节是什么？</strong></p><p><strong>A: 我们使用消息队列实现延迟双删：</strong></p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Service</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> CacheService</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    </span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    @</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Autowired</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> RedisTemplate</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Object</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> redisTemplate</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    </span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    @</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Autowired</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> RabbitTemplate</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> rabbitTemplate</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    </span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> updateData</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> key</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Object</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> value</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 1. 更新数据库</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        databaseService</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">update</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(key, value);</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        </span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 2. 删除缓存</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        redisTemplate</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">delete</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(key);</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        </span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 3. 发送延迟删除消息</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">        sendDelayDeleteMessage</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(key, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">5000</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">); </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 5秒后再次删除</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    </span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> sendDelayDeleteMessage</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> key</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">long</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> delay</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 使用RabbitMQ的延迟队列插件</span></span>\n<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        Message</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> message</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> MessageBuilder</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">            .</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">withBody</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">key</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getBytes</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">())</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">            .</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">setHeader</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;x-delay&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, delay)</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">            .</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">build</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        </span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        rabbitTemplate</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">send</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;cache.delay.exchange&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;cache.delay.queue&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, message);</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    </span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    @</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">RabbitListener</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">queues</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;cache.delay.queue&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> handleDelayDelete</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> key</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 延迟删除缓存，防止缓存不一致</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        redisTemplate</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">delete</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(key);</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_4-线程池异步分片深度解析" tabindex="-1"><a class="header-anchor" href="#_4-线程池异步分片深度解析"><span>4. 线程池异步分片深度解析</span></a></h3><h4 id="线程池参数配置" tabindex="-1"><a class="header-anchor" href="#线程池参数配置"><span>线程池参数配置</span></a></h4><p><strong>Q: 线程池的核心线程数和最大线程数如何确定？</strong></p><p><strong>A: 我们通过性能测试和资源分析确定：</strong></p><ol><li><p><strong>资源分析</strong></p><ul><li>CPU核心数：8核</li><li>内存容量：16GB</li><li>数据库连接池：20个连接</li></ul></li><li><p><strong>性能测试结果</strong></p><ul><li>核心线程数：8（等于CPU核心数）</li><li>最大线程数：16（CPU核心数的2倍）</li><li>队列大小：1000（避免OOM）</li></ul></li><li><p><strong>动态调整机制</strong></p><ul><li>监控线程池活跃线程数</li><li>当活跃线程数持续超过核心线程数时，增加最大线程数</li><li>通过配置中心实时调整</li></ul></li></ol><h4 id="分片大小确定" tabindex="-1"><a class="header-anchor" href="#分片大小确定"><span>分片大小确定</span></a></h4><p><strong>Q: 分片大小1万行是如何确定的？</strong></p><p><strong>A: 我们通过多维度测试确定最优分片大小：</strong></p><ol><li><p><strong>内存使用测试</strong></p><ul><li>5000行：内存使用2GB，处理时间30秒</li><li>10000行：内存使用4GB，处理时间55秒</li><li>20000行：内存使用8GB，处理时间120秒</li></ul></li><li><p><strong>数据库性能测试</strong></p><ul><li>批量插入10000行：响应时间2秒</li><li>批量插入20000行：响应时间5秒</li><li>批量插入50000行：响应时间15秒</li></ul></li><li><p><strong>用户体验考虑</strong></p><ul><li>10000行分片：进度更新频率适中（每10秒更新一次）</li><li>用户等待时间可接受（单分片处理时间约1分钟）</li><li>错误定位精确（问题数据范围可控）</li></ul></li></ol><h3 id="_5-策略模式spring实现深度解析" tabindex="-1"><a class="header-anchor" href="#_5-策略模式spring实现深度解析"><span>5. 策略模式Spring实现深度解析</span></a></h3><h4 id="自动发现和注册策略" tabindex="-1"><a class="header-anchor" href="#自动发现和注册策略"><span>自动发现和注册策略</span></a></h4><p><strong>Q: 如何通过Spring自动发现和注册策略？</strong></p><p><strong>A: 我们使用Spring的自动装配机制：</strong></p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Component</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> MessageSenderFactory</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    </span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    @</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Autowired</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Map</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> MessageSender</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> senderMap</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    </span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> MessageSender</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> getSender</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> type</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        MessageSender</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> sender</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> senderMap</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">get</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(type </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;Sender&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (sender </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">==</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">            throw</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> IllegalArgumentException</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;不支持的消息类型: &quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> +</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> type);</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        }</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> sender;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Component</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;emailSender&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> EmailSender</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> implements</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> MessageSender</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 邮件发送实现</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Component</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;smsSender&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) </span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> SmsSender</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> implements</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> MessageSender</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 短信发送实现</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="策略动态切换" tabindex="-1"><a class="header-anchor" href="#策略动态切换"><span>策略动态切换</span></a></h4><p><strong>Q: 策略的动态切换如何实现？</strong></p><p><strong>A: 我们使用配置中心实现动态切换：</strong></p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Component</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> DynamicMessageSenderFactory</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    </span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    @</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Autowired</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> NacosConfigService</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> configService</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    </span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    @</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Autowired</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Map</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> MessageSender</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> senderMap</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    </span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> MessageSender</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> getSender</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> type</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 从配置中心获取策略配置</span></span>\n<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        String</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> config</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> configService</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getConfig</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;message.sender.&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> +</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> type, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;DEFAULT&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">5000</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        </span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 根据配置选择策略</span></span>\n<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        String</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> strategy</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> JSON</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">parseObject</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(config).</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getString</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;strategy&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>\n<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        MessageSender</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> sender</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> senderMap</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">get</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(strategy);</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        </span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (sender </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">==</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">            // 降级到默认策略</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">            sender </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> senderMap</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">get</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;defaultSender&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        }</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        </span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> sender;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="策略配置热更新" tabindex="-1"><a class="header-anchor" href="#策略配置热更新"><span>策略配置热更新</span></a></h4><p><strong>Q: 策略的配置热更新如何做？</strong></p><p><strong>A: 我们使用Nacos配置中心实现热更新：</strong></p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Component</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> MessageSenderConfigListener</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    </span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    @</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">NacosConfigListener</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">dataId</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;message.sender.config&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> groupId</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;DEFAULT_GROUP&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> onMessage</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> newContent</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 解析新配置</span></span>\n<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        MessageSenderConfig</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> config</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> JSON</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">parseObject</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(newContent, </span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">MessageSenderConfig</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">class</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        </span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 更新策略配置</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">        updateStrategyConfig</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(config);</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        </span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 记录配置变更日志</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        log</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">info</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;消息发送策略配置已更新: {}&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, config);</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    </span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> updateStrategyConfig</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">MessageSenderConfig</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> config</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 更新策略映射关系</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 更新重试策略</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 更新限流配置</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_6-性能指标和监控数据" tabindex="-1"><a class="header-anchor" href="#_6-性能指标和监控数据"><span>6. 性能指标和监控数据</span></a></h3><h4 id="系统性能指标" tabindex="-1"><a class="header-anchor" href="#系统性能指标"><span>系统性能指标</span></a></h4><p><strong>京东项目性能数据：</strong></p><ul><li>系统响应时间：平均200ms，95%请求 &lt; 500ms</li><li>并发处理能力：支持1000并发用户</li><li>任务调度延迟：&lt; 100ms</li><li>系统可用性：99.9%</li></ul><p><strong>招行项目性能数据：</strong></p><ul><li>数据处理速度：10万行数据处理时间 &lt; 10分钟</li><li>内存使用：峰值内存使用 &lt; 8GB</li><li>并发处理：支持20个并发任务</li><li>缓存命中率：&gt; 95%</li></ul><h4 id="监控和告警" tabindex="-1"><a class="header-anchor" href="#监控和告警"><span>监控和告警</span></a></h4><p><strong>监控指标：</strong></p><ul><li>系统资源：CPU、内存、磁盘、网络</li><li>应用性能：响应时间、吞吐量、错误率</li><li>业务指标：任务执行成功率、处理时间、数据质量</li></ul><p><strong>告警策略：</strong></p><ul><li>CPU使用率 &gt; 80%：警告</li><li>内存使用率 &gt; 85%：警告</li><li>响应时间 &gt; 2秒：警告</li><li>错误率 &gt; 1%：严重告警</li></ul><h3 id="_7-边界情况和异常处理" tabindex="-1"><a class="header-anchor" href="#_7-边界情况和异常处理"><span>7. 边界情况和异常处理</span></a></h3><h4 id="极端场景处理" tabindex="-1"><a class="header-anchor" href="#极端场景处理"><span>极端场景处理</span></a></h4><p><strong>网络分区场景：</strong></p><ul><li>使用心跳检测识别网络分区</li><li>实现分区容忍的分布式算法</li><li>提供手动干预接口</li></ul><p><strong>服务雪崩场景：</strong></p><ul><li>实现熔断器模式</li><li>提供降级服务</li><li>使用限流保护</li></ul><p><strong>数据不一致场景：</strong></p><ul><li>定期数据一致性检查</li><li>提供数据修复工具</li><li>实现数据版本控制</li></ul><h4 id="降级和应急预案" tabindex="-1"><a class="header-anchor" href="#降级和应急预案"><span>降级和应急预案</span></a></h4><p><strong>系统降级策略：</strong></p><ul><li>功能降级：非核心功能可关闭</li><li>性能降级：降低并发处理能力</li><li>服务降级：使用缓存数据替代实时数据</li></ul><p><strong>应急处理流程：</strong></p><ul><li>问题识别：监控告警 + 日志分析</li><li>影响评估：业务影响范围和时间</li><li>应急处理：启用降级策略</li><li>问题修复：根本原因分析和修复</li><li>恢复验证：功能验证和性能测试</li></ul><p>通过以上详细的解决方案，你可以更好地应对面试官的深度追问，展示你的技术深度和解决问题的能力。</p>',252)]))}]]),t=JSON.parse('{"path":"/zh/posts/review/%E5%A4%8D%E4%B9%A0.html","title":"复习","lang":"zh-CN","frontmatter":{"icon":"pen-to-square","date":"2025-07-13T00:00:00.000Z","category":["Learning Records"],"tag":["Review"],"description":"复习 京东项目 - 分布式调度引擎 1. 架构设计相关问题 Q1: 项目中碰到了哪些困难？架构层面和开发层面？ 架构层面 高可用架构设计困难 问题：如何保证系统的高可用性 挑战：需要设计无单点故障的架构 解决方案： 应用层：Spring Boot集群部署（3个实例），Nginx轮询分发请求到应用层 调度器：XXL-JOB调度中心（1个+热备），XXL-...","head":[["meta",{"property":"og:url","content":"https://crc011220.github.io/zh/posts/review/%E5%A4%8D%E4%B9%A0.html"}],["meta",{"property":"og:site_name","content":"Ruochen Chen"}],["meta",{"property":"og:title","content":"复习"}],["meta",{"property":"og:description","content":"复习 京东项目 - 分布式调度引擎 1. 架构设计相关问题 Q1: 项目中碰到了哪些困难？架构层面和开发层面？ 架构层面 高可用架构设计困难 问题：如何保证系统的高可用性 挑战：需要设计无单点故障的架构 解决方案： 应用层：Spring Boot集群部署（3个实例），Nginx轮询分发请求到应用层 调度器：XXL-JOB调度中心（1个+热备），XXL-..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-14T09:26:52.000Z"}],["meta",{"property":"article:tag","content":"Review"}],["meta",{"property":"article:published_time","content":"2025-07-13T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-14T09:26:52.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"复习\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-07-13T00:00:00.000Z\\",\\"dateModified\\":\\"2025-08-14T09:26:52.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Ruochen Chen\\"}]}"]]},"headers":[{"level":2,"title":"京东项目 - 分布式调度引擎","slug":"京东项目-分布式调度引擎","link":"#京东项目-分布式调度引擎","children":[{"level":3,"title":"1. 架构设计相关问题","slug":"_1-架构设计相关问题","link":"#_1-架构设计相关问题","children":[]}]},{"level":2,"title":"招行项目 - Excel处理框架","slug":"招行项目-excel处理框架","link":"#招行项目-excel处理框架","children":[{"level":3,"title":"1. 架构设计相关问题","slug":"_1-架构设计相关问题-1","link":"#_1-架构设计相关问题-1","children":[]},{"level":3,"title":"2. 具体业务逻辑是什么？","slug":"_2-具体业务逻辑是什么","link":"#_2-具体业务逻辑是什么","children":[]}]},{"level":2,"title":"招行项目 - 消息通知服务","slug":"招行项目-消息通知服务","link":"#招行项目-消息通知服务","children":[{"level":3,"title":"项目背景","slug":"项目背景","link":"#项目背景","children":[]},{"level":3,"title":"❌ 碰到的主要困难","slug":"❌-碰到的主要困难","link":"#❌-碰到的主要困难","children":[]},{"level":3,"title":"🛠️ 解决方案：策略+工厂模式","slug":"🛠️-解决方案-策略-工厂模式","link":"#🛠️-解决方案-策略-工厂模式","children":[]},{"level":3,"title":"具体实现优势","slug":"具体实现优势","link":"#具体实现优势","children":[]}]},{"level":2,"title":"大学项目 - 云平台数据分析","slug":"大学项目-云平台数据分析","link":"#大学项目-云平台数据分析","children":[{"level":3,"title":"1. ES如何优化的","slug":"_1-es如何优化的","link":"#_1-es如何优化的","children":[]}]},{"level":2,"title":"加密货币交易平台","slug":"加密货币交易平台","link":"#加密货币交易平台","children":[{"level":3,"title":"1. 困难和解决","slug":"_1-困难和解决","link":"#_1-困难和解决","children":[]}]},{"level":2,"title":"🚨 面试官挖坑应对方案","slug":"🚨-面试官挖坑应对方案","link":"#🚨-面试官挖坑应对方案","children":[{"level":3,"title":"1. 分布式一致性方案深度解析","slug":"_1-分布式一致性方案深度解析","link":"#_1-分布式一致性方案深度解析","children":[]},{"level":3,"title":"2. ProxySQL故障切换深度解析","slug":"_2-proxysql故障切换深度解析","link":"#_2-proxysql故障切换深度解析","children":[]},{"level":3,"title":"3. Redis双写一致性深度解析","slug":"_3-redis双写一致性深度解析","link":"#_3-redis双写一致性深度解析","children":[]},{"level":3,"title":"4. 线程池异步分片深度解析","slug":"_4-线程池异步分片深度解析","link":"#_4-线程池异步分片深度解析","children":[]},{"level":3,"title":"5. 策略模式Spring实现深度解析","slug":"_5-策略模式spring实现深度解析","link":"#_5-策略模式spring实现深度解析","children":[]},{"level":3,"title":"6. 性能指标和监控数据","slug":"_6-性能指标和监控数据","link":"#_6-性能指标和监控数据","children":[]},{"level":3,"title":"7. 边界情况和异常处理","slug":"_7-边界情况和异常处理","link":"#_7-边界情况和异常处理","children":[]}]}],"git":{"createdTime":1755071191000,"updatedTime":1755163612000,"contributors":[{"name":"Ruochen Chen","email":"ruocchen1220@gmail.com","commits":3}]},"readingTime":{"minutes":32.26,"words":9679},"filePathRelative":"zh/posts/review/复习.md","localizedDate":"2025年7月13日","excerpt":"\\n<h2>京东项目 - 分布式调度引擎</h2>\\n<h3>1. 架构设计相关问题</h3>\\n<p><strong>Q1: 项目中碰到了哪些困难？架构层面和开发层面？</strong></p>\\n<h4>架构层面</h4>\\n<ol>\\n<li>高可用架构设计困难</li>\\n</ol>\\n<ul>\\n<li>问题：如何保证系统的高可用性</li>\\n<li>挑战：需要设计无单点故障的架构</li>\\n<li>解决方案：\\n<ul>\\n<li>应用层：Spring Boot集群部署（3个实例），Nginx轮询分发请求到应用层</li>\\n<li>调度器：XXL-JOB调度中心（1个+热备），XXL-JOB执行器（3个）</li>\\n<li>数据库层：MySQL主从复制（1主2从），ProxySQL读写分离（1个，待优化）</li>\\n<li>缓存层：Redis哨兵模式（3哨兵+1主2从），Redis缓存热点数据</li>\\n<li>监控：集成Spring Boot Actuator（监控 CPU、JVM、MySQL、Redis状态）</li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true}')},6262:(i,s)=>{s.A=(i,s)=>{const l=i.__vccOpts||i;for(const[i,a]of s)l[i]=a;return l}}}]);