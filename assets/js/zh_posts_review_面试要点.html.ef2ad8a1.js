"use strict";(self.webpackChunkpersonalweb=self.webpackChunkpersonalweb||[]).push([[2071],{1771:(t,d,r)=>{r.r(d),r.d(d,{comp:()=>n,data:()=>s});var e=r(641);const a=r.p+"assets/img/JVM.3c1ca3ce.png",l={},n=(0,r(6262).A)(l,[["render",function(t,d){return(0,e.uX)(),(0,e.CE)("div",null,d[0]||(d[0]=[(0,e.Fv)('<h1 id="面试要点" tabindex="-1"><a class="header-anchor" href="#面试要点"><span>面试要点</span></a></h1><h2 id="java基础" tabindex="-1"><a class="header-anchor" href="#java基础"><span>Java基础</span></a></h2><h3 id="_1-equals-和-的区别-如何正确重写-equals-和-hashcode-方法-为什么需要同时重写" tabindex="-1"><a class="header-anchor" href="#_1-equals-和-的区别-如何正确重写-equals-和-hashcode-方法-为什么需要同时重写"><span>1. equals() 和 == 的区别？如何正确重写 equals() 和 hashCode() 方法？为什么需要同时重写？</span></a></h3><h4 id="和-equals-的区别" tabindex="-1"><a class="header-anchor" href="#和-equals-的区别"><span>== 和 equals() 的区别</span></a></h4><ul><li><strong>== 操作符</strong>：对于基本数据类型比较值，对于引用类型比较内存地址</li><li><strong>equals() 方法</strong>：Object类默认实现是比较引用，String等类重写后比较内容</li></ul><h4 id="正确重写的五个原则" tabindex="-1"><a class="header-anchor" href="#正确重写的五个原则"><span>正确重写的五个原则</span></a></h4><ol><li><strong>自反性</strong>：x.equals(x) 必须返回 true</li><li><strong>对称性</strong>：x.equals(y) 和 y.equals(x) 结果相同</li><li><strong>传递性</strong>：如果 x.equals(y) 且 y.equals(z)，则 x.equals(z)</li><li><strong>一致性</strong>：多次调用结果一致</li><li><strong>非空性</strong>：x.equals(null) 返回 false</li></ol><h4 id="为什么要同时重写" tabindex="-1"><a class="header-anchor" href="#为什么要同时重写"><span>为什么要同时重写？</span></a></h4><p>因为HashMap/HashSet的工作机制：先用hashCode()确定存储位置，再用equals()处理哈希冲突。如果不同时重写会导致相等对象无法在HashMap中正确查找。Java约定：如果两个对象equals()返回true，它们的hashCode()必须相同。</p><ul><li>equals 方法判断两个对象是相等的，那这两个对象的 hashCode 值也要相等。</li><li>两个对象有相同的 hashCode 值，他们也不一定是相等的（哈希碰撞）。</li></ul><table><thead><tr><th>问题</th><th>结论</th></tr></thead><tbody><tr><td><code>equals()</code> 比较什么？</td><td>值是否相等</td></tr><tr><td><code>hashCode()</code> 用来干嘛？</td><td>快速查找桶</td></tr><tr><td>为什么要同时重写？</td><td>保证集合类正常工作，避免逻辑错误</td></tr><tr><td>不重写会怎样？</td><td>数据重复、查找失败、逻辑异常</td></tr></tbody></table><h3 id="_2-接口和抽象类的区别-何时用接口-何时用抽象类" tabindex="-1"><a class="header-anchor" href="#_2-接口和抽象类的区别-何时用接口-何时用抽象类"><span>2. 接口和抽象类的区别？何时用接口？何时用抽象类？</span></a></h3><h4 id="主要区别" tabindex="-1"><a class="header-anchor" href="#主要区别"><span>主要区别</span></a></h4><ul><li><strong>继承关系</strong>：接口支持多实现，抽象类只能单继承</li><li><strong>方法</strong>：接口Java8前只有抽象方法，抽象类可以有具体实现</li><li><strong>成员变量</strong>：接口只能有常量，抽象类可以有各种成员变量</li><li><strong>构造方法</strong>：接口不能有，抽象类可以有</li></ul><h4 id="使用场景" tabindex="-1"><a class="header-anchor" href="#使用场景"><span>使用场景</span></a></h4><ul><li><strong>接口</strong>：定义契约规范、实现多重&quot;继承&quot;、强调&quot;能做什么&quot;（can-do关系）</li><li><strong>抽象类</strong>：代码复用、提供部分实现、强调&quot;是什么&quot;（is-a关系）、需要有状态</li></ul><table><thead><tr><th>特性</th><th>接口</th><th>抽象类</th></tr></thead><tbody><tr><td>继承关系</td><td>可实现多个</td><td>只能继承一个</td></tr><tr><td>方法实现</td><td>抽象方法+默认方法（Java8+）</td><td>抽象方法+具体方法</td></tr><tr><td>成员变量</td><td>只能有常量</td><td>可以有各种类型变量</td></tr><tr><td>构造方法</td><td>不能有</td><td>可以有</td></tr><tr><td>关系类型</td><td>can-do（能做什么）</td><td>is-a（是什么）</td></tr><tr><td>使用场景</td><td>定义规范、多重继承</td><td>代码复用、部分实现、有状态</td></tr></tbody></table><h3 id="_3-string-vs-stringbuffer-vs-stringbuilder" tabindex="-1"><a class="header-anchor" href="#_3-string-vs-stringbuffer-vs-stringbuilder"><span>3. String vs StringBuffer vs StringBuilder？</span></a></h3><h4 id="特性对比" tabindex="-1"><a class="header-anchor" href="#特性对比"><span>特性对比</span></a></h4><ul><li><strong>String</strong>：不可变，线程安全，频繁操作性能差，会创建大量临时对象</li><li><strong>StringBuffer</strong>：可变，线程安全（synchronized），适合多线程环境</li><li><strong>StringBuilder</strong>：可变，线程不安全，单线程环境性能最佳</li></ul><h4 id="选择原则" tabindex="-1"><a class="header-anchor" href="#选择原则"><span>选择原则</span></a></h4><ul><li><strong>String</strong>：字符串很少改变的情况</li><li><strong>StringBuffer</strong>：多线程环境下的字符串频繁操作</li><li><strong>StringBuilder</strong>：单线程环境下的字符串频繁操作</li></ul><table><thead><tr><th>特性</th><th>String</th><th>StringBuffer</th><th>StringBuilder</th></tr></thead><tbody><tr><td>可变性</td><td>不可变</td><td>可变</td><td>可变</td></tr><tr><td>线程安全</td><td>安全（不可变）</td><td>安全（同步）</td><td>不安全</td></tr><tr><td>性能</td><td>频繁操作差</td><td>中等</td><td>最佳</td></tr><tr><td>内存使用</td><td>创建新对象</td><td>内部缓冲区</td><td>内部缓冲区</td></tr><tr><td>适用场景</td><td>少量操作</td><td>多线程字符串操作</td><td>单线程字符串操作</td></tr></tbody></table><h3 id="_4-自动装箱与拆箱原理及潜在问题" tabindex="-1"><a class="header-anchor" href="#_4-自动装箱与拆箱原理及潜在问题"><span>4. 自动装箱与拆箱原理及潜在问题</span></a></h3><h4 id="基本概念" tabindex="-1"><a class="header-anchor" href="#基本概念"><span>基本概念</span></a></h4><ul><li><strong>自动装箱</strong>：基本类型自动转换为包装类型（如int→Integer）</li><li><strong>自动拆箱</strong>：包装类型自动转换为基本类型</li><li><strong>实现原理</strong>：编译器自动插入valueOf()和xxxValue()方法调用</li></ul><h4 id="四大潜在问题" tabindex="-1"><a class="header-anchor" href="#四大潜在问题"><span>四大潜在问题</span></a></h4><ol><li><strong>缓存范围问题</strong>：-128到127范围内的Integer对象会被缓存复用，超出范围会创建新对象</li><li><strong>性能问题</strong>：频繁装箱拆箱会影响性能，特别是在循环中</li><li><strong>NullPointerException</strong>：null的包装类型拆箱时会抛NPE</li><li><strong>三目运算符陷阱</strong>：类型不一致时编译器会自动拆箱，可能导致NPE</li></ol><h4 id="最佳实践" tabindex="-1"><a class="header-anchor" href="#最佳实践"><span>最佳实践</span></a></h4><p>尽量使用基本类型、比较包装类型用equals()、避免循环中频繁装箱拆箱、注意缓存范围、小心null值拆箱</p><table><thead><tr><th>问题类型</th><th>具体表现</th><th>解决方案</th></tr></thead><tbody><tr><td>缓存范围问题</td><td>-128~127外用==比较结果为false</td><td>用equals()比较</td></tr><tr><td>性能问题</td><td>循环中频繁装箱拆箱</td><td>使用基本类型</td></tr><tr><td>NPE问题</td><td>null包装类型拆箱时抛异常</td><td>判空或使用基本类型</td></tr><tr><td>三目运算符陷阱</td><td>类型不一致导致自动拆箱NPE</td><td>保证两边类型一致</td></tr><tr><td>最佳实践</td><td>什么时候用包装类型？</td><td>需要null值或泛型时才用</td></tr></tbody></table><h3 id="_5-bio、nio、aio的区别" tabindex="-1"><a class="header-anchor" href="#_5-bio、nio、aio的区别"><span>5. BIO、NIO、AIO的区别？</span></a></h3><h4 id="i-o模型核心概念" tabindex="-1"><a class="header-anchor" href="#i-o模型核心概念"><span>I/O模型核心概念</span></a></h4><p><strong>BIO、NIO、AIO三种I/O模型对比：</strong></p><table><thead><tr><th>特性</th><th>BIO（同步阻塞）</th><th>NIO（同步非阻塞）</th><th>AIO（异步非阻塞）</th></tr></thead><tbody><tr><td>全称</td><td>Blocking I/O</td><td>Non-blocking I/O</td><td>Asynchronous I/O</td></tr><tr><td>阻塞性</td><td>阻塞</td><td>非阻塞</td><td>异步</td></tr><tr><td>同步性</td><td>同步</td><td>同步</td><td>异步</td></tr><tr><td>线程模型</td><td>一线程一连接</td><td>一线程处理多连接</td><td>一线程处理多连接</td></tr><tr><td>API复杂度</td><td>简单</td><td>复杂</td><td>复杂</td></tr><tr><td>适用场景</td><td>连接数少、并发度低</td><td>连接数多、并发度高</td><td>连接数多、并发度高</td></tr></tbody></table><h4 id="工作原理对比" tabindex="-1"><a class="header-anchor" href="#工作原理对比"><span>工作原理对比</span></a></h4><table><thead><tr><th>I/O模型</th><th>工作原理</th><th>线程利用率</th><th>内存消耗</th><th>CPU利用率</th></tr></thead><tbody><tr><td>BIO</td><td>每个连接创建一个线程，线程阻塞等待I/O完成</td><td>低</td><td>高</td><td>低</td></tr><tr><td>NIO</td><td>一个线程通过Selector轮询多个Channel</td><td>高</td><td>中</td><td>高</td></tr><tr><td>AIO</td><td>操作系统完成I/O后通知应用程序</td><td>高</td><td>低</td><td>中</td></tr></tbody></table><h4 id="性能特性对比" tabindex="-1"><a class="header-anchor" href="#性能特性对比"><span>性能特性对比</span></a></h4><table><thead><tr><th>性能指标</th><th>BIO</th><th>NIO</th><th>AIO</th></tr></thead><tbody><tr><td>吞吐量</td><td>低（受线程数限制）</td><td>高</td><td>高</td></tr><tr><td>延迟</td><td>中等</td><td>低</td><td>最低</td></tr><tr><td>内存占用</td><td>高（大量线程栈）</td><td>中等</td><td>低</td></tr><tr><td>CPU消耗</td><td>低（大量阻塞等待）</td><td>中等</td><td>低</td></tr><tr><td>可扩展性</td><td>差</td><td>好</td><td>最好</td></tr></tbody></table><h4 id="编程模型对比" tabindex="-1"><a class="header-anchor" href="#编程模型对比"><span>编程模型对比</span></a></h4><table><thead><tr><th>模型</th><th>编程模型</th><th>事件处理</th><th>错误处理</th><th>学习成本</th></tr></thead><tbody><tr><td>BIO</td><td>顺序编程，符合人类思维</td><td>同步处理</td><td>try-catch</td><td>低</td></tr><tr><td>NIO</td><td>事件驱动，需要状态机管理</td><td>事件循环</td><td>复杂</td><td>高</td></tr><tr><td>AIO</td><td>回调驱动，异步编程</td><td>回调函数</td><td>回调地狱</td><td>高</td></tr></tbody></table><h4 id="实际应用场景选择" tabindex="-1"><a class="header-anchor" href="#实际应用场景选择"><span>实际应用场景选择</span></a></h4><table><thead><tr><th>应用场景</th><th>推荐模型</th><th>选择理由</th><th>注意事项</th></tr></thead><tbody><tr><td>Web服务器</td><td>NIO</td><td>大量连接，请求处理时间短</td><td>需要处理粘包拆包问题</td></tr><tr><td>文件服务器</td><td>BIO</td><td>文件I/O多为顺序操作，编程简单</td><td>控制并发连接数</td></tr><tr><td>即时通讯</td><td>NIO</td><td>长连接，需要高并发</td><td>心跳检测，连接管理</td></tr><tr><td>游戏服务器</td><td>AIO</td><td>实时性要求高，性能敏感</td><td>回调处理复杂</td></tr><tr><td>数据库连接池</td><td>BIO</td><td>连接数可控，操作多为短连接</td><td>连接复用</td></tr><tr><td>大数据传输</td><td>AIO</td><td>大文件传输，异步处理效率高</td><td>需要处理传输中断</td></tr></tbody></table><h3 id="_6-select、poll、epoll的区别" tabindex="-1"><a class="header-anchor" href="#_6-select、poll、epoll的区别"><span>6. Select、Poll、Epoll的区别？</span></a></h3><p>IO多路复用是指通过一个线程/进程监控多个IO文件描述符，当某个IO准备好（可读/可写）时，通知应用程序处理该IO，从而实现“单线程高效管理多IO”，避免传统阻塞IO的线程浪费。</p><p><strong>I/O多路复用机制对比：</strong></p><table><thead><tr><th>特性</th><th>Select</th><th>Poll</th><th>Epoll</th></tr></thead><tbody><tr><td>操作系统支持</td><td>几乎所有Unix/Linux</td><td>Unix/Linux</td><td>仅Linux</td></tr><tr><td>文件描述符限制</td><td>有限制（通常1024）</td><td>无硬性限制</td><td>无限制</td></tr><tr><td>数据结构</td><td>bitmap位图</td><td>链表</td><td>红黑树+双链表</td></tr><tr><td>时间复杂度</td><td>O(n)</td><td>O(n)</td><td>O(1)</td></tr><tr><td>内存拷贝</td><td>每次调用都要拷贝</td><td>每次调用都要拷贝</td><td>使用mmap减少拷贝</td></tr><tr><td>工作模式</td><td>水平触发</td><td>水平触发</td><td>水平触发+边缘触发</td></tr></tbody></table><p><strong>工作原理对比：</strong></p><table><thead><tr><th>机制</th><th>工作流程</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>Select</td><td>轮询所有fd，返回就绪的fd集合</td><td>跨平台兼容性好</td><td>性能差、fd数量限制</td></tr><tr><td>Poll</td><td>与select类似，但使用链表存储fd</td><td>没有fd数量限制</td><td>性能仍然较差</td></tr><tr><td>Epoll</td><td>基于事件通知，只返回活跃的fd</td><td>高性能、支持大量连接</td><td>仅支持Linux</td></tr></tbody></table><ul><li>fd File Descriptor（文件描述符）是操作系统对“打开资源”的标识，IO 多路复用技术（如 epoll）让我们能高效管理多个 fd，从而构建高并发服务器。</li><li>select/poll：每次调用都要把所有 fd 从用户态拷到内核态，然后内核从头到尾扫描一遍，看哪些 fd 就绪。复杂度是 O(n)，n 是 fd 数量。</li><li>epoll： <ul><li>注册时：把 fd 放入内核的 红黑树（管理所有监听的 fd），只做一次。</li><li>内核维护一个 就绪链表（ready list），当某个 fd 就绪时，内核驱动会直接把这个 fd 加入就绪链表。</li><li>epoll_wait 直接返回链表里的就绪 fd，不需要扫描所有 fd。</li></ul></li></ul><h3 id="_7-stream流的特性" tabindex="-1"><a class="header-anchor" href="#_7-stream流的特性"><span>7. Stream流的特性？</span></a></h3><ul><li>函数式编程：支持lambda表达式和函数式接口</li><li>惰性求值：中间操作不立即执行，终端操作才执行</li><li>并行处理：支持并行流提高性能</li><li>不可变性：不修改原数据，返回新流</li></ul><h3 id="_8-java异常" tabindex="-1"><a class="header-anchor" href="#_8-java异常"><span>8. Java异常？</span></a></h3><table><thead><tr><th>特性</th><th>Checked Exception</th><th>RuntimeException</th><th>Error</th></tr></thead><tbody><tr><td>编译期检查</td><td>✅ 必须显式处理</td><td>❌ 无需强制处理</td><td>❌ 无需处理</td></tr><tr><td>代表的问题类型</td><td>业务流程问题</td><td>程序逻辑错误</td><td>系统级、JVM错误</td></tr><tr><td>是否可恢复</td><td>✅ 一般可恢复</td><td>⚠ 逻辑修复可避免</td><td>❌ 不可恢复</td></tr><tr><td>常见示例</td><td>IOException, SQLException</td><td>NullPointerException</td><td>OutOfMemoryError</td></tr></tbody></table><h3 id="_9-阻塞队列" tabindex="-1"><a class="header-anchor" href="#_9-阻塞队列"><span>9. 阻塞队列？</span></a></h3><ul><li>在队列为空时取数据会阻塞线程，队列满时插入数据会阻塞线程。它非常适合 生产者-消费者模式。</li></ul><table><thead><tr><th>类</th><th>队列类型</th><th>特点</th><th>典型应用</th></tr></thead><tbody><tr><td><code>ArrayBlockingQueue</code></td><td>有界数组</td><td>插入/取出固定顺序（FIFO）</td><td>生产者-消费者、线程池任务队列</td></tr><tr><td><code>LinkedBlockingQueue</code></td><td>链表</td><td>可选有界/无界，吞吐量高</td><td>高并发场景的线程池队列</td></tr><tr><td><code>PriorityBlockingQueue</code></td><td>优先级队列</td><td>不保证 FIFO，而是按元素优先级</td><td>任务调度、定时任务</td></tr><tr><td><code>SynchronousQueue</code></td><td>同步队列</td><td>每次插入必须有线程立即取走</td><td>线程池扩容策略（如 <code>CachedThreadPool</code>）</td></tr><tr><td><code>DelayQueue</code></td><td>延迟队列</td><td>元素在到期前无法取出</td><td>延迟任务、定时器</td></tr></tbody></table><h3 id="_10-泛型和类型擦除" tabindex="-1"><a class="header-anchor" href="#_10-泛型和类型擦除"><span>10. 泛型和类型擦除？</span></a></h3><ul><li><p>Java 泛型的作用是提供 编译期的类型检查 和 代码复用，比如 <code>List&lt;String&gt;</code> 只能放字符串，避免了运行时的类型错误。</p></li><li><p>Java 泛型的实现机制是 类型擦除：编译后泛型参数会被擦除成 Object 或上界类型，所以在运行时 <code>List&lt;String&gt;</code> 和 <code>List&lt;Integer&gt;</code> 是一样的。</p></li><li><p>这样做的原因是 向下兼容（兼容老代码），但是带来了限制，比如不能用泛型创建数组、不能获取运行时的泛型类型。</p></li></ul><h2 id="集合" tabindex="-1"><a class="header-anchor" href="#集合"><span>集合</span></a></h2><h3 id="_1-hashmap-的实现原理-jdk-1-7和1-8的区别-hash-方法的作用-如何处理哈希冲突" tabindex="-1"><a class="header-anchor" href="#_1-hashmap-的实现原理-jdk-1-7和1-8的区别-hash-方法的作用-如何处理哈希冲突"><span>1. HashMap 的实现原理？JDK 1.7和1.8的区别？hash()方法的作用？如何处理哈希冲突？</span></a></h3><h4 id="实现原理" tabindex="-1"><a class="header-anchor" href="#实现原理"><span>实现原理</span></a></h4><p>HashMap基于数组+链表/红黑树的数据结构，通过hash算法将key映射到数组索引位置。</p><h4 id="jdk-1-7-vs-1-8-主要区别" tabindex="-1"><a class="header-anchor" href="#jdk-1-7-vs-1-8-主要区别"><span>JDK 1.7 vs 1.8 主要区别</span></a></h4><ul><li><strong>数据结构</strong>：1.7是数组+链表，1.8是数组+链表+红黑树</li><li><strong>插入方式</strong>：1.7头插法（并发环境可能死循环），1.8尾插法 <ul><li>头插法会反转链表，多个线程交叉修改容易把 next 指针指回前面节点 → 形成环。尾插法保持链表顺序不变，即使并发也只会有数据覆盖，不会出现环。</li></ul></li><li><strong>扩容时机</strong>：1.7先扩容再插入，1.8先插入再扩容</li><li><strong>hash算法</strong>：1.8优化了hash算法，减少碰撞</li></ul><h4 id="hash-方法作用" tabindex="-1"><a class="header-anchor" href="#hash-方法作用"><span>hash()方法作用</span></a></h4><p>将key的hashCode进行二次hash，让hash值更均匀分布，减少哈希冲突。</p><h4 id="哈希冲突处理" tabindex="-1"><a class="header-anchor" href="#哈希冲突处理"><span>哈希冲突处理</span></a></h4><ol><li><strong>链表法</strong>：相同hash值的元素用链表连接</li><li><strong>红黑树优化</strong>：当链表长度≥8且数组长度≥64时，链表转红黑树。当红黑树节点数小于6时，转回链表</li><li><strong>扩容机制</strong>：负载因子超过0.75时，数组容量翻倍</li></ol><table><thead><tr><th>版本对比</th><th>JDK 1.7</th><th>JDK 1.8</th></tr></thead><tbody><tr><td>数据结构</td><td>数组+链表</td><td>数组+链表+红黑树</td></tr><tr><td>插入方式</td><td>头插法</td><td>尾插法</td></tr><tr><td>链表转树</td><td>无</td><td>链表长度≥8且数组长度≥64时</td></tr><tr><td>扩容时机</td><td>先扩容再插入</td><td>先插入再扩容</td></tr><tr><td>并发问题</td><td>可能死循环</td><td>避免了死循环</td></tr></tbody></table><h4 id="put方法" tabindex="-1"><a class="header-anchor" href="#put方法"><span>Put方法</span></a></h4><ol><li>判断键值对数组table是否为空或为null，否则执行resize()进行扩容（初始化）</li><li>根据键值key计算hash值得到数组索引</li><li>判断table[i]==null，条件成立，直接新建节点添加</li><li>如果table[i]==null ,不成立</li><li>4.1 判断table[i]的首个元素是否和key一样，如果相同直接覆盖value</li><li>4.2 判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对</li><li>4.3 遍历table[i]，链表的尾部插入数据，然后判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操 作，遍历过程中若发现key已经存在直接覆盖value</li><li>插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold（数组长度*0.75），如果超过，进行扩容。</li></ol><h4 id="为何hashmap的数组长度一定是2的次幂" tabindex="-1"><a class="header-anchor" href="#为何hashmap的数组长度一定是2的次幂"><span>为何HashMap的数组长度一定是2的次幂？</span></a></h4><ol><li>计算索引时效率更高：如果是 2 的 n 次幂可以使用位与运算代替取模：(n-1) &amp; hash = hash % n 当n为2的次幂时</li><li>扩容时重新计算索引效率更高： hash &amp; oldCap == 0 的元素留在原来位置 ，否则新位置 = 旧位置 + oldCap</li></ol><h3 id="_2-concurrenthashmap-如何实现线程安全" tabindex="-1"><a class="header-anchor" href="#_2-concurrenthashmap-如何实现线程安全"><span>2. ConcurrentHashMap 如何实现线程安全？</span></a></h3><h4 id="jdk-1-7-分段锁机制" tabindex="-1"><a class="header-anchor" href="#jdk-1-7-分段锁机制"><span>JDK 1.7：分段锁机制</span></a></h4><ul><li><strong>Segment数组</strong>：将HashMap分成多个段，每个段有独立的锁（ReentrantLock）</li><li><strong>锁粒度</strong>：只锁需要操作的段，其他段可并发访问</li><li><strong>并发度</strong>：默认16个段，最多支持16个线程同时写入</li></ul><h4 id="jdk-1-8-cas-synchronized" tabindex="-1"><a class="header-anchor" href="#jdk-1-8-cas-synchronized"><span>JDK 1.8：CAS + synchronized</span></a></h4><ul><li><strong>取消Segment</strong>：直接在Node节点上加锁</li><li><strong>CAS操作</strong>：数组元素为空时用CAS插入</li><li><strong>synchronized</strong>：发生冲突时锁住链表/红黑树的头节点</li><li><strong>更细粒度</strong>：锁的是具体的hash桶，并发性能更好</li></ul><table><thead><tr><th>版本</th><th>JDK 1.7</th><th>JDK 1.8</th></tr></thead><tbody><tr><td>锁机制</td><td>分段锁（Segment）</td><td>CAS + synchronized</td></tr><tr><td>锁粒度</td><td>段级别</td><td>节点级别</td></tr><tr><td>并发度</td><td>最多16个写线程</td><td>理论上无限制</td></tr><tr><td>内存占用</td><td>Segment额外开销</td><td>更少的内存开销</td></tr><tr><td>性能</td><td>读写分离，性能较好</td><td>读写性能都更优</td></tr></tbody></table><h3 id="_3-arraylist-和-linkedlist-的底层实现、时间复杂度" tabindex="-1"><a class="header-anchor" href="#_3-arraylist-和-linkedlist-的底层实现、时间复杂度"><span>3. ArrayList 和 LinkedList 的底层实现、时间复杂度？</span></a></h3><h4 id="底层实现" tabindex="-1"><a class="header-anchor" href="#底层实现"><span>底层实现</span></a></h4><ul><li><strong>ArrayList</strong>：动态数组，连续内存空间存储</li><li><strong>LinkedList</strong>：双向链表，节点包含data、prev、next指针</li></ul><h4 id="时间复杂度对比" tabindex="-1"><a class="header-anchor" href="#时间复杂度对比"><span>时间复杂度对比</span></a></h4><table><thead><tr><th>操作</th><th>ArrayList</th><th>LinkedList</th></tr></thead><tbody><tr><td>随机访问</td><td>O(1)</td><td>O(n)</td></tr><tr><td>头部插入</td><td>O(n)</td><td>O(1)</td></tr><tr><td>尾部插入</td><td>O(1)</td><td>O(1)</td></tr><tr><td>中间插入</td><td>O(n)</td><td>O(1)*</td></tr><tr><td>头部删除</td><td>O(n)</td><td>O(1)</td></tr><tr><td>尾部删除</td><td>O(1)</td><td>O(1)</td></tr><tr><td>中间删除</td><td>O(n)</td><td>O(1)*</td></tr></tbody></table><p>*注：LinkedList中间插入/删除的O(1)是指已知节点位置的情况，查找节点仍需O(n)</p><h4 id="使用场景-1" tabindex="-1"><a class="header-anchor" href="#使用场景-1"><span>使用场景</span></a></h4><ul><li><strong>ArrayList</strong>：频繁随机访问、少量插入删除</li><li><strong>LinkedList</strong>：频繁插入删除、顺序访问</li></ul><h3 id="_4-iterator-和-listiterator-的区别-fail-fast-和-fail-safe-机制" tabindex="-1"><a class="header-anchor" href="#_4-iterator-和-listiterator-的区别-fail-fast-和-fail-safe-机制"><span>4. Iterator 和 ListIterator 的区别？fail-fast 和 fail-safe 机制？</span></a></h3><h4 id="iterator-vs-listiterator" tabindex="-1"><a class="header-anchor" href="#iterator-vs-listiterator"><span>Iterator vs ListIterator</span></a></h4><table><thead><tr><th>特性</th><th>Iterator</th><th>ListIterator</th></tr></thead><tbody><tr><td>适用范围</td><td>所有Collection</td><td>只适用于List</td></tr><tr><td>遍历方向</td><td>单向（向前）</td><td>双向（前进+后退）</td></tr><tr><td>操作能力</td><td>只能删除</td><td>增删改查都支持</td></tr><tr><td>索引访问</td><td>不支持</td><td>支持获取当前索引</td></tr><tr><td>起始位置</td><td>只能从头开始</td><td>可以从任意位置开始</td></tr></tbody></table><h4 id="fail-fast-vs-fail-safe" tabindex="-1"><a class="header-anchor" href="#fail-fast-vs-fail-safe"><span>fail-fast vs fail-safe</span></a></h4><p><strong>fail-fast（快速失败）：</strong></p><ul><li><strong>机制</strong>：检测到并发修改立即抛ConcurrentModificationException</li><li><strong>实现</strong>：通过modCount计数器检测结构性修改</li><li><strong>代表</strong>：ArrayList、HashMap的迭代器</li></ul><p><strong>fail-safe（安全失败）：</strong></p><ul><li><strong>机制</strong>：在副本上迭代，不会抛异常但可能读到过期数据</li><li><strong>实现</strong>：复制一份数据进行迭代</li><li><strong>代表</strong>：CopyOnWriteArrayList、ConcurrentHashMap</li></ul><table><thead><tr><th>机制</th><th>fail-fast</th><th>fail-safe</th></tr></thead><tbody><tr><td>异常处理</td><td>立即抛异常</td><td>不抛异常</td></tr><tr><td>数据一致性</td><td>强一致性</td><td>可能读到过期数据</td></tr><tr><td>性能开销</td><td>低</td><td>高（需要复制）</td></tr><tr><td>内存使用</td><td>少</td><td>多（额外副本）</td></tr><tr><td>适用场景</td><td>单线程环境</td><td>多线程环境</td></tr></tbody></table><h3 id="_5-如何保证集合的线程安全" tabindex="-1"><a class="header-anchor" href="#_5-如何保证集合的线程安全"><span>5. 如何保证集合的线程安全？</span></a></h3><h4 id="五种解决方案" tabindex="-1"><a class="header-anchor" href="#五种解决方案"><span>五种解决方案</span></a></h4><p><strong>1. Collections.synchronizedXXX()</strong></p><ul><li><strong>原理</strong>：为每个方法加synchronized关键字</li><li><strong>缺点</strong>：性能较差，复合操作仍不安全</li></ul><p><strong>2. Vector、Hashtable</strong></p><ul><li><strong>原理</strong>：方法级别的synchronized</li><li><strong>缺点</strong>：过时的重量级同步，性能差</li></ul><p><strong>3. CopyOnWriteArrayList</strong></p><ul><li><strong>原理</strong>：写时复制，读写分离。内部维护一个数组，每次写操作（添加、删除、修改）都会复制一个新的数组，然后在新数组上操作，写完后替换原数组引用</li><li><strong>适用</strong>：读多写少的场景</li></ul><p><strong>4. ConcurrentHashMap</strong></p><ul><li><strong>原理</strong>：分段锁/CAS+synchronized</li><li><strong>优点</strong>：高并发性能好</li></ul><p><strong>5. 外部加锁</strong></p><ul><li><strong>原理</strong>：使用外部锁控制访问</li><li><strong>灵活性</strong>：可控制锁的粒度</li></ul><table><thead><tr><th>方案</th><th>性能</th><th>适用场景</th><th>缺点</th></tr></thead><tbody><tr><td>Collections.synchronized</td><td>差</td><td>简单场景</td><td>复合操作不安全</td></tr><tr><td>Vector/Hashtable</td><td>差</td><td>遗留代码</td><td>重量级同步</td></tr><tr><td>CopyOnWriteArrayList</td><td>读快</td><td>读多写少</td><td>写操作开销大</td></tr><tr><td>ConcurrentHashMap</td><td>优</td><td>高并发Map操作</td><td>只适用于Map</td></tr><tr><td>外部加锁</td><td>中</td><td>复杂业务逻辑</td><td>需要小心死锁</td></tr></tbody></table><h3 id="_6-comparable-和-comparator-接口的区别" tabindex="-1"><a class="header-anchor" href="#_6-comparable-和-comparator-接口的区别"><span>6. Comparable 和 Comparator 接口的区别？</span></a></h3><h4 id="核心区别" tabindex="-1"><a class="header-anchor" href="#核心区别"><span>核心区别</span></a></h4><ul><li><strong>Comparable</strong>：内部比较器，对象自己定义排序规则</li><li><strong>Comparator</strong>：外部比较器，第三方定义排序规则</li></ul><h4 id="详细对比" tabindex="-1"><a class="header-anchor" href="#详细对比"><span>详细对比</span></a></h4><p><strong>Comparable接口：</strong></p><ul><li><strong>方法</strong>：compareTo(T o)</li><li><strong>实现位置</strong>：在被比较的类内部实现</li><li><strong>排序规则</strong>：固定的，类的自然排序</li><li><strong>使用方式</strong>：Collections.sort(list)</li></ul><p><strong>Comparator接口：</strong></p><ul><li><strong>方法</strong>：compare(T o1, T o2)</li><li><strong>实现位置</strong>：可以在任何地方实现</li><li><strong>排序规则</strong>：灵活的，可以有多种排序方式</li><li><strong>使用方式</strong>：Collections.sort(list, comparator)</li></ul><table><thead><tr><th>特性</th><th>Comparable</th><th>Comparator</th></tr></thead><tbody><tr><td>位置</td><td>类内部实现</td><td>外部实现</td></tr><tr><td>方法</td><td>compareTo()</td><td>compare()</td></tr><tr><td>排序规则</td><td>单一固定</td><td>多样化灵活</td></tr><tr><td>修改成本</td><td>需要修改原类</td><td>不需要修改原类</td></tr><tr><td>使用场景</td><td>类有明确的自然排序</td><td>需要多种排序方式或无法修改原类</td></tr><tr><td>实现数量</td><td>一个类只能有一种</td><td>可以有多个不同的实现</td></tr></tbody></table><h2 id="多线程" tabindex="-1"><a class="header-anchor" href="#多线程"><span>多线程</span></a></h2><h3 id="_1-进程和线程的区别-创建线程的几种方式-哪种更推荐" tabindex="-1"><a class="header-anchor" href="#_1-进程和线程的区别-创建线程的几种方式-哪种更推荐"><span>1. 进程和线程的区别？创建线程的几种方式？哪种更推荐？</span></a></h3><p><strong>进程 vs 线程：</strong></p><ul><li><strong>进程</strong>：操作系统资源分配的基本单位，拥有独立的内存空间 <ul><li>每个进程有独立的地址空间（内存、堆、栈、数据段等）</li></ul></li><li><strong>线程</strong>：CPU 调度和执行的最小单位，同一进程内的线程共享内存空间 <ul><li>同一进程内的线程共享进程的内存空间（堆、方法区等），但每个线程有自己的程序计数器、栈空间和局部变量表</li></ul></li></ul><table><thead><tr><th>特性</th><th>进程</th><th>线程</th></tr></thead><tbody><tr><td>资源占用</td><td>独立内存空间</td><td>共享进程内存空间</td></tr><tr><td>创建开销</td><td>大</td><td>小</td></tr><tr><td>通信方式</td><td>IPC（管道、消息队列）</td><td>共享内存、同步机制</td></tr><tr><td>崩溃影响</td><td>不影响其他进程</td><td>可能影响整个进程</td></tr><tr><td>切换开销</td><td>大</td><td>小</td></tr></tbody></table><ul><li>线程切换比进程切换快是因为<strong>线程共享同一进程的地址空间和资源</strong>，<strong>线程切换时只需切换堆栈和程序计数器等少量信息，而不需要切换地址空间，避免了进程切换时需要切换内存映射表等大量资源的开销</strong>，从而节省了时间和系统资源。<strong>进程切换时需要切换内存映射表等大量资源的开销。</strong></li></ul><p><strong>创建线程的方式：</strong></p><table><thead><tr><th>方式</th><th>特点</th><th>推荐度</th><th>使用场景</th></tr></thead><tbody><tr><td>继承Thread类</td><td>简单，但Java单继承限制</td><td>⭐⭐</td><td>简单场景，不推荐</td></tr><tr><td>实现Runnable接口</td><td>可多继承，推荐</td><td>⭐⭐⭐</td><td>一般异步任务</td></tr><tr><td>实现Callable+FutureTask</td><td>有返回值，可抛异常</td><td>⭐⭐⭐</td><td>需要返回结果的任务</td></tr><tr><td>线程池</td><td>复用线程，性能好，资源可控</td><td>⭐⭐⭐⭐⭐</td><td>生产环境，高并发场景</td></tr></tbody></table><p><strong>最推荐</strong>：线程池方式，因为可以避免频繁创建销毁线程的开销，更好地控制并发数量。</p><p><strong>操作系统调度器负责线程切换：</strong></p><ul><li>使用时间片轮转算法（分配CPU时间片）</li><li>Java线程调度由 OS 决定（非 Java 自己控制）</li><li>优先级机制：Thread.setPriority() 是建议，不保证生效。</li></ul><h3 id="_2-sleep-wait-yield-join-方法的区别" tabindex="-1"><a class="header-anchor" href="#_2-sleep-wait-yield-join-方法的区别"><span>2. sleep(), wait(), yield(), join() 方法的区别？</span></a></h3><table><thead><tr><th>方法</th><th>所属类</th><th>锁状态</th><th>使用场景</th><th>唤醒方式</th></tr></thead><tbody><tr><td>sleep()</td><td>Thread</td><td>不释放锁</td><td>暂停指定时间</td><td>时间到自动唤醒</td></tr><tr><td>wait()</td><td>Object</td><td>释放锁</td><td>等待条件满足</td><td>notify/notifyAll</td></tr><tr><td>yield()</td><td>Thread</td><td>不释放锁</td><td>让出CPU给同优先级线程</td><td>立即重新参与调度</td></tr><tr><td>join()</td><td>Thread</td><td>不释放锁</td><td>等待线程执行完毕</td><td>目标线程执行完毕</td></tr></tbody></table><p><strong>核心区别：</strong></p><ul><li><strong>sleep()和wait()的最大区别</strong>：sleep不释放锁，wait释放锁</li><li><strong>yield()作用</strong>：暂停当前线程，让同优先级线程有机会执行，但实际是否让出 CPU 要看调度器。</li><li><strong>join()用途</strong>：主线程等待子线程执行完毕后再继续</li></ul><h3 id="_3-上下文切换是什么-开销在哪里" tabindex="-1"><a class="header-anchor" href="#_3-上下文切换是什么-开销在哪里"><span>3. 上下文切换是什么？开销在哪里？</span></a></h3><p><strong>上下文切换</strong>：CPU从一个线程切换到另一个线程时，需要保存当前线程状态并加载新线程状态的过程。</p><p><strong>开销构成：</strong></p><ol><li><strong>保存现场</strong>：寄存器、程序计数器、栈指针等</li><li><strong>加载新现场</strong>：新线程的执行环境</li><li><strong>内存缓存失效</strong>：CPU缓存可能失效，需要重新加载</li><li><strong>内核态切换</strong>：用户态到内核态的切换开销</li></ol><table><thead><tr><th>开销类型</th><th>具体内容</th><th>影响程度</th></tr></thead><tbody><tr><td>寄存器保存</td><td>CPU寄存器状态保存/恢复</td><td>中等</td></tr><tr><td>内存访问</td><td>栈、堆内存访问模式变化</td><td>高</td></tr><tr><td>缓存失效</td><td>CPU缓存、TLB失效</td><td>高</td></tr><tr><td>系统调用</td><td>用户态/内核态切换</td><td>中等</td></tr></tbody></table><p><strong>减少上下文切换的方法：</strong></p><ul><li>减少线程数量：使用线程池复用线程</li><li>使用无锁并发结构：如 ConcurrentHashMap、CAS</li><li>减少共享资源：降低锁竞争</li><li>使用协程</li></ul><h3 id="_4-什么是线程安全-如何理解原子性、可见性、有序性" tabindex="-1"><a class="header-anchor" href="#_4-什么是线程安全-如何理解原子性、可见性、有序性"><span>4. 什么是线程安全？如何理解原子性、可见性、有序性？</span></a></h3><p><strong>线程安全</strong>：多个线程同时访问共享资源时，不会产生数据不一致或其他非预期的结果。</p><p><strong>并发编程三大特性：</strong></p><table><thead><tr><th>特性</th><th>定义</th><th>问题表现</th><th>解决方案</th></tr></thead><tbody><tr><td>原子性</td><td>操作不可被中断，要么全部成功要么全部失败</td><td>数据不一致</td><td>synchronized、CAS</td></tr><tr><td>可见性</td><td>一个线程修改共享变量，其他线程能立即看到</td><td>读取到过期数据</td><td>volatile、synchronized</td></tr><tr><td>有序性</td><td>程序执行顺序与代码顺序一致</td><td>指令重排序导致逻辑错误</td><td>volatile、synchronized</td></tr></tbody></table><h3 id="_5-synchronized-关键字的原理-使用方式-锁升级过程" tabindex="-1"><a class="header-anchor" href="#_5-synchronized-关键字的原理-使用方式-锁升级过程"><span>5. synchronized 关键字的原理？使用方式？锁升级过程？</span></a></h3><p><strong>使用方式：</strong></p><ul><li><strong>修饰实例方法</strong>：锁的是当前实例对象</li><li><strong>修饰静态方法</strong>：锁的是Class对象</li><li><strong>修饰代码块</strong>：锁的是指定对象</li></ul><p><strong>锁升级过程（JDK1.6+）：</strong></p><table><thead><tr><th>锁状态</th><th>特点</th><th>适用场景</th><th>性能</th></tr></thead><tbody><tr><td>无锁</td><td>没有锁竞争</td><td>单线程访问</td><td>最高</td></tr><tr><td>偏向锁</td><td>偏向第一个获得锁的线程</td><td>基本没有竞争</td><td>高</td></tr><tr><td>轻量级锁</td><td>CAS自旋获取锁</td><td>竞争不激烈，持锁时间短</td><td>中等</td></tr><tr><td>重量级锁</td><td>操作系统互斥锁</td><td>竞争激烈，持锁时间长</td><td>低</td></tr></tbody></table><p><strong>升级路径</strong>：无锁 → 偏向锁 → 轻量级锁 → 重量级锁（不可逆）</p><h3 id="_6-volatile-关键字的语义-原理-能保证原子性吗-适用场景" tabindex="-1"><a class="header-anchor" href="#_6-volatile-关键字的语义-原理-能保证原子性吗-适用场景"><span>6. volatile 关键字的语义？原理？能保证原子性吗？适用场景？</span></a></h3><p><strong>volatile的两大语义：</strong></p><ol><li><strong>保证可见性</strong>：修改立即刷新到主内存，读取直接从主内存读</li><li><strong>保证有序性</strong>：禁止指令重排序</li></ol><p><strong>实现原理：</strong></p><ul><li><strong>内存屏障</strong>：编译器在volatile变量前后插入内存屏障指令</li><li><strong>缓存一致性协议</strong>：MESI协议确保缓存一致性</li></ul><p><strong>不能保证原子性</strong>：volatile不能保证复合操作的原子性，如 i++ 操作。</p><table><thead><tr><th>特性</th><th>volatile</th><th>synchronized</th></tr></thead><tbody><tr><td>原子性</td><td>❌</td><td>✅</td></tr><tr><td>可见性</td><td>✅</td><td>✅</td></tr><tr><td>有序性</td><td>✅</td><td>✅</td></tr><tr><td>阻塞性</td><td>不阻塞</td><td>可能阻塞</td></tr><tr><td>性能</td><td>高</td><td>相对较低</td></tr></tbody></table><p><strong>适用场景：</strong></p><ul><li>状态标记（如停止标志）</li><li>双重检查锁定模式</li><li>单例模式中的实例变量</li></ul><h3 id="_7-synchronized-和-volatile-的区别" tabindex="-1"><a class="header-anchor" href="#_7-synchronized-和-volatile-的区别"><span>7. synchronized 和 volatile 的区别？</span></a></h3><table><thead><tr><th>对比维度</th><th>synchronized</th><th>volatile</th></tr></thead><tbody><tr><td>作用对象</td><td>方法、代码块</td><td>变量</td></tr><tr><td>原子性</td><td>保证</td><td>不保证</td></tr><tr><td>可见性</td><td>保证</td><td>保证</td></tr><tr><td>有序性</td><td>保证</td><td>保证</td></tr><tr><td>阻塞特性</td><td>可能阻塞</td><td>不阻塞</td></tr><tr><td>锁机制</td><td>互斥锁</td><td>无锁</td></tr><tr><td>性能开销</td><td>较高</td><td>较低</td></tr><tr><td>适用场景</td><td>复合操作、临界区</td><td>状态标记、简单赋值</td></tr></tbody></table><h3 id="_8-cas-操作的原理-atomic类实现-aba问题及解决方案" tabindex="-1"><a class="header-anchor" href="#_8-cas-操作的原理-atomic类实现-aba问题及解决方案"><span>8. CAS 操作的原理？Atomic类实现？ABA问题及解决方案？</span></a></h3><p><strong>CAS（Compare-And-Swap）原理：</strong> 比较内存位置的值与期望值，如果相同则更新为新值，整个操作是原子的。</p><p><strong>三个操作数：</strong></p><ul><li><strong>内存位置V</strong>：要更新的变量</li><li><strong>预期值A</strong>：期望的当前值</li><li><strong>新值B</strong>：要设置的新值</li></ul><p><strong>Atomic类实现：</strong> 基于CAS + volatile，通过无锁算法实现线程安全。</p><p><strong>ABA问题：</strong> 值从A变成B再变回A，CAS检测不到中间的变化过程。</p><table><thead><tr><th>问题</th><th>表现</th><th>解决方案</th></tr></thead><tbody><tr><td>ABA问题</td><td>值变化后又变回原值，CAS误判为未变化</td><td>AtomicStampedReference 引入了版本戳</td></tr><tr><td>性能问题</td><td>高竞争时自旋消耗CPU</td><td>结合synchronized</td></tr><tr><td>只能保证单变量</td><td>多个变量的原子性无法保证</td><td>AtomicReference包装对象</td></tr></tbody></table><ul><li>AtomicReference 是 Java 并发包提供的原子引用工具，利用 CAS 原理在多线程环境下安全更新对象引用，无需锁。常用于非阻塞队列、状态机、对象共享更新等场景。</li></ul><h3 id="_9-threadlocal-的原理-使用场景-内存泄漏问题及如何避免" tabindex="-1"><a class="header-anchor" href="#_9-threadlocal-的原理-使用场景-内存泄漏问题及如何避免"><span>9. ThreadLocal 的原理？使用场景？内存泄漏问题及如何避免？</span></a></h3><ul><li>ThreadLocal 提供了一个线程内部的局部变量。每个线程都有自己独立的副本，互不影响。</li></ul><p><strong>原理：</strong> 每个线程都有一个ThreadLocalMap，以ThreadLocal为key存储线程私有数据。</p><p><strong>数据结构：</strong> Thread → ThreadLocalMap → Entry(ThreadLocal, Value)</p><p><strong>使用场景：</strong></p><ul><li><strong>数据库连接管理</strong>：每个线程独立的连接</li><li><strong>用户会话信息</strong>：Web请求中的用户信息</li><li><strong>数据格式化</strong>：SimpleDateFormat等非线程安全类</li></ul><p><strong>内存泄漏问题：</strong></p><table><thead><tr><th>问题原因</th><th>后果</th><th>解决方案</th></tr></thead><tbody><tr><td>ThreadLocal被回收</td><td>key为null</td><td>手动调用remove()</td></tr><tr><td>线程长期存活</td><td>value无法回收</td><td>使用完毕立即remove()</td></tr><tr><td>强引用链</td><td>整个对象无法回收</td><td>避免在线程池中使用静态ThreadLocal</td></tr></tbody></table><p><strong>最佳实践：</strong></p><ol><li>使用完毕后立即调用 <code>remove()</code></li><li>使用 <code>try-finally</code> 确保清理</li><li>避免在线程池中使用静态ThreadLocal</li></ol><h3 id="_10-aqs底层和他的一些实现" tabindex="-1"><a class="header-anchor" href="#_10-aqs底层和他的一些实现"><span>10. AQS底层和他的一些实现？</span></a></h3><p><strong>核心思想：</strong></p><ul><li>维护一个<strong>共享资源的状态（state）</strong></li><li>使用**一个 FIFO 等待队列（CLH 队列）**来管理线程的访问</li><li>提供<strong>模板方法</strong>让子类实现同步器逻辑</li></ul><p><strong>核心组成：</strong></p><ul><li><code>state</code> 变量： <ul><li>是一个 <code>volatile int</code>，表示同步资源的状态（例如：锁是否被占用、计数器数量等）</li><li>子类通过 <code>getState()</code>、<code>setState()</code>、<code>compareAndSetState()</code> 来操作它</li></ul></li><li>CLH 同步队列： <ul><li>AQS 使用一个 <strong>双向链表队列（CLH队列）</strong> 保存等待锁的线程 <ul><li>CLH 队列提供了有序、公平、高效的线程管理能力，能很好地支持 AQS 的可扩展、高性能并发模型，是实现 Java 锁的理想选择。</li></ul></li><li>每个线程抢锁失败后，构造成一个 <code>Node</code> 挂在队列尾部，阻塞等待</li></ul></li></ul><p><strong>独占模式与共享模式：</strong></p><ul><li>独占模式（如：ReentrantLock） <ul><li>一个线程持有资源，其它线程必须等待。</li><li>核心方法（子类可重写）：</li></ul></li></ul><ul><li><code>tryAcquire(int)</code></li><li><code>tryRelease(int)</code></li></ul><ul><li>共享模式（如：Semaphore、CountDownLatch） <ul><li>多个线程可共享资源。</li><li>核心方法（子类可重写）：</li></ul></li></ul><ul><li><code>tryAcquireShared(int)</code></li><li><code>tryReleaseShared(int)</code></li></ul><p><strong>AQS 的主要实现类：</strong></p><table><thead><tr><th>实现类</th><th>描述</th></tr></thead><tbody><tr><td><code>ReentrantLock</code></td><td>可重入独占锁，支持公平/非公平</td></tr><tr><td><code>ReentrantReadWriteLock</code></td><td>支持读写分离锁，读共享，写独占</td></tr><tr><td><code>CountDownLatch</code></td><td>倒计时器，等到计数归零再执行</td></tr><tr><td><code>Semaphore</code></td><td>控制并发数量</td></tr><tr><td><code>CyclicBarrier</code></td><td>多线程 barrier，同步屏障</td></tr><tr><td><code>FutureTask</code></td><td>支持异步计算的任务容器（如线程池结果）</td></tr></tbody></table><p><strong>AQS 的优点：</strong></p><ul><li><strong>高可扩展性</strong>：只需重写模板方法即可实现自定义同步器</li><li><strong>统一阻塞机制</strong>：统一使用 <code>LockSupport</code> 管理线程挂起与唤醒</li><li><strong>性能优化</strong>：使用自旋、CAS、懒中断、队列策略来减少资源竞争</li></ul><h3 id="_11-线程同步的一些手段-使用时机" tabindex="-1"><a class="header-anchor" href="#_11-线程同步的一些手段-使用时机"><span>11. 线程同步的一些手段？使用时机？</span></a></h3><h4 id="线程同步方式总结表" tabindex="-1"><a class="header-anchor" href="#线程同步方式总结表"><span>线程同步方式总结表</span></a></h4><table><thead><tr><th>同步方式</th><th>核心原理</th><th>适用场景</th><th>优点</th><th>缺点</th><th>典型实现示例</th></tr></thead><tbody><tr><td><code>synchronized</code> 关键字</td><td>基于对象内置锁（Intrinsic Lock），JVM 自动管理锁的获取与释放，保证同一时刻仅一个线程执行临界区</td><td>简单同步场景（如单例模式、单个共享变量读写、简单方法/代码块互斥）</td><td>使用简单，无需手动释放锁，降低死锁风险；JVM 优化成熟（如锁消除、锁粗化）</td><td>功能单一，不支持超时获取、公平锁、中断等待；锁粒度较难精细控制</td><td><code>synchronized void syncMethod() { ... }</code> 或 <code>synchronized (lockObj) { ... }</code></td></tr><tr><td>ReentrantLock 可重入锁</td><td>基于 AQS（AbstractQueuedSynchronizer）实现显式锁，需手动调用 <code>lock()</code> 获取、<code>unlock()</code> 释放，支持重入</td><td>复杂同步逻辑（如超时获取锁、公平锁需求、多条件变量协作）</td><td>支持中断响应、超时机制、公平锁；可配合 <code>Condition</code> 实现精准通知</td><td>需手动释放锁（需在 <code>finally</code> 中处理，否则易导致死锁）；代码复杂度高于 <code>synchronized</code></td><td><code>Lock lock = new ReentrantLock(true); lock.lock(); try { ... } finally { lock.unlock(); }</code></td></tr><tr><td><code>volatile</code> 关键字</td><td>保证变量可见性（线程修改后其他线程立即可见）、禁止指令重排序，不保证原子性</td><td>状态标记场景（如 <code>boolean isRunning</code> 控制线程启停）；无需原子性的变量读写</td><td>轻量级，性能开销远低于锁机制；避免内存可见性问题</td><td>不保证原子性，无法解决复合操作（如 <code>i++</code>）的线程安全问题</td><td><code>private volatile boolean isStopped = false;</code></td></tr><tr><td>等待/通知机制</td><td>基于 <code>synchronized</code> 的 <code>wait()</code>/<code>notify()</code>/<code>notifyAll()</code>，或 <code>ReentrantLock</code> 配合 <code>Condition</code> 的 <code>await()</code>/<code>signal()</code>，实现线程间等待与唤醒</td><td>线程间依赖协作（如生产者-消费者模型、线程按顺序执行）</td><td>实现线程间精准协作，减少无效轮询</td><td><code>notify()</code> 随机唤醒线程，可能导致“虚假唤醒”（需循环检查条件）；依赖锁机制，使用有一定门槛</td><td><code>synchronized (obj) { while (condition) obj.wait(); }</code> 或 <code>condition.await(); condition.signal();</code></td></tr><tr><td>Semaphore 信号量</td><td>维护“许可”计数器，线程获取许可（<code>acquire()</code>）后执行，释放许可（<code>release()</code>）归还，控制并发线程数</td><td>限流场景（如接口并发调用限制）；资源池访问控制（如数据库连接池）</td><td>灵活控制并发度，支持公平/非公平模式；可实现多线程协作</td><td>需手动释放许可，遗漏会导致资源永久阻塞；不直接保护资源，仅控制访问数量</td><td><code>Semaphore sem = new Semaphore(5); sem.acquire(); try { ... } finally { sem.release(); }</code></td></tr><tr><td>CountDownLatch 倒计时器</td><td>初始化计数器，线程调用 <code>countDown()</code> 递减计数，调用 <code>await()</code> 的线程阻塞至计数为 0，计数器不可重置</td><td>主线程等待多子线程完成（如并行计算结果汇总）；多线程等待同一“开始信号”</td><td>操作简单，适合一次性同步场景；支持超时等待</td><td>计数器不可重用，需重复同步需创建新实例</td><td><code>CountDownLatch latch = new CountDownLatch(3); latch.await();</code>（主线程）；<code>latch.countDown();</code>（子线程）</td></tr><tr><td>CyclicBarrier 循环屏障</td><td>等待一组线程全部到达“屏障点”（<code>await()</code>）后，所有线程同时继续执行，屏障可重复使用</td><td>分阶段任务（如流水线作业，每个阶段需所有线程完成后进入下一阶段）</td><td>可重复使用；支持“屏障动作”（所有线程到达后执行的回调）</td><td>仅适用于线程数量固定的场景；某线程异常会导致其他线程永久阻塞</td><td><code>CyclicBarrier barrier = new CyclicBarrier(3, () -&gt; System.out.println(&quot;所有线程到达屏障&quot;)); barrier.await();</code></td></tr><tr><td>Atomic 原子类</td><td>基于 CAS（Compare-And-Swap）硬件指令，保证变量“读取-修改-写入”操作的原子性，无锁机制</td><td>简单计数器（如请求次数统计、任务完成数计数）；轻量级状态更新</td><td>无锁操作，性能优于锁机制；避免线程上下文切换开销</td><td>仅支持简单原子操作，复杂逻辑需组合使用；高并发下可能存在 CAS 自旋开销</td><td><code>AtomicInteger count = new AtomicInteger(0); count.incrementAndGet();</code>（原子自增）</td></tr></tbody></table><h4 id="进程同步方式总结表" tabindex="-1"><a class="header-anchor" href="#进程同步方式总结表"><span>进程同步方式总结表</span></a></h4><table><thead><tr><th>同步方式</th><th>核心原理</th><th>适用场景</th><th>优点</th><th>缺点</th><th>典型实现示例（以 Linux 为例）</th></tr></thead><tbody><tr><td>互斥锁（Mutex）</td><td>特殊的“二值信号量”（仅 0/1 状态），进程获取锁（<code>pthread_mutex_lock</code>）后独占资源，释放锁（<code>pthread_mutex_unlock</code>）后其他进程可获取</td><td>保护进程间共享资源（如共享内存中的数据、物理设备），防止并发修改导致数据不一致</td><td>专注“互斥”，保证临界区独占访问；支持递归加锁（可重入互斥锁）</td><td>仅支持同一进程内线程或有亲缘关系进程（如 pthread_mutex）；非亲缘进程需依赖共享内存存储锁</td><td><code>pthread_mutex_t mutex; pthread_mutex_init(&amp;mutex, NULL); pthread_mutex_lock(&amp;mutex); // 临界区 pthread_mutex_unlock(&amp;mutex);</code></td></tr><tr><td>信号量（Semaphore）</td><td>内核维护“许可”计数器，进程调用 <code>sem_wait</code> 减 1（无许可则阻塞），<code>sem_post</code> 加 1，控制共享资源访问数量</td><td>限制并发进程数（如多进程访问有限的打印机资源）；进程间简单协作（如生产者-消费者模型控制缓冲区）</td><td>支持计数信号量（允许多进程并发访问）；可用于任意进程间同步</td><td>需手动释放许可，遗漏会导致资源永久不可用；内核维护，操作开销高于共享内存</td><td><code>sem_t *sem = sem_open(&quot;/my_sem&quot;, O_CREAT, 0644, 3); sem_wait(sem); // 访问资源 sem_post(sem); sem_close(sem);</code></td></tr><tr><td>管道（Pipe）</td><td>内核创建的半双工缓冲区，进程通过 <code>read</code>/<code>write</code> 读写管道传递数据，通过“数据是否可读/可写”间接实现同步</td><td>亲缘进程（父子、兄弟进程）间简单通信与同步（如 shell 命令管道 `cmd1</td><td>cmd2`）</td><td>实现简单，无需手动管理缓冲区；依赖内核，安全性高</td><td>半双工通信（需两个管道实现双向）；仅支持亲缘进程；数据随读随清，无法重复读取</td></tr><tr><td>消息队列（Message Queue）</td><td>内核维护的消息链表，进程通过 <code>msgsnd</code> 发送消息（带类型），<code>msgrcv</code> 接收消息，通过消息传递触发同步</td><td>无亲缘关系进程间通信与同步（如不同应用程序间任务调度、结果返回）</td><td>支持双向通信；消息带类型，可按类型接收；数据可持久化（重启后可能保留）</td><td>内核维护，通信效率低于共享内存；消息大小和队列长度有限制</td><td><code>int msqid = msgget(IPC_PRIVATE, 0666); struct msgbuf buf = {1, &quot;msg data&quot;}; msgsnd(msqid, &amp;buf, sizeof(buf.mtext), 0); msgrcv(msqid, &amp;buf, sizeof(buf.mtext), 1, 0);</code></td></tr><tr><td>共享内存（Shared Memory）</td><td>内核分配一块物理内存，多个进程通过 <code>shmat</code> 映射到自身虚拟地址空间，直接读写内存实现数据共享，需配合其他同步机制（如信号量）保证安全</td><td>进程间高频、大数据量共享（如高性能计算中的数据交换、实时系统数据传输）</td><td>通信效率最高（无需内核中转）；支持任意进程间共享</td><td>本身不提供同步机制，必须配合互斥锁/信号量使用；进程异常退出可能导致内存泄漏</td><td><code>int shmid = shmget(IPC_PRIVATE, 1024, 0666); char *shm = (char*)shmat(shmid, NULL, 0); strcpy(shm, &quot;shared data&quot;); shmdt(shm); shmctl(shmid, IPC_RMID, NULL);</code></td></tr><tr><td>信号（Signal）</td><td>操作系统向进程发送的异步通知（如 <code>SIGINT</code> 中断、<code>SIGTERM</code> 终止），进程通过 <code>signal</code>/<code>sigaction</code> 注册处理函数，触发同步逻辑</td><td>进程异常处理（如捕获崩溃信号、用户中断）；简单进程唤醒（如进程完成任务后通知其他进程）</td><td>轻量级，无需复杂通信机制；可跨进程触发</td><td>仅传递“信号类型”，无法携带复杂数据；信号处理函数需简洁（避免重入问题）</td><td><code>signal(SIGUSR1, handler); // 注册自定义信号处理函数 kill(pid, SIGUSR1); // 向目标进程发送信号</code></td></tr><tr><td>条件变量（Condition Variable）</td><td>与互斥锁配合使用，进程调用 <code>pthread_cond_wait</code> 释放锁并阻塞，<code>pthread_cond_signal</code> 唤醒阻塞进程，等待特定条件满足</td><td>进程间依赖协作（如“进程 B 等待进程 A 初始化完成后再执行”）；复杂生产者-消费者模型</td><td>实现精准条件等待，减少无效轮询；支持批量唤醒（<code>pthread_cond_broadcast</code>）</td><td>必须与互斥锁配合使用；存在“虚假唤醒”，需循环检查条件</td><td><code>pthread_cond_t cond; pthread_cond_wait(&amp;cond, &amp;mutex); // 等待条件 pthread_cond_signal(&amp;cond); // 唤醒进程</code></td></tr></tbody></table><h2 id="数据库" tabindex="-1"><a class="header-anchor" href="#数据库"><span>数据库</span></a></h2><h3 id="_1-sql基础语法-ddl-dml-dql-dcl-常用函数" tabindex="-1"><a class="header-anchor" href="#_1-sql基础语法-ddl-dml-dql-dcl-常用函数"><span>1. SQL基础语法（DDL, DML, DQL, DCL）？常用函数？</span></a></h3><p><strong>SQL语言分类：</strong></p><table><thead><tr><th>类型</th><th>全称</th><th>作用</th><th>常用语句</th></tr></thead><tbody><tr><td>DDL</td><td>Data Definition Language</td><td>数据定义语言</td><td>CREATE、ALTER、DROP</td></tr><tr><td>DML</td><td>Data Manipulation Language</td><td>数据操作语言</td><td>INSERT、UPDATE、DELETE</td></tr><tr><td>DQL</td><td>Data Query Language</td><td>数据查询语言</td><td>SELECT</td></tr><tr><td>DCL</td><td>Data Control Language</td><td>数据控制语言</td><td>GRANT、REVOKE、COMMIT、ROLLBACK</td></tr></tbody></table><p><strong>常用函数分类：</strong></p><table><thead><tr><th>函数类型</th><th>常用函数</th><th>作用</th></tr></thead><tbody><tr><td>聚合函数</td><td>COUNT、SUM、AVG、MAX、MIN</td><td>统计计算</td></tr><tr><td>字符串函数</td><td>CONCAT、SUBSTRING、LENGTH、UPPER、LOWER</td><td>字符串处理</td></tr><tr><td>日期函数</td><td>NOW、CURDATE、DATE_FORMAT、DATEDIFF</td><td>日期时间处理</td></tr><tr><td>数学函数</td><td>ROUND、CEIL、FLOOR、ABS、MOD</td><td>数值计算</td></tr><tr><td>条件函数</td><td>IF、CASE WHEN、IFNULL、NULLIF</td><td>条件判断</td></tr></tbody></table><h3 id="_2-mysql核心区别-事务、锁、外键、索引结构" tabindex="-1"><a class="header-anchor" href="#_2-mysql核心区别-事务、锁、外键、索引结构"><span>2. MySQL核心区别（事务、锁、外键、索引结构）？</span></a></h3><p><strong>存储引擎对比：</strong></p><table><thead><tr><th>特性</th><th>InnoDB</th><th>MyISAM</th><th>Memory</th></tr></thead><tbody><tr><td>事务支持</td><td>✅支持ACID</td><td>❌不支持</td><td>❌不支持</td></tr><tr><td>锁级别</td><td>行级锁</td><td>表级锁</td><td>表级锁</td></tr><tr><td>外键支持</td><td>✅支持</td><td>❌不支持</td><td>❌不支持</td></tr><tr><td>索引结构</td><td>B+树聚集索引</td><td>B+树非聚集索引</td><td>Hash索引</td></tr><tr><td>崩溃恢复</td><td>✅支持</td><td>❌不支持</td><td>❌不支持</td></tr><tr><td>适用场景</td><td>事务处理、高并发写入</td><td>只读、数据仓库</td><td>临时表、缓存</td></tr></tbody></table><h3 id="_3-索引-什么是索引-为什么能提高查询效率-索引的优缺点" tabindex="-1"><a class="header-anchor" href="#_3-索引-什么是索引-为什么能提高查询效率-索引的优缺点"><span>3. 索引：什么是索引？为什么能提高查询效率？索引的优缺点？</span></a></h3><p><strong>索引定义：</strong> 索引是数据库表中一个或多个列的值排序的数据结构，类似书的目录，用于快速定位数据。</p><p><strong>提高效率原理：</strong></p><ul><li><strong>减少扫描行数</strong>：从全表扫描变为索引查找</li><li><strong>有序存储</strong>：B+树结构保证数据有序，支持范围查询</li><li><strong>减少I/O操作</strong>：索引通常比数据小，能缓存在内存中（MySQL的Buffer Pool）</li></ul><p><strong>索引优缺点：</strong></p><table><thead><tr><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>大幅提高查询速度</td><td>占用额外存储空间</td></tr><tr><td>加速表连接</td><td>降低写操作性能（增删改）</td></tr><tr><td>减少分组和排序时间</td><td>维护索引需要额外开销</td></tr><tr><td>唯一索引保证数据唯一性</td><td>过多索引影响优化器选择</td></tr></tbody></table><ul><li>MySQL会根据成本估算选择最优索引，但最好的解决方案通常是创建适合查询模式的复合索引，而不是依赖两个独立索引。</li></ul><h3 id="_4-b-树索引结构-为什么mysql使用b-树而不是b树或哈希表" tabindex="-1"><a class="header-anchor" href="#_4-b-树索引结构-为什么mysql使用b-树而不是b树或哈希表"><span>4. B+树索引结构？为什么MySQL使用B+树而不是B树或哈希表？</span></a></h3><p><strong>B+树特点：</strong></p><ul><li><strong>所有数据在叶子节点</strong>：非叶子节点只存储键值</li><li><strong>叶子节点连接</strong>：叶子节点通过指针连接，支持范围查询</li><li><strong>更高的扇出比</strong>：非叶子节点可存储更多键值</li><li>B+ 树内部节点存 Key 和子节点指针，用于查找；叶子节点存 Key、数据指针，并用链表顺序连接，支持范围查询。</li></ul><p><strong>选择B+树的原因：</strong></p><table><thead><tr><th>对比项</th><th>B+树</th><th>B树</th><th>哈希表</th></tr></thead><tbody><tr><td>范围查询</td><td>✅优秀</td><td>❌较差</td><td>❌不支持</td></tr><tr><td>顺序访问</td><td>✅优秀</td><td>❌一般</td><td>❌不支持</td></tr><tr><td>磁盘I/O</td><td>✅少</td><td>❌多</td><td>✅少</td></tr><tr><td>内存利用率</td><td>✅高</td><td>❌低</td><td>✅高</td></tr><tr><td>等值查询</td><td>✅快</td><td>✅快</td><td>✅最快</td></tr><tr><td>数据有序性</td><td>✅有序</td><td>✅有序</td><td>❌无序</td></tr></tbody></table><h3 id="_5-聚集索引和非聚集索引的区别-innodb的主键索引结构" tabindex="-1"><a class="header-anchor" href="#_5-聚集索引和非聚集索引的区别-innodb的主键索引结构"><span>5. 聚集索引和非聚集索引的区别？InnoDB的主键索引结构？</span></a></h3><p><strong>聚集索引 vs 非聚集索引：</strong></p><table><thead><tr><th>特性</th><th>聚集索引（主键索引）</th><th>非聚集索引（辅助索引）</th></tr></thead><tbody><tr><td>数据存储</td><td>叶子节点存储完整行数据</td><td>叶子节点存储主键值</td></tr><tr><td>数据排序</td><td>数据按索引键物理排序</td><td>数据排序与索引无关</td></tr><tr><td>查询性能</td><td>一次查询获取所有数据</td><td>可能需要回表查询</td></tr><tr><td>每表数量</td><td>最多一个</td><td>可以有多个</td></tr><tr><td>存储开销</td><td>无额外开销</td><td>需要额外存储空间</td></tr></tbody></table><p><strong>InnoDB主键索引结构：</strong></p><ul><li><strong>主键索引</strong>：聚集索引，叶子节点存储完整行数据</li><li><strong>辅助索引</strong>：非聚集索引，叶子节点存储主键值</li><li><strong>回表查询</strong>：通过辅助索引查询时，需要根据主键值再查主键索引</li></ul><h3 id="_6-索引类型分类" tabindex="-1"><a class="header-anchor" href="#_6-索引类型分类"><span>6. 索引类型分类？</span></a></h3><p><strong>按功能分类：</strong></p><table><thead><tr><th>索引类型</th><th>特点</th><th>使用场景</th><th>示例</th></tr></thead><tbody><tr><td>主键索引</td><td>唯一+非空，自动创建聚集索引</td><td>主键字段</td><td>PRIMARY KEY</td></tr><tr><td>唯一索引</td><td>值唯一，允许一个NULL</td><td>身份证号、邮箱</td><td>UNIQUE</td></tr><tr><td>普通索引</td><td>无唯一性限制，提高查询速度</td><td>查询频繁的字段</td><td>INDEX</td></tr><tr><td>组合索引</td><td>多列联合索引，遵循最左前缀原则</td><td>多条件查询</td><td>(name, age, city)</td></tr><tr><td>全文索引</td><td>文本关键词搜索</td><td>文章内容搜索</td><td>FULLTEXT</td></tr></tbody></table><p><strong>按数据结构分类</strong></p><table><thead><tr><th>索引类型</th><th>特点</th><th>使用场景</th><th>示例</th></tr></thead><tbody><tr><td>B+树索引</td><td>平衡二叉树，支持范围查询</td><td>主键字段</td><td>PRIMARY KEY</td></tr><tr><td>B树索引</td><td>平衡二叉树，支持范围查询</td><td>主键字段</td><td>PRIMARY KEY</td></tr><tr><td>哈希索引</td><td>哈希表，支持等值查询</td><td>主键字段</td><td>PRIMARY KEY</td></tr><tr><td>倒排索引</td><td>倒排索引，支持全文搜索</td><td>文章内容搜索</td><td>FULLTEXT</td></tr><tr><td>R-Tree</td><td>空间数据索引，支持空间查询</td><td>地理位置查询</td><td>SPATIAL</td></tr></tbody></table><h3 id="_7-索引失效的常见场景" tabindex="-1"><a class="header-anchor" href="#_7-索引失效的常见场景"><span>7. 索引失效的常见场景？</span></a></h3><p><strong>索引失效情况：</strong></p><table><thead><tr><th>失效场景</th><th>示例</th><th>原因</th></tr></thead><tbody><tr><td>函数操作</td><td>WHERE YEAR(date) = 2023</td><td>对索引列使用函数</td></tr><tr><td>隐式类型转换</td><td>WHERE age = &#39;18&#39;</td><td>数据类型不匹配</td></tr><tr><td>LIKE以%开头</td><td>WHERE name LIKE &#39;%张&#39;</td><td>无法利用索引的有序性</td></tr><tr><td>OR条件</td><td>WHERE a = 1 OR b = 2</td><td>其中一个条件没有索引</td></tr><tr><td>组合索引不满足最左前缀</td><td>INDEX(a,b,c) WHERE b = 1</td><td>违反最左前缀原则</td></tr><tr><td>不等于操作</td><td>WHERE age != 18</td><td>范围太大，优化器选择全表扫描</td></tr><tr><td>IS NULL判断</td><td>WHERE name IS NULL</td><td>NULL值不存储在索引中</td></tr></tbody></table><h3 id="_8-explain命令的作用-关键字段的含义" tabindex="-1"><a class="header-anchor" href="#_8-explain命令的作用-关键字段的含义"><span>8. EXPLAIN命令的作用？关键字段的含义？</span></a></h3><p><strong>EXPLAIN作用：</strong> 分析SQL语句执行计划，帮助优化查询性能。</p><p><strong>关键字段含义：</strong></p><table><thead><tr><th>字段</th><th>含义</th><th>重要值</th></tr></thead><tbody><tr><td>type</td><td>访问类型</td><td>system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL</td></tr><tr><td>key</td><td>实际使用的索引</td><td>NULL表示未使用索引</td></tr><tr><td>rows</td><td>预估扫描行数</td><td>数值越小越好</td></tr><tr><td>Extra</td><td>额外信息</td><td>Using index &gt; Using where &gt; Using filesort</td></tr></tbody></table><p><strong>type字段详解：</strong></p><table><thead><tr><th>type值</th><th>性能</th><th>说明</th></tr></thead><tbody><tr><td>system</td><td>最优</td><td>表只有一行</td></tr><tr><td>const</td><td>优</td><td>主键或唯一索引等值查询</td></tr><tr><td>eq_ref</td><td>优</td><td>主键或唯一索引关联</td></tr><tr><td>ref</td><td>良</td><td>非唯一索引等值查询</td></tr><tr><td>range</td><td>中</td><td>范围查询</td></tr><tr><td>index</td><td>差</td><td>索引全扫描</td></tr><tr><td>ALL</td><td>最差</td><td>全表扫描</td></tr></tbody></table><h3 id="_9-锁-innodb的行锁、间隙锁、临键锁-mvcc的原理-如何解决幻读" tabindex="-1"><a class="header-anchor" href="#_9-锁-innodb的行锁、间隙锁、临键锁-mvcc的原理-如何解决幻读"><span>9. 锁：InnoDB的行锁、间隙锁、临键锁？MVCC的原理？如何解决幻读？</span></a></h3><p><strong>InnoDB锁类型：</strong></p><table><thead><tr><th>锁类型</th><th>锁范围</th><th>作用</th><th>示例场景</th></tr></thead><tbody><tr><td>行锁</td><td>锁定具体的行</td><td>防止并发修改同一行数据</td><td>UPDATE具体记录</td></tr><tr><td>间隙锁</td><td>锁定索引记录之间的间隙</td><td>防止在间隙中插入新记录</td><td>防止幻读</td></tr><tr><td>临键锁</td><td>行锁+间隙锁的组合</td><td>既锁记录又锁间隙</td><td>范围查询时使用</td></tr><tr><td>意向锁</td><td>表级锁，表示事务的加锁意图</td><td>提高表锁检测效率</td><td>加行锁时自动加意向锁</td></tr></tbody></table><p><strong>MVCC（多版本并发控制）原理：</strong></p><ul><li><strong>版本链</strong>：每行记录维护多个版本</li><li><strong>ReadView</strong>：事务开始时创建的一致性视图，在RR的时候，在第一次查询的时候创建一个ReadView并且在事务中复用，在RC的时候，每次读取数据前都会创建一个ReadView</li><li><strong>undo log</strong>：存储历史版本数据</li><li><strong>实现隔离</strong>：不同事务看到不同版本的数据</li><li><strong>总结</strong>：事务的隔离性通过锁和多版本并发控制（MVCC）来保证。MVCC通过维护数据的多个版本来避免读写冲突。底层实现包括隐藏字段、undo log和read view。隐藏字段包括trx_id和roll_pointer。undo log记录了不同版本的数据，通过roll_pointer形成版本链。read view定义了不同隔离级别下的快照读，决定了事务访问哪个版本的数据。</li></ul><p><strong>解决幻读：</strong></p><ul><li><strong>快照读</strong>：通过MVCC，读取事务开始时的数据快照 <ul><li>快照读：默认的 SELECT 查询，在事务里读的是事务开始时的快照，不会加锁，也不会被其他事务影响。</li></ul></li><li><strong>当前读</strong>：通过临键锁，锁定查询范围防止插入新数据 <ul><li>当前读：会加锁防止别的事务插入/更新你正在看的范围，用来保证一致性或做更新，比如<code>select .. for update</code>。</li></ul></li></ul><h3 id="_10-事务隔离级别-mysql默认级别-不同级别解决的问题" tabindex="-1"><a class="header-anchor" href="#_10-事务隔离级别-mysql默认级别-不同级别解决的问题"><span>10. 事务隔离级别？MySQL默认级别？不同级别解决的问题？</span></a></h3><p><strong>四大隔离级别：</strong></p><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th><th>实现方式</th><th>性能</th></tr></thead><tbody><tr><td>读未提交（READ UNCOMMITTED）</td><td>❌</td><td>❌</td><td>❌</td><td>无锁</td><td>最高</td></tr><tr><td>读已提交（READ COMMITTED）</td><td>✅</td><td>❌</td><td>❌</td><td>行锁+MVCC</td><td>高</td></tr><tr><td>可重复读（REPEATABLE READ）</td><td>✅</td><td>✅</td><td>部分解决</td><td>临键锁+MVCC</td><td>中</td></tr><tr><td>串行化（SERIALIZABLE）</td><td>✅</td><td>✅</td><td>✅</td><td>表锁</td><td>低</td></tr></tbody></table><p><strong>MySQL默认隔离级别</strong>：可重复读（REPEATABLE READ）</p><ul><li>为什么大厂喜欢换成RC？RC解决了脏读问题，但是没有解决幻读问题，幻读问题在RR下可以解决，但是性能开销太大，所以大厂喜欢换成RC，RC的不可重复读可以用乐观锁（时间戳/版本号）或手动加锁解决</li></ul><p><strong>问题说明：</strong></p><ul><li><strong>脏读</strong>：读到其他事务未提交的数据</li><li><strong>不可重复读</strong>：同一事务中多次读取同一数据结果不同</li><li><strong>幻读</strong>：同一事务中多次查询记录数量不同</li></ul><h3 id="_11-如何优化慢查询" tabindex="-1"><a class="header-anchor" href="#_11-如何优化慢查询"><span>11. 如何优化慢查询？</span></a></h3><p><strong>优化策略：</strong></p><table><thead><tr><th>优化方向</th><th>具体方法</th><th>效果评估</th></tr></thead><tbody><tr><td>索引优化</td><td>添加合适索引、优化索引使用</td><td>⭐⭐⭐⭐⭐</td></tr><tr><td>SQL语句优化</td><td>避免SELECT *、减少子查询</td><td>⭐⭐⭐⭐</td></tr><tr><td>分库分表</td><td>水平/垂直分割减少单表数据量</td><td>⭐⭐⭐⭐⭐</td></tr><tr><td>读写分离</td><td>主库写、从库读，减少主库压力</td><td>⭐⭐⭐⭐</td></tr></tbody></table><p><strong>具体优化手段：</strong></p><table><thead><tr><th>方法</th><th>说明</th><th>适用场景</th></tr></thead><tbody><tr><td>添加索引</td><td>为WHERE、ORDER BY字段添加索引</td><td>查询频繁的字段</td></tr><tr><td>优化JOIN</td><td>使用小表驱动大表</td><td>多表关联查询</td></tr><tr><td>避免函数计算</td><td>不在WHERE条件中使用函数</td><td>所有查询</td></tr><tr><td>分页优化</td><td>使用子查询选中ID+索引代替LIMIT大偏移</td><td>深度分页查询</td></tr><tr><td>垂直分表</td><td>将大字段拆分到独立表</td><td>表字段过多</td></tr><tr><td>水平分表</td><td>按规则将数据分散到多个表</td><td>单表数据量过大</td></tr><tr><td>使用缓存</td><td>Redis缓存热点数据</td><td>读多写少场景</td></tr><tr><td>连接池优化</td><td>合理设置连接池参数</td><td>高并发场景</td></tr></tbody></table><h3 id="_12-mysql日志-redo-log、undo-log、binlog" tabindex="-1"><a class="header-anchor" href="#_12-mysql日志-redo-log、undo-log、binlog"><span>12. MySQL日志：redo log、undo log、binlog</span></a></h3><table><thead><tr><th>维度</th><th>Redo Log</th><th>Undo Log</th><th>Binlog</th></tr></thead><tbody><tr><td>层级</td><td>InnoDB 引擎层</td><td>InnoDB 引擎层</td><td>MySQL Server 层</td></tr><tr><td>性质</td><td>物理日志</td><td>逻辑日志</td><td>逻辑日志</td></tr><tr><td>写入时机</td><td>写入前先落盘（WAL）</td><td>修改前生成</td><td>事务提交时一次写入</td></tr><tr><td>用途</td><td>崩溃恢复</td><td>回滚 / MVCC</td><td>复制 / 备份 / 审计</td></tr><tr><td>记录内容</td><td>数据页的物理修改（如某行某页被改成什么）</td><td>数据被修改前的逻辑值（如修改前的一行数据）</td><td>逻辑操作（如 INSERT INTO ...、UPDATE ... 的事件）</td></tr><tr><td>是否刷盘</td><td>事务提交时 fsync 刷盘</td><td>内存日志（非立即刷盘）</td><td>事务提交时 fsync 刷盘</td></tr></tbody></table><ul><li>Redo Log 保证 已提交事务的持久性（crash-safe，物理日志），崩溃恢复时</li><li>Undo Log 用于 事务回滚和 MVCC（逻辑日志）</li><li>Binlog 记录 所有变更用于主从复制和恢复（逻辑日志）</li></ul><h2 id="redis" tabindex="-1"><a class="header-anchor" href="#redis"><span>Redis</span></a></h2><h3 id="_1-redis是什么-常用数据类型及其底层实现和典型应用场景" tabindex="-1"><a class="header-anchor" href="#_1-redis是什么-常用数据类型及其底层实现和典型应用场景"><span>1. Redis是什么？常用数据类型及其底层实现和典型应用场景？</span></a></h3><p><strong>Redis定义：</strong> Redis是一个开源的内存数据结构存储系统，可用作数据库、缓存和消息代理。</p><p><strong>常用数据类型：</strong></p><table><thead><tr><th>数据类型</th><th>底层实现</th><th>典型应用场景</th><th>常用命令</th></tr></thead><tbody><tr><td>String</td><td>SDS（简单动态字符串）</td><td>缓存、计数器、分布式锁</td><td>SET、GET、INCR</td></tr><tr><td>Hash</td><td>压缩列表(ziplist)/哈希表</td><td>用户信息、商品信息</td><td>HSET、HGET、HMGET</td></tr><tr><td>List</td><td>压缩列表(ziplist)/双向链表(linkedlist)</td><td>消息队列、最新消息列表</td><td>LPUSH、RPOP、LRANGE</td></tr><tr><td>Set</td><td>整数集合(intset)/哈希表</td><td>标签、好友关系、唯一性统计</td><td>SADD、SMEMBERS、SINTER</td></tr><tr><td>Sorted Set</td><td>压缩列表(ziplist)/跳跃表(skiplist)+哈希表</td><td>排行榜、延时队列</td><td>ZADD、ZRANGE、ZRANK</td></tr><tr><td>HyperLogLog</td><td>基数估算算法</td><td>UV统计、独立访客统计</td><td>PFADD、PFCOUNT</td></tr><tr><td>Bitmap</td><td>位数组</td><td>用户签到、在线状态</td><td>SETBIT、GETBIT、BITCOUNT</td></tr><tr><td>Geospatial</td><td>Sorted Set + GeoHash</td><td>地理位置、附近的人</td><td>GEOADD、GEORADIUS</td></tr><tr><td>Stream</td><td>Radix Tree + Listpack</td><td>消息流、日志收集</td><td>XADD、XREAD、XGROUP</td></tr></tbody></table><p><strong>ZipList和Listpack的区别：</strong></p><table><thead><tr><th>特性</th><th>Ziplist</th><th>Listpack</th></tr></thead><tbody><tr><td>引入时间</td><td>Redis 早期版本</td><td>Redis 5.0及以后</td></tr><tr><td>设计目标</td><td>内存节省，紧凑存储</td><td>更简洁高效，兼顾内存和性能</td></tr><tr><td>内存布局</td><td>复杂，含多重头部和编码字段</td><td>更简化的编码方式和头部结构</td></tr><tr><td>操作性能</td><td>插入删除时内存移动成本高</td><td>改进了读写性能和内存操作效率</td></tr><tr><td>支持的数据类型</td><td>字符串和整数编码</td><td>更灵活的数据编码（整数、字符串等）</td></tr><tr><td>维护难度</td><td>代码复杂，维护难</td><td>设计简化，易维护</td></tr></tbody></table><ul><li>跳表 = 多层索引链表，查找/插入/删除平均 O(log n)，实现简单，适合高并发场景。</li><li>红黑树和跳表的时间复杂度都是 O(log n)，但红黑树通过旋转维持平衡，代码复杂，范围查询不友好；跳表通过随机化索引维持平衡，实现简单，顺序遍历和范围查询更高效，所以 Redis ZSet 选择了跳表而不是红黑树。</li><li>B+树主要为磁盘优化，减少磁盘 I/O，适合数据库存储；而 Redis 完全基于内存，随机访问代价低，不需要 B+树复杂的页分裂与合并。跳表实现简单，插入删除轻量，范围查询和顺序遍历高效，所以 Redis ZSet 选择了跳表而不是 B+树。</li><li>ZSet的底层结构设计： <ul><li>哈希表提供O(1)的成员查找</li><li>跳跃表提供O(log N)的有序操作</li><li>压缩列表优化小数据集的内存使用</li><li>随机层级保证跳跃表的平衡性</li></ul></li></ul><h3 id="_2-redis为什么快" tabindex="-1"><a class="header-anchor" href="#_2-redis为什么快"><span>2. Redis为什么快？</span></a></h3><p><strong>性能优势分析：</strong></p><table><thead><tr><th>优势</th><th>具体表现</th><th>性能影响</th></tr></thead><tbody><tr><td>内存存储</td><td>数据存储在内存中，避免磁盘I/O</td><td>⭐⭐⭐⭐⭐</td></tr><tr><td>单线程模型</td><td>避免线程切换和锁竞争开销</td><td>⭐⭐⭐⭐</td></tr><tr><td>I/O多路复用</td><td>epoll机制处理并发连接</td><td>⭐⭐⭐⭐</td></tr><tr><td>高效数据结构</td><td>针对不同场景优化的数据结构</td><td>⭐⭐⭐</td></tr><tr><td>简单协议</td><td>RESP协议简单，解析开销小</td><td>⭐⭐⭐</td></tr></tbody></table><p><strong>核心原因：</strong></p><ul><li><strong>纯内存操作</strong>：避免磁盘I/O，速度快10000倍</li><li><strong>单线程避免竞争</strong>：无锁设计，减少上下文切换</li><li><strong>非阻塞I/O</strong>：高效处理大量并发连接</li><li>在Redis6.0之后，为了提升更好的性能，在命令回复处理器使用了多线程来处理回复事件，在命令请求处理器中，将命令的转换使用了多线程，增加命令转换速度，在命令执行的时候，依然是单线程</li></ul><h3 id="_3-redis的持久化机制-优缺点-如何选择" tabindex="-1"><a class="header-anchor" href="#_3-redis的持久化机制-优缺点-如何选择"><span>3. Redis的持久化机制？优缺点？如何选择？</span></a></h3><p><strong>两种持久化方式：</strong></p><table><thead><tr><th>特性</th><th>RDB快照</th><th>AOF日志</th></tr></thead><tbody><tr><td>持久化方式</td><td>定期生成数据快照</td><td>记录每个写操作命令</td></tr><tr><td>文件大小</td><td>紧凑，文件小</td><td>较大，包含所有操作</td></tr><tr><td>恢复速度</td><td>快</td><td>慢</td></tr><tr><td>数据完整性</td><td>可能丢失最后一次快照后的数据</td><td>根据同步策略，丢失较少</td></tr><tr><td>性能影响</td><td>fork子进程时有短暂阻塞</td><td>持续写入，影响相对较小</td></tr><tr><td>适用场景</td><td>对数据丢失不敏感的场景</td><td>对数据完整性要求高的场景</td></tr></tbody></table><p><strong>AOF过大如何处理？</strong></p><table><thead><tr><th>问题</th><th>原因</th><th>解决方案</th><th>说明</th></tr></thead><tbody><tr><td>AOF 文件过大</td><td>累积了大量写命令，无冗余合并</td><td><strong>AOF 重写（BGREWRITEAOF）</strong></td><td>生成精简的AOF文件，去掉冗余命令，减小文件体积</td></tr><tr><td></td><td>高频写入导致日志快速增长</td><td>调整写入策略 <code>appendfsync</code></td><td><code>everysec</code> 权衡性能和安全，避免每次写都同步</td></tr><tr><td></td><td>持久化策略单一</td><td><strong>结合 RDB 快照和 AOF 日志</strong></td><td>加快恢复速度，减少日志回放量</td></tr><tr><td>磁盘占用大</td><td>AOF 文件不断增长</td><td>定期备份和清理旧文件</td><td>防止磁盘满，保障稳定运行</td></tr></tbody></table><p><strong>AOF写入策略</strong></p><table><thead><tr><th>策略</th><th>行为</th><th>优点</th><th>缺点</th><th>可能丢失的数据</th></tr></thead><tbody><tr><td><code>always</code></td><td>每次写命令都立即 <code>fsync</code> 到磁盘</td><td>数据最安全，几乎不丢</td><td>性能最差</td><td>理论上 0</td></tr><tr><td><code>everysec</code>（默认）</td><td>每秒 <code>fsync</code> 一次</td><td>性能和安全折中</td><td>最常用</td><td>最多丢 1 秒的数据</td></tr><tr><td><code>no</code></td><td>由操作系统决定何时刷盘</td><td>性能最好</td><td>安全性最差</td><td>可能丢失几秒甚至更多数据</td></tr></tbody></table><p><strong>选择策略：</strong></p><table><thead><tr><th>场景</th><th>推荐方案</th><th>原因</th></tr></thead><tbody><tr><td>缓存场景</td><td>仅RDB</td><td>数据可重新计算，性能优先</td></tr><tr><td>重要数据存储</td><td>RDB + AOF</td><td>双重保障，确保数据安全</td></tr><tr><td>高写入量场景</td><td>仅RDB</td><td>避免AOF写入影响性能</td></tr><tr><td>数据完整性要求极高的场景</td><td>AOF</td><td>最大程度保证数据不丢失</td></tr></tbody></table><h3 id="_4-redis的过期键删除策略" tabindex="-1"><a class="header-anchor" href="#_4-redis的过期键删除策略"><span>4. Redis的过期键删除策略？</span></a></h3><p><strong>三种删除策略：</strong></p><table><thead><tr><th>策略</th><th>触发时机</th><th>优点</th><th>缺点</th><th>CPU消耗</th><th>内存消耗</th></tr></thead><tbody><tr><td>定时删除</td><td>设置定时器</td><td>内存友好</td><td>CPU消耗大</td><td>高</td><td>低</td></tr><tr><td>惰性删除</td><td>访问时检查</td><td>CPU友好</td><td>内存不友好</td><td>低</td><td>高</td></tr><tr><td>定期删除</td><td>定期随机抽查</td><td>平衡CPU和内存</td><td>可能有漏网之鱼</td><td>中</td><td>中</td></tr></tbody></table><p><strong>Redis实际策略：</strong> 惰性删除 + 定期删除的组合方式</p><h3 id="_5-内存淘汰策略" tabindex="-1"><a class="header-anchor" href="#_5-内存淘汰策略"><span>5. 内存淘汰策略？</span></a></h3><p><strong>8种淘汰策略：</strong></p><table><thead><tr><th>策略</th><th>作用范围</th><th>淘汰算法</th><th>适用场景</th></tr></thead><tbody><tr><td>noeviction</td><td>无</td><td>不淘汰</td><td>内存足够，不希望数据丢失</td></tr><tr><td>allkeys-lru</td><td>所有key</td><td>LRU最近最少使用</td><td>通用缓存，访问有热点</td></tr><tr><td>volatile-lru</td><td>有过期时间的key</td><td>LRU</td><td>只淘汰临时数据</td></tr><tr><td>allkeys-random</td><td>所有key</td><td>随机</td><td>访问模式均匀</td></tr><tr><td>volatile-random</td><td>有过期时间的key</td><td>随机</td><td>临时数据访问均匀</td></tr><tr><td>volatile-ttl</td><td>有过期时间的key</td><td>TTL最短优先</td><td>希望快到期的数据先删除</td></tr><tr><td>allkeys-lfu</td><td>所有key</td><td>LFU最少使用频率</td><td>访问频率差异明显</td></tr><tr><td>volatile-lfu</td><td>有过期时间的key</td><td>LFU</td><td>临时数据访问频率差异明显</td></tr></tbody></table><p><strong>推荐选择：</strong></p><ul><li><strong>通用场景</strong>：allkeys-lru（最常用）</li><li><strong>只缓存场景</strong>：volatile-lru</li><li><strong>混合数据</strong>：volatile-ttl</li></ul><h3 id="_6-如何保证redis的高可用-redis-cluster的槽分配原理" tabindex="-1"><a class="header-anchor" href="#_6-如何保证redis的高可用-redis-cluster的槽分配原理"><span>6. 如何保证Redis的高可用？Redis Cluster的槽分配原理？</span></a></h3><p><strong>高可用方案：</strong></p><table><thead><tr><th>方案</th><th>特点</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>主从复制</td><td>一主多从，读写分离</td><td>简单，读性能好</td><td>主节点单点故障</td><td>读多写少</td></tr><tr><td>哨兵模式</td><td>自动故障转移</td><td>高可用，自动切换</td><td>配置复杂</td><td>中小型应用</td></tr><tr><td>Redis Cluster</td><td>分布式，无中心节点</td><td>高可用+高性能</td><td>运维复杂</td><td>大型分布式应用</td></tr></tbody></table><p><strong>Redis Cluster槽分配：</strong></p><ul><li><strong>总槽数</strong>：16384个槽（0-16383） = 2^14 既不太小（保证分片粒度），又不会太大（避免管理复杂）方便用位运算和取模计算键对应的槽</li><li><strong>分配原理</strong>：CRC16(key) % 16384</li><li><strong>槽分布</strong>：平均分配到各个主节点</li><li><strong>数据分片</strong>：根据key计算槽位，找到对应节点</li></ul><table><thead><tr><th>集群规模</th><th>节点配置</th><th>槽分配示例</th></tr></thead><tbody><tr><td>3主3从</td><td>每主1从</td><td>0-5460, 5461-10922, 10923-16383</td></tr><tr><td>6主6从</td><td>每主1从</td><td>每个主节点约2730个槽</td></tr><tr><td>9主9从</td><td>每主1从</td><td>每个主节点约1820个槽</td></tr></tbody></table><h3 id="_7-缓存穿透、缓存击穿、缓存雪崩的概念、原因及解决方案" tabindex="-1"><a class="header-anchor" href="#_7-缓存穿透、缓存击穿、缓存雪崩的概念、原因及解决方案"><span>7. 缓存穿透、缓存击穿、缓存雪崩的概念、原因及解决方案？</span></a></h3><p><strong>三大缓存问题对比：</strong></p><table><thead><tr><th>问题类型</th><th>定义</th><th>原因分析</th><th>解决方案</th></tr></thead><tbody><tr><td>缓存穿透</td><td>查询不存在的数据，缓存和数据库都没有</td><td>恶意攻击、业务逻辑错误</td><td>布隆过滤器、空值缓存、参数校验</td></tr><tr><td>缓存击穿</td><td>热点数据过期，大量请求同时访问数据库</td><td>热点key过期</td><td>互斥锁、热点数据永不过期、提前更新、逻辑过期</td></tr><tr><td>缓存雪崩</td><td>大量缓存同时过期，数据库压力剧增</td><td>缓存集中过期、Redis宕机</td><td>过期时间随机化、熔断降级、多级缓存、集群部署</td></tr></tbody></table><p><strong>详细解决方案：</strong></p><table><thead><tr><th>解决方案</th><th>实现方式</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>布隆过滤器</td><td>位数组+多个hash函数</td><td>内存占用小，查询快</td><td>存在误判，不支持删除</td></tr><tr><td>空值缓存</td><td>对空结果设置较短过期时间</td><td>简单有效</td><td>占用内存</td></tr><tr><td>互斥锁</td><td>只允许一个线程查询数据库</td><td>避免重复查询</td><td>可能造成阻塞</td></tr><tr><td>熔断降级</td><td>失败率超过阈值时停止访问</td><td>保护系统</td><td>可能影响用户体验</td></tr></tbody></table><h3 id="_8-如何设计一个分布式锁-watch-dog机制" tabindex="-1"><a class="header-anchor" href="#_8-如何设计一个分布式锁-watch-dog机制"><span>8. 如何设计一个分布式锁？Watch Dog机制？</span></a></h3><p><strong>分布式锁实现要点：</strong></p><table><thead><tr><th>要求</th><th>Redis实现方式</th><th>说明</th></tr></thead><tbody><tr><td>互斥性</td><td>SET key value NX EX</td><td>NX确保原子性设置</td></tr><tr><td>防死锁</td><td>设置过期时间</td><td>避免持锁进程崩溃导致死锁</td></tr><tr><td>防误删</td><td>删除时校验value</td><td>确保只能删除自己的锁</td></tr><tr><td>可重入</td><td>记录线程ID和重入次数</td><td>支持同一线程多次获取锁</td></tr><tr><td>阻塞等待</td><td>循环尝试获取锁</td><td>获取失败时等待重试</td></tr></tbody></table><p><strong>Watch Dog机制：</strong></p><table><thead><tr><th>特性</th><th>实现原理</th><th>作用</th></tr></thead><tbody><tr><td>自动续期</td><td>定时任务延长锁过期时间</td><td>防止业务执行时间超过锁过期时间</td></tr><tr><td>续期条件</td><td>锁仍被当前线程持有</td><td>避免给其他线程的锁续期</td></tr><tr><td>续期时间</td><td>通常为锁过期时间的1/3</td><td>保证在锁过期前完成续期</td></tr><tr><td>停止条件</td><td>锁被释放或线程结束</td><td>避免无限续期</td></tr></tbody></table><p><strong>方案对比：</strong></p><table><thead><tr><th>实现方案</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>单Redis节点</td><td>简单，性能好</td><td>单点故障</td><td>对可用性要求不高</td></tr><tr><td>Redis集群</td><td>高可用</td><td>脑裂时可能出现多个锁</td><td>一般业务场景</td></tr><tr><td>Redlock算法</td><td>更高的安全性</td><td>复杂，性能较差</td><td>对数据一致性要求极高</td></tr><tr><td>ZooKeeper</td><td>强一致性，自动续期</td><td>性能较差，依赖ZK集群</td><td>强一致性要求</td></tr></tbody></table><h3 id="_9-redis哨兵的原理-如何实现故障转移" tabindex="-1"><a class="header-anchor" href="#_9-redis哨兵的原理-如何实现故障转移"><span>9. Redis哨兵的原理？如何实现故障转移？</span></a></h3><p><strong>Redis哨兵定义：</strong> Redis Sentinel是Redis官方提供的高可用解决方案，用于监控Redis主从复制集群，并在主节点故障时自动进行故障转移。</p><p><strong>核心功能：</strong></p><table><thead><tr><th>功能</th><th>描述</th><th>作用</th><th>实现方式</th></tr></thead><tbody><tr><td>监控</td><td>持续监控主从节点的健康状态</td><td>及时发现节点故障</td><td>定期发送PING命令</td></tr><tr><td>通知</td><td>当节点状态发生变化时通知管理员</td><td>提供故障告警</td><td>发布订阅机制</td></tr><tr><td>自动故障转移</td><td>主节点故障时自动选举新的主节点</td><td>保证服务持续可用</td><td>选举算法+配置更新</td></tr><tr><td>配置提供</td><td>为客户端提供当前主节点信息</td><td>客户端自动连接到正确的主节点</td><td>服务发现机制</td></tr></tbody></table><p><strong>哨兵工作原理：</strong></p><table><thead><tr><th>阶段</th><th>工作内容</th><th>判断条件</th><th>处理方式</th></tr></thead><tbody><tr><td>主观下线</td><td>单个哨兵认为主节点不可用</td><td>超过down-after-milliseconds时间未响应</td><td>标记为SDOWN</td></tr><tr><td>客观下线</td><td>多个哨兵确认主节点不可用</td><td>达到quorum数量的哨兵确认主观下线</td><td>标记为ODOWN并开始故障转移</td></tr><tr><td>领导者选举</td><td>选出负责故障转移的哨兵</td><td>Raft算法选举</td><td>获得majority票数的哨兵成为领导者</td></tr><tr><td>故障转移</td><td>将从节点提升为新的主节点</td><td>领导者哨兵执行转移流程</td><td>更新配置并通知所有节点</td></tr></tbody></table><p><strong>故障转移详细流程：</strong></p><table><thead><tr><th>步骤</th><th>操作</th><th>目的</th><th>注意事项</th></tr></thead><tbody><tr><td>1</td><td>从从节点中选择新的主节点</td><td>选出最适合的节点</td><td>考虑优先级、复制偏移量、运行ID</td></tr><tr><td>2</td><td>向选中的从节点发送SLAVEOF NO ONE</td><td>将从节点提升为主节点</td><td>确保命令执行成功</td></tr><tr><td>3</td><td>向其他从节点发送SLAVEOF命令</td><td>让其他从节点跟随新主节点</td><td>更新主从关系</td></tr><tr><td>4</td><td>更新哨兵配置文件</td><td>记录新的主节点信息</td><td>持久化配置变更</td></tr><tr><td>5</td><td>向客户端发布新主节点信息</td><td>通知客户端连接新主节点</td><td>通过发布订阅机制</td></tr></tbody></table><p><strong>从节点选择策略：</strong></p><table><thead><tr><th>优先级</th><th>选择条件</th><th>权重</th><th>说明</th></tr></thead><tbody><tr><td>第一优先级</td><td>slave-priority最高</td><td>最高</td><td>手动设置的优先级</td></tr><tr><td>第二优先级</td><td>复制偏移量最大</td><td>高</td><td>数据最新的从节点</td></tr><tr><td>第三优先级</td><td>运行ID最小</td><td>中</td><td>启动时间最早的从节点</td></tr><tr><td>排除条件</td><td>主观下线、断线时间过长、INFO_REPL响应异常</td><td>无</td><td>不健康的节点不参与选举</td></tr></tbody></table><p><strong>优缺点对比：</strong></p><table><thead><tr><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>自动故障转移</td><td>配置相对复杂</td><td>中小型应用</td></tr><tr><td>高可用性</td><td>脑裂问题</td><td>对可用性要求高的系统</td></tr><tr><td>支持多个从节点</td><td>数据可能短暂不一致</td><td>读多写少的业务</td></tr><tr><td>客户端透明</td><td>需要至少3个哨兵节点</td><td>单机房部署</td></tr><tr><td>成熟稳定</td><td>不支持数据分片</td><td>数据量不是特别大的场景</td></tr></tbody></table><p><strong>与其他方案对比：</strong></p><table><thead><tr><th>特性</th><th>Redis哨兵</th><th>Redis Cluster</th><th>主从复制</th></tr></thead><tbody><tr><td>高可用性</td><td>自动故障转移</td><td>自动故障转移</td><td>手动故障转移</td></tr><tr><td>数据分片</td><td>不支持</td><td>支持</td><td>不支持</td></tr><tr><td>配置复杂度</td><td>中等</td><td>高</td><td>低</td></tr><tr><td>客户端支持</td><td>需要支持哨兵协议</td><td>需要支持集群协议</td><td>标准Redis协议</td></tr><tr><td>适用规模</td><td>中小型</td><td>大型</td><td>小型</td></tr><tr><td>数据一致性</td><td>最终一致性</td><td>最终一致性</td><td>最终一致性</td></tr></tbody></table><p><strong>最佳实践：</strong></p><table><thead><tr><th>实践建议</th><th>具体做法</th><th>原因</th></tr></thead><tbody><tr><td>奇数个哨兵节点</td><td>部署3个或5个哨兵</td><td>避免脑裂，确保能选出领导者</td></tr><tr><td>分布式部署</td><td>哨兵部署在不同的物理机器上</td><td>提高容灾能力</td></tr><tr><td>合理设置quorum</td><td>一般设置为哨兵数量的一半+1</td><td>平衡误判和可用性</td></tr><tr><td>监控哨兵状态</td><td>监控哨兵进程和日志</td><td>确保哨兵本身的可用性</td></tr><tr><td>客户端连接池配置</td><td>配置哨兵地址而非直接连接Redis</td><td>实现自动故障转移</td></tr></tbody></table><h3 id="_10-缓存和数据库的一致性" tabindex="-1"><a class="header-anchor" href="#_10-缓存和数据库的一致性"><span>10. 缓存和数据库的一致性？</span></a></h3><table><thead><tr><th>不一致原因</th><th>说明</th><th>解决方案</th></tr></thead><tbody><tr><td><strong>缓存淘汰/过期</strong></td><td>Redis 设置了 TTL 或被 LRU 淘汰，但数据库数据还在</td><td>设置合理的过期时间，关键数据加定时刷新；缓存预热</td></tr><tr><td><strong>更新顺序错误</strong></td><td>先更新缓存后更新数据库，或更新数据库后未及时删除缓存</td><td>采用 <strong>Cache Aside 模式</strong>：先更新数据库 → 再删除缓存</td></tr><tr><td><strong>缓存删除失败</strong></td><td>数据库已更新，但删除缓存操作失败（网络/异常）</td><td>使用 <strong>延时双删</strong>：更新库 → 删除缓存 → 延时几百 ms 再删一次</td></tr><tr><td><strong>并发更新</strong></td><td>多线程并发写，旧数据可能覆盖新数据</td><td>使用分布式锁（如 Redis setnx）、乐观锁机制，保证写顺序</td></tr><tr><td><strong>异步延迟</strong></td><td>通过 MQ 或 Canal 异步删除缓存，可能存在延迟</td><td>设置缓存短 TTL；结合延时双删减少窗口期</td></tr><tr><td><strong>主从延迟</strong></td><td>数据库主从同步延迟，应用读从库而缓存用的是新值</td><td>读强一致场景下读主库；或缓存更新基于 binlog（Canal）保证最终一致性</td></tr><tr><td><strong>业务异常</strong></td><td>代码遗漏更新缓存，或异常提前返回</td><td>统一封装数据更新逻辑；引入中间件保证可靠投递（如 Outbox 模式）</td></tr></tbody></table><p>总结：<strong>没有完美解决方案</strong>，通常要结合 <strong>Cache Aside + 延时双删 + 消息队列/Canal</strong> 来提升一致性。</p><h4 id="常见方法总结" tabindex="-1"><a class="header-anchor" href="#常见方法总结"><span>常见方法总结</span></a></h4><table><thead><tr><th>方法名称</th><th>核心逻辑</th><th>适用场景</th><th>一致性级别</th><th>性能影响</th><th>复杂度</th></tr></thead><tbody><tr><td>Cache Aside（旁路缓存）</td><td>读：缓存→数据库（未命中则更新缓存）；写：数据库→删除缓存</td><td>读多写少、对一致性要求不严格（允许短暂不一致）的场景（如商品详情、新闻资讯）</td><td>弱一致性（短暂）</td><td>读性能高，写操作需删缓存</td><td>简单</td></tr><tr><td>Read/Write Through</td><td>应用只与缓存交互，缓存负责同步数据库（读穿透加载数据库数据到缓存；写穿透同步更新数据库）</td><td>对一致性要求较高，且缓存中间件支持该模式的场景</td><td>强一致性</td><td>性能受限于缓存与数据库同步效率</td><td>复杂</td></tr><tr><td>Write Back（写回）</td><td>写操作只更新缓存，缓存异步批量更新数据库</td><td>写操作频繁、对写性能要求极高，且能容忍短期数据不一致的场景（如日志系统）</td><td>最终一致性</td><td>写性能极高，存在数据丢失风险</td><td>复杂</td></tr><tr><td>延时双删</td><td>写操作：更新数据库→删缓存→延迟后再删缓存</td><td>高并发读写场景（如电商库存、价格更新），需平衡延迟时间</td><td>较好的一致性</td><td>有延迟等待，影响并发性能</td><td>中等</td></tr><tr><td>分布式锁 + 串行化</td><td>通过分布式锁将读写操作串行化，确保同一数据的读写不并发</td><td>对一致性要求极高（不允许任何不一致），可接受性能损耗的场景（如金融交易）</td><td>强一致性</td><td>并发性能低，有锁竞争风险</td><td>复杂</td></tr><tr><td>binlog 同步</td><td>监听数据库 binlog，异步同步数据到缓存</td><td>读写分离、分布式系统，追求最终一致性且不想侵入业务代码的场景（如微服务）</td><td>最终一致性</td><td>存在同步延迟</td><td>中等</td></tr><tr><td>缓存过期时间兜底</td><td>为缓存设置合理过期时间，到期自动失效</td><td>所有场景，作为其他一致性方案的补充，避免永久不一致</td><td>最终一致性</td><td>无额外性能影响</td><td>简单</td></tr></tbody></table><h3 id="_11-zset排行榜-大key问题如何解决" tabindex="-1"><a class="header-anchor" href="#_11-zset排行榜-大key问题如何解决"><span>11. Zset排行榜？大Key问题如何解决？</span></a></h3><h4 id="zset-实现排行榜的常规思路" tabindex="-1"><a class="header-anchor" href="#zset-实现排行榜的常规思路"><span>ZSET 实现排行榜的常规思路</span></a></h4><ul><li>使用 <strong>分数 (score)</strong> 表示排名依据（如积分、分数、时间戳）。</li><li>使用 <strong>成员 (member)</strong> 表示用户或对象 ID。</li></ul><p>常用命令：</p><ul><li><code>ZADD key score member</code> → 插入/更新分数</li><li><code>ZRANGE key 0 9 WITHSCORES</code> → 获取前 10 名</li><li><code>ZREVRANK key member</code> → 获取某用户排名</li><li><code>ZREVRANGE key start end WITHSCORES</code> → 获取排名区间</li></ul><h4 id="大-key-问题" tabindex="-1"><a class="header-anchor" href="#大-key-问题"><span>大 Key 问题</span></a></h4><ul><li><p>排行榜里可能有 <strong>百万级甚至千万级用户</strong>，导致：</p><ul><li><strong>内存占用过大</strong>（单个 ZSET 占用几十 MB 甚至上百 MB）</li><li><strong>操作耗时长</strong>（排名、范围查询需要更多计算）</li><li><strong>持久化和迁移困难</strong>（RDB/AOF 写盘压力大）</li></ul></li></ul><table><thead><tr><th>方案</th><th>实现思路</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>分桶 (Sharding)</strong></td><td>按用户ID Hash 或地域分成多个 ZSET</td><td>避免大 Key，支持水平扩展</td><td>查询 Top-N 需聚合多个桶，复杂度高</td><td>千万级以上用户规模，分区/区服排行榜</td></tr><tr><td><strong>分段存储</strong></td><td>只保留前 N 名在 Redis，其余放 DB/冷存储</td><td>高频查询快，降低 Redis 内存占用</td><td>非 Top-N 查询需查 DB，数据同步成本高</td><td>电竞积分榜、只关心头部的场景</td></tr><tr><td><strong>Top-N 缓存 + 全量 DB</strong></td><td>Redis 存 Top-N，数据库存全量</td><td>内存压力小，热点查询快</td><td>长尾查询性能差，需要跨存储</td><td>普通应用，只关注前几百/几千名</td></tr><tr><td><strong>分布式排行榜</strong></td><td>Redis Cluster 或自研分片，多实例存储</td><td>支持超大规模并发，高可用</td><td>排名聚合复杂，需额外一致性保证</td><td>超大规模高并发系统（百万+ QPS）</td></tr><tr><td><strong>近似排名</strong></td><td>分桶计数，桶内再排序（概率近似）</td><td>内存消耗小，性能好，对大规模用户友好</td><td>排名不精确，适合近似计算场景</td><td>活跃度排行、社交热度榜等不需严格名次的业务</td></tr><tr><td><strong>单 ZSET</strong></td><td>全量存一个 ZSET</td><td>实现简单，Redis API 直接支持</td><td>大 Key 问题，内存消耗大，不适合大规模</td><td>小规模榜单（几十万以内）</td></tr></tbody></table><ul><li>大key删除为了防止阻塞，可以用unlink异步删除</li></ul><h2 id="jvm" tabindex="-1"><a class="header-anchor" href="#jvm"><span>JVM</span></a></h2><figure><img src="'+a+'" alt="JVM" tabindex="0" loading="lazy"><figcaption>JVM</figcaption></figure><h3 id="_1-jvm内存结构-各个区域的作用" tabindex="-1"><a class="header-anchor" href="#_1-jvm内存结构-各个区域的作用"><span>1. JVM内存结构？各个区域的作用？</span></a></h3><p><strong>JVM内存模型：</strong></p><table><thead><tr><th>内存区域</th><th>线程私有/共享</th><th>作用</th><th>存储内容</th><th>是否会OOM</th></tr></thead><tbody><tr><td>程序计数器</td><td>私有</td><td>记录当前线程执行字节码位置</td><td>字节码行号指示器</td><td>否</td></tr><tr><td>虚拟机栈</td><td>私有</td><td>存储方法调用的栈帧</td><td>局部变量、操作数栈、方法返回地址</td><td>是(StackOverflowError)</td></tr><tr><td>本地方法栈</td><td>私有</td><td>为native方法服务</td><td>native方法调用栈</td><td>是</td></tr><tr><td>堆内存</td><td>共享</td><td>存储对象实例</td><td>对象实例、数组</td><td>是(OutOfMemoryError)</td></tr><tr><td>方法区/元空间</td><td>共享</td><td>存储类信息、常量、静态变量</td><td>类元数据、常量池、静态变量</td><td>是</td></tr><tr><td>直接内存</td><td>共享</td><td>NIO操作、堆外内存</td><td>DirectByteBuffer等</td><td>是</td></tr></tbody></table><p><strong>堆内存详细结构：</strong></p><table><thead><tr><th>区域</th><th>Java8前</th><th>Java8后</th><th>作用</th><th>GC频率</th></tr></thead><tbody><tr><td>新生代</td><td>Eden + Survivor(S0,S1)</td><td>同左</td><td>新对象分配</td><td>频繁</td></tr><tr><td>老年代</td><td>Old Generation</td><td>同左</td><td>长期存活对象</td><td>较少</td></tr><tr><td>永久代</td><td>PermGen</td><td>已移除</td><td>类元数据(Java8前)</td><td>很少</td></tr><tr><td>元空间</td><td>不存在</td><td>Metaspace</td><td>类元数据(Java8后)</td><td>很少</td></tr></tbody></table><p><strong>永久代和元空间对比：</strong></p><table><thead><tr><th>特性</th><th>永久代 (PermGen)</th><th>元空间 (Metaspace)</th></tr></thead><tbody><tr><td>存放位置</td><td>JVM 堆内</td><td>本地内存</td></tr><tr><td>管理方式</td><td>固定大小</td><td>按需增长</td></tr><tr><td>出现版本</td><td>Java 7 及以前</td><td>Java 8 及以后</td></tr><tr><td>OOM 报错</td><td><code>OutOfMemoryError: PermGen space</code></td><td><code>OutOfMemoryError: Metaspace</code></td></tr></tbody></table><ul><li>Java 8 把永久代移到本地内存，变成元空间，解决了因固定大小导致的 OOM 问题，但如果类加载过多，元空间仍可能撑爆物理内存。</li></ul><p><strong>分代收集策略：</strong></p><table><thead><tr><th>策略</th><th>原理</th><th>优势</th><th>典型场景</th></tr></thead><tbody><tr><td>新生代</td><td>大多数对象朝生夕死</td><td>使用复制算法，效率高</td><td>频繁创建的临时对象</td></tr><tr><td>老年代</td><td>对象存活时间长</td><td>使用标记-清除或标记-整理</td><td>长期使用的对象</td></tr><tr><td>跨代引用</td><td>记忆集(Remembered Set)</td><td>避免全堆扫描</td><td>老年代引用新生代</td></tr></tbody></table><h3 id="_2-垃圾回收算法-各自的优缺点" tabindex="-1"><a class="header-anchor" href="#_2-垃圾回收算法-各自的优缺点"><span>2. 垃圾回收算法？各自的优缺点？</span></a></h3><p><strong>四大垃圾回收算法：</strong></p><table><thead><tr><th>算法</th><th>原理</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>标记-清除</td><td>标记垃圾对象，然后清除</td><td>简单，不需要移动对象</td><td>产生内存碎片，效率低</td><td>老年代</td></tr><tr><td>复制算法</td><td>将存活对象复制到另一块内存</td><td>效率高，无内存碎片</td><td>浪费一半内存空间</td><td>新生代</td></tr><tr><td>标记-整理</td><td>标记后将存活对象向一端移动</td><td>无内存碎片，空间利用率高</td><td>移动对象开销大</td><td>老年代</td></tr><tr><td>分代收集</td><td>不同代使用不同算法</td><td>结合各算法优点</td><td>实现复杂</td><td>整个堆内存</td></tr></tbody></table><p><strong>算法详细对比：</strong></p><table><thead><tr><th>对比维度</th><th>标记-清除</th><th>复制算法</th><th>标记-整理</th><th>分代收集</th></tr></thead><tbody><tr><td>时间复杂度</td><td>O(n)</td><td>O(存活对象数)</td><td>O(n)</td><td>取决于具体算法</td></tr><tr><td>空间复杂度</td><td>无额外要求</td><td>需要双倍空间</td><td>无额外要求</td><td>根据分代策略</td></tr><tr><td>内存碎片</td><td>有</td><td>无</td><td>无</td><td>新生代无，老年代可能有</td></tr><tr><td>效率</td><td>中等</td><td>高(存活率低时)</td><td>低</td><td>整体较高</td></tr></tbody></table><p><strong>对象分配过程：</strong></p><table><thead><tr><th>步骤</th><th>操作</th><th>说明</th><th>异常情况</th></tr></thead><tbody><tr><td>1</td><td>Eden区分配</td><td>新对象优先在Eden区分配</td><td>Eden区满时触发Minor GC</td></tr><tr><td>2</td><td>Survivor区</td><td>GC后存活对象进入Survivor</td><td>两个Survivor区交替使用</td></tr><tr><td>3</td><td>年龄增长</td><td>GC后对象年龄+1</td><td>默认15岁进入老年代</td></tr><tr><td>4</td><td>老年代</td><td>长期存活或大对象进入老年代</td><td>老年代满时触发Major GC</td></tr><tr><td>5</td><td>晋升失败</td><td>老年代空间不足</td><td>触发Full GC</td></tr></tbody></table><h3 id="_3-常见垃圾回收器-特点和使用场景" tabindex="-1"><a class="header-anchor" href="#_3-常见垃圾回收器-特点和使用场景"><span>3. 常见垃圾回收器？特点和使用场景？</span></a></h3><p><strong>垃圾回收器发展历程：</strong></p><table><thead><tr><th>回收器</th><th>发布版本</th><th>类型</th><th>特点</th><th>适用场景</th><th>停顿时间</th></tr></thead><tbody><tr><td>Serial</td><td>JDK1.3+</td><td>串行</td><td>单线程，简单稳定</td><td>小型应用、客户端</td><td>较长</td></tr><tr><td>ParNew</td><td>JDK1.4+</td><td>并行</td><td>Serial的多线程版本</td><td>配合CMS使用</td><td>中等</td></tr><tr><td>Parallel Scavenge</td><td>JDK1.4+</td><td>并行</td><td>关注吞吐量</td><td>后台计算任务</td><td>中等</td></tr><tr><td>CMS</td><td>JDK1.5+</td><td>并发</td><td>低延迟，并发收集</td><td>响应时间敏感应用</td><td>短</td></tr><tr><td>G1</td><td>JDK1.7+</td><td>低延迟</td><td>可预测停顿时间</td><td>大堆内存应用</td><td>可控</td></tr></tbody></table><p><strong>收集器组合使用：</strong></p><table><thead><tr><th>新生代收集器</th><th>老年代收集器</th><th>特点</th><th>推荐场景</th></tr></thead><tbody><tr><td>Serial</td><td>Serial Old</td><td>全串行</td><td>小型应用</td></tr><tr><td>ParNew</td><td>CMS</td><td>低延迟组合</td><td>Web应用</td></tr><tr><td>Parallel Scavenge</td><td>Parallel Old</td><td>高吞吐量组合</td><td>批处理应用</td></tr><tr><td>G1</td><td>G1</td><td>统一收集器</td><td>大内存应用</td></tr></tbody></table><p><strong>G1垃圾回收器详解：</strong></p><ul><li>划分成多个区域，每个区域都可以充当 eden，survivor，old，humongous，其中 humongous 专为大对象准备</li><li>采用标记整理算法</li><li>响应时间与吞吐量兼顾</li><li>分成三个阶段：<strong>新生代回收</strong>（Minor GC）主要清理新生代；<strong>并发标记</strong>（CMS/并发标记阶段）在应用线程运行时标记存活对象，减少停顿；<strong>混合收集</strong>（Mixed GC）在 G1 中既回收新生代也回收部分老年代，兼顾吞吐和延迟。</li><li>如果并发失败（即回收速度赶不上创建新对象速度），会触发 Full GC</li><li>判断两个 G1 Region 是否有关联的核心思路是： <ul><li>是否存在对象引用跨越这两个 Region</li><li>使用 Remembered Set 或 GC 遍历引用图 来判断</li></ul></li></ul><table><thead><tr><th>特性</th><th>说明</th><th>优势</th><th>适用条件</th></tr></thead><tbody><tr><td>Region概念</td><td>将堆分为多个固定大小区域</td><td>可预测停顿时间</td><td>堆内存&gt;4GB</td></tr><tr><td>混合收集</td><td>同时收集新生代和老年代</td><td>整体效率高</td><td>需要调优参数</td></tr><tr><td>并发标记</td><td>与应用线程同时进行</td><td>减少停顿时间</td><td>CPU资源充足</td></tr><tr><td>记忆集</td><td>跨Region引用记录</td><td>避免全堆扫描</td><td>内存开销可接受</td></tr></tbody></table><h3 id="_4-类加载机制-双亲委派模型" tabindex="-1"><a class="header-anchor" href="#_4-类加载机制-双亲委派模型"><span>4. 类加载机制？双亲委派模型？</span></a></h3><p><strong>类加载过程：</strong></p><table><thead><tr><th>阶段</th><th>操作</th><th>说明</th><th>可逆性</th></tr></thead><tbody><tr><td>加载(Loading)</td><td>读取class文件到内存</td><td>通过类加载器读取字节码</td><td>否</td></tr><tr><td>验证(Verification)</td><td>验证字节码正确性</td><td>确保class文件符合JVM规范</td><td>否</td></tr><tr><td>准备(Preparation)</td><td>为静态变量分配内存</td><td>设置默认初始值</td><td>否</td></tr><tr><td>解析(Resolution)</td><td>符号引用转直接引用</td><td>将常量池符号引用解析为直接引用</td><td>是</td></tr><tr><td>初始化(Initialization)</td><td>执行静态代码块</td><td><code>执行&lt;clinit&gt;方法</code></td><td>否</td></tr></tbody></table><p><strong>双亲委派模型：</strong></p><table><thead><tr><th>类加载器</th><th>层级</th><th>加载内容</th><th>特点</th></tr></thead><tbody><tr><td>Bootstrap ClassLoader</td><td>顶层</td><td>JDK核心类库(rt.jar等)</td><td>C++实现，无父加载器</td></tr><tr><td>Extension ClassLoader</td><td>扩展</td><td>JDK扩展类库(ext目录)</td><td>Java实现</td></tr><tr><td>Application ClassLoader</td><td>应用</td><td>应用程序类路径</td><td>默认类加载器</td></tr><tr><td>Custom ClassLoader</td><td>自定义</td><td>特定需求的类</td><td>用户自定义</td></tr></tbody></table><p><strong>双亲委派优势：</strong></p><table><thead><tr><th>优势</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td>避免重复加载</td><td>父加载器已加载的类不会重复加载</td><td>java.lang.Object只加载一次</td></tr><tr><td>安全性</td><td>核心类库不会被替换</td><td>无法自定义java.lang.String</td></tr><tr><td>一致性</td><td>保证类的唯一性</td><td>同一个类在JVM中只有一份</td></tr></tbody></table><p><strong>破坏双亲委派：</strong></p><table><thead><tr><th>方面</th><th>说明</th><th>具体原因/场景</th></tr></thead><tbody><tr><td><strong>双亲委派机制定义</strong></td><td>类加载时，先委托父加载器加载，父加载失败才自己加载</td><td>保证核心类库统一加载，防止篡改</td></tr><tr><td><strong>破坏双亲委派含义</strong></td><td>跳过父加载器，自己优先加载指定类</td><td>破坏父子加载器顺序，自己先加载</td></tr><tr><td><strong>主要目的</strong></td><td>实现热部署、版本隔离、定制类加载逻辑</td><td>热更新、插件隔离、多版本共存</td></tr><tr><td><strong>应用场景</strong></td><td>1. 热部署 / 热更新<br>2. 多版本依赖隔离<br>3. 动态类加载<br>4. 解决第三方库冲突</td><td>应用服务器插件加载，复杂框架，自定义加载</td></tr><tr><td><strong>实现方式</strong></td><td>重写 <code>loadClass</code> 方法，优先自己加载特定类</td><td>自定义类加载器代码逻辑</td></tr><tr><td><strong>优点</strong></td><td>灵活控制加载过程，支持热更新和版本共存</td><td>应对复杂应用需求</td></tr><tr><td><strong>风险和缺点</strong></td><td>可能破坏安全性，导致类不兼容（ClassCastException），难以调试</td><td>影响系统稳定，带来潜在风险</td></tr></tbody></table><h3 id="_5-jvm参数调优-常用参数" tabindex="-1"><a class="header-anchor" href="#_5-jvm参数调优-常用参数"><span>5. JVM参数调优？常用参数？</span></a></h3><p><strong>JVM参数分类：</strong></p><table><thead><tr><th>参数类型</th><th>格式</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>标准参数</td><td>-xxx</td><td>稳定，各版本通用</td><td>-cp, -classpath</td></tr><tr><td>非标准参数</td><td>-Xxxx</td><td>默认JVM实现，可能变化</td><td>-Xms, -Xmx</td></tr><tr><td>不稳定参数</td><td>-XX:xxx</td><td>特定JVM实现，可能移除</td><td>-XX:+UseG1GC</td></tr></tbody></table><p><strong>内存相关参数：</strong></p><table><thead><tr><th>参数</th><th>作用</th><th>建议值</th><th>说明</th></tr></thead><tbody><tr><td>-Xms</td><td>初始堆大小</td><td>与-Xmx相同</td><td>避免动态扩容</td></tr><tr><td>-Xmx</td><td>最大堆大小</td><td>系统内存的70-80%</td><td>预留给系统和其他进程</td></tr><tr><td>-Xmn</td><td>新生代大小</td><td>堆内存的1/3-1/2</td><td>根据对象存活时间调整</td></tr><tr><td>-XX:MetaspaceSize</td><td>元空间初始大小</td><td>128M-256M</td><td>Java8+替代PermGen</td></tr><tr><td>-XX:MaxMetaspaceSize</td><td>元空间最大大小</td><td>不设置(无限制)</td><td>避免内存泄漏</td></tr><tr><td>-Xss</td><td>线程栈大小</td><td>256k-1M</td><td>根据递归深度调整</td></tr></tbody></table><p><strong>垃圾回收器参数：</strong></p><table><thead><tr><th>参数</th><th>作用</th><th>适用场景</th><th>注意事项</th></tr></thead><tbody><tr><td>-XX:+UseSerialGC</td><td>使用Serial收集器</td><td>小型应用</td><td>单线程</td></tr><tr><td>-XX:+UseParallelGC</td><td>使用Parallel收集器</td><td>吞吐量优先</td><td>JDK8默认</td></tr><tr><td>-XX:+UseConcMarkSweepGC</td><td>使用CMS收集器</td><td>低延迟</td><td>JDK9标记废弃</td></tr><tr><td>-XX:+UseG1GC</td><td>使用G1收集器</td><td>大堆内存</td><td>JDK9+默认</td></tr><tr><td>-XX:MaxGCPauseMillis</td><td>最大GC停顿时间</td><td>G1收集器</td><td>仅为目标值</td></tr></tbody></table><p><strong>性能监控参数：</strong></p><table><thead><tr><th>参数</th><th>作用</th><th>输出内容</th><th>使用场景</th></tr></thead><tbody><tr><td>-XX:+PrintGC</td><td>打印GC信息</td><td>简单GC日志</td><td>基本监控</td></tr><tr><td>-XX:+PrintGCDetails</td><td>打印详细GC信息</td><td>详细GC日志</td><td>性能调优</td></tr><tr><td>-XX:+PrintGCTimeStamps</td><td>打印GC时间戳</td><td>带时间的GC日志</td><td>问题定位</td></tr><tr><td>-Xloggc:gc.log</td><td>GC日志文件</td><td>输出到文件</td><td>生产环境</td></tr><tr><td>-XX:+HeapDumpOnOutOfMemoryError</td><td>OOM时生成堆转储</td><td>hprof文件</td><td>问题诊断</td></tr></tbody></table><h3 id="_6-内存泄漏vs内存溢出-如何排查" tabindex="-1"><a class="header-anchor" href="#_6-内存泄漏vs内存溢出-如何排查"><span>6. 内存泄漏vs内存溢出？如何排查？</span></a></h3><p><strong>概念区别：</strong></p><table><thead><tr><th>概念</th><th>定义</th><th>原因</th><th>表现</th></tr></thead><tbody><tr><td>内存泄漏(Memory Leak)</td><td>对象无法被GC回收但不再使用</td><td>引用没有释放</td><td>内存使用率持续上升</td></tr><tr><td>内存溢出(Out Of Memory)</td><td>内存空间不足以分配新对象</td><td>内存空间耗尽</td><td>抛出OutOfMemoryError</td></tr></tbody></table><p><strong>常见内存泄漏场景：</strong></p><table><thead><tr><th>场景</th><th>原因</th><th>示例</th><th>解决方案</th></tr></thead><tbody><tr><td>静态集合</td><td>集合持有对象引用不释放</td><td><code>static List&lt;Object&gt; list</code></td><td>及时清理集合</td></tr><tr><td>监听器</td><td>注册监听器未注销</td><td>addListener未配对removeListener</td><td>手动注销监听器</td></tr><tr><td>内部类</td><td>非静态内部类持有外部类引用</td><td>Handler持有Activity引用</td><td>使用静态内部类+弱引用</td></tr><tr><td>线程池</td><td>线程不结束持有对象引用</td><td>ThreadLocal使用后未清理</td><td>使用后调用remove()</td></tr><tr><td>数据库连接</td><td>连接未关闭</td><td>Connection、ResultSet未关闭</td><td>try-with-resources</td></tr></tbody></table><p><strong>内存溢出类型：</strong></p><table><thead><tr><th>OOM类型</th><th>发生区域</th><th>原因</th><th>解决方案</th></tr></thead><tbody><tr><td>Java heap space</td><td>堆内存</td><td>对象太多或内存泄漏</td><td>增加堆内存、排查泄漏</td></tr><tr><td>GC overhead limit exceeded</td><td>堆内存</td><td>GC时间过长</td><td>优化代码、调整GC参数</td></tr><tr><td>Metaspace</td><td>元空间</td><td>类太多</td><td>增加元空间大小</td></tr><tr><td>unable to create new native thread</td><td>线程</td><td>线程数超限</td><td>减少线程数、调整系统参数</td></tr><tr><td>Direct buffer memory</td><td>直接内存</td><td>NIO使用过多堆外内存</td><td>调整-XX:MaxDirectMemorySize</td></tr></tbody></table><p><strong>排查工具和方法：</strong></p><table><thead><tr><th>工具</th><th>用途</th><th>优点</th><th>使用场景</th></tr></thead><tbody><tr><td>jps</td><td>查看Java进程</td><td>简单快速</td><td>基础排查</td></tr><tr><td>jstack</td><td>查看线程状态和堆栈</td><td>排查死锁</td><td>死锁排查</td></tr><tr><td>jstat</td><td>监控GC和内存</td><td>实时监控</td><td>性能分析</td></tr><tr><td>jmap</td><td>生成堆转储</td><td>分析内存使用</td><td>内存问题排查</td></tr><tr><td>jhat</td><td>分析堆转储文件</td><td>基础分析</td><td>简单分析</td></tr><tr><td>MAT</td><td>Eclipse Memory Analyzer</td><td>功能强大</td><td>深度分析</td></tr><tr><td>JProfiler</td><td>商业性能分析工具</td><td>功能全面</td><td>全面性能分析</td></tr><tr><td>VisualVM</td><td>可视化监控工具</td><td>界面友好</td><td>开发调试</td></tr></tbody></table><h3 id="_7-强、软、弱、虚引用" tabindex="-1"><a class="header-anchor" href="#_7-强、软、弱、虚引用"><span>7. 强、软、弱、虚引用？</span></a></h3><ul><li>强引用最为普通的引用方式，表示一个对象处于有用且必须的状态，如果一个对象具有强引用，则GC并不会回收它。即便堆中内存不足了，宁可出现OOM，也不会对其进行回收</li><li>软引用表示一个对象处于有用且非必须状态，如果一个对象处于软引用，在内存空间足够的情况下，GC机制并不会回收它，而在内存空间不足时，则会在OOM异常出现之间对其进行回收。但值得注意的是，因为GC线程优先级较低，软引用并不会立即被回收。</li><li>弱引用表示一个对象处于可能有用且非必须的状态。在GC线程扫描内存区域时，一旦发现弱引用，就会回收到弱引用相关联的对象。对于弱引用的回收，无关内存区域是否足够，一旦发现则会被回收。同样的，因为GC线程优先级较低，所以弱引用也并不是会被立刻回收。</li><li>虚引用表示一个对象处于无用的状态。在任何时候都有可能被垃圾回收。虚引用的使用必须和引用队列Reference Queue联合使用</li></ul><h2 id="分布式" tabindex="-1"><a class="header-anchor" href="#分布式"><span>分布式</span></a></h2><h3 id="_1-cap理论-base理论" tabindex="-1"><a class="header-anchor" href="#_1-cap理论-base理论"><span>1. CAP理论？BASE理论？</span></a></h3><p><strong>CAP理论（布鲁尔定理）：</strong> 分布式系统不可能同时满足一致性（Consistency）、可用性（Availability）、分区容错性（Partition tolerance）三个特性。</p><table><thead><tr><th>特性</th><th>定义</th><th>说明</th></tr></thead><tbody><tr><td>一致性（C）</td><td>所有节点同时看到相同的数据</td><td>数据在所有节点保持同步</td></tr><tr><td>可用性（A）</td><td>系统持续可用，快速响应</td><td>系统不会因为部分节点故障而停止服务</td></tr><tr><td>分区容错性（P）</td><td>系统在网络分区故障时仍能继续运行</td><td>网络故障不会导致整个系统不可用</td></tr></tbody></table><p><strong>CAP组合选择：</strong></p><table><thead><tr><th>组合</th><th>特点</th><th>典型应用</th><th>使用场景</th></tr></thead><tbody><tr><td>CA</td><td>一致性+可用性</td><td>传统关系型数据库</td><td>单机或局域网环境</td></tr><tr><td>CP</td><td>一致性+分区容错性</td><td>Zookeeper、Raft、Paxos</td><td>数据一致性要求高</td></tr><tr><td>AP</td><td>可用性+分区容错性</td><td>Redis</td><td>高可用性要求，允许数据延迟</td></tr></tbody></table><p><strong>BASE理论：</strong> 作为CAP理论的延伸，提供了一种在分布式系统中实现高可用的方式。</p><table><thead><tr><th>特性</th><th>全称</th><th>含义</th></tr></thead><tbody><tr><td>基本可用（BA）</td><td>Basically Available</td><td>系统基本可用，允许损失部分功能</td></tr><tr><td>软状态（S）</td><td>Soft State</td><td>允许系统中数据存在中间状态</td></tr><tr><td>最终一致性（E）</td><td>Eventually Consistent</td><td>系统中数据最终达到一致状态</td></tr></tbody></table><h3 id="_2-分布式事务的解决方案" tabindex="-1"><a class="header-anchor" href="#_2-分布式事务的解决方案"><span>2. 分布式事务的解决方案？</span></a></h3><p><strong>分布式事务挑战：</strong> 跨多个服务或数据库的事务操作，需要保证ACID特性。</p><p><strong>解决方案对比：</strong></p><table><thead><tr><th>方案</th><th>实现原理</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>2PC</td><td>两阶段提交</td><td>强一致性</td><td>阻塞、单点故障</td><td>强一致性要求</td></tr><tr><td>3PC</td><td>三阶段提交</td><td>减少阻塞时间</td><td>复杂度高、网络分区问题</td><td>对2PC的改进</td></tr><tr><td>TCC</td><td>Try-Confirm-Cancel</td><td>灵活性高</td><td>实现复杂、补偿逻辑、业务侵入</td><td>业务逻辑相对简单</td></tr><tr><td>Saga</td><td>长事务拆分+补偿</td><td>高性能、最终一致性</td><td>补偿逻辑复杂</td><td>长流程业务</td></tr><tr><td>消息事务</td><td>消息队列保证最终一致性</td><td>异步高性能</td><td>最终一致性、消息重复</td><td>异步处理场景</td></tr><tr><td>Outbox Pattern</td><td>消息队列保证最终一致性</td><td>异步高性能</td><td>最终一致性、消息重复</td><td>异步处理场景</td></tr><tr><td>最大努力通知</td><td>定期重试+人工介入</td><td>简单易实现</td><td>可能不一致</td><td>对一致性要求不严格</td></tr></tbody></table><p><strong>详细方案分析：</strong></p><table><thead><tr><th>方案特点</th><th>2PC</th><th>TCC</th><th>Saga</th></tr></thead><tbody><tr><td>一致性</td><td>强一致性</td><td>最终一致性</td><td>最终一致性</td></tr><tr><td>性能</td><td>较差</td><td>好</td><td>好</td></tr><tr><td>复杂度</td><td>简单</td><td>中等</td><td>复杂</td></tr><tr><td>业务侵入性</td><td>无</td><td>中等</td><td>高</td></tr><tr><td>故障恢复</td><td>困难</td><td>相对容易</td><td>容易</td></tr></tbody></table><h3 id="_3-分布式锁的实现" tabindex="-1"><a class="header-anchor" href="#_3-分布式锁的实现"><span>3. 分布式锁的实现？</span></a></h3><p><strong>实现方案对比：</strong></p><table><thead><tr><th>实现方案</th><th>原理</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>数据库锁</td><td>基于数据库唯一索引</td><td>简单易理解</td><td>性能差、单点故障</td><td>简单场景</td></tr><tr><td>Redis分布式锁</td><td>SET NX EX命令</td><td>性能好、支持过期</td><td>可能出现锁丢失</td><td>一般业务场景</td></tr><tr><td>ZooKeeper临时节点</td><td>临时有序节点</td><td>强一致性、自动释放</td><td>性能相对较差</td><td>强一致性要求</td></tr><tr><td>Etcd</td><td>基于Raft算法的分布式锁</td><td>强一致性、高可用</td><td>依赖额外组件</td><td>微服务架构</td></tr></tbody></table><p><strong>各方案详细对比：</strong></p><table><thead><tr><th>对比维度</th><th>Redis</th><th>ZooKeeper</th><th>数据库</th><th>Etcd</th></tr></thead><tbody><tr><td>性能</td><td>高</td><td>中</td><td>低</td><td>中</td></tr><tr><td>可靠性</td><td>中</td><td>高</td><td>中</td><td>高</td></tr><tr><td>复杂度</td><td>低</td><td>中</td><td>低</td><td>中</td></tr><tr><td>运维成本</td><td>低</td><td>中</td><td>低</td><td>中</td></tr></tbody></table><h3 id="_4-分布式id生成方案" tabindex="-1"><a class="header-anchor" href="#_4-分布式id生成方案"><span>4. 分布式ID生成方案？</span></a></h3><p><strong>ID生成方案对比：</strong></p><table><thead><tr><th>方案</th><th>实现原理</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>UUID</td><td>随机生成128位标识符</td><td>简单、本地生成</td><td>无序、占用空间大</td><td>对顺序无要求的场景</td></tr><tr><td>数据库自增ID</td><td>数据库AUTO_INCREMENT</td><td>简单、有序</td><td>性能瓶颈、单点故障</td><td>单机应用</td></tr><tr><td>号段模式</td><td>批量获取ID段</td><td>高性能、减少数据库访问</td><td>浪费ID、重启丢失</td><td>高并发场景</td></tr><tr><td>雪花算法</td><td>时间戳+机器ID+序列号</td><td>有序、高性能、分布式</td><td>时钟回拨问题</td><td>分布式高并发</td></tr><tr><td>美团Leaf</td><td>号段模式+雪花算法优化</td><td>高可用、性能好</td><td>复杂度较高</td><td>大规模分布式系统</td></tr><tr><td>百度UidGenerator</td><td>雪花算法优化</td><td>解决时钟回拨、高性能</td><td>依赖机器时间</td><td>对顺序性要求高的场景</td></tr></tbody></table><p><strong>雪花算法详解：</strong></p><table><thead><tr><th>组成部分</th><th>位数</th><th>说明</th><th>取值范围</th></tr></thead><tbody><tr><td>符号位</td><td>1位</td><td>固定为0</td><td>0</td></tr><tr><td>时间戳</td><td>41位</td><td>相对于某个起始时间的毫秒数</td><td>69年</td></tr><tr><td>机器ID</td><td>10位</td><td>数据中心ID(5位)+机器ID(5位)</td><td>1024台机器</td></tr><tr><td>序列号</td><td>12位</td><td>毫秒内的序列号</td><td>4096个序列号</td></tr></tbody></table><p><strong>雪花算法时钟回拨问题及解决方案：</strong></p><p><strong>问题产生原因：</strong></p><ul><li>系统时钟被人为调整（向后调整）</li><li>NTP时间同步导致时钟回退</li><li>虚拟机时钟漂移</li><li>闰秒调整</li></ul><p><strong>解决方案对比：</strong></p><table><thead><tr><th>解决方案</th><th>实现原理</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>抛出异常</td><td>检测到回拨立即抛异常</td><td>简单，保证ID不重复</td><td>服务不可用</td><td>对一致性要求极高</td></tr><tr><td>等待时钟追上</td><td>阻塞等待直到时钟超过上次时间戳</td><td>ID绝对不重复</td><td>可能长时间阻塞</td><td>回拨时间较短</td></tr><tr><td>使用备用方案</td><td>回拨时切换到其他ID生成方式</td><td>服务持续可用</td><td>需要维护多套方案</td><td>高可用要求</td></tr><tr><td>容忍小幅回拨</td><td>允许小范围（如5秒内）回拨</td><td>性能好，可用性高</td><td>可能产生重复ID</td><td>一般业务场景</td></tr><tr><td>机器位扩展</td><td>增加机器位，减少时间戳位数</td><td>减少时钟依赖</td><td>ID长度可能增加</td><td>集群规模大</td></tr></tbody></table><p><strong>详细实现方案：</strong></p><table><thead><tr><th>方案类型</th><th>具体实现</th><th>代码逻辑</th><th>注意事项</th></tr></thead><tbody><tr><td>异常处理</td><td>检测当前时间 &lt; 上次时间，抛TimeBackException</td><td>if(current &lt; lastTime) throw</td><td>需要上层调用处理异常</td></tr><tr><td>自旋等待</td><td>while循环等待时钟追上</td><td>while(current &lt;= lastTime)</td><td>可能长时间占用CPU</td></tr><tr><td>序列号预留</td><td>预留部分序列号给回拨时使用</td><td>正常时使用0-2047，回拨时使用2048-4095</td><td>需要合理分配序列号空间</td></tr><tr><td>时间戳缓存</td><td>缓存最近的时间戳，回拨时使用缓存值</td><td>维护时间戳队列</td><td>需要考虑缓存大小和过期策略</td></tr></tbody></table><p><strong>方案选择建议：</strong></p><table><thead><tr><th>场景需求</th><th>推荐方案</th><th>原因</th></tr></thead><tbody><tr><td>对性能要求不高</td><td>UUID</td><td>实现简单</td></tr><tr><td>需要有序ID</td><td>雪花算法</td><td>趋势递增、性能好</td></tr><tr><td>超高并发</td><td>号段模式</td><td>批量获取、减少竞争</td></tr><tr><td>对可用性要求极高</td><td>美团Leaf/百度UidGenerator</td><td>双buffer、解决时钟回拨问题</td></tr></tbody></table><h3 id="_5-负载均衡算法" tabindex="-1"><a class="header-anchor" href="#_5-负载均衡算法"><span>5. 负载均衡算法？</span></a></h3><p><strong>负载均衡算法对比：</strong></p><table><thead><tr><th>算法</th><th>实现原理</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>轮询</td><td>依次分配请求到每个服务器</td><td>简单、分布均匀</td><td>不考虑服务器性能差异</td><td>服务器性能相近</td></tr><tr><td>加权轮询</td><td>根据权重分配请求</td><td>考虑服务器性能差异</td><td>静态权重、不能动态调整</td><td>服务器性能差异已知</td></tr><tr><td>最少连接</td><td>分配到连接数最少的服务器</td><td>考虑服务器当前负载</td><td>需要维护连接数统计</td><td>长连接场景</td></tr><tr><td>加权最少连接</td><td>结合权重和连接数</td><td>综合考虑性能和负载</td><td>计算复杂度高</td><td>复杂负载场景</td></tr><tr><td>随机</td><td>随机选择服务器</td><td>实现简单</td><td>可能分布不均匀</td><td>服务器数量多</td></tr><tr><td>加权随机</td><td>根据权重随机选择</td><td>简单、考虑性能差异</td><td>短期可能不均匀</td><td>一般业务场景</td></tr><tr><td>IP Hash</td><td>根据客户端IP哈希选择</td><td>相同IP访问同一服务器</td><td>可能负载不均</td><td>需要会话保持</td></tr><tr><td>最短响应时间</td><td>选择响应时间最短的服务器</td><td>考虑服务器实际性能</td><td>需要监控响应时间</td><td>对延迟敏感的应用</td></tr></tbody></table><p><strong>算法适用场景详解：</strong></p><table><thead><tr><th>业务特点</th><th>推荐算法</th><th>原因</th></tr></thead><tbody><tr><td>无状态服务</td><td>轮询/随机</td><td>简单高效，分布均匀</td></tr><tr><td>有状态服务</td><td>IP Hash</td><td>保证同一用户访问同一服务器</td></tr><tr><td>服务器性能差异大</td><td>加权轮询/加权随机</td><td>根据性能分配不同权重</td></tr><tr><td>长连接场景</td><td>最少连接</td><td>避免连接过度集中</td></tr><tr><td>对延迟敏感</td><td>最短响应时间</td><td>选择响应最快的服务器</td></tr><tr><td>高并发场景</td><td>一致性哈希</td><td>避免服务器变化时大量请求重新分配</td></tr></tbody></table><ul><li>一致性哈希：一致性哈希是一种分布式哈希算法，主要用于将数据均匀且稳定地分布到多个节点上，减少节点变动时数据重新分配的开销。将所有的节点和数据都映射到一个虚拟的哈希环（0 到 2³²-1 的范围）上。数据根据哈希值顺时针找到第一个节点并存储在该节点上。当新增或移除节点时，仅需重新分配该节点顺时针邻居范围内的数据，避免了数据大规模迁移，提高了系统的可扩展性和稳定性。</li><li>一致性哈希解决了传统哈希扩缩容的大量数据迁移问题，但仍需通过虚拟节点、副本、多层哈希等方式来优化负载均衡、高可用性和跨地域访问。</li></ul><table><thead><tr><th>缺点</th><th>具体问题</th><th>解决方案</th></tr></thead><tbody><tr><td>数据分布不均匀</td><td>节点数量少或节点在环上分布不均，部分节点成为热点</td><td>使用<strong>虚拟节点</strong>，为每个物理节点映射多个虚拟节点，均衡数据</td></tr><tr><td>扩容/缩容时负载倾斜</td><td>新增或移除节点会导致部分数据集中迁移，短期热点</td><td>平滑迁移、分批迁移，或配合副本机制</td></tr><tr><td>数据倾斜仍可能存在</td><td>虚拟节点数量不足，仍可能有节点负载过高</td><td>增加虚拟节点数量，动态调整虚拟节点分布</td></tr><tr><td>高可用性问题</td><td>节点故障时数据丢失或不可用</td><td>哈希环上放置<strong>多个副本</strong>（Replica）</td></tr><tr><td>多机房/跨集群访问延迟</td><td>一致性哈希只考虑单环，不考虑地理位置</td><td><strong>多层哈希</strong>（先选机房，再选节点）或<strong>locality-aware hash</strong></td></tr><tr><td>数据移动量非最小</td><td>扩缩容时部分数据仍需迁移</td><td>可考虑改进算法，如跳一致性哈希（Jump Consistent Hash）</td></tr></tbody></table><h3 id="_6-seata-分布式事务" tabindex="-1"><a class="header-anchor" href="#_6-seata-分布式事务"><span>6. Seata 分布式事务？</span></a></h3><h4 id="seata核心组件" tabindex="-1"><a class="header-anchor" href="#seata核心组件"><span><strong>Seata核心组件</strong></span></a></h4><ul><li><strong>TC (Transaction Coordinator)</strong>：事务协调者，管理全局事务状态</li><li><strong>TM (Transaction Manager)</strong>：事务管理器，定义全局事务边界</li><li><strong>RM (Resource Manager)</strong>：资源管理器，管理分支事务</li></ul><h4 id="四种事务模式" tabindex="-1"><a class="header-anchor" href="#四种事务模式"><span><strong>四种事务模式</strong></span></a></h4><h5 id="_1-at模式-automatic-transaction" tabindex="-1"><a class="header-anchor" href="#_1-at模式-automatic-transaction"><span><strong>1. AT模式（Automatic Transaction）</strong></span></a></h5><ul><li><strong>特点</strong>：自动模式，对业务无侵入，自动生成反向SQL实现回滚</li><li><strong>优势</strong>：零侵入、高性能、自动回滚</li><li><strong>限制</strong>：需要支持本地ACID事务，不支持复杂SQL</li><li><strong>适用场景</strong>：基于关系型数据库的微服务</li></ul><h5 id="_2-tcc模式-try-confirm-cancel" tabindex="-1"><a class="header-anchor" href="#_2-tcc模式-try-confirm-cancel"><span><strong>2. TCC模式（Try-Confirm-Cancel）</strong></span></a></h5><ul><li><p><strong>核心思想</strong>：</p><ul><li>三阶段提交：Try（尝试）、Confirm（确认）、Cancel（取消）</li><li>资源预留：在Try阶段预留资源，避免长时间锁定</li><li>补偿机制：通过Cancel阶段实现回滚</li></ul></li><li><p><strong>特点</strong>：手动模式，需要实现Try、Confirm、Cancel三个接口</p></li><li><p><strong>优势</strong>：高性能、灵活性高、支持复杂业务逻辑</p></li><li><p><strong>限制</strong>：开发复杂、业务侵入、需要保证幂等性</p></li><li><p><strong>适用场景</strong>：对性能要求高，业务逻辑复杂的场景</p></li></ul><h5 id="_3-saga模式" tabindex="-1"><a class="header-anchor" href="#_3-saga模式"><span><strong>3. SAGA模式</strong></span></a></h5><ul><li><p><strong>核心思想</strong>：</p><ul><li>长事务：将长事务分解为多个本地事务</li><li>补偿机制：通过补偿操作实现回滚</li><li>事件驱动：基于事件驱动的架构</li></ul></li><li><p><strong>特点</strong>：长事务模式，通过补偿操作实现回滚</p></li><li><p><strong>优势</strong>：支持长事务、灵活性高、补偿机制完善</p></li><li><p><strong>限制</strong>：开发复杂、最终一致性、补偿逻辑复杂</p></li><li><p><strong>适用场景</strong>：业务流程长，需要补偿的场景</p></li></ul><h5 id="_4-xa模式" tabindex="-1"><a class="header-anchor" href="#_4-xa模式"><span><strong>4. XA模式</strong></span></a></h5><ul><li><strong>特点</strong>：基于XA协议，保证强一致性</li><li><strong>优势</strong>：强一致性、标准化、可靠性高</li><li><strong>限制</strong>：性能低、锁定时间长、需要数据库支持XA</li><li><strong>适用场景</strong>：对一致性要求极高的场景</li></ul><h4 id="模式对比总结" tabindex="-1"><a class="header-anchor" href="#模式对比总结"><span><strong>模式对比总结</strong></span></a></h4><table><thead><tr><th>模式</th><th>性能</th><th>一致性</th><th>侵入性</th><th>复杂度</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>AT</strong></td><td>高</td><td>最终一致性</td><td>无侵入</td><td>低</td><td>关系型数据库微服务</td></tr><tr><td><strong>TCC</strong></td><td>高</td><td>最终一致性</td><td>高侵入</td><td>高</td><td>复杂业务逻辑</td></tr><tr><td><strong>SAGA</strong></td><td>中</td><td>最终一致性</td><td>中侵入</td><td>高</td><td>长事务业务流程</td></tr><tr><td><strong>XA</strong></td><td>低</td><td>强一致性</td><td>无侵入</td><td>低</td><td>强一致性要求</td></tr></tbody></table><h4 id="选择建议" tabindex="-1"><a class="header-anchor" href="#选择建议"><span><strong>选择建议</strong></span></a></h4><ul><li><strong>AT模式</strong>：适合大多数场景，基于关系型数据库</li><li><strong>TCC模式</strong>：适合复杂业务逻辑，需要高性能</li><li><strong>SAGA模式</strong>：适合长事务业务流程，需要补偿机制</li><li><strong>XA模式</strong>：适合对一致性要求极高的场景</li></ul><p><strong>要点：</strong> Seata提供了四种分布式事务模式，AT模式最常用，TCC模式适合复杂业务，SAGA模式适合长事务，XA模式适合强一致性要求。</p><h3 id="_7-分布式事务接口幂等" tabindex="-1"><a class="header-anchor" href="#_7-分布式事务接口幂等"><span>7. 分布式事务接口幂等？</span></a></h3><ul><li>幂等 ID（如订单号、消息ID）</li><li>分布式锁：Redis 的 SETNX</li><li>数据库唯一约束</li><li>状态码控制</li></ul><h2 id="微服务" tabindex="-1"><a class="header-anchor" href="#微服务"><span>微服务</span></a></h2><h3 id="_1-微服务的优势和挑战" tabindex="-1"><a class="header-anchor" href="#_1-微服务的优势和挑战"><span>1. 微服务的优势和挑战？</span></a></h3><p><strong>微服务定义：</strong> 将单一应用程序拆分为一组小型服务，每个服务运行在独立进程中，通过轻量级通信机制协作。</p><p><strong>优势 vs 挑战对比：</strong></p><table><thead><tr><th>维度</th><th>优势</th><th>挑战</th></tr></thead><tbody><tr><td>开发维护</td><td>代码库小、团队独立开发、技术栈灵活</td><td>服务间协调复杂、版本管理困难</td></tr><tr><td>部署运维</td><td>独立部署、故障隔离、弹性伸缩</td><td>运维复杂度高、监控困难</td></tr><tr><td>性能扩展</td><td>按需扩展、资源利用率高</td><td>网络延迟、分布式事务复杂</td></tr><tr><td>团队协作</td><td>团队自治、并行开发</td><td>服务边界划分难、团队沟通成本高</td></tr><tr><td>系统稳定性</td><td>单点故障影响范围小</td><td>服务间依赖复杂、调试困难</td></tr></tbody></table><p><strong>适用场景判断：</strong></p><table><thead><tr><th>项目特征</th><th>单体架构</th><th>微服务架构</th><th>推荐理由</th></tr></thead><tbody><tr><td>团队规模</td><td>&lt; 10人</td><td>&gt; 10人</td><td>微服务需要足够的团队支撑</td></tr><tr><td>业务复杂度</td><td>简单</td><td>复杂</td><td>复杂业务适合拆分独立维护</td></tr><tr><td>技术栈要求</td><td>统一</td><td>多样化</td><td>微服务支持不同技术栈</td></tr><tr><td>部署频率</td><td>低</td><td>高</td><td>微服务支持独立快速部署</td></tr><tr><td>扩展性要求</td><td>一般</td><td>高</td><td>微服务支持按需精确扩展</td></tr></tbody></table><h3 id="_2-服务注册与发现-原理-常用组件-比较" tabindex="-1"><a class="header-anchor" href="#_2-服务注册与发现-原理-常用组件-比较"><span>2. 服务注册与发现：原理？常用组件？比较？</span></a></h3><p><strong>服务发现原理：</strong> 解决微服务环境下服务实例动态变化时的相互发现和调用问题。</p><p><strong>实现模式对比：</strong></p><table><thead><tr><th>模式</th><th>原理</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>客户端发现</td><td>客户端查询注册中心获取服务实例列表</td><td>性能好、负载均衡灵活</td><td>客户端逻辑复杂、语言绑定</td><td>性能要求高</td></tr><tr><td>服务端发现</td><td>通过负载均衡器代理访问服务</td><td>客户端简单、语言无关</td><td>负载均衡器成为瓶颈</td><td>多语言环境</td></tr><tr><td>服务网格</td><td>基础设施层处理服务通信</td><td>业务无感知、功能丰富</td><td>架构复杂、性能开销</td><td>大规模微服务</td></tr></tbody></table><p><strong>主流组件对比：</strong></p><table><thead><tr><th>组件</th><th>类型</th><th>一致性算法</th><th>多数据中心</th><th>健康检查</th><th>负载均衡</th><th>适用场景</th></tr></thead><tbody><tr><td>Eureka</td><td>AP</td><td>无</td><td>支持</td><td>支持</td><td>客户端</td><td>Spring Cloud</td></tr><tr><td>Consul</td><td>CP</td><td>Raft</td><td>支持</td><td>支持</td><td>支持</td><td>多语言环境</td></tr><tr><td>Zookeeper</td><td>CP</td><td>ZAB</td><td>支持</td><td>支持</td><td>不支持</td><td>Dubbo生态</td></tr><tr><td>Nacos</td><td>AP/CP</td><td>Raft</td><td>支持</td><td>支持</td><td>支持</td><td>阿里云生态</td></tr><tr><td>Etcd</td><td>CP</td><td>Raft</td><td>支持</td><td>支持</td><td>不支持</td><td>Kubernetes</td></tr></tbody></table><p><strong>Nacos</strong></p><ul><li>服务注册发现 <ul><li>主动健康检查：主动探测服务提供者健康状态</li><li>推送通知：服务列表变更实时推送给客户端</li><li>负载均衡：内置负载均衡能力</li><li>多数据中心：支持跨地域部署</li></ul></li><li>配置管理 <ul><li>动态配置：配置变更实时推送，无需重启应用</li><li>多环境支持：开发、测试、生产环境配置隔离</li><li>版本管理：配置历史版本和回滚</li><li>权限控制：细粒度权限管理</li></ul></li></ul><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>服务实例启动 → 向Nacos注册 → 定期心跳 → 维护健康状态</span></span>\n<span class="line"><span>服务消费者请求 → 从Nacos获取服务列表 → 负载均衡调用目标实例</span></span>\n<span class="line"><span>Nacos集群通过Raft保证一致性和高可用</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>服务注册是服务实例启动时向注册中心登记自己信息，包括服务名、IP、端口和健康检查接口；注册中心保存实例信息并定期心跳监测。</li><li>服务发现是客户端或网关查询注册中心，获取可用服务列表，实现动态调用和负载均衡，从而保证服务可用性和系统的高可用架构。</li></ul><h3 id="_3-服务调用-restful-api-和-rpc-dubbo-grpc-比较" tabindex="-1"><a class="header-anchor" href="#_3-服务调用-restful-api-和-rpc-dubbo-grpc-比较"><span>3. 服务调用：RESTful API 和 RPC (Dubbo, gRPC)？比较？</span></a></h3><p><strong>调用方式对比：</strong></p><table><thead><tr><th>对比维度</th><th>HTTP (RESTful API)</th><th>RPC (gRPC / Thrift / Dubbo 等)</th></tr></thead><tbody><tr><td><strong>传输协议</strong></td><td>基于 HTTP/1.1 或 HTTP/2</td><td>可基于多种协议（TCP、HTTP/2、QUIC）</td></tr><tr><td><strong>数据格式</strong></td><td>主要是 JSON / XML（文本化，可读性好）</td><td>常用 Protobuf、Thrift（二进制，高效）</td></tr><tr><td><strong>性能</strong></td><td>JSON 序列化/反序列化开销大，性能一般</td><td>二进制序列化，占用带宽小，性能更高</td></tr><tr><td><strong>调用方式</strong></td><td>面向资源（GET/POST/PUT/DELETE），语义清晰</td><td>面向方法（直接像调用函数一样），更贴近编程模型</td></tr><tr><td><strong>易用性</strong></td><td>对前端/第三方开放友好，跨语言支持好</td><td>对后端服务间调用友好，更自然地和代码结合</td></tr><tr><td><strong>工具生态</strong></td><td>浏览器直接支持，调试方便（curl、Postman）</td><td>需要生成 SDK（Protobuf/IDL 编译器），但 IDE 内联支持好</td></tr><tr><td><strong>可扩展性</strong></td><td>适合开放 API、跨组织调用</td><td>适合微服务内部高性能通信</td></tr><tr><td><strong>场景</strong></td><td>Web API、移动端调用、对外服务</td><td>微服务之间调用、后端高并发场景</td></tr></tbody></table><ul><li>HTTP (REST API) ：更适合对外开放接口，易于理解、调试和跨平台。</li><li>RPC ：更适合后端服务之间的高性能、强类型通信，调用方式更接近本地函数。</li><li>即使有了 HTTP，RPC 在 高性能微服务调用 和 强类型接口管理 上依然不可替代</li></ul><p><strong>技术选型建议：</strong></p><table><thead><tr><th>场景需求</th><th>推荐方案</th><th>原因</th></tr></thead><tbody><tr><td>对外开放API</td><td>RESTful API</td><td>标准化、易于集成</td></tr><tr><td>内部服务高性能调用</td><td>Dubbo/gRPC</td><td>性能好、功能丰富</td></tr><tr><td>多语言团队</td><td>gRPC</td><td>跨语言支持好</td></tr><tr><td>Spring Boot项目</td><td>RESTful API</td><td>生态集成度高</td></tr><tr><td>大数据量传输</td><td>gRPC</td><td>二进制序列化、HTTP/2协议</td></tr><tr><td>快速原型开发</td><td>RESTful API</td><td>开发简单、调试方便</td></tr></tbody></table><p><strong>框架对比</strong></p><table><thead><tr><th>维度</th><th>OpenFeign (基于 HTTP 的 RPC 风格)</th><th>典型 RPC 框架 (Dubbo / gRPC)</th></tr></thead><tbody><tr><td><strong>传输协议</strong></td><td>HTTP/REST</td><td>TCP、HTTP/2（可选）</td></tr><tr><td><strong>序列化格式</strong></td><td>JSON（默认），也支持自定义</td><td>高效二进制（Protobuf、Hessian）</td></tr><tr><td><strong>调用方式</strong></td><td>接口 + 注解，像本地方法调用</td><td>接口直接生成代理，像本地方法调用</td></tr><tr><td><strong>性能</strong></td><td>一般（HTTP + JSON）</td><td>更高（TCP/HTTP2 + 二进制序列化）</td></tr><tr><td><strong>适用场景</strong></td><td>Spring Cloud 体系内，开发效率优先</td><td>高并发、跨语言微服务，性能优先</td></tr><tr><td><strong>本质</strong></td><td><strong>RPC 框架的“HTTP实现”</strong></td><td>RPC 框架的“高性能实现”</td></tr></tbody></table><h3 id="_4-服务网关-api-gateway-作用-常用组件" tabindex="-1"><a class="header-anchor" href="#_4-服务网关-api-gateway-作用-常用组件"><span>4. 服务网关 (API Gateway)：作用？常用组件？</span></a></h3><p><strong>API网关作用：</strong> 作为所有客户端请求的统一入口，提供路由、认证、限流、监控等功能。</p><p><strong>核心功能对比：</strong></p><table><thead><tr><th>功能类别</th><th>具体功能</th><th>价值</th><th>实现方式</th></tr></thead><tbody><tr><td>请求路由</td><td>动态路由、负载均衡</td><td>请求分发到正确服务</td><td>规则配置、服务发现</td></tr><tr><td>安全认证</td><td>身份验证、权限控制</td><td>统一安全策略</td><td>JWT、OAuth2</td></tr><tr><td>流量控制</td><td>限流、熔断、降级</td><td>保护后端服务</td><td>令牌桶、熔断器</td></tr><tr><td>协议转换</td><td>HTTP/WebSocket等</td><td>协议统一</td><td>协议适配器</td></tr><tr><td>监控运维</td><td>日志、监控、链路追踪</td><td>可观测性</td><td>APM集成</td></tr></tbody></table><p><strong>API网关和Nginx对比：</strong></p><table><thead><tr><th>维度</th><th>API 网关</th><th>Nginx</th></tr></thead><tbody><tr><td><strong>定位</strong></td><td>专注于微服务架构的统一入口，管理 API 请求</td><td>通用的高性能反向代理服务器和负载均衡器</td></tr><tr><td><strong>功能</strong></td><td>API 路由、认证授权、限流、请求聚合、协议转换、监控、安全策略等</td><td>反向代理、负载均衡、静态文件服务、SSL终端、缓存</td></tr><tr><td><strong>协议支持</strong></td><td>HTTP/HTTPS为主，支持API管理相关协议（如REST、GraphQL）</td><td>支持HTTP、HTTPS、TCP、UDP等多种协议</td></tr><tr><td><strong>智能路由</strong></td><td>根据API版本、用户权限、服务发现动态路由</td><td>配置静态反向代理规则，路由相对简单</td></tr><tr><td><strong>安全</strong></td><td>集中管理API安全策略，支持OAuth、JWT等认证方式</td><td>支持基本认证和SSL证书，但不具备复杂API安全能力</td></tr><tr><td><strong>流量控制</strong></td><td>支持限流、熔断、降级、请求合并，防止系统过载</td><td>仅支持基本的连接数限制、带宽限制</td></tr><tr><td><strong>可扩展性</strong></td><td>支持插件机制，动态扩展功能</td><td>通过模块化扩展功能，但多为服务器层面功能</td></tr><tr><td><strong>监控与分析</strong></td><td>提供详细的API调用统计、日志分析、调用链追踪</td><td>主要提供访问日志和性能监控，需要结合第三方工具实现更丰富分析</td></tr><tr><td><strong>部署复杂度</strong></td><td>通常作为微服务架构中的独立组件，配置和维护较复杂</td><td>配置相对简单，部署灵活</td></tr><tr><td><strong>代表产品</strong></td><td>Kong、Spring Cloud Gateway、AWS API Gateway、Zuul</td><td>Nginx、OpenResty、Caddy</td></tr></tbody></table><h3 id="_5-配置中心-作用-常用组件" tabindex="-1"><a class="header-anchor" href="#_5-配置中心-作用-常用组件"><span>5. 配置中心：作用？常用组件？</span></a></h3><p><strong>配置中心价值：</strong> 集中管理微服务配置，支持动态更新，避免重启服务。</p><p><strong>核心能力对比：</strong></p><table><thead><tr><th>能力</th><th>传统配置文件</th><th>配置中心</th><th>提升效果</th></tr></thead><tbody><tr><td>配置管理</td><td>散落在各个服务</td><td>集中统一管理</td><td>管理效率提升90%</td></tr><tr><td>动态更新</td><td>需要重启服务</td><td>实时推送更新</td><td>变更速度提升10倍</td></tr><tr><td>环境隔离</td><td>手动维护多套配置</td><td>自动环境区分</td><td>错误率降低80%</td></tr><tr><td>权限控制</td><td>无权限控制</td><td>细粒度权限管理</td><td>安全性大幅提升</td></tr><tr><td>版本管理</td><td>手动备份</td><td>自动版本控制和回滚</td><td>可靠性提升</td></tr></tbody></table><p><strong>主流配置中心对比：</strong></p><table><thead><tr><th>组件</th><th>数据存储</th><th>动态推送</th><th>多环境</th><th>权限控制</th><th>可视化界面</th><th>生态集成</th></tr></thead><tbody><tr><td>Spring Cloud Config</td><td>Git/SVN</td><td>需结合Bus</td><td>支持</td><td>基础</td><td>基础</td><td>Spring生态</td></tr><tr><td>Apollo</td><td>MySQL</td><td>支持</td><td>支持</td><td>完善</td><td>优秀</td><td>多语言</td></tr><tr><td>Nacos</td><td>内置数据库</td><td>支持</td><td>支持</td><td>支持</td><td>优秀</td><td>阿里云生态</td></tr><tr><td>Consul</td><td>KV存储</td><td>支持</td><td>支持</td><td>支持</td><td>基础</td><td>HashiCorp生态</td></tr></tbody></table><h3 id="_6-服务容错-熔断、降级、限流-令牌桶、漏桶-sentinel和hystrix" tabindex="-1"><a class="header-anchor" href="#_6-服务容错-熔断、降级、限流-令牌桶、漏桶-sentinel和hystrix"><span>6. 服务容错：熔断、降级、限流 (令牌桶、漏桶)，Sentinel和Hystrix？</span></a></h3><p><strong>容错机制对比：</strong></p><table><thead><tr><th>机制</th><th>目的</th><th>触发条件</th><th>恢复机制</th><th>适用场景</th></tr></thead><tbody><tr><td>熔断</td><td>避免连锁故障</td><td>错误率/响应时间超阈值</td><td>半开状态探测</td><td>依赖服务不稳定</td></tr><tr><td>降级</td><td>保证核心功能可用</td><td>系统负载过高</td><td>手动或自动恢复</td><td>非核心功能可牺牲</td></tr><tr><td>限流</td><td>保护系统不被压垮</td><td>请求量超过系统处理能力</td><td>拒绝或排队等待</td><td>高并发场景</td></tr></tbody></table><p><strong>限流算法对比：</strong></p><table><thead><tr><th>算法</th><th>原理说明</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>漏桶（Leaky Bucket）</strong></td><td>请求进入一个固定容量的“漏桶”，以恒定速率处理出桶，超出容量的请求被丢弃或等待</td><td>流量均匀、平滑，防止突发流量冲击系统</td><td>不支持短时间突发请求，突发流量会被直接丢弃或限流</td><td>系统需要稳定、均匀的流量控制，如视频流速率控制</td></tr><tr><td><strong>令牌桶（Token Bucket）</strong></td><td>按固定速率生成令牌，请求需拿令牌才能处理，令牌可积累，允许突发请求瞬时处理</td><td>支持突发流量，系统能灵活应对瞬时流量峰值</td><td>实现较复杂，需要管理令牌生成和消耗</td><td>允许短时间突发请求的限流，如电商秒杀、API接口限流</td></tr><tr><td><strong>固定窗口（Fixed Window）</strong></td><td>将时间划分为固定长度的窗口，在每个窗口内限制最大请求数</td><td>实现简单，统计方便</td><td>窗口边界临界时可能产生“请求激增”，导致突发限流不平滑</td><td>对实时精度要求不高、实现简单的场景，如简单API限流</td></tr><tr><td><strong>滑动窗口（Sliding Window）</strong></td><td>按滑动时间窗口统计请求数，实时统计更精确地控制请求流量</td><td>限流更平滑、精准，避免固定窗口临界问题</td><td>实现复杂，内存和计算资源消耗较大</td><td>对限流准确度要求高，流量波动较大，需要精细限流的业务场景</td></tr></tbody></table><h3 id="_7-链路追踪-目的-原理-常用组件-zipkin-skywalking" tabindex="-1"><a class="header-anchor" href="#_7-链路追踪-目的-原理-常用组件-zipkin-skywalking"><span>7. 链路追踪：目的？原理？常用组件 (Zipkin, SkyWalking)？</span></a></h3><p><strong>链路追踪目的：</strong> 在分布式系统中追踪请求的完整调用链路，快速定位性能瓶颈和故障根因。</p><p><strong>核心概念：</strong></p><table><thead><tr><th>概念</th><th>定义</th><th>作用</th></tr></thead><tbody><tr><td>Trace</td><td>一次完整的请求调用链路</td><td>代表一次业务请求的全链路</td></tr><tr><td>Span</td><td>链路中的一个操作单元</td><td>代表一次服务调用或操作</td></tr><tr><td>SpanId</td><td>Span的唯一标识</td><td>标识具体的操作单元</td></tr><tr><td>TraceId</td><td>Trace的唯一标识</td><td>串联整个调用链路</td></tr><tr><td>采样率</td><td>采集链路数据的比例</td><td>平衡性能和可观测性</td></tr></tbody></table><p><strong>实现原理：</strong></p><ol><li><strong>埋点收集</strong>：在应用中插入追踪代码收集调用信息</li><li><strong>传递TraceId</strong>：通过HTTP头或RPC上下文传递追踪标识</li><li><strong>数据上报</strong>：异步上报链路数据到追踪系统</li><li><strong>存储分析</strong>：存储并分析链路数据，提供查询界面</li></ol><p><strong>主流组件对比：</strong></p><table><thead><tr><th>组件</th><th>开发者</th><th>语言支持</th><th>存储支持</th><th>性能开销</th><th>界面友好度</th><th>生态集成</th></tr></thead><tbody><tr><td>Zipkin</td><td>Twitter</td><td>多语言</td><td>多种存储后端</td><td>低</td><td>一般</td><td>广泛</td></tr><tr><td>SkyWalking</td><td>Apache</td><td>Java为主</td><td>ES/H2/MySQL</td><td>低</td><td>优秀</td><td>Java生态</td></tr><tr><td>Jaeger</td><td>Uber</td><td>多语言</td><td>多种存储后端</td><td>低</td><td>良好</td><td>云原生</td></tr><tr><td>Pinpoint</td><td>Naver</td><td>Java</td><td>HBase</td><td>中等</td><td>优秀</td><td>Java专用</td></tr></tbody></table><p><strong>技术选型建议：</strong></p><table><thead><tr><th>场景需求</th><th>推荐方案</th><th>选择理由</th></tr></thead><tbody><tr><td>Java微服务</td><td>SkyWalking</td><td>无侵入、功能全面、界面友好</td></tr><tr><td>多语言环境</td><td>Zipkin/Jaeger</td><td>语言支持广泛</td></tr><tr><td>云原生架构</td><td>Jaeger</td><td>CNCF项目，K8s集成好</td></tr><tr><td>性能敏感应用</td><td>自研或轻量级方案</td><td>减少性能开销</td></tr><tr><td>大数据量场景</td><td>SkyWalking</td><td>支持采样和聚合分析</td></tr><tr><td>快速上手</td><td>Zipkin</td><td>简单易用，社区资源丰富</td></tr></tbody></table><h3 id="_8-微服务中的常见架构和组件有哪些" tabindex="-1"><a class="header-anchor" href="#_8-微服务中的常见架构和组件有哪些"><span>8. 微服务中的常见架构和组件有哪些？</span></a></h3><p><strong>微服务架构核心组件分层：</strong></p><table><thead><tr><th>组件层级</th><th>核心组件</th><th>主要作用</th><th>代表技术</th></tr></thead><tbody><tr><td>接入层</td><td>API网关、负载均衡</td><td>流量接入、路由分发</td><td>Spring Cloud Gateway、Kong</td></tr><tr><td>治理层</td><td>服务注册发现、配置中心</td><td>服务管理、配置管理</td><td>Nacos、Consul、Eureka</td></tr><tr><td>通信层</td><td>服务调用、消息队列</td><td>服务间通信</td><td>Feign、Dubbo、RocketMQ</td></tr><tr><td>容错层</td><td>熔断降级、限流、重试</td><td>系统保护</td><td>Sentinel、Hystrix</td></tr><tr><td>监控层</td><td>链路追踪、指标监控、日志收集</td><td>可观测性</td><td>SkyWalking、Prometheus</td></tr><tr><td>安全层</td><td>认证授权、密钥管理</td><td>安全保障</td><td>OAuth2、JWT、Vault</td></tr></tbody></table><p><strong>服务注册与发现组件：</strong></p><table><thead><tr><th>组件</th><th>架构模式</th><th>一致性</th><th>健康检查</th><th>负载均衡</th><th>适用场景</th></tr></thead><tbody><tr><td>Eureka</td><td>AP</td><td>最终一致</td><td>支持</td><td>客户端</td><td>Spring Cloud生态</td></tr><tr><td>Consul</td><td>CP</td><td>强一致</td><td>支持</td><td>支持</td><td>多数据中心部署</td></tr><tr><td>Nacos</td><td>AP/CP</td><td>可配置</td><td>支持</td><td>支持</td><td>阿里云原生应用</td></tr><tr><td>Zookeeper</td><td>CP</td><td>强一致</td><td>支持</td><td>不支持</td><td>Dubbo生态</td></tr><tr><td>Etcd</td><td>CP</td><td>强一致</td><td>支持</td><td>不支持</td><td>Kubernetes</td></tr></tbody></table><p><strong>API网关功能对比：</strong></p><table><thead><tr><th>功能类别</th><th>Spring Cloud Gateway</th><th>Zuul</th><th>Kong</th><th>Nginx Plus</th></tr></thead><tbody><tr><td>性能</td><td>高（WebFlux异步）</td><td>中等</td><td>极高</td><td>极高</td></tr><tr><td>路由规则</td><td>灵活强大</td><td>基础</td><td>极其丰富</td><td>丰富</td></tr><tr><td>插件生态</td><td>Spring生态</td><td>有限</td><td>极其丰富</td><td>商业插件</td></tr><tr><td>限流熔断</td><td>结合Sentinel</td><td>基础</td><td>内置</td><td>内置</td></tr><tr><td>协议支持</td><td>HTTP/WebSocket</td><td>HTTP</td><td>HTTP/TCP等</td><td>全协议</td></tr><tr><td>学习成本</td><td>中等</td><td>低</td><td>高</td><td>中等</td></tr></tbody></table><p><strong>服务调用方式对比：</strong></p><table><thead><tr><th>调用方式</th><th>协议</th><th>序列化</th><th>性能</th><th>跨语言支持</th><th>适用场景</th></tr></thead><tbody><tr><td>HTTP REST</td><td>HTTP</td><td>JSON/XML</td><td>中等</td><td>优秀</td><td>Web服务、对外API</td></tr><tr><td>RPC (Dubbo)</td><td>TCP</td><td>Hessian等</td><td>高</td><td>Java</td><td>Java微服务</td></tr><tr><td>gRPC</td><td>HTTP/2</td><td>Protobuf</td><td>高</td><td>优秀</td><td>多语言微服务</td></tr><tr><td>GraphQL</td><td>HTTP</td><td>JSON</td><td>中等</td><td>优秀</td><td>前后端分离</td></tr><tr><td>消息队列</td><td>TCP/AMQP</td><td>多种</td><td>高</td><td>优秀</td><td>异步解耦</td></tr></tbody></table><p><strong>配置中心功能对比：</strong></p><table><thead><tr><th>配置中心</th><th>存储方式</th><th>动态推送</th><th>多环境</th><th>版本管理</th><th>权限控制</th><th>界面友好度</th></tr></thead><tbody><tr><td>Spring Cloud Config</td><td>Git</td><td>需Bus</td><td>支持</td><td>Git</td><td>基础</td><td>一般</td></tr><tr><td>Apollo</td><td>MySQL</td><td>支持</td><td>支持</td><td>完善</td><td>细粒度</td><td>优秀</td></tr><tr><td>Nacos</td><td>内置DB</td><td>支持</td><td>支持</td><td>支持</td><td>支持</td><td>良好</td></tr><tr><td>Consul KV</td><td>内置</td><td>支持</td><td>支持</td><td>基础</td><td>ACL</td><td>简洁</td></tr></tbody></table><p><strong>容错保护组件：</strong></p><table><thead><tr><th>组件</th><th>熔断降级</th><th>限流</th><th>实时监控</th><th>规则配置</th><th>性能开销</th><th>适用场景</th></tr></thead><tbody><tr><td>Sentinel</td><td>支持</td><td>多算法</td><td>实时</td><td>动态</td><td>低</td><td>阿里云生态</td></tr><tr><td>Hystrix</td><td>支持</td><td>基础</td><td>支持</td><td>注解</td><td>中等</td><td>Netflix技术栈</td></tr><tr><td>Resilience4j</td><td>支持</td><td>支持</td><td>支持</td><td>函数式</td><td>低</td><td>现代Java应用</td></tr></tbody></table><p><strong>微服务监控体系：</strong></p><table><thead><tr><th>监控类型</th><th>监控对象</th><th>关键指标</th><th>技术选型</th></tr></thead><tbody><tr><td>链路追踪</td><td>请求调用链</td><td>延迟、错误率、吞吐量</td><td>SkyWalking、Zipkin</td></tr><tr><td>指标监控</td><td>系统和业务指标</td><td>CPU、内存、QPS、业务指标</td><td>Prometheus、Micrometer</td></tr><tr><td>日志监控</td><td>应用日志</td><td>错误日志、业务日志</td><td>ELK、Fluentd</td></tr><tr><td>健康检查</td><td>服务健康状态</td><td>存活性、就绪性</td><td>Spring Actuator</td></tr><tr><td>告警通知</td><td>异常情况</td><td>阈值告警、趋势预警</td><td>AlertManager、钉钉</td></tr></tbody></table><p><strong>微服务架构模式：</strong></p><table><thead><tr><th>架构模式</th><th>特点</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>单体架构</td><td>所有功能在一个应用中</td><td>简单易部署</td><td>扩展性差、技术栈固定</td><td>小型应用</td></tr><tr><td>垂直切分</td><td>按业务功能拆分</td><td>团队独立、技术栈灵活</td><td>数据共享复杂</td><td>中型应用</td></tr><tr><td>水平切分</td><td>按数据或用户维度拆分</td><td>高可扩展性</td><td>架构复杂</td><td>大型应用</td></tr><tr><td>服务网格</td><td>基础设施层处理服务通信</td><td>业务无感知、功能强大</td><td>架构复杂、学习成本高</td><td>大规模微服务</td></tr><tr><td>Serverless</td><td>函数即服务</td><td>按需扩展、成本优化</td><td>冷启动、状态管理困难</td><td>事件驱动应用</td></tr></tbody></table><p><strong>容器化和编排：</strong></p><table><thead><tr><th>技术组件</th><th>作用</th><th>优势</th><th>学习曲线</th><th>适用场景</th></tr></thead><tbody><tr><td>Docker</td><td>容器化</td><td>环境一致性、轻量级</td><td>低</td><td>开发测试环境</td></tr><tr><td>Kubernetes</td><td>容器编排</td><td>自动扩缩容、服务发现</td><td>高</td><td>生产环境容器管理</td></tr><tr><td>Docker Compose</td><td>本地容器编排</td><td>简单易用、适合开发</td><td>低</td><td>本地开发环境</td></tr><tr><td>Helm</td><td>K8s包管理</td><td>应用打包、版本管理</td><td>中等</td><td>K8s应用部署</td></tr><tr><td>Istio</td><td>服务网格</td><td>流量管理、安全策略</td><td>高</td><td>大规模微服务治理</td></tr></tbody></table><p><strong>微服务部署策略：</strong></p><table><thead><tr><th>部署策略</th><th>实现方式</th><th>优点</th><th>缺点</th><th>风险等级</th></tr></thead><tbody><tr><td>蓝绿部署</td><td>维护两套完全相同的环境</td><td>零停机、快速回滚</td><td>资源消耗大</td><td>低</td></tr><tr><td>滚动部署</td><td>逐步替换旧实例</td><td>资源利用率高</td><td>部署时间长</td><td>中</td></tr><tr><td>金丝雀部署</td><td>新版本先部署到小部分流量</td><td>风险可控</td><td>实现复杂</td><td>低</td></tr><tr><td>A/B测试部署</td><td>同时运行多个版本进行对比测试</td><td>数据驱动决策</td><td>维护成本高</td><td>中</td></tr></tbody></table><h3 id="_9-负载均衡的机制" tabindex="-1"><a class="header-anchor" href="#_9-负载均衡的机制"><span>9. 负载均衡的机制</span></a></h3><p><strong>负载均衡</strong>是保证服务高可用和性能的关键机制。主要有两类负载均衡方式：<strong>客户端负载均衡</strong>和<strong>服务端负载均衡</strong>。</p><h4 id="_1️⃣-客户端负载均衡-client-side-load-balancing" tabindex="-1"><a class="header-anchor" href="#_1️⃣-客户端负载均衡-client-side-load-balancing"><span>1️⃣ 客户端负载均衡（Client-Side Load Balancing）</span></a></h4><ul><li><p><strong>特点</strong>：调用方自己从注册中心获取服务列表，然后选择一个实例进行调用</p></li><li><p><strong>实现机制</strong>：</p><ol><li><p><strong>服务发现</strong>：通过注册中心（如 Nacos、Eureka）获取服务实例列表</p></li><li><p><strong>负载均衡策略</strong>：</p><ul><li><strong>轮询（Round Robin）</strong>：按顺序选择实例</li><li><strong>随机（Random）</strong>：随机选择实例</li><li><strong>权重（Weighted）</strong>：根据实例权重选择</li><li><strong>最小连接数（Least Connections）</strong>：选择当前连接数最少的实例</li></ul></li></ol></li><li><p><strong>常用框架</strong>：</p><ul><li>Spring Cloud Ribbon（已被 Spring Cloud LoadBalancer 替代）</li><li>gRPC 自带的负载均衡策略</li></ul></li></ul><p><strong>流程示意</strong>：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>服务消费者 -&gt; 注册中心获取可用实例列表 -&gt; 按策略选择实例 -&gt; 直接调用</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h4 id="_2️⃣-服务端负载均衡-server-side-load-balancing" tabindex="-1"><a class="header-anchor" href="#_2️⃣-服务端负载均衡-server-side-load-balancing"><span>2️⃣ 服务端负载均衡（Server-Side Load Balancing）</span></a></h4><ul><li><p><strong>特点</strong>：客户端请求发送到统一入口（如网关、负载均衡器），由服务端负责选择实例转发</p></li><li><p><strong>实现机制</strong>：</p><ol><li><p><strong>入口负载均衡器</strong>（如 Nginx、HAProxy、Kong、Spring Cloud Gateway）</p></li><li><p><strong>转发策略</strong>：</p><ul><li>轮询、IP 哈希、权重等</li></ul></li></ol></li><li><p><strong>优点</strong>：</p><ul><li>客户端无需维护服务实例列表</li><li>易于统一监控和限流</li></ul></li><li><p><strong>缺点</strong>：</p><ul><li>增加一层转发，可能成为单点瓶颈（可集群化解决）</li></ul></li></ul><p><strong>流程示意</strong>：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>客户端请求 -&gt; 网关/负载均衡器 -&gt; 按策略选择后端实例 -&gt; 转发请求</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h4 id="_3️⃣-结合微服务生态的实践" tabindex="-1"><a class="header-anchor" href="#_3️⃣-结合微服务生态的实践"><span>3️⃣ 结合微服务生态的实践</span></a></h4><ul><li><strong>服务发现 + 客户端负载均衡</strong>：Ribbon + Nacos/Eureka</li><li><strong>网关 + 服务端负载均衡</strong>：Spring Cloud Gateway + Nginx</li><li><strong>云原生微服务</strong>：Kubernetes 使用 <strong>Service + Endpoints + kube-proxy</strong> 实现负载均衡</li></ul><p>💡 <strong>一句话总结</strong>：</p><ul><li><strong>客户端负载均衡</strong>：调用方自己选实例</li><li><strong>服务端负载均衡</strong>：入口/网关帮你选实例</li></ul><h2 id="消息队列" tabindex="-1"><a class="header-anchor" href="#消息队列"><span>消息队列</span></a></h2><h3 id="_1-消息队列的作用-解耦、异步、削峰填谷" tabindex="-1"><a class="header-anchor" href="#_1-消息队列的作用-解耦、异步、削峰填谷"><span>1. 消息队列的作用？（解耦、异步、削峰填谷）</span></a></h3><p><strong>消息队列定义：</strong> 在分布式系统中用于服务间通信的中间件，实现消息的异步传递和处理。</p><p><strong>三大核心作用：</strong></p><table><thead><tr><th>作用</th><th>定义</th><th>解决问题</th><th>应用场景</th><th>效果评估</th></tr></thead><tbody><tr><td>解耦</td><td>消息发送者和接收者不直接依赖</td><td>系统间强耦合</td><td>订单系统通知库存、支付、物流系统</td><td>耦合度降低80%</td></tr><tr><td>异步</td><td>发送消息后立即返回，不等待处理结果</td><td>同步调用响应时间长</td><td>用户注册后发送邮件、短信</td><td>响应时间减少70%</td></tr><tr><td>削峰填谷</td><td>缓冲高并发请求，平滑处理</td><td>瞬时高并发冲击</td><td>秒杀活动、双11促销</td><td>系统稳定性提升</td></tr></tbody></table><p><strong>使用前后对比：</strong></p><table><thead><tr><th>场景</th><th>不使用消息队列</th><th>使用消息队列</th><th>改善效果</th></tr></thead><tbody><tr><td>订单处理</td><td>同步调用库存、支付、物流，响应时间3秒</td><td>异步通知，响应时间500ms</td><td>响应速度提升6倍</td></tr><tr><td>系统故障</td><td>一个服务故障导致整个链路失败</td><td>服务故障不影响消息发送，具备容错能力</td><td>可用性从95%提升到99.9%</td></tr><tr><td>促销活动</td><td>瞬时流量冲垮系统</td><td>消息队列缓冲，平稳处理</td><td>系统零宕机</td></tr></tbody></table><h3 id="_2-消息模型-点对点queue和发布-订阅topic" tabindex="-1"><a class="header-anchor" href="#_2-消息模型-点对点queue和发布-订阅topic"><span>2. 消息模型？（点对点Queue和发布/订阅Topic）</span></a></h3><p><strong>两种消息模型对比：</strong></p><table><thead><tr><th>特性</th><th>点对点模型（Queue）</th><th>发布/订阅模型（Topic）</th></tr></thead><tbody><tr><td>消息消费</td><td>一条消息只能被一个消费者消费</td><td>一条消息可以被多个消费者消费</td></tr><tr><td>消费者关系</td><td>竞争关系</td><td>独立关系</td></tr><tr><td>消息持久化</td><td>消费后从队列删除</td><td>根据配置决定是否删除</td></tr><tr><td>扩展性</td><td>通过增加消费者实现负载均衡</td><td>通过增加订阅者实现广播</td></tr><tr><td>应用场景</td><td>任务分发、负载均衡</td><td>事件通知、数据同步</td></tr><tr><td>典型例子</td><td>订单处理队列</td><td>用户注册事件广播</td></tr></tbody></table><p><strong>使用场景选择：</strong></p><table><thead><tr><th>业务需求</th><th>推荐模型</th><th>原因</th><th>典型应用</th></tr></thead><tbody><tr><td>任务处理</td><td>Queue</td><td>确保每个任务只被处理一次</td><td>邮件发送、文件处理</td></tr><tr><td>事件广播</td><td>Topic</td><td>多个系统需要响应同一事件</td><td>用户注册、订单状态变更</td></tr><tr><td>负载均衡</td><td>Queue</td><td>多个消费者竞争处理消息</td><td>并发订单处理</td></tr><tr><td>数据同步</td><td>Topic</td><td>多个下游系统需要同步数据</td><td>数据仓库同步、缓存更新</td></tr><tr><td>日志收集</td><td>Topic</td><td>多个监控系统需要收集日志</td><td>ELK日志分析</td></tr></tbody></table><h3 id="_3-如何保证消息不丢失" tabindex="-1"><a class="header-anchor" href="#_3-如何保证消息不丢失"><span>3. 如何保证消息不丢失？</span></a></h3><p><strong>消息丢失的三个阶段：</strong></p><table><thead><tr><th>阶段</th><th>丢失场景</th><th>解决方案</th><th>实现方式</th></tr></thead><tbody><tr><td>生产者阶段</td><td>网络故障、Broker宕机</td><td>生产者确认机制</td><td>同步发送、异步回调确认</td></tr><tr><td>Broker阶段</td><td>消息未持久化到磁盘</td><td>消息持久化</td><td>同步刷盘、主从复制</td></tr><tr><td>消费者阶段</td><td>消费者宕机、处理失败</td><td>手动ACK</td><td>消费成功后再确认</td></tr></tbody></table><p><strong>详细保障机制：</strong></p><table><thead><tr><th>保障机制</th><th>实现原理</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>生产者确认</td><td>Producer等待Broker确认</td><td>确保消息到达Broker</td><td>性能略有下降</td><td>重要业务消息</td></tr><tr><td>同步刷盘</td><td>消息写入磁盘后返回确认</td><td>数据安全性高</td><td>性能影响大</td><td>金融级别可靠性</td></tr><tr><td>异步刷盘</td><td>消息先写入内存，异步写入磁盘</td><td>性能好</td><td>极端情况可能丢失消息</td><td>一般业务场景</td></tr><tr><td>主从复制</td><td>主节点同步消息到从节点</td><td>高可用</td><td>网络开销</td><td>高可用要求</td></tr><tr><td>手动ACK</td><td>消费者处理完业务逻辑后手动确认</td><td>确保消息被正确处理</td><td>需要处理重复消息</td><td>所有重要业务</td></tr></tbody></table><ul><li>刷盘：把内存中的数据写入磁盘文件，确保数据真正持久化到硬盘。</li></ul><h3 id="_4-如何保证消息不被重复消费-幂等性" tabindex="-1"><a class="header-anchor" href="#_4-如何保证消息不被重复消费-幂等性"><span>4. 如何保证消息不被重复消费（幂等性）？</span></a></h3><p><strong>重复消费产生原因：</strong></p><ul><li>网络抖动导致ACK丢失</li><li>消费者重启导致消息重新投递</li><li>Broker故障恢复后重新发送消息</li></ul><p><strong>幂等性保障方案：</strong></p><table><thead><tr><th>方案</th><th>实现原理</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>唯一ID去重</td><td>每条消息携带唯一标识</td><td>简单有效</td><td>需要存储已处理ID</td><td>通用场景</td></tr><tr><td>数据库唯一约束</td><td>利用数据库唯一索引</td><td>实现简单</td><td>依赖数据库</td><td>数据库操作为主的业务</td></tr><tr><td>Redis去重</td><td>使用Redis存储消息ID</td><td>性能好</td><td>需要额外的Redis实例</td><td>高性能要求</td></tr><tr><td>状态机控制</td><td>通过业务状态判断是否已处理</td><td>业务语义明确</td><td>业务逻辑复杂</td><td>有明确状态的业务流程</td></tr><tr><td>业务逻辑幂等</td><td>设计天然幂等的业务逻辑</td><td>无额外开销</td><td>并非所有业务都能实现</td><td>查询类操作</td></tr></tbody></table><p><strong>实现示例对比：</strong></p><table><thead><tr><th>业务场景</th><th>推荐方案</th><th>实现方式</th><th>注意事项</th></tr></thead><tbody><tr><td>账户扣款</td><td>数据库唯一约束</td><td>订单号作为唯一约束</td><td>避免重复扣款</td></tr><tr><td>发送邮件</td><td>Redis去重</td><td>消息ID作为Redis key</td><td>设置合理的过期时间</td></tr><tr><td>数据同步</td><td>状态机控制</td><td>检查目标数据是否已存在</td><td>处理并发更新问题</td></tr><tr><td>积分增加</td><td>业务逻辑幂等</td><td>使用CAS操作更新积分</td><td>处理ABA问题</td></tr></tbody></table><h3 id="_5-如何保证消息的顺序性" tabindex="-1"><a class="header-anchor" href="#_5-如何保证消息的顺序性"><span>5. 如何保证消息的顺序性？</span></a></h3><p><strong>顺序性需求分析：</strong></p><table><thead><tr><th>顺序性类型</th><th>定义</th><th>实现难度</th><th>性能影响</th><th>适用场景</th></tr></thead><tbody><tr><td>全局有序</td><td>所有消息严格按时间顺序处理</td><td>高</td><td>大</td><td>金融交易、账务流水</td></tr><tr><td>分区有序</td><td>同一分区内消息有序</td><td>中</td><td>小</td><td>同一用户的操作序列</td></tr><tr><td>局部有序</td><td>特定业务场景下的消息有序</td><td>低</td><td>无</td><td>单个订单的状态变更流程</td></tr></tbody></table><p><strong>实现方案对比：</strong></p><table><thead><tr><th>方案</th><th>实现方式</th><th>优点</th><th>缺点</th><th>性能影响</th></tr></thead><tbody><tr><td>单队列单消费者</td><td>只使用一个队列和一个消费者</td><td>严格有序</td><td>性能瓶颈、无法扩展</td><td>性能最差</td></tr><tr><td>分区有序</td><td>相同Key的消息发送到同一分区</td><td>平衡性能与顺序</td><td>分区内有序、全局无序</td><td>性能较好</td></tr><tr><td>消息队列顺序</td><td>业务层面保证同类消息的顺序处理</td><td>业务灵活性高</td><td>实现复杂</td><td>性能影响小</td></tr><tr><td>时间戳排序</td><td>消费者根据时间戳重新排序</td><td>全局有序</td><td>延迟高、内存占用大</td><td>延迟增加</td></tr></tbody></table><p><strong>技术选型建议：</strong></p><table><thead><tr><th>业务场景</th><th>推荐方案</th><th>理由</th><th>实现要点</th></tr></thead><tbody><tr><td>股票交易</td><td>单队列单消费者</td><td>严格时序要求</td><td>可以牺牲性能保证正确性</td></tr><tr><td>用户操作日志</td><td>分区有序</td><td>同一用户操作需要有序</td><td>以用户ID作为分区Key</td></tr><tr><td>订单状态流转</td><td>消息队列顺序</td><td>只需要同一订单内有序</td><td>以订单ID作为分组</td></tr><tr><td>系统日志收集</td><td>无需严格顺序</td><td>日志分析不严格依赖顺序</td><td>优先考虑性能和吞吐量</td></tr></tbody></table><h3 id="_6-常用消息队列比较-kafka、rabbitmq、rocketmq-队列的类型" tabindex="-1"><a class="header-anchor" href="#_6-常用消息队列比较-kafka、rabbitmq、rocketmq-队列的类型"><span>6. 常用消息队列比较？（Kafka、RabbitMQ、RocketMQ）队列的类型？</span></a></h3><p><strong>核心特性对比：</strong></p><table><thead><tr><th>特性</th><th>Kafka</th><th>RabbitMQ</th><th>RocketMQ</th></tr></thead><tbody><tr><td>开发语言</td><td>Scala/Java</td><td>Erlang</td><td>Java</td></tr><tr><td>性能</td><td>极高（百万级/秒）</td><td>高（万级/秒）</td><td>高（十万级/秒）</td></tr><tr><td>可靠性</td><td>高</td><td>极高</td><td>高</td></tr><tr><td>功能丰富度</td><td>基础</td><td>丰富</td><td>丰富</td></tr><tr><td>运维复杂度</td><td>中等</td><td>简单</td><td>中等</td></tr><tr><td>社区活跃度</td><td>极高</td><td>高</td><td>中等</td></tr><tr><td>企业支持</td><td>Apache基金会</td><td>VMware</td><td>阿里巴巴</td></tr></tbody></table><p><strong>详细功能对比：</strong></p><table><thead><tr><th>功能</th><th>Kafka</th><th>RabbitMQ</th><th>RocketMQ</th></tr></thead><tbody><tr><td>消息顺序性</td><td>分区有序</td><td>队列有序</td><td>分区有序</td></tr><tr><td>消息路由</td><td>简单</td><td>灵活强大</td><td>丰富</td></tr><tr><td>消息过滤</td><td>不支持</td><td>支持</td><td>支持</td></tr><tr><td>死信队列</td><td>不支持</td><td>支持</td><td>支持</td></tr><tr><td>延时消息</td><td>不支持</td><td>插件支持</td><td>原生支持</td></tr><tr><td>事务消息</td><td>0.11版本后支持</td><td>支持</td><td>支持</td></tr><tr><td>消息重试</td><td>不支持</td><td>支持</td><td>支持</td></tr><tr><td>集群部署</td><td>原生支持</td><td>支持</td><td>支持</td></tr></tbody></table><p><strong>适用场景推荐：</strong></p><table><thead><tr><th>使用场景</th><th>推荐MQ</th><th>选择理由</th><th>注意事项</th></tr></thead><tbody><tr><td>日志收集、大数据处理</td><td>Kafka</td><td>超高吞吐量、水平扩展能力强</td><td>功能相对简单，需要自己实现一些特性</td></tr><tr><td>企业级应用、复杂路由</td><td>RabbitMQ</td><td>功能丰富、可靠性高、运维简单</td><td>性能相对较低</td></tr><tr><td>电商、金融等业务系统</td><td>RocketMQ</td><td>功能全面、性能好、专门为业务场景设计</td><td>社区相对较小</td></tr><tr><td>微服务间通信</td><td>RabbitMQ</td><td>消息路由灵活、支持多种协议</td><td>需要考虑消息积压问题</td></tr><tr><td>实时数据流处理</td><td>Kafka</td><td>低延迟、高吞吐、与大数据生态集成好</td><td>不适合复杂的业务逻辑处理</td></tr><tr><td>订单处理、支付系统</td><td>RocketMQ</td><td>事务消息、顺序消息、高可靠性</td><td>运维复杂度相对较高</td></tr></tbody></table><ul><li>传统消息队列适合异步解耦和事务消息，Kafka 更偏向高吞吐量、可扩展、持久化日志和流式数据处理场景。</li><li>Kafka 支持事务，保证生产者端跨分区/Topic 的消息原子写入；RabbitMQ 理论上支持事务，但实际性能低，通常使用确认机制代替。RabbitMQ 常用于异步解耦、流量削峰和复杂路由场景。引入这些中间件虽然可以提高系统可用性和解耦能力，但也带来系统复杂度、消息一致性、性能调优和运维成本增加等问题。</li></ul><p><strong>消息队列类型：</strong></p><table><thead><tr><th>队列类型</th><th>描述</th><th>优点</th><th>缺点</th><th>典型场景</th></tr></thead><tbody><tr><td><strong>普通队列 / 点对点（Queue）</strong></td><td>单个消息被一个消费者消费</td><td>简单可靠</td><td>吞吐有限</td><td>单机任务分发、日志处理</td></tr><tr><td><strong>发布/订阅队列（Topic）</strong></td><td>消息被所有订阅者接收</td><td>广播能力强</td><td>消费者数量多时占用资源大</td><td>广播通知、事件分发</td></tr><tr><td><strong>延时队列（Delayed / TTL）</strong></td><td>消息在一定时间后才被消费</td><td>实现定时任务简单</td><td>精度依赖 Broker 支持</td><td>秒级定时任务、消息重试</td></tr><tr><td><strong>死信队列（DLQ）</strong></td><td>消费失败或超时的消息进入 DLQ</td><td>便于异常处理和补偿</td><td>需要额外管理</td><td>异常消息处理、补偿机制</td></tr><tr><td><strong>顺序队列（FIFO / Ordered Queue）</strong></td><td>保证消息严格顺序消费</td><td>保证顺序一致性</td><td>吞吐量可能下降</td><td>订单处理、支付流水</td></tr><tr><td><strong>优先队列（Priority Queue）</strong></td><td>消息带优先级，先消费高优先级</td><td>支持紧急任务调度</td><td>Broker 支持有限</td><td>高优先级任务处理</td></tr><tr><td><strong>事务消息队列</strong></td><td>消息发送和业务操作保持一致</td><td>支持分布式事务补偿</td><td>性能较低、实现复杂</td><td>金融支付、库存扣减</td></tr></tbody></table><h3 id="_7-rabbitmq的高可用-仲裁队列-死信队列" tabindex="-1"><a class="header-anchor" href="#_7-rabbitmq的高可用-仲裁队列-死信队列"><span>7. RabbitMQ的高可用？仲裁队列？死信队列？</span></a></h3><table><thead><tr><th>项目</th><th>镜像队列（Mirrored）</th><th>仲裁队列（Quorum）</th></tr></thead><tbody><tr><td>数据复制方式</td><td>所有副本都同步</td><td>Raft 共识，仅主副本写入</td></tr><tr><td>一致性保障</td><td>弱一致性</td><td>强一致性（需要多数写入）</td></tr><tr><td>容错机制</td><td>主挂换从</td><td>少数节点故障可存活</td></tr><tr><td>性能</td><td>副本多时开销大</td><td>更高效，扩展性更好</td></tr><tr><td>RabbitMQ 推荐情况</td><td>已废弃（不推荐新建）</td><td>官方推荐用于生产环境</td></tr></tbody></table><p><strong>仲裁队列：</strong></p><ul><li>每个仲裁队列在多个节点中有副本，通常奇数个（推荐 3 个）</li><li>一个节点是 Leader，其他是 Follower</li><li>消息发送到 Leader，只有在多数副本（Quorum）确认后才认为写入成功</li><li>Leader 宕机会自动选举新的 Leader，过程对客户端透明</li><li>写成功 = 半数以上副本写成功 → 强一致性</li></ul><p><strong>死信队列：</strong></p><ul><li>死信队列是专门处理无法正常消费或过期的消息的队列。当消息被拒绝、过期或队列满时，会自动进入死信队列。消费死信队列的消息可以做日志、告警或重试操作，这样可以保证主队列正常消费不被阻塞，同时方便异常消息分析和补偿。</li></ul><h3 id="_8-kafka的高可用和高性能" tabindex="-1"><a class="header-anchor" href="#_8-kafka的高可用和高性能"><span>8. Kafka的高可用和高性能？</span></a></h3><p><strong>Kafka的高可用性主要通过以下机制实现：</strong></p><ul><li>集群部署，多broker实例，单点故障不影响整体服务。</li><li>复制机制，每个分区有多个副本，leader和follower，leader故障时从follower中选举新leader。</li></ul><p><strong>Kafka高性能设计：</strong></p><ul><li>消息分区，提升数据处理能力。</li><li>顺序读写，提高磁盘操作效率。</li><li>页缓存，减少磁盘访问。</li><li>零拷贝，减少数据拷贝和上下文切换。sendfile 系统调用，这样 Broker 可以直接把磁盘数据发给 Socket，不需要读到用户态再写出去。</li><li>消息压缩，减少IO负载。</li><li>分批发送，降低网络开销。</li></ul><h3 id="_9-单条消息阻塞了-如何处理" tabindex="-1"><a class="header-anchor" href="#_9-单条消息阻塞了-如何处理"><span>9. 单条消息阻塞了，如何处理？</span></a></h3><ul><li>增加消费者并发度（多线程消费 / 多分区）。</li><li>设置消费超时，失败消息转入死信队列或延迟队列。</li><li>将不同类型/耗时差异大的消息隔离到不同队列。</li><li>必要时改为异步处理，避免 MQ 消费链路被单点阻塞。</li></ul><h2 id="主流框架、系统设计、编码能力" tabindex="-1"><a class="header-anchor" href="#主流框架、系统设计、编码能力"><span>主流框架、系统设计、编码能力</span></a></h2><h3 id="_1-spring方向-ioc-控制反转-di-依赖注入-aop-面向切面编程" tabindex="-1"><a class="header-anchor" href="#_1-spring方向-ioc-控制反转-di-依赖注入-aop-面向切面编程"><span>1. Spring方向 - (IoC - 控制反转 / DI - 依赖注入, AOP - 面向切面编程)</span></a></h3><p><strong>IoC（控制反转）核心概念：</strong></p><table><thead><tr><th>概念</th><th>定义</th><th>传统方式</th><th>IoC方式</th><th>优势</th></tr></thead><tbody><tr><td>控制反转</td><td>对象创建控制权从程序代码转移到外部容器</td><td>程序主动创建依赖对象</td><td>容器创建并注入对象</td><td>降低耦合度、提高可测试性</td></tr><tr><td>依赖注入</td><td>容器负责将依赖的对象注入到需要的地方</td><td>new 关键字创建对象</td><td>@Autowired等注解注入</td><td>自动装配、配置灵活</td></tr><tr><td>容器管理</td><td>Spring容器负责对象的生命周期管理</td><td>手动管理对象生命周期</td><td>容器自动管理</td><td>减少内存泄漏、提高性能</td></tr></tbody></table><p><strong>DI依赖注入方式对比：</strong></p><table><thead><tr><th>注入方式</th><th>实现方式</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>构造器注入</td><td>通过构造函数参数注入</td><td>强制依赖、不可变对象</td><td>构造函数参数可能过多</td><td>必需依赖</td></tr><tr><td>Setter注入</td><td>通过setter方法注入</td><td>可选依赖、灵活配置</td><td>可能忘记注入某些依赖</td><td>可选依赖</td></tr><tr><td>字段注入</td><td>直接在字段上使用@Autowired</td><td>代码简洁</td><td>难以测试、违反封装性</td><td>快速开发</td></tr></tbody></table><p><strong>Autowired和Resource的区别：</strong></p><ul><li>@Autowired 是 Spring 提供的注解，默认按类型ByType注入</li><li>@Resource 是 JSR-250 规范提供的注解，默认按名称ByName注入</li></ul><h3 id="_2-aop-面向切面编程" tabindex="-1"><a class="header-anchor" href="#_2-aop-面向切面编程"><span>2. AOP (面向切面编程)</span></a></h3><p><strong>AOP核心概念：</strong></p><table><thead><tr><th>概念</th><th>定义</th><th>作用</th><th>示例</th></tr></thead><tbody><tr><td>切面(Aspect)</td><td>横切关注点的模块化</td><td>封装横切逻辑</td><td>日志切面、事务切面</td></tr><tr><td>连接点(JoinPoint)</td><td>程序执行过程中能够插入切面的点</td><td>定义切入位置</td><td>方法调用、异常抛出</td></tr><tr><td>切入点(Pointcut)</td><td>匹配连接点的表达式</td><td>定义在哪些地方切入</td><td>execution(* com.<em>.</em>(..))</td></tr><tr><td>通知(Advice)</td><td>在切入点执行的代码</td><td>定义切入后做什么</td><td>@Before、@After</td></tr><tr><td>织入(Weaving)</td><td>将切面应用到目标对象的过程</td><td>实现AOP功能</td><td>编译时、类加载时、运行时</td></tr></tbody></table><p><strong>Spring AOP实现方式：</strong> 动态代理（Dynamic Proxy）指的是在运行时（而不是编译时）动态生成代理类，并通过代理对象来增强或拦截目标对象的方法调用。</p><p>👉 代理对象 = 真实对象 + 增强逻辑（例如日志、事务、权限验证、AOP切面）。</p><table><thead><tr><th>实现方式</th><th>原理</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>JDK动态代理</td><td>基于接口的代理</td><td>标准JDK实现</td><td>只能代理接口</td><td>有接口的类</td></tr><tr><td>CGLIB代理</td><td>基于继承的代理</td><td>可以代理普通类</td><td>不能代理final类和方法</td><td>没有接口的类</td></tr></tbody></table><ul><li>Spring AOP 默认用 JDK 动态代理（如果目标类实现了接口）。如果目标类 没有实现接口，Spring 自动切换成 CGLIB 动态代理。</li><li>Spring Boot默认用CGLIB动态代理。</li></ul><p><strong>AOP失效情况：</strong></p><table><thead><tr><th>情况</th><th>原因</th><th>解决思路</th></tr></thead><tbody><tr><td><strong>非 Spring 管理的对象</strong></td><td>AOP 基于 Spring 容器代理，容器外对象不会被增强</td><td>确保对象交由 Spring 容器管理（如使用 <code>@Component</code>、<code>@Bean</code> 等）</td></tr><tr><td><strong>同一 Bean 内部方法调用</strong></td><td>内部方法调用绕过了代理对象</td><td>通过 <strong>自我注入（Self-injection）</strong>，从容器获取自身代理调用</td></tr><tr><td><strong>静态方法</strong></td><td>AOP 依赖动态代理，无法增强 <code>static</code> 方法</td><td>避免在切面中拦截 <code>static</code> 方法</td></tr><tr><td><strong>final 方法</strong></td><td><code>final</code> 方法不可被代理类重写</td><td>去掉 <code>final</code> 修饰符，或用字节码增强工具（如 ASM）</td></tr><tr><td><strong>对象内部直接调用方法（非代理调用）</strong></td><td>AOP 只在 <strong>代理对象的方法调用</strong> 时生效</td><td>始终通过代理对象来调用目标方法</td></tr></tbody></table><ul><li>Spring AOP 只能拦截 Spring 容器管理的 Bean，且必须通过代理对象调用非静态、非 final 方法。</li></ul><h3 id="_3-spring事务管理" tabindex="-1"><a class="header-anchor" href="#_3-spring事务管理"><span>3. Spring事务管理</span></a></h3><p><strong>事务传播行为：</strong></p><table><thead><tr><th>传播行为</th><th>行为描述</th><th>使用场景</th><th>风险提示</th></tr></thead><tbody><tr><td>REQUIRED（默认）</td><td>有事务就加入，没有就新建</td><td>最常用的传播行为</td><td>无</td></tr><tr><td>REQUIRES_NEW</td><td>总是新建事务</td><td>需要独立事务的操作</td><td>可能导致死锁</td></tr><tr><td>SUPPORTS</td><td>有事务就加入，没有就非事务执行</td><td>查询操作</td><td>数据一致性问题</td></tr><tr><td>NOT_SUPPORTED</td><td>总是非事务执行</td><td>纯查询操作</td><td>不支持事务回滚</td></tr><tr><td>MANDATORY</td><td>必须在事务中执行</td><td>强制事务的业务逻辑</td><td>没有事务会抛异常</td></tr><tr><td>NEVER</td><td>不能在事务中执行</td><td>不能有事务的操作</td><td>有事务会抛异常</td></tr><tr><td>NESTED</td><td>嵌套事务</td><td>部分回滚场景</td><td>依赖数据库支持</td></tr></tbody></table><p><strong>事务类型对比：</strong></p><table><thead><tr><th>对比项</th><th>声明式事务</th><th>编程式事务</th></tr></thead><tbody><tr><td><strong>使用方法</strong></td><td><code>@Transactional</code></td><td><code>TransactionTemplate</code></td></tr><tr><td><strong>优点</strong></td><td>使用简单</td><td>可以控制事务提交的开启和提交时机，能够更小粒度地控制事务的范围，也更加直观</td></tr><tr><td><strong>缺点</strong></td><td>使用不当事务可能失效；多个事务性操作可能导致事务无法正常提交，导致长事务</td><td>需要硬编码来控制事务</td></tr><tr><td><strong>适用场景</strong></td><td>同一个方法中，事务操作比较多</td><td>当事务操作的数量很少</td></tr></tbody></table><p><strong>事务嵌套：</strong></p><table><thead><tr><th>传播行为</th><th>与外部事务关系</th><th>回滚行为</th></tr></thead><tbody><tr><td><code>REQUIRED</code></td><td>同一个事务</td><td>内部异常导致整个事务回滚</td></tr><tr><td><code>REQUIRES_NEW</code></td><td>独立事务</td><td>内部异常只回滚自己事务，外部不影响</td></tr><tr><td><code>NESTED</code></td><td>子事务</td><td>内部异常回滚到保存点，外部可继续或回滚</td></tr></tbody></table><ul><li>注意：异常回滚问题：默认只在抛出 RuntimeException 或 Error 时才回滚，checked exception 需手动指定，在注解上添加 <code>rollbackFor = Exception.class</code>，否则不会回滚。</li></ul><h3 id="_4-spring-mvc的工作原理-核心组件-处理请求的流程" tabindex="-1"><a class="header-anchor" href="#_4-spring-mvc的工作原理-核心组件-处理请求的流程"><span>4. Spring MVC的工作原理？核心组件？处理请求的流程？</span></a></h3><p><strong>Spring MVC核心组件：</strong></p><table><thead><tr><th>组件</th><th>作用</th><th>核心功能</th><th>配置方式</th></tr></thead><tbody><tr><td>DispatcherServlet</td><td>前端控制器，统一调度请求</td><td>请求分发、异常处理、视图渲染</td><td>web.xml或Java配置</td></tr><tr><td>HandlerMapping</td><td>处理器映射器，找到处理请求的Controller</td><td>URL映射、RESTful路由</td><td>@RequestMapping</td></tr><tr><td>HandlerAdapter</td><td>处理器适配器，调用具体的处理方法</td><td>参数解析、返回值处理</td><td>自动配置</td></tr><tr><td>ViewResolver</td><td>视图解析器，解析逻辑视图名</td><td>视图路径解析、模板引擎集成</td><td>配置文件</td></tr></tbody></table><p><strong>请求处理流程：</strong></p><table><thead><tr><th>步骤</th><th>组件</th><th>具体操作</th><th>数据流转</th></tr></thead><tbody><tr><td>1</td><td>DispatcherServlet</td><td>接收HTTP请求</td><td>HttpServletRequest</td></tr><tr><td>2</td><td>HandlerMapping</td><td>根据URL找到对应的Controller和方法</td><td>HandlerExecutionChain</td></tr><tr><td>3</td><td>HandlerAdapter</td><td>调用Controller方法，处理业务逻辑</td><td>ModelAndView</td></tr><tr><td>4</td><td>ViewResolver</td><td>解析逻辑视图名，找到具体视图模板</td><td>View对象</td></tr><tr><td>5</td><td>View</td><td>渲染视图，生成HTML响应</td><td>HttpServletResponse</td></tr></tbody></table><h3 id="_5-spring如何解决循环依赖" tabindex="-1"><a class="header-anchor" href="#_5-spring如何解决循环依赖"><span>5. Spring如何解决循环依赖？</span></a></h3><table><thead><tr><th>缓存名</th><th>顺序</th><th>类型</th><th>存什么</th></tr></thead><tbody><tr><td><code>singletonObjects</code></td><td>第 1 级</td><td>成品缓存</td><td>已经创建好 + 初始化 + 注入完的 Bean</td></tr><tr><td><code>earlySingletonObjects</code></td><td>第 2 级</td><td>半成品缓存</td><td>只实例化了，还没注入依赖或初始化的 Bean（裸对象）</td></tr><tr><td><code>singletonFactories</code></td><td>第 3 级</td><td>工厂缓存</td><td>可以生成早期引用的对象（可能是代理对象）</td></tr></tbody></table><ul><li>二级缓存只能暴露裸对象，对于需要 AOP 代理的 Bean 不够灵活，可能会导致 Bean 被提前注入的是未代理版本。</li><li>三级缓存允许通过 ObjectFactory 延迟创建最终版本（带代理）Bean，从而解决代理和依赖注入的“先后顺序冲突”问题。</li></ul><p><strong>具体步骤：</strong></p><ol><li>实例化A对象，并创建ObjectFactory存入三级缓存。</li><li>A在初始化时需要B对象，开始B的创建逻辑。</li><li>B实例化完成，也创建ObjectFactory存入三级缓存。</li><li>B需要注入A，通过三级缓存获取ObjectFactory生成A对象，存入二级缓存。</li><li>B通过二级缓存获得A对象后，B创建成功，存入一级缓存。</li><li>A对象初始化时，由于B已创建完成，可以直接注入B，A创建成功存入一级缓存。</li><li>清除二级缓存中的临时对象A。</li></ol><ul><li><strong>Spring 只能解决“非构造器注入”的循环依赖（比如 setter 注入且是在单例模式、字段注入(@Autowired)）</strong></li><li><strong>Spring 无法解决“构造器注入”导致的循环依赖！</strong><ul><li>可以使用 <code>@Lazy</code> 注解延迟加载，避免立即触发实例化</li></ul></li></ul><h3 id="_6-1-一级缓存和二级缓存的区别" tabindex="-1"><a class="header-anchor" href="#_6-1-一级缓存和二级缓存的区别"><span>6.1 一级缓存和二级缓存的区别？</span></a></h3><p><strong>缓存级别对比：</strong></p><table><thead><tr><th>特性</th><th>一级缓存（SqlSession级别）</th><th>二级缓存（Mapper级别）</th></tr></thead><tbody><tr><td>作用域</td><td>单个SqlSession</td><td>同一个Mapper的所有SqlSession</td></tr><tr><td>生命周期</td><td>SqlSession关闭时失效</td><td>应用程序关闭时失效</td></tr><tr><td>默认开启</td><td>默认开启</td><td>需要手动开启</td></tr><tr><td>共享性</td><td>不共享</td><td>多个SqlSession共享</td></tr><tr><td>清空时机</td><td>commit/rollback/close</td><td>手动清空或配置自动清空</td></tr><tr><td>存储位置</td><td>SqlSession内存</td><td>可配置多种存储方式</td></tr></tbody></table><p><strong>缓存配置和使用：</strong></p><table><thead><tr><th>配置项目</th><th>一级缓存</th><th>二级缓存</th></tr></thead><tbody><tr><td>开启方式</td><td>无需配置，默认开启</td><td><code>@CacheNamespace</code>或<code>&lt;cache&gt;</code></td></tr><tr><td>失效策略</td><td>自动失效</td><td>LRU、FIFO、SOFT、WEAK</td></tr><tr><td>刷新策略</td><td>增删改操作自动清空</td><td>可配置flushInterval</td></tr><tr><td>序列化要求</td><td>无</td><td>实体类需实现Serializable接口</td></tr></tbody></table><h3 id="_6-2-resultmap-和-resulttype-的区别" tabindex="-1"><a class="header-anchor" href="#_6-2-resultmap-和-resulttype-的区别"><span>6.2 ResultMap 和 ResultType 的区别？</span></a></h3><p><strong>使用场景对比：</strong></p><table><thead><tr><th>特性</th><th>ResultType</th><th>ResultMap</th></tr></thead><tbody><tr><td>适用场景</td><td>简单映射、字段名一致</td><td>复杂映射、字段名不一致、关联查询</td></tr><tr><td>配置复杂度</td><td>简单</td><td>复杂</td></tr><tr><td>映射方式</td><td>自动映射</td><td>手动配置映射关系</td></tr><tr><td>性能</td><td>较好</td><td>略差（需要解析配置）</td></tr><tr><td>功能</td><td>基础功能</td><td>支持嵌套、关联、继承等高级功能</td></tr><tr><td>维护成本</td><td>低</td><td>高</td></tr></tbody></table><p><strong>选择建议：</strong></p><table><thead><tr><th>场景</th><th>推荐方案</th><th>原因</th></tr></thead><tbody><tr><td>简单POJO映射</td><td>ResultType</td><td>配置简单，性能好</td></tr><tr><td>字段名与属性名不一致</td><td>ResultMap</td><td>需要手动映射</td></tr><tr><td>一对一、一对多关联查询</td><td>ResultMap</td><td>支持嵌套映射</td></tr><tr><td>需要类型转换</td><td>ResultMap</td><td>支持TypeHandler</td></tr><tr><td>继承关系映射</td><td>ResultMap</td><td>支持继承和多态</td></tr></tbody></table><h3 id="_6-3-延迟加载-懒加载-的原理和配置" tabindex="-1"><a class="header-anchor" href="#_6-3-延迟加载-懒加载-的原理和配置"><span>6.3 延迟加载（懒加载）的原理和配置？</span></a></h3><p><strong>延迟加载机制：</strong></p><table><thead><tr><th>概念</th><th>定义</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>延迟加载</td><td>关联对象在真正使用时才加载</td><td>提高性能、减少内存占用</td><td>可能产生N+1问题</td><td>大对象关联</td></tr><tr><td>立即加载</td><td>查询时一次性加载所有关联对象</td><td>减少数据库访问次数</td><td>可能加载不需要的数据</td><td>小对象关联</td></tr></tbody></table><p><strong>配置方式：</strong></p><table><thead><tr><th>配置级别</th><th>配置位置</th><th>配置项</th><th>说明</th></tr></thead><tbody><tr><td>全局配置</td><td>mybatis-config.xml</td><td>lazyLoadingEnabled=true</td><td>全局开启延迟加载</td></tr><tr><td>局部配置</td><td>ResultMap</td><td>fetchType=&quot;lazy/eager&quot;</td><td>针对特定关联配置</td></tr><tr><td>方法级配置</td><td>@Select等注解</td><td>fetchType属性</td><td>注解方式配置</td></tr></tbody></table><h3 id="_6-4-如何实现分页" tabindex="-1"><a class="header-anchor" href="#_6-4-如何实现分页"><span>6.4 如何实现分页？</span></a></h3><p><strong>分页实现方案对比：</strong></p><table><thead><tr><th>方案</th><th>实现原理</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>RowBounds内存分页</td><td>查询所有数据后在内存中分页</td><td>实现简单</td><td>性能差、内存占用大</td><td>小数据量</td></tr><tr><td>PageHelper物理分页</td><td>自动改写SQL添加LIMIT</td><td>性能好、使用简单</td><td>依赖插件</td><td>大数据量、生产环境</td></tr><tr><td>手写SQL分页</td><td>手动编写带LIMIT的SQL</td><td>性能最好、可控性强</td><td>开发复杂、维护成本高</td><td>复杂查询场景</td></tr></tbody></table><p><strong>PageHelper使用示例：</strong></p><table><thead><tr><th>使用方式</th><th>代码示例</th><th>说明</th></tr></thead><tbody><tr><td>方法调用</td><td><code>PageHelper.startPage(1, 10)</code></td><td>在查询前调用</td></tr><tr><td>注解方式</td><td><code>@Select + @Options</code></td><td>注解配置分页参数</td></tr><tr><td>参数传递</td><td><code>PageInfo&lt;User&gt; pageInfo</code></td><td>封装分页结果</td></tr></tbody></table><h3 id="_7-设计一个秒杀系统" tabindex="-1"><a class="header-anchor" href="#_7-设计一个秒杀系统"><span>7. 设计一个秒杀系统</span></a></h3><p><strong>秒杀系统面临的问题：</strong></p><ul><li>高并发压力：数据库、缓存和服务容易被瞬时流量压垮，需要限流、异步排队和缓存预减库存；</li><li>数据一致性：库存和订单分布式更新可能出现超卖，需要 Redis 原子操作、分布式锁或最终一致性机制；</li><li>服务可靠性：服务雪崩风险，需要熔断、降级、隔离线程池；</li><li>用户体验：排队、超时和失败反馈，需要前端排队和异步处理机制。</li></ul><p><strong>系统架构设计：</strong></p><table><thead><tr><th>层次</th><th>组件</th><th>作用</th><th>技术选型</th><th>关键指标</th></tr></thead><tbody><tr><td>接入层</td><td>CDN + 负载均衡</td><td>静态资源加速、流量分发</td><td>Nginx、LVS</td><td>QPS: 10万+</td></tr><tr><td>应用层</td><td>微服务集群</td><td>业务逻辑处理</td><td>Spring Boot集群</td><td>响应时间: &lt;100ms</td></tr><tr><td>缓存层</td><td>Redis集群</td><td>热点数据缓存</td><td>Redis Cluster</td><td>命中率: &gt;95%</td></tr><tr><td>数据层</td><td>MySQL主从</td><td>数据持久化</td><td>MySQL 8.0</td><td>TPS: 1万+</td></tr><tr><td>消息层</td><td>消息队列</td><td>异步处理、削峰填谷</td><td>RocketMQ</td><td>吞吐量: 10万条/秒</td></tr></tbody></table><p><strong>核心技术方案：</strong></p><table><thead><tr><th>技术挑战</th><th>解决方案</th><th>实现方式</th><th>效果评估</th></tr></thead><tbody><tr><td>高并发读</td><td>多级缓存 + CDN</td><td>Redis + 本地缓存 + CDN静态化</td><td>减少99%数据库访问</td></tr><tr><td>库存扣减</td><td>Redis Lua脚本</td><td>原子性操作，避免超卖</td><td>100%准确性</td></tr><tr><td>流量削峰</td><td>消息队列异步处理</td><td>秒杀请求先入队，异步处理订单</td><td>削峰90%</td></tr><tr><td>限流保护</td><td>令牌桶 + 熔断降级</td><td>Sentinel限流，超限返回友好提示</td><td>系统稳定性99.9%</td></tr><tr><td>数据一致性</td><td>分布式事务</td><td>Seata分布式事务，保证最终一致性</td><td>数据准确性100%</td></tr></tbody></table><p><strong>Redis Lua脚本示例：</strong></p><table><thead><tr><th>功能</th><th>脚本逻辑</th><th>优势</th></tr></thead><tbody><tr><td>库存扣减</td><td>检查库存 → 扣减库存 → 记录用户购买</td><td>原子性操作，避免超卖</td></tr><tr><td>防重复购买</td><td>检查用户购买记录 → 执行购买逻辑</td><td>避免重复下单</td></tr><tr><td>限流控制</td><td>检查请求频率 → 更新计数器</td><td>精确限流</td></tr></tbody></table><p><strong>防止超卖的核心要点</strong></p><table><thead><tr><th>方案</th><th>实现方式</th><th>优点</th><th>缺点</th><th>适用场景</th><th>一致性</th></tr></thead><tbody><tr><td><strong>数据库悲观锁</strong></td><td><code>SELECT FOR UPDATE</code></td><td>强一致性，简单可靠</td><td>性能较低，容易死锁</td><td>并发量不高的场景</td><td>强一致性</td></tr><tr><td><strong>数据库乐观锁</strong></td><td>版本号/时间戳比较</td><td>性能好，无锁等待</td><td>可能重试多次，实现复杂</td><td>冲突较少的场景</td><td>强一致性</td></tr><tr><td><strong>Redis分布式锁</strong></td><td><code>SET NX EX</code> + Lua脚本</td><td>性能好，支持分布式</td><td>需要处理锁超时</td><td>高并发分布式场景</td><td>最终一致性</td></tr><tr><td><strong>Redis原子操作</strong></td><td><code>DECR/INCRBY</code></td><td>性能最好，原子性强</td><td>数据一致性依赖Redis</td><td>高并发读写场景</td><td>最终一致性</td></tr><tr><td><strong>消息队列削峰</strong></td><td>异步处理订单</td><td>削峰填谷，系统稳定</td><td>实时性差，复杂度高</td><td>秒杀等高峰场景</td><td>最终一致性</td></tr></tbody></table><p><strong>最佳实践组合：</strong></p><ol><li><strong>前端限制</strong> + <strong>后端验证</strong> 双重保障</li><li><strong>Redis原子操作</strong> + <strong>数据库最终一致性</strong> 保证性能和可靠性</li><li><strong>消息队列异步处理</strong> + <strong>定时对账</strong> 处理高并发场景</li><li><strong>限流组件</strong> + <strong>熔断降级</strong> 保护系统稳定性</li></ol><h3 id="_8-设计一个短链接系统" tabindex="-1"><a class="header-anchor" href="#_8-设计一个短链接系统"><span>8. 设计一个短链接系统</span></a></h3><p><strong>短链接生成算法对比：</strong></p><table><thead><tr><th>算法</th><th>原理</th><th>优点</th><th>缺点</th><th>链接长度</th><th>适用场景</th></tr></thead><tbody><tr><td>哈希算法</td><td>MD5/SHA1+截取</td><td>实现简单</td><td>可能冲突</td><td>6-8位</td><td>小规模系统</td></tr><tr><td>Base62编码</td><td>数字ID转62进制</td><td>无冲突，有序</td><td>需要全局ID</td><td>6-7位</td><td>大规模系统</td></tr><tr><td>随机字符串</td><td>随机生成+冲突检测</td><td>无规律性</td><td>需要检测冲突</td><td>6-8位</td><td>安全性要求高</td></tr><tr><td>分布式ID</td><td>雪花算法+Base62</td><td>分布式友好</td><td>实现复杂</td><td>7-8位</td><td>微服务架构</td></tr></tbody></table><p><strong>推荐方案：Base62编码 + 分布式ID</strong></p><table><thead><tr><th>组件</th><th>选择</th><th>原因</th><th>实现细节</th></tr></thead><tbody><tr><td>ID生成</td><td>雪花算法</td><td>分布式、有序、高性能</td><td>1位符号+41位时间戳+10位机器ID+12位序列号</td></tr><tr><td>编码算法</td><td>Base62</td><td>包含数字+大小写字母，URL友好</td><td>0-9,a-z,A-Z共62个字符</td></tr><tr><td>短链格式</td><td>http://t.co/xxxxxx</td><td>6-7位标识符</td><td>前缀+Base62编码</td></tr></tbody></table><p><strong>系统架构设计：</strong></p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>[客户端] → [负载均衡器] → [API网关] → [短链接服务集群]</span></span>\n<span class="line"><span>                                              ↓</span></span>\n<span class="line"><span>[Redis缓存集群] ← [消息队列] ← [统计服务] ← [数据库集群]</span></span>\n<span class="line"><span>                     ↓</span></span>\n<span class="line"><span>                [监控系统]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>核心服务组件：</strong></p><table><thead><tr><th>服务</th><th>职责</th><th>技术选型</th><th>部署方式</th></tr></thead><tbody><tr><td>短链接服务</td><td>生成和解析短链接</td><td>Spring Boot + Redis</td><td>无状态集群</td></tr><tr><td>跳转服务</td><td>处理短链接跳转</td><td>Nginx + Lua脚本</td><td>CDN边缘节点</td></tr><tr><td>统计服务</td><td>收集和分析数据</td><td>Kafka + ClickHouse</td><td>异步处理</td></tr><tr><td>缓存服务</td><td>热点数据缓存</td><td>Redis Cluster</td><td>主从+分片</td></tr><tr><td>存储服务</td><td>持久化数据</td><td>MySQL分库分表</td><td>读写分离</td></tr></tbody></table><p><strong>数据库设计：</strong></p><p><strong>短链接表 (url_mapping)：</strong></p><table><thead><tr><th>字段</th><th>类型</th><th>说明</th><th>索引</th></tr></thead><tbody><tr><td>id</td><td>bigint</td><td>主键，雪花算法生成</td><td>主键</td></tr><tr><td>short_url</td><td>varchar(32)</td><td>短链接标识符</td><td>唯一索引</td></tr><tr><td>long_url</td><td>text</td><td>原始长链接</td><td>-</td></tr><tr><td>user_id</td><td>bigint</td><td>创建用户ID</td><td>普通索引</td></tr><tr><td>created_time</td><td>datetime</td><td>创建时间</td><td>普通索引</td></tr><tr><td>expired_time</td><td>datetime</td><td>过期时间</td><td>普通索引</td></tr><tr><td>status</td><td>tinyint</td><td>状态(0删除,1正常)</td><td>-</td></tr></tbody></table><p><strong>统计表 (url_stats)：</strong></p><table><thead><tr><th>字段</th><th>类型</th><th>说明</th><th>索引</th></tr></thead><tbody><tr><td>id</td><td>bigint</td><td>主键</td><td>主键</td></tr><tr><td>short_url</td><td>varchar(32)</td><td>短链接标识符</td><td>普通索引</td></tr><tr><td>click_count</td><td>bigint</td><td>点击次数</td><td>-</td></tr><tr><td>unique_visitor</td><td>bigint</td><td>独立访客数</td><td>-</td></tr><tr><td>last_access_time</td><td>datetime</td><td>最后访问时间</td><td>-</td></tr><tr><td>date</td><td>date</td><td>统计日期</td><td>普通索引</td></tr></tbody></table><p><strong>分库分表策略：</strong></p><table><thead><tr><th>策略</th><th>分片键</th><th>分片规则</th><th>优势</th><th>注意事项</th></tr></thead><tbody><tr><td>按短链接哈希</td><td>short_url</td><td>hash(short_url) % 库数</td><td>读写均衡</td><td>跨库查询困难</td></tr><tr><td>按用户ID分片</td><td>user_id</td><td>user_id % 库数</td><td>用户数据聚合</td><td>热点用户问题</td></tr><tr><td>按时间分片</td><td>created_time</td><td>按月/年分表</td><td>便于数据清理</td><td>跨时间查询复杂</td></tr></tbody></table><p><strong>缓存设计：</strong></p><p><strong>多级缓存架构：</strong></p><table><thead><tr><th>缓存层级</th><th>技术</th><th>TTL</th><th>命中率</th><th>用途</th></tr></thead><tbody><tr><td>浏览器缓存</td><td>HTTP Cache</td><td>1小时</td><td>30%</td><td>减少请求</td></tr><tr><td>CDN缓存</td><td>边缘节点</td><td>24小时</td><td>50%</td><td>就近访问</td></tr><tr><td>应用缓存</td><td>本地缓存</td><td>5分钟</td><td>70%</td><td>热点数据</td></tr><tr><td>分布式缓存</td><td>Redis</td><td>1天</td><td>90%</td><td>数据共享</td></tr></tbody></table><p><strong>缓存策略：</strong></p><table><thead><tr><th>场景</th><th>策略</th><th>实现</th><th>好处</th></tr></thead><tbody><tr><td>热点短链接</td><td>Cache Aside</td><td>先查缓存，缓存失效查DB</td><td>减少DB压力</td></tr><tr><td>新增短链接</td><td>Write Through</td><td>同时写缓存和DB</td><td>保证一致性</td></tr><tr><td>批量预热</td><td>定时任务</td><td>凌晨预热热点数据</td><td>提高命中率</td></tr><tr><td>缓存穿透</td><td>布隆过滤器</td><td>预先判断数据是否存在</td><td>防止无效查询</td></tr></tbody></table><p><strong>核心算法实现：</strong></p><p><strong>Base62编码实现：</strong></p><table><thead><tr><th>步骤</th><th>操作</th><th>示例</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>生成全局唯一ID</td><td>1234567890</td><td>雪花算法生成</td></tr><tr><td>2</td><td>转换为Base62</td><td>dBvJIh</td><td>62进制编码</td></tr><tr><td>3</td><td>拼接域名</td><td>http://t.co/dBvJIh</td><td>形成完整短链接</td></tr></tbody></table><p><strong>解码过程：</strong></p><table><thead><tr><th>步骤</th><th>操作</th><th>示例</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>提取标识符</td><td>dBvJIh</td><td>从URL中提取</td></tr><tr><td>2</td><td>Base62解码</td><td>1234567890</td><td>转换为数字ID</td></tr><tr><td>3</td><td>查询映射关系</td><td>从缓存/DB查询</td><td>获取原始URL</td></tr></tbody></table><p><strong>性能优化策略：</strong></p><table><thead><tr><th>优化点</th><th>策略</th><th>实现方式</th><th>效果</th></tr></thead><tbody><tr><td>读性能</td><td>缓存预热</td><td>定时任务预加载热点数据</td><td>提升50%响应速度</td></tr><tr><td>写性能</td><td>批量生成</td><td>预生成短链接池</td><td>提升写入TPS</td></tr><tr><td>数据库</td><td>读写分离</td><td>主库写，从库读</td><td>分散读压力</td></tr><tr><td>网络</td><td>CDN加速</td><td>就近访问</td><td>减少50%网络延迟</td></tr><tr><td>存储</td><td>数据压缩</td><td>URL压缩存储</td><td>节省30%存储空间</td></tr></tbody></table><p><strong>高可用设计：</strong></p><table><thead><tr><th>层面</th><th>方案</th><th>实现</th><th>目标</th></tr></thead><tbody><tr><td>应用层</td><td>负载均衡</td><td>Nginx + 多实例</td><td>99.9%可用性</td></tr><tr><td>缓存层</td><td>Redis集群</td><td>主从+哨兵</td><td>秒级故障切换</td></tr><tr><td>数据层</td><td>MySQL集群</td><td>主从复制+MHA</td><td>分钟级故障恢复</td></tr><tr><td>网络层</td><td>多机房部署</td><td>异地多活</td><td>机房级容灾</td></tr></tbody></table><p><strong>监控告警：</strong></p><table><thead><tr><th>监控指标</th><th>阈值</th><th>告警方式</th><th>处理方案</th></tr></thead><tbody><tr><td>QPS</td><td>&gt;8000</td><td>短信+邮件</td><td>自动扩容</td></tr><tr><td>响应时间</td><td>&gt;100ms</td><td>钉钉群</td><td>检查缓存命中率</td></tr><tr><td>错误率</td><td>&gt;1%</td><td>电话告警</td><td>紧急处理</td></tr><tr><td>缓存命中率</td><td>&lt;90%</td><td>邮件通知</td><td>优化缓存策略</td></tr><tr><td>存储空间</td><td>&gt;80%</td><td>邮件通知</td><td>数据清理</td></tr></tbody></table><h3 id="_9-设计一个rpc框架" tabindex="-1"><a class="header-anchor" href="#_9-设计一个rpc框架"><span>9. 设计一个RPC框架</span></a></h3><table><thead><tr><th>模块</th><th>关键点</th></tr></thead><tbody><tr><td>网络层</td><td>TCP/UDP，连接复用，Netty</td></tr><tr><td>协议层</td><td>Protobuf，压缩，加密</td></tr><tr><td>注册中心</td><td>服务发现，负载均衡</td></tr><tr><td>容错机制</td><td>超时，重试，熔断</td></tr><tr><td>扩展能力</td><td>多语言，插件化，监控</td></tr><tr><td>安全性</td><td>TLS，鉴权</td></tr></tbody></table><h3 id="_10-扫码登录如何实现" tabindex="-1"><a class="header-anchor" href="#_10-扫码登录如何实现"><span>10. 扫码登录如何实现？</span></a></h3><p>扫码登录本质是通过二维码作为PC端和移动端的通信桥梁。PC端生成包含唯一标识(UUID)的二维码，移动端扫码后获取这个UUID，然后通过UUID关联两端的登录状态。整个过程分为：生成二维码→扫码获取信息→移动端确认→PC端获得登录凭证四个步骤。</p><h4 id="技术实现要点" tabindex="-1"><a class="header-anchor" href="#技术实现要点"><span>技术实现要点</span></a></h4><p><strong>后端架构：</strong> 使用Redis存储二维码状态(待扫描/已扫描/已确认/已过期)，提供生成二维码、检查状态、扫码确认等REST API接口。通过WebSocket或轮询实现PC端实时状态更新。</p><p><strong>前端实现：</strong> PC端通过WebSocket监听状态变化，移动端扫码后调用确认接口。二维码内容通常包含UUID和应用标识信息。</p><p><strong>状态管理：</strong> 关键是维护二维码的生命周期状态，设置合理的过期时间(通常5分钟)，防止重复使用和安全风险。</p><h4 id="安全考虑" tabindex="-1"><a class="header-anchor" href="#安全考虑"><span>安全考虑</span></a></h4><p>设置二维码过期时间、使用HTTPS传输、验证用户身份后才能确认登录、防止重放攻击。UUID应该足够随机且一次性使用。</p><h4 id="优势" tabindex="-1"><a class="header-anchor" href="#优势"><span>优势</span></a></h4><p>用户体验好(免输入密码)、安全性高(移动端已登录状态验证)、适合大屏设备登录场景。</p><h3 id="_10-设计一个内存池" tabindex="-1"><a class="header-anchor" href="#_10-设计一个内存池"><span>10. 设计一个内存池？</span></a></h3><table><thead><tr><th>设计方面</th><th>说明</th><th>实现/优化手段</th></tr></thead><tbody><tr><td><strong>内存管理策略</strong></td><td>决定块大小、对齐</td><td>固定块 / 可变块；对齐到 cache line</td></tr><tr><td><strong>分配与释放</strong></td><td>快速分配和减少碎片</td><td>空闲链表（Free List）、slab allocator、buddy system</td></tr><tr><td><strong>并发安全</strong></td><td>多线程访问控制</td><td>锁、无锁设计、线程局部分配池</td></tr><tr><td><strong>内存回收</strong></td><td>管理释放和回收策略</td><td>显式 free、延迟回收、引用计数</td></tr><tr><td><strong>扩展性 &amp; 监控</strong></td><td>动态调整和统计</td><td>可扩容/缩容；统计已用/空闲块数</td></tr><tr><td><strong>安全性</strong></td><td>防止越界和非法操作</td><td>Fence/Canaries、防止双重释放</td></tr></tbody></table><h3 id="_11-设计一个消息队列" tabindex="-1"><a class="header-anchor" href="#_11-设计一个消息队列"><span>11. 设计一个消息队列？</span></a></h3><h4 id="_1️⃣-消息队列核心功能" tabindex="-1"><a class="header-anchor" href="#_1️⃣-消息队列核心功能"><span><strong>1️⃣ 消息队列核心功能</strong></span></a></h4><table><thead><tr><th>功能</th><th>描述</th></tr></thead><tbody><tr><td>生产者接口</td><td>支持发送消息到队列</td></tr><tr><td>消费者接口</td><td>支持从队列拉取或订阅消息</td></tr><tr><td>消息持久化</td><td>消息可靠存储，防止丢失</td></tr><tr><td>消息确认</td><td>消费者确认消息，支持重试或 DLQ</td></tr><tr><td>消息顺序</td><td>支持单分区 FIFO 或弱顺序</td></tr><tr><td>消息延迟</td><td>支持定时/延迟消息</td></tr><tr><td>高可用 &amp; 扩展性</td><td>支持集群、分区、负载均衡</td></tr></tbody></table><h4 id="_2️⃣-核心设计与实现问题" tabindex="-1"><a class="header-anchor" href="#_2️⃣-核心设计与实现问题"><span><strong>2️⃣ 核心设计与实现问题</strong></span></a></h4><table><thead><tr><th>关注点</th><th>解决思路 / 技术方案</th></tr></thead><tbody><tr><td>消息存储</td><td>内存 + 持久化日志（Commit Log），异步刷盘</td></tr><tr><td>消息顺序</td><td>单分区 FIFO，跨分区可放宽顺序</td></tr><tr><td>可靠性</td><td>ACK/NACK 确认、重试机制、Dead Letter Queue</td></tr><tr><td>吞吐量</td><td>批量写入/批量拉取、消息压缩</td></tr><tr><td>高可用</td><td>多副本（Leader + Follower）、故障切换</td></tr><tr><td>扩展性</td><td>分区机制 + Broker 集群，支持水平扩展</td></tr><tr><td>流控/限流</td><td>防止生产端过快堆积消息</td></tr><tr><td>幂等消费</td><td>消息去重，避免重复处理</td></tr></tbody></table><h4 id="_3️⃣-消费模式与策略" tabindex="-1"><a class="header-anchor" href="#_3️⃣-消费模式与策略"><span><strong>3️⃣ 消费模式与策略</strong></span></a></h4><table><thead><tr><th>模式</th><th>描述</th><th>适用场景</th></tr></thead><tbody><tr><td>点对点（Queue）</td><td>一个消息只能被一个消费者消费</td><td>订单处理、任务队列</td></tr><tr><td>发布/订阅（Topic）</td><td>消息广播给所有订阅者</td><td>通知、消息广播</td></tr><tr><td>拉模式</td><td>消费者主动拉取消息</td><td>控制消费流量</td></tr><tr><td>推模式</td><td>Broker 主动推送消息</td><td>低延迟实时场景</td></tr><tr><td>批量处理</td><td>一次拉/推多条消息</td><td>降低网络开销，提高吞吐</td></tr></tbody></table><p>💡 <strong>设计原则总结</strong></p><ol><li><strong>可靠性</strong>：不丢失消息、支持幂等消费、ACK 确认</li><li><strong>性能</strong>：批量操作、异步刷盘、内存缓存、分区并行</li><li><strong>可扩展性</strong>：分区 + Broker 集群 + 消费组</li><li><strong>高可用性</strong>：副本机制 + Leader 选举 + 容错处理</li></ol><h2 id="计算机网络" tabindex="-1"><a class="header-anchor" href="#计算机网络"><span>计算机网络</span></a></h2><h3 id="_1-tcp和udp的区别-tcp基于流和udp基于数据包的区别" tabindex="-1"><a class="header-anchor" href="#_1-tcp和udp的区别-tcp基于流和udp基于数据包的区别"><span>1. TCP和UDP的区别？TCP基于流和UDP基于数据包的区别？</span></a></h3><p><strong>基本特性对比：</strong></p><table><thead><tr><th>特性</th><th>TCP</th><th>UDP</th></tr></thead><tbody><tr><td>连接性</td><td>面向连接（需要建立连接）</td><td>无连接（直接发送数据）</td></tr><tr><td>可靠性</td><td>可靠传输（确认、重传、排序）</td><td>不可靠传输（不保证到达）</td></tr><tr><td>流量控制</td><td>支持（滑动窗口）</td><td>不支持</td></tr><tr><td>拥塞控制</td><td>支持（慢启动、拥塞避免等）</td><td>不支持</td></tr><tr><td>数据边界</td><td>无边界（流式传输）</td><td>有边界（数据报传输）</td></tr><tr><td>开销</td><td>大（20字节头部+连接管理）</td><td>小（8字节头部）</td></tr><tr><td>速度</td><td>相对较慢</td><td>快</td></tr><tr><td>适用场景</td><td>可靠性要求高的应用</td><td>实时性要求高的应用</td></tr></tbody></table><p><strong>流式传输 vs 数据包传输核心区别：</strong></p><table><thead><tr><th>对比维度</th><th>TCP流式传输</th><th>UDP数据包传输</th></tr></thead><tbody><tr><td>数据传输方式</td><td>连续的字节流，无消息边界</td><td>独立的数据报，有明确边界</td></tr><tr><td>数据顺序</td><td>保证按序到达</td><td>不保证顺序</td></tr><tr><td>数据完整性</td><td>自动重传丢失数据</td><td>丢失就丢失，不重传</td></tr><tr><td>发送/接收</td><td>可分批发送，可分批接收</td><td>一次发送一个完整数据报</td></tr><tr><td>缓冲区处理</td><td>内核自动管理发送/接收缓冲区</td><td>应用层直接处理</td></tr><tr><td>消息边界保护</td><td>无消息边界，需要应用层协议定义</td><td>天然保持消息边界</td></tr></tbody></table><p><strong>TCP和UDP对比：</strong></p><table><thead><tr><th>维度</th><th>TCP (Transmission Control Protocol)</th><th>UDP (User Datagram Protocol)</th></tr></thead><tbody><tr><td>是否连接</td><td>面向连接：三次握手建立，四次挥手释放</td><td>无连接：直接发报文</td></tr><tr><td>可靠性</td><td>序列号 + ACK + 重传 → <strong>可靠、有序、不丢不重</strong></td><td>Best-Effort：<strong>可能丢、乱序、重复，不保证送达</strong></td></tr><tr><td>传输粒度</td><td>字节流（Stream） 应用看不到分段</td><td>报文（Datagram） 一次send()＝一次完整包</td></tr><tr><td>流量 / 拥塞控制</td><td>有窗口 + 拥塞算法（慢启动、拥塞避免、BBR…）</td><td>无流控、无拥塞控制，<strong>发得快丢得多</strong></td></tr><tr><td>首部开销</td><td>20 Byte 起，带选项可到 40–60 Byte</td><td>8 Byte 固定，结构简单</td></tr><tr><td>传输速度</td><td>稳定但握手 + 拥塞控制 → <strong>首包慢，稳中求胜</strong></td><td><strong>低延迟、抖动小</strong>，但需应用自行容错</td></tr><tr><td>组播 / 广播</td><td>不支持</td><td>原生支持单播 / 组播 / 广播</td></tr><tr><td>适用场景</td><td>HTTP/HTTPS、FTP、数据库、电子邮件…</td><td>DNS、VoIP、直播、在线游戏、DHCP…</td></tr><tr><td>稳定性成本</td><td>端口占用多、FD 常驻、握手耗 RTT</td><td>资源占用低、无状态、服务端易做并发</td></tr><tr><td>消息边界</td><td>无，需应用层自行划分</td><td>天然保留边界，一包一消息</td></tr></tbody></table><h3 id="_2-osi七层模型和tcp-ip四层模型" tabindex="-1"><a class="header-anchor" href="#_2-osi七层模型和tcp-ip四层模型"><span>2. OSI七层模型和TCP/IP四层模型？</span></a></h3><p><strong>模型对比：</strong></p><table><thead><tr><th>OSI七层模型</th><th>TCP/IP四层模型</th><th>主要协议</th><th>功能描述</th><th>典型设备</th></tr></thead><tbody><tr><td>应用层</td><td>应用层</td><td>HTTP、HTTPS、FTP、SMTP</td><td>为用户提供网络服务接口</td><td>浏览器、邮件客户端</td></tr><tr><td>表示层</td><td>↑</td><td>SSL/TLS、JPEG、MPEG</td><td>数据格式转换、加密解密</td><td>-</td></tr><tr><td>会话层</td><td>↑</td><td>NetBIOS、RPC</td><td>建立、管理、终止会话</td><td>-</td></tr><tr><td>传输层</td><td>传输层</td><td>TCP、UDP</td><td>端到端的可靠数据传输</td><td>四层交换机</td></tr><tr><td>网络层</td><td>网络层</td><td>IP、ICMP</td><td>路径选择、逻辑地址</td><td>路由器</td></tr><tr><td>数据链路层</td><td>数据链路层</td><td>Ethernet、PPP、WiFi、ARP</td><td>物理地址、错误检测</td><td>交换机、网卡</td></tr><tr><td>物理层</td><td>↑</td><td>RJ45、光纤、无线</td><td>比特流传输、物理连接</td><td>集线器、中继器</td></tr></tbody></table><p><strong>数据封装过程：</strong></p><table><thead><tr><th>层次</th><th>数据单位</th><th>添加的头部</th><th>作用</th><th>示例</th></tr></thead><tbody><tr><td>应用层</td><td>Data</td><td>应用头部</td><td>应用协议信息</td><td>HTTP请求</td></tr><tr><td>传输层</td><td>Segment</td><td>TCP/UDP头</td><td>端口号、序列号</td><td>TCP段</td></tr><tr><td>网络层</td><td>Packet</td><td>IP头</td><td>源/目标IP地址</td><td>IP数据包</td></tr><tr><td>数据链路层</td><td>Frame</td><td>以太网头</td><td>MAC地址</td><td>以太网帧</td></tr><tr><td>物理层</td><td>Bit</td><td>-</td><td>电信号传输</td><td>比特流</td></tr></tbody></table><h3 id="_3-http和https的区别" tabindex="-1"><a class="header-anchor" href="#_3-http和https的区别"><span>3. HTTP和HTTPS的区别？</span></a></h3><p><strong>核心对比：</strong></p><table><thead><tr><th>特性</th><th>HTTP</th><th>HTTPS</th></tr></thead><tbody><tr><td>安全性</td><td>明文传输，不安全</td><td>SSL/TLS加密，安全</td></tr><tr><td>端口</td><td>80</td><td>443</td></tr><tr><td>性能</td><td>快</td><td>相对较慢（加密开销）</td></tr><tr><td>证书</td><td>不需要</td><td>需要CA证书</td></tr><tr><td>SEO</td><td>一般</td><td>搜索引擎更偏好</td></tr><tr><td>成本</td><td>低</td><td>高（证书费用）</td></tr></tbody></table><p><strong>HTTP状态码分类：</strong></p><table><thead><tr><th>类别</th><th>范围</th><th>含义</th><th>常见状态码</th><th>说明</th></tr></thead><tbody><tr><td>信息响应</td><td>1xx</td><td>请求已接收，继续处理</td><td>100 Continue</td><td>客户端应继续请求</td></tr><tr><td>成功响应</td><td>2xx</td><td>请求成功处理</td><td>200 OK, 201 Created</td><td>请求成功</td></tr><tr><td>重定向</td><td>3xx</td><td>需要进一步操作</td><td>301 Moved, 302 Found</td><td>资源已移动</td></tr><tr><td>客户端错误</td><td>4xx</td><td>客户端请求错误</td><td>404 Not Found, 403 Forbidden</td><td>请求错误</td></tr><tr><td>服务端错误</td><td>5xx</td><td>服务器处理错误</td><td>500 Internal Error, 502 Bad Gateway</td><td>服务器错误</td></tr></tbody></table><p><strong>TLS握手过程：</strong></p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>TLS 1.3 握手过程：</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>Client                         Server</span></span>\n<span class="line"><span>  | ------- ClientHello --------&gt; |  👋 包含支持的加密算法 + 随机数 + KeyShare</span></span>\n<span class="line"><span>  | &lt;------ ServerHello --------- |  🤝 选定算法，返回随机数 + KeyShare</span></span>\n<span class="line"><span>  | &lt;------ EncryptedExtensions - |</span></span>\n<span class="line"><span>  | &lt;------ Certificate ----------|</span></span>\n<span class="line"><span>  | &lt;------ CertificateVerify ----| 🪪 验证服务器身份</span></span>\n<span class="line"><span>  | &lt;------ Finished -------------| ✅ 服务端完成握手</span></span>\n<span class="line"><span>  | -------- Finished -----------&gt;| ✅ 客户端确认完成</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_4-tcp三次握手和四次挥手" tabindex="-1"><a class="header-anchor" href="#_4-tcp三次握手和四次挥手"><span>4. TCP三次握手和四次挥手？</span></a></h3><p><strong>三次握手过程：</strong></p><table><thead><tr><th>步骤</th><th>发送方</th><th>标志位</th><th>序列号</th><th>确认号</th><th>作用</th><th>状态变化</th></tr></thead><tbody><tr><td>1</td><td>客户端</td><td>SYN=1</td><td>seq=x</td><td>-</td><td>请求建立连接</td><td>CLOSED → SYN_SENT</td></tr><tr><td>2</td><td>服务端</td><td>SYN=1, ACK=1</td><td>seq=y</td><td>ack=x+1</td><td>同意连接，确认客户端</td><td>SYN_SENT → SYN_RCVD</td></tr><tr><td>3</td><td>客户端</td><td>ACK=1</td><td>seq=x+1</td><td>ack=y+1</td><td>确认服务端，连接建立</td><td>SYN_RCVD → ESTABLISHED</td></tr></tbody></table><table><thead><tr><th>名称</th><th>作用阶段</th><th>存放什么</th><th>队列满会怎样</th></tr></thead><tbody><tr><td>半连接队列</td><td>第一次到第三次握手前</td><td>正在进行握手（SYN已收到）</td><td>拒绝新的 SYN（可能导致握手失败）</td></tr><tr><td>全连接队列</td><td>握手完成后</td><td>等待被 <code>accept()</code> 的连接</td><td>新连接被丢弃（握手虽然完成）</td></tr></tbody></table><ul><li>半连接队列 → 防攻击： SYN 洪泛攻击利用不发最后一个 ACK 消耗服务端资源。可以设置半连接队列大小，超过则丢弃SYN包</li><li>全连接队列 → 解耦： 三次握手完成不等于应用立刻处理，因此需要缓冲区。</li></ul><p><strong>四次挥手过程：</strong></p><table><thead><tr><th>步骤</th><th>发送方</th><th>标志位</th><th>说明</th><th>状态变化</th></tr></thead><tbody><tr><td>1</td><td>客户端</td><td>FIN=1</td><td>客户端请求关闭连接</td><td>FIN_WAIT_1</td></tr><tr><td>2</td><td>服务端</td><td>ACK=1</td><td>服务端确认收到关闭请求</td><td>CLOSE_WAIT</td></tr><tr><td>3</td><td>服务端</td><td>FIN=1</td><td>服务端也请求关闭连接</td><td>LAST_ACK</td></tr><tr><td>4</td><td>客户端</td><td>ACK=1</td><td>客户端确认，连接关闭</td><td>TIME_WAIT → CLOSED</td></tr></tbody></table><ul><li>TIME_WAIT 状态是 TCP 连接在关闭后仍然保持的状态，用于确保连接的可靠关闭。 <ul><li>防止旧连接的数据包干扰新连接</li><li>确保最后的ACK能够到达对端</li><li>给网络中的延迟包足够时间消失</li><li>默认时间：2*MSL（Maximum Segment Lifetime）</li><li>TIME_WAIT 过多会导致本地 端口耗尽、内存/CPU 占用升高，影响新连接建立与系统吞吐，可通过 长连接/连接池、内核参数调优、急迫关闭 等方式优化。</li></ul></li><li>除了标准的四次挥手（FIN/ACK）优雅关闭，TCP 还可以通过发送 RST 报文进行急迫中断（Abortive Close），以立即释放连接资源。</li></ul><p><strong>为什么是三次握手？</strong></p><table><thead><tr><th>次数</th><th>问题</th><th>说明</th></tr></thead><tbody><tr><td>一次</td><td>无法确认服务端接收能力</td><td>客户端不知道自己发的消息服务端能否收到</td></tr><tr><td>两次</td><td>无法确认客户端接收能力</td><td>服务端不知道自己发的消息客户端能否收到</td></tr><tr><td>三次</td><td>✅ 完美解决</td><td>双方都确认了对方的发送和接收能力</td></tr><tr><td>四次</td><td>浪费资源</td><td>三次已经足够，第四次是多余的</td></tr></tbody></table><p><strong>为什么是四次挥手？</strong></p><table><thead><tr><th>原因</th><th>说明</th></tr></thead><tbody><tr><td>TCP全双工通信</td><td>需要分别关闭两个方向的连接</td></tr><tr><td>数据传输可能未完成</td><td>服务端可能还有数据要发送</td></tr><tr><td>ACK和FIN分开发送</td><td>服务端先确认收到关闭请求，再发送自己的关闭请求</td></tr></tbody></table><h3 id="_5-从输入url到页面显示的完整过程" tabindex="-1"><a class="header-anchor" href="#_5-从输入url到页面显示的完整过程"><span>5. 从输入URL到页面显示的完整过程？</span></a></h3><p><strong>详细步骤分解：</strong></p><table><thead><tr><th>阶段</th><th>步骤</th><th>具体操作</th><th>时间消耗</th><th>涉及协议</th></tr></thead><tbody><tr><td><strong>URL解析</strong></td><td>1</td><td>解析URL各部分</td><td>&lt;1ms</td><td>-</td></tr><tr><td><strong>DNS解析</strong></td><td>2</td><td>域名解析为IP地址</td><td>20-120ms</td><td>DNS</td></tr><tr><td><strong>建立连接</strong></td><td>3</td><td>TCP三次握手</td><td>10-100ms</td><td>TCP</td></tr><tr><td></td><td>4</td><td>TLS握手(HTTPS)</td><td>50-200ms</td><td>TLS</td></tr><tr><td><strong>发送请求</strong></td><td>5</td><td>发送HTTP请求</td><td>1-10ms</td><td>HTTP</td></tr><tr><td><strong>服务器处理</strong></td><td>6</td><td>服务器处理请求</td><td>10-500ms</td><td>-</td></tr><tr><td><strong>返回响应</strong></td><td>7</td><td>返回HTML内容</td><td>10-100ms</td><td>HTTP</td></tr><tr><td><strong>页面渲染</strong></td><td>8</td><td>解析HTML</td><td>10-50ms</td><td>-</td></tr><tr><td></td><td>9</td><td>加载CSS/JS/图片</td><td>100-2000ms</td><td>HTTP</td></tr><tr><td></td><td>10</td><td>渲染页面</td><td>50-500ms</td><td>-</td></tr></tbody></table><p><strong>浏览器渲染过程：</strong></p><table><thead><tr><th>步骤</th><th>操作</th><th>产生结果</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>解析HTML</td><td>DOM树</td><td>文档对象模型</td></tr><tr><td>2</td><td>解析CSS</td><td>CSSOM树</td><td>CSS对象模型</td></tr><tr><td>3</td><td>合并DOM和CSSOM</td><td>渲染树</td><td>确定显示元素和样式</td></tr><tr><td>4</td><td>计算布局(Layout)</td><td>盒模型</td><td>确定元素位置和大小</td></tr><tr><td>5</td><td>绘制(Paint)</td><td>像素</td><td>填充像素到屏幕</td></tr><tr><td>6</td><td>合成(Composite)</td><td>最终页面</td><td>处理层叠、透明度等</td></tr></tbody></table><h3 id="_6-tcp粘包和拆包问题" tabindex="-1"><a class="header-anchor" href="#_6-tcp粘包和拆包问题"><span>6. TCP粘包和拆包问题？</span></a></h3><p><strong>粘包拆包现象：</strong></p><table><thead><tr><th>现象</th><th>描述</th><th>产生原因</th><th>示例场景</th></tr></thead><tbody><tr><td>粘包</td><td>多个数据包被合并在一起接收</td><td>TCP缓冲区优化、Nagle算法</td><td>连续发送小数据包</td></tr><tr><td>拆包</td><td>一个数据包被分割成多次接收</td><td>数据包大于MSS、接收缓冲区不足</td><td>发送大数据包</td></tr><tr><td>半包</td><td>数据包接收不完整</td><td>网络拥塞、缓冲区大小限制</td><td>网络环境不稳定</td></tr></tbody></table><p><strong>产生原因详解：</strong></p><table><thead><tr><th>原因类别</th><th>具体原因</th><th>影响范围</th><th>解决难度</th></tr></thead><tbody><tr><td>TCP机制</td><td>流式传输特性，无消息边界</td><td>所有TCP应用</td><td>应用层解决</td></tr><tr><td>缓冲区机制</td><td>发送/接收缓冲区大小不匹配</td><td>高频小数据传输</td><td>调优配置</td></tr><tr><td>Nagle算法</td><td>小包合并算法，提高网络利用率</td><td>小数据包场景</td><td>关闭算法</td></tr><tr><td>MSS限制</td><td>最大报文段长度限制，大包会被分割</td><td>大数据传输</td><td>分片处理</td></tr><tr><td>网络传输</td><td>网络延迟、丢包重传导致数据到达不连续</td><td>不稳定网络环境</td><td>网络优化</td></tr></tbody></table><p><strong>解决方案对比：</strong></p><table><thead><tr><th>解决方案</th><th>实现原理</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>固定长度</td><td>每个消息固定字节数</td><td>实现简单</td><td>浪费空间，不灵活</td><td>定长消息场景</td></tr><tr><td>分隔符</td><td>使用特定字符作为消息分隔符</td><td>实现简单，节省空间</td><td>消息内容不能包含分隔符</td><td>文本协议</td></tr><tr><td>长度前缀</td><td>消息头包含消息体长度</td><td>灵活，支持变长消息</td><td>稍微复杂</td><td>二进制协议</td></tr><tr><td>固定头+变长体</td><td>固定长度头部+变长消息体</td><td>最灵活，工业标准</td><td>实现相对复杂</td><td>复杂应用协议</td></tr></tbody></table><p><strong>框架解决方案：</strong></p><table><thead><tr><th>框架/库</th><th>解决方式</th><th>特点</th><th>使用场景</th></tr></thead><tbody><tr><td>Netty</td><td>ByteToMessageDecoder</td><td>高性能，灵活的编解码器</td><td>高并发网络应用</td></tr><tr><td>Protobuf</td><td>长度前缀+序列化</td><td>跨语言，高效序列化</td><td>微服务通信</td></tr><tr><td>Thrift</td><td>帧传输+二进制协议</td><td>RPC框架，自动处理</td><td>分布式服务</td></tr><tr><td>HTTP</td><td>Content-Length头</td><td>标准化协议</td><td>Web应用</td></tr><tr><td>WebSocket</td><td>帧格式定义</td><td>实时双向通信</td><td>实时应用</td></tr><tr><td>MessagePack</td><td>自描述格式</td><td>紧凑的序列化格式</td><td>数据传输优化</td></tr></tbody></table><p><strong>最佳实践建议：</strong></p><table><thead><tr><th>实践建议</th><th>具体做法</th><th>预期效果</th></tr></thead><tbody><tr><td>根据应用特点选择方案</td><td>文本协议用分隔符，二进制协议用长度前缀</td><td>平衡性能和复杂度</td></tr><tr><td>设置合理的缓冲区大小</td><td>根据消息大小调整Socket缓冲区</td><td>减少粘包拆包发生频率</td></tr><tr><td>使用成熟框架</td><td>优先选择Netty等成熟网络框架</td><td>减少开发工作量和Bug</td></tr><tr><td>充分测试边界情况</td><td>测试网络延迟、大小包混合等场景</td><td>确保协议解析的健壮性</td></tr><tr><td>监控和日志</td><td>记录解包失败、协议错误等异常</td><td>快速定位和解决问题</td></tr></tbody></table><h3 id="_7-dns解析过程" tabindex="-1"><a class="header-anchor" href="#_7-dns解析过程"><span>7. DNS解析过程？</span></a></h3><p><strong>DNS解析步骤：</strong></p><table><thead><tr><th>步骤</th><th>操作</th><th>涉及的DNS服务器</th><th>查询类型</th><th>缓存位置</th></tr></thead><tbody><tr><td>1</td><td>检查本地缓存</td><td>本地DNS缓存</td><td>-</td><td>浏览器、操作系统</td></tr><tr><td>2</td><td>查询本地DNS服务器</td><td>递归DNS服务器</td><td>递归查询</td><td>ISP DNS</td></tr><tr><td>3</td><td>查询根域名服务器</td><td>根DNS服务器</td><td>迭代查询</td><td>全球13个根服务器</td></tr><tr><td>4</td><td>查询顶级域DNS服务器</td><td>TLD DNS服务器</td><td>迭代查询</td><td>.com, .org等</td></tr><tr><td>5</td><td>查询权威域名服务器</td><td>权威DNS服务器</td><td>迭代查询</td><td>域名注册商</td></tr><tr><td>6</td><td>返回IP地址</td><td>-</td><td>-</td><td>逐层缓存</td></tr></tbody></table><p><strong>DNS记录类型：</strong></p><table><thead><tr><th>记录类型</th><th>作用</th><th>示例</th><th>说明</th></tr></thead><tbody><tr><td>A</td><td>域名指向IPv4地址</td><td>www.example.com → 192.168.1.1</td><td>最常见的记录</td></tr><tr><td>AAAA</td><td>域名指向IPv6地址</td><td>www.example.com → 2001:db8::1</td><td>IPv6版本的A记录</td></tr><tr><td>CNAME</td><td>域名别名</td><td>www.example.com → example.com</td><td>域名指向另一个域名</td></tr><tr><td>MX</td><td>邮件服务器</td><td>example.com → mail.example.com</td><td>邮件路由</td></tr><tr><td>NS</td><td>域名服务器</td><td>example.com → ns1.example.com</td><td>指定权威DNS</td></tr><tr><td>TXT</td><td>文本记录</td><td>域名验证、SPF记录</td><td>多用途文本信息</td></tr></tbody></table><h3 id="_8-cookie、session、localstorage、jwt对比" tabindex="-1"><a class="header-anchor" href="#_8-cookie、session、localstorage、jwt对比"><span>8. Cookie、Session、LocalStorage、JWT对比</span></a></h3><h4 id="存储位置和安全性对比" tabindex="-1"><a class="header-anchor" href="#存储位置和安全性对比"><span><strong>存储位置和安全性对比</strong></span></a></h4><table><thead><tr><th>特性</th><th>Cookie</th><th>Session</th><th>LocalStorage</th><th>JWT</th></tr></thead><tbody><tr><td><strong>存储位置</strong></td><td>客户端浏览器</td><td>服务端内存/数据库</td><td>客户端浏览器</td><td>客户端浏览器</td></tr><tr><td><strong>存储大小</strong></td><td>4KB限制</td><td>服务器内存决定</td><td>5-10MB</td><td>无限制（但建议&lt;4KB）</td></tr><tr><td><strong>安全性</strong></td><td>相对不安全</td><td>相对安全</td><td>不安全</td><td>相对安全（签名验证）</td></tr><tr><td><strong>生命周期</strong></td><td>可设置过期时间</td><td>会话结束即失效</td><td>永久存储（除非手动删除）</td><td>可设置过期时间</td></tr><tr><td><strong>跨域支持</strong></td><td>受同源策略限制</td><td>服务端控制</td><td>同源策略限制</td><td>可跨域使用</td></tr><tr><td><strong>网络传输</strong></td><td>每次请求都发送</td><td>只传输SessionID</td><td>不自动传输</td><td>每次请求都发送</td></tr></tbody></table><h4 id="工作机制对比" tabindex="-1"><a class="header-anchor" href="#工作机制对比"><span><strong>工作机制对比</strong></span></a></h4><table><thead><tr><th>步骤</th><th>Cookie机制</th><th>Session机制</th><th>LocalStorage机制</th><th>JWT机制</th></tr></thead><tbody><tr><td><strong>1</strong></td><td>服务端设置Set-Cookie响应头</td><td>服务端创建Session对象</td><td>客户端JavaScript设置</td><td>服务端生成JWT</td></tr><tr><td><strong>2</strong></td><td>浏览器保存Cookie到本地</td><td>服务端生成SessionID</td><td>浏览器保存到本地存储</td><td>服务端返回JWT给客户端</td></tr><tr><td><strong>3</strong></td><td>后续请求自动携带Cookie</td><td>SessionID通过Cookie发送给客户端</td><td>需要手动添加到请求头</td><td>客户端保存JWT</td></tr><tr><td><strong>4</strong></td><td>服务端读取Cookie信息</td><td>客户端后续请求携带SessionID</td><td>客户端JavaScript读取</td><td>客户端请求时携带JWT</td></tr><tr><td><strong>5</strong></td><td>-</td><td>服务端根据SessionID查找Session</td><td>-</td><td>服务端验证JWT签名</td></tr></tbody></table><h4 id="详细特性对比" tabindex="-1"><a class="header-anchor" href="#详细特性对比"><span><strong>详细特性对比</strong></span></a></h4><h5 id="_1-安全性" tabindex="-1"><a class="header-anchor" href="#_1-安全性"><span><strong>1. 安全性</strong></span></a></h5><ul><li><strong>Cookie</strong>：容易被XSS攻击，可设置HttpOnly提高安全性</li><li><strong>Session</strong>：最安全，敏感信息存储在服务端</li><li><strong>LocalStorage</strong>：最不安全，容易被XSS攻击</li><li><strong>JWT</strong>：相对安全，通过签名防止篡改，但payload是明文</li></ul><h5 id="_2-性能影响" tabindex="-1"><a class="header-anchor" href="#_2-性能影响"><span><strong>2. 性能影响</strong></span></a></h5><ul><li><strong>Cookie</strong>：每次请求都发送，增加网络开销</li><li><strong>Session</strong>：只传输SessionID，网络开销小</li><li><strong>LocalStorage</strong>：不自动传输，需要手动处理</li><li><strong>JWT</strong>：每次请求都发送，但服务端无需查询数据库</li></ul><h5 id="_3-服务端负载" tabindex="-1"><a class="header-anchor" href="#_3-服务端负载"><span><strong>3. 服务端负载</strong></span></a></h5><ul><li><strong>Cookie</strong>：服务端需要解析Cookie</li><li><strong>Session</strong>：服务端需要存储和查询Session</li><li><strong>LocalStorage</strong>：服务端无感知</li><li><strong>JWT</strong>：服务端只需验证签名，无状态</li></ul><h4 id="使用场景对比" tabindex="-1"><a class="header-anchor" href="#使用场景对比"><span><strong>使用场景对比</strong></span></a></h4><table><thead><tr><th>场景</th><th>推荐方案</th><th>原因</th></tr></thead><tbody><tr><td><strong>用户登录状态</strong></td><td>Session/JWT</td><td>Session更安全，JWT更适合分布式</td></tr><tr><td><strong>购物车信息</strong></td><td>LocalStorage + Session</td><td>LocalStorage存储商品列表，Session存储用户信息</td></tr><tr><td><strong>用户偏好设置</strong></td><td>LocalStorage</td><td>简单信息，可以持久化保存</td></tr><tr><td><strong>临时数据</strong></td><td>Session</td><td>会话结束自动清理</td></tr><tr><td><strong>API认证</strong></td><td>JWT</td><td>无状态，适合微服务架构</td></tr><tr><td><strong>跨域认证</strong></td><td>JWT</td><td>可以跨域使用，无需服务端存储</td></tr><tr><td><strong>记住登录</strong></td><td>Cookie</td><td>可以设置过期时间，自动发送</td></tr></tbody></table><p><strong>选择建议：</strong></p><ul><li><strong>传统Web应用</strong>：Session + Cookie</li><li><strong>SPA应用</strong>：JWT + LocalStorage</li><li><strong>微服务架构</strong>：JWT</li><li><strong>简单数据存储</strong>：LocalStorage</li><li><strong>跨域应用</strong>：JWT</li></ul><p><strong>安全考虑：</strong></p><ul><li>敏感信息不要存储在客户端</li><li>使用HttpOnly Cookie防止XSS</li><li>JWT要设置合理的过期时间</li><li>LocalStorage只存储非敏感信息</li></ul><h3 id="_9-websocket原理和应用" tabindex="-1"><a class="header-anchor" href="#_9-websocket原理和应用"><span>9. WebSocket原理和应用？</span></a></h3><p><strong>WebSocket vs HTTP：</strong></p><table><thead><tr><th>特性</th><th>HTTP</th><th>WebSocket</th></tr></thead><tbody><tr><td>连接模式</td><td>请求-响应，短连接</td><td>持久连接，全双工</td></tr><tr><td>数据格式</td><td>文本（HTTP头+内容）</td><td>二进制帧或文本帧</td></tr><tr><td>开销</td><td>每次请求都有HTTP头开销</td><td>握手后开销极小</td></tr><tr><td>实时性</td><td>需要轮询，实时性差</td><td>真正实时通信</td></tr><tr><td>服务端主动推送</td><td>不支持</td><td>支持</td></tr><tr><td>适用场景</td><td>普通Web应用</td><td>实时应用（聊天、游戏）</td></tr></tbody></table><p><strong>WebSocket握手过程：</strong></p><table><thead><tr><th>步骤</th><th>发送方</th><th>内容</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>客户端</td><td><code>Upgrade: websocket</code></td><td>请求协议升级</td></tr><tr><td>2</td><td>客户端</td><td><code>Sec-WebSocket-Key: xxx</code></td><td>随机key</td></tr><tr><td>3</td><td>服务端</td><td><code>HTTP/1.1 101 Switching Protocols</code></td><td>同意协议升级</td></tr><tr><td>4</td><td>服务端</td><td><code>Sec-WebSocket-Accept: yyy</code></td><td>基于客户端key计算的响应</td></tr><tr><td>5</td><td>双方</td><td>开始WebSocket通信</td><td>使用WebSocket协议</td></tr></tbody></table><p><strong>应用场景：</strong></p><table><thead><tr><th>应用类型</th><th>使用原因</th><th>典型例子</th></tr></thead><tbody><tr><td>即时聊天</td><td>需要实时双向通信</td><td>微信网页版、QQ空间</td></tr><tr><td>在线游戏</td><td>实时交互，低延迟</td><td>网页游戏、H5游戏</td></tr><tr><td>实时数据</td><td>服务端主动推送数据</td><td>股票行情、体育比分</td></tr><tr><td>协作编辑</td><td>多人实时编辑</td><td>Google Docs、石墨文档</td></tr><tr><td>直播弹幕</td><td>大量实时消息</td><td>直播平台弹幕系统</td></tr></tbody></table><h3 id="_10-tcp如何保证可靠传输" tabindex="-1"><a class="header-anchor" href="#_10-tcp如何保证可靠传输"><span>10. TCP如何保证可靠传输？</span></a></h3><h4 id="_1-序列号和确认机制" tabindex="-1"><a class="header-anchor" href="#_1-序列号和确认机制"><span>1. <strong>序列号和确认机制</strong></span></a></h4><ul><li><strong>序列号</strong>：每个字节都有唯一序列号，用于标识数据顺序</li><li><strong>确认号（ACK）</strong>：接收方确认已收到的数据</li><li><strong>累积确认</strong>：确认号表示期望收到的下一个字节的序列号</li></ul><h4 id="_2-超时重传机制" tabindex="-1"><a class="header-anchor" href="#_2-超时重传机制"><span>2. <strong>超时重传机制</strong></span></a></h4><ul><li><strong>RTO（重传超时）</strong>：动态计算重传超时时间</li><li><strong>快速重传</strong>：收到3个重复ACK立即重传</li><li><strong>指数退避</strong>：重传失败后增加超时时间</li></ul><h4 id="_3-流量控制-flow-control" tabindex="-1"><a class="header-anchor" href="#_3-流量控制-flow-control"><span>3. <strong>流量控制（Flow Control）</strong></span></a></h4><ul><li><strong>滑动窗口</strong>：接收方通过窗口大小控制发送方发送速率</li><li><strong>窗口大小</strong>：接收方缓冲区可用空间</li><li><strong>零窗口探测</strong>：窗口为0时定期发送探测包</li></ul><h4 id="_4-拥塞控制-congestion-control" tabindex="-1"><a class="header-anchor" href="#_4-拥塞控制-congestion-control"><span>4. <strong>拥塞控制（Congestion Control）</strong></span></a></h4><ul><li><strong>慢启动</strong>：连接初期指数增长窗口大小，探测网络带宽，快速建立拥塞窗口</li><li><strong>拥塞避免</strong>：达到阈值后线性增长，避免拥塞、保持稳定增长</li><li><strong>快速恢复</strong>：连续收到3个重复ACK时快速恢复，缩短数据重传时间</li><li><strong>快速重传</strong>：立即重传丢失的包，不用回到慢启动，连接恢复速度更快</li></ul><h4 id="_5-连接管理" tabindex="-1"><a class="header-anchor" href="#_5-连接管理"><span>5. <strong>连接管理</strong></span></a></h4><ul><li><strong>三次握手</strong>：建立连接时同步序列号</li><li><strong>四次挥手</strong>：安全关闭连接</li><li><strong>TIME_WAIT</strong>：防止旧连接的数据包干扰新连接</li></ul><h4 id="_6-数据完整性" tabindex="-1"><a class="header-anchor" href="#_6-数据完整性"><span>6. <strong>数据完整性</strong></span></a></h4><ul><li><strong>校验和</strong>：检测传输过程中的数据错误</li><li><strong>校验失败</strong>：丢弃错误包，触发重传</li></ul><h4 id="_7-分片和重组" tabindex="-1"><a class="header-anchor" href="#_7-分片和重组"><span>7. <strong>分片和重组</strong></span></a></h4><ul><li><strong>MSS（最大分段大小）</strong>：根据MTU确定分段大小</li><li><strong>有序重组</strong>：接收方按序列号重组数据</li><li><strong>乱序处理</strong>：缓存乱序到达的数据</li></ul><h2 id="操作系统" tabindex="-1"><a class="header-anchor" href="#操作系统"><span>操作系统</span></a></h2><h3 id="_1-虚拟内存管理" tabindex="-1"><a class="header-anchor" href="#_1-虚拟内存管理"><span>1. 虚拟内存管理？</span></a></h3><ul><li>虚拟内存（Virtual Memory）是操作系统提供的一种内存管理机制，它让应用程序以为自己拥有一个连续的、大容量的内存空间，但实际上这些内存可能只是部分在物理内存中，其他的存在磁盘里。</li></ul><p><strong>虚拟内存核心概念：</strong></p><table><thead><tr><th>概念</th><th>定义</th><th>作用</th><th>优势</th></tr></thead><tbody><tr><td>虚拟地址</td><td>程序使用的逻辑地址</td><td>程序地址空间抽象</td><td>程序间地址隔离</td></tr><tr><td>物理地址</td><td>实际内存位置</td><td>硬件内存访问</td><td>真实内存定位</td></tr><tr><td>地址转换</td><td>虚拟地址→物理地址</td><td>MMU硬件完成</td><td>透明的地址映射</td></tr><tr><td>页表</td><td>地址映射表</td><td>记录页面映射关系</td><td>实现地址转换</td></tr></tbody></table><p><strong>虚拟内存优势：</strong></p><table><thead><tr><th>优势</th><th>说明</th><th>解决的问题</th><th>实现方式</th></tr></thead><tbody><tr><td>内存保护</td><td>进程间内存隔离</td><td>避免进程间相互干扰</td><td>页表权限控制</td></tr><tr><td>内存扩展</td><td>逻辑内存&gt;物理内存</td><td>运行超大程序</td><td>磁盘交换空间</td></tr><tr><td>地址无关</td><td>程序可在任意位置加载</td><td>简化程序设计</td><td>动态地址映射</td></tr><tr><td>内存共享</td><td>多进程共享内存页</td><td>节省物理内存</td><td>共享页面映射</td></tr></tbody></table><p><strong>分页机制：</strong></p><table><thead><tr><th>概念</th><th>大小</th><th>作用</th><th>特点</th></tr></thead><tbody><tr><td>页面(Page)</td><td>通常4KB</td><td>虚拟内存管理单位</td><td>固定大小，便于管理</td></tr><tr><td>页框(Frame)</td><td>通常4KB</td><td>物理内存管理单位</td><td>与页面大小相同</td></tr><tr><td>页表项(PTE)</td><td>4-8字节</td><td>存储映射关系和控制信息</td><td>包含权限位、有效位等</td></tr><tr><td>TLB</td><td>硬件缓存</td><td>加速地址转换</td><td>缓存页表项</td></tr></tbody></table><h3 id="_2-页面置换算法" tabindex="-1"><a class="header-anchor" href="#_2-页面置换算法"><span>2. 页面置换算法？</span></a></h3><p><strong>算法对比：</strong></p><table><thead><tr><th>算法</th><th>全称</th><th>原理</th><th>时间复杂度</th><th>缺页率</th><th>实现难度</th></tr></thead><tbody><tr><td>FIFO</td><td>先进先出</td><td>最早进入的页面先被置换</td><td>O(1)</td><td>高</td><td>简单</td></tr><tr><td>LRU</td><td>最近最少使用</td><td>最久未访问的页面被置换</td><td>O(n)</td><td>中低</td><td>复杂</td></tr><tr><td>LFU</td><td>最少使用频率</td><td>访问次数最少的页面被置换</td><td>O(n)</td><td>中</td><td>复杂</td></tr><tr><td>OPT</td><td>最优算法</td><td>最远将来才访问的页面被置换</td><td>O(n)</td><td>最低</td><td>无法实现</td></tr><tr><td>Clock</td><td>时钟算法</td><td>环形队列+访问位</td><td>O(n)</td><td>中</td><td>中等</td></tr><tr><td>改进Clock</td><td>增强时钟</td><td>考虑访问位和修改位</td><td>O(n)</td><td>中低</td><td>中等</td></tr></tbody></table><p><strong>LRU算法实现方式：</strong></p><table><thead><tr><th>实现方式</th><th>数据结构</th><th>时间复杂度</th><th>空间复杂度</th><th>特点</th></tr></thead><tbody><tr><td>链表实现</td><td>双向链表</td><td>O(n)</td><td>O(n)</td><td>查找慢，移动快</td></tr><tr><td>栈实现</td><td>栈</td><td>O(n)</td><td>O(n)</td><td>需要搜索栈</td></tr><tr><td>哈希+链表</td><td>HashMap + 双向链表</td><td>O(1)</td><td>O(n)</td><td>最优实现</td></tr><tr><td>硬件支持</td><td>特殊寄存器</td><td>O(1)</td><td>O(1)</td><td>成本高</td></tr></tbody></table><p><strong>Belady异常：</strong></p><table><thead><tr><th>算法</th><th>是否存在Belady异常</th><th>说明</th></tr></thead><tbody><tr><td>FIFO</td><td>是</td><td>增加物理页面可能导致缺页率增加</td></tr><tr><td>LRU</td><td>否</td><td>栈式算法，单调性</td></tr><tr><td>OPT</td><td>否</td><td>理论最优算法</td></tr><tr><td>LFU</td><td>否</td><td>基于访问频率的栈式算法</td></tr></tbody></table><h3 id="_3-死锁问题" tabindex="-1"><a class="header-anchor" href="#_3-死锁问题"><span>3. 死锁问题？</span></a></h3><p><strong>死锁四个必要条件：</strong></p><table><thead><tr><th>条件</th><th>定义</th><th>举例</th><th>破坏方法</th></tr></thead><tbody><tr><td>互斥条件</td><td>资源不能被多个进程同时使用</td><td>打印机、文件锁</td><td>资源共享化</td></tr><tr><td>持有并等待</td><td>进程持有资源的同时等待其他资源</td><td>拿着A等B</td><td>一次性申请所有资源</td></tr><tr><td>不可剥夺</td><td>资源不能被强制回收</td><td>进程独占CPU</td><td>允许资源抢占</td></tr><tr><td>循环等待</td><td>多个进程形成等待环路</td><td>A等B，B等A</td><td>资源有序分配</td></tr></tbody></table><p><strong>死锁处理策略：</strong></p><table><thead><tr><th>策略</th><th>方法</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>死锁预防</td><td>破坏四个必要条件之一</td><td>不会发生死锁</td><td>资源利用率低</td><td>实时系统</td></tr><tr><td>死锁避免</td><td>银行家算法</td><td>安全性高</td><td>需要预知资源需求</td><td>资源固定的系统</td></tr><tr><td>死锁检测</td><td>定期检测资源分配图</td><td>资源利用率高</td><td>需要额外开销</td><td>一般系统</td></tr><tr><td>死锁恢复</td><td>撤销进程或回收资源</td><td>灵活性高</td><td>可能丢失工作</td><td>容错系统</td></tr></tbody></table><p><strong>银行家算法步骤：</strong></p><ul><li>在分配资源前，模拟分配并检查是否会导致不安全状态。</li></ul><h3 id="_4-cpu调度算法" tabindex="-1"><a class="header-anchor" href="#_4-cpu调度算法"><span>4. CPU调度算法？</span></a></h3><p><strong>调度算法对比：</strong></p><table><thead><tr><th>算法</th><th>调度方式</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>FCFS</td><td>先来先服务</td><td>简单公平</td><td>平均等待时间长</td><td>批处理系统</td></tr><tr><td>SJF</td><td>短作业优先</td><td>平均等待时间最短</td><td>长作业可能饥饿</td><td>批处理系统</td></tr><tr><td>SRTF</td><td>短剩余时间优先</td><td>响应时间好</td><td>频繁切换开销</td><td>交互系统</td></tr><tr><td>RR</td><td>时间片轮转</td><td>响应时间均匀</td><td>时间片选择困难</td><td>分时系统</td></tr><tr><td>优先级调度</td><td>按优先级选择</td><td>重要任务优先</td><td>低优先级饥饿</td><td>实时系统</td></tr><tr><td>多级队列</td><td>不同队列不同算法</td><td>灵活性强</td><td>复杂度高</td><td>通用系统</td></tr></tbody></table><p><strong>时间片选择原则：</strong></p><table><thead><tr><th>时间片大小</th><th>优点</th><th>缺点</th><th>适用情况</th></tr></thead><tbody><tr><td>很小(1-5ms)</td><td>响应时间快</td><td>切换开销大</td><td>I/O密集型任务</td></tr><tr><td>适中(10-100ms)</td><td>平衡性能和响应</td><td>需要调优</td><td>混合型任务</td></tr><tr><td>很大(&gt;100ms)</td><td>切换开销小</td><td>响应时间慢</td><td>CPU密集型任务</td></tr></tbody></table><p><strong>调度评价指标：</strong></p><table><thead><tr><th>指标</th><th>定义</th><th>计算方式</th><th>重要性</th></tr></thead><tbody><tr><td>周转时间</td><td>作业完成时间-提交时间</td><td>完成时间-到达时间</td><td>高</td></tr><tr><td>等待时间</td><td>进程在就绪队列中等待的总时间</td><td>周转时间-运行时间</td><td>高</td></tr><tr><td>响应时间</td><td>首次响应的时间</td><td>首次运行时间-到达时间</td><td>交互系统重要</td></tr><tr><td>吞吐量</td><td>单位时间完成的作业数</td><td>完成作业数/总时间</td><td>批处理重要</td></tr></tbody></table><h3 id="_5-同步与异步、阻塞与非阻塞" tabindex="-1"><a class="header-anchor" href="#_5-同步与异步、阻塞与非阻塞"><span>5. 同步与异步、阻塞与非阻塞？</span></a></h3><p><strong>概念区别：</strong></p><table><thead><tr><th>概念</th><th>关注点</th><th>描述</th><th>举例</th></tr></thead><tbody><tr><td>同步</td><td>消息通信机制</td><td>调用后等待结果返回</td><td>打电话</td></tr><tr><td>异步</td><td>消息通信机制</td><td>调用后立即返回，结果通过回调获取</td><td>发短信</td></tr><tr><td>阻塞</td><td>程序等待状态</td><td>调用线程被挂起</td><td>等红绿灯</td></tr><tr><td>非阻塞</td><td>程序等待状态</td><td>调用线程不被挂起</td><td>边走边看手机</td></tr></tbody></table><p><strong>四种组合方式：</strong></p><table><thead><tr><th>组合</th><th>特点</th><th>应用场景</th><th>性能特点</th></tr></thead><tbody><tr><td>同步阻塞</td><td>等待结果，线程挂起</td><td>简单顺序处理</td><td>简单但效率低</td></tr><tr><td>同步非阻塞</td><td>等待结果，线程不挂起</td><td>轮询检查</td><td>占用CPU资源</td></tr><tr><td>异步阻塞</td><td>不等待结果，线程挂起</td><td>很少使用</td><td>没有意义</td></tr><tr><td>异步非阻塞</td><td>不等待结果，线程不挂起</td><td>高并发处理</td><td>最高效率</td></tr></tbody></table><p><strong>实际应用对比：</strong></p><table><thead><tr><th>场景</th><th>同步阻塞</th><th>同步非阻塞</th><th>异步非阻塞</th></tr></thead><tbody><tr><td>文件读取</td><td>fread()</td><td>fcntl设置O_NONBLOCK</td><td>aio_read()</td></tr><tr><td>网络通信</td><td>recv()</td><td>select/poll轮询</td><td>epoll + 回调</td></tr><tr><td>数据库操作</td><td>JDBC同步查询</td><td>轮询查询状态</td><td>异步回调查询</td></tr></tbody></table><h3 id="_6-内存分配算法" tabindex="-1"><a class="header-anchor" href="#_6-内存分配算法"><span>6. 内存分配算法？</span></a></h3><p><strong>分配算法对比：</strong></p><table><thead><tr><th>算法</th><th>原理</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>首次适应</td><td>从头开始找第一个够大的块</td><td>简单快速</td><td>容易产生小碎片</td><td>一般应用</td></tr><tr><td>最佳适应</td><td>找最小的够用的块</td><td>碎片小</td><td>搜索时间长</td><td>内存紧张时</td></tr><tr><td>最坏适应</td><td>找最大的块</td><td>剩余块大</td><td>浪费大块内存</td><td>需要大块内存时</td></tr><tr><td>快速适应</td><td>为不同大小维护空闲链表</td><td>分配回收快</td><td>内存开销大</td><td>频繁分配回收</td></tr></tbody></table><p><strong>内存碎片问题：</strong></p><table><thead><tr><th>碎片类型</th><th>产生原因</th><th>解决方法</th><th>效果</th></tr></thead><tbody><tr><td>内部碎片</td><td>分配单位大于实际需求</td><td>减小分配单位</td><td>提高内存利用率</td></tr><tr><td>外部碎片</td><td>频繁分配回收造成不连续</td><td>内存紧缩、分页</td><td>合并空闲空间</td></tr></tbody></table><p><strong>伙伴系统算法：</strong></p><table><thead><tr><th>特点</th><th>说明</th><th>优势</th><th>劣势</th></tr></thead><tbody><tr><td>块大小</td><td>2的幂次方(1,2,4,8,...)</td><td>快速分配和合并</td><td>内部碎片较大</td></tr><tr><td>分割策略</td><td>大块分割为两个相等的小块</td><td>算法简单</td><td>可能浪费空间</td></tr><tr><td>合并策略</td><td>相邻的伙伴块可以合并</td><td>减少外部碎片</td><td>需要维护伙伴关系</td></tr></tbody></table><h3 id="_7-文件系统" tabindex="-1"><a class="header-anchor" href="#_7-文件系统"><span>7. 文件系统？</span></a></h3><p><strong>文件系统类型：</strong></p><table><thead><tr><th>文件系统</th><th>特点</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>FAT32</td><td>简单的文件分配表</td><td>兼容性好</td><td>单文件4GB限制</td><td>U盘、小存储</td></tr><tr><td>NTFS</td><td>Windows主流文件系统</td><td>支持大文件、权限控制</td><td>Linux支持有限</td><td>Windows系统</td></tr><tr><td>ext4</td><td>Linux主流文件系统</td><td>性能好、可靠性高</td><td>Windows不支持</td><td>Linux系统</td></tr><tr><td>ZFS</td><td>高级文件系统</td><td>数据完整性、快照</td><td>内存消耗大</td><td>企业存储</td></tr></tbody></table><p><strong>文件分配方法：</strong></p><table><thead><tr><th>分配方法</th><th>原理</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>连续分配</td><td>文件占用连续的磁盘块</td><td>访问速度快</td><td>外部碎片严重</td><td>顺序访问</td></tr><tr><td>链式分配</td><td>文件块通过指针链接</td><td>无外部碎片</td><td>随机访问慢</td><td>顺序访问文件</td></tr><tr><td>索引分配</td><td>用索引块记录文件块位置</td><td>支持随机访问</td><td>索引块开销</td><td>随机访问文件</td></tr></tbody></table><h3 id="_8-epoll-的原理及其-o-1-查询速度-有哪两种工作模式" tabindex="-1"><a class="header-anchor" href="#_8-epoll-的原理及其-o-1-查询速度-有哪两种工作模式"><span>8. epoll 的原理及其 O(1) 查询速度？有哪两种工作模式？</span></a></h3><p><strong>epoll 原理：</strong></p><ul><li>事件驱动：epoll 通过事件通知机制，避免了反复遍历文件描述符集，提高了效率。</li><li>内核支持：epoll 在内核中维护一个红黑树和一个就绪链表，红黑树用于存储所有注册的文件描述符，就绪链表用于存储已就绪的事件。</li><li>O(1) 查询：由于就绪链表只包含已就绪的事件，epoll_wait 只需遍历就绪链表，查询速度为 O(1)。</li><li>红黑树：存储所有注册的文件描述符，支持快速增删查。</li><li>就绪链表：存储已就绪的事件，支持快速遍历。</li></ul><p><strong>epoll 工作模式：</strong></p><table><thead><tr><th>模式</th><th>特点</th><th>适用场景</th></tr></thead><tbody><tr><td>LT（水平触发）</td><td>事件触发后，内核通知应用，应用需要主动处理</td><td>长连接、文件监控</td></tr><tr><td>ET（边缘触发）</td><td>事件触发后，内核通知应用，应用需要处理完所有事件</td><td>低延迟网络、高性能场合</td></tr></tbody></table><ul><li>LT 在状态满足时反复通知，ET 只在状态变化时通知一次。</li></ul><p><strong>系统调用机制：</strong></p><table><thead><tr><th>系统调用类型</th><th>功能</th><th>典型例子</th><th>返回值</th></tr></thead><tbody><tr><td>进程控制</td><td>进程管理</td><td>fork(), exec(), exit()</td><td>进程ID或状态</td></tr><tr><td>文件操作</td><td>文件I/O</td><td>open(), read(), write()</td><td>文件描述符或字节数</td></tr><tr><td>设备管理</td><td>设备控制</td><td>ioctl()</td><td>成功/失败状态</td></tr><tr><td>信息维护</td><td>获取系统信息</td><td>getpid(), time()</td><td>相应的信息值</td></tr><tr><td>通信</td><td>进程间通信</td><td>pipe(), socket()</td><td>通信描述符</td></tr></tbody></table><h3 id="_9-linux常用命令-查看进程有哪些命令" tabindex="-1"><a class="header-anchor" href="#_9-linux常用命令-查看进程有哪些命令"><span>9. Linux常用命令？ 查看进程有哪些命令？</span></a></h3><p><strong>Linux常用命令分类：</strong></p><table><thead><tr><th>类别</th><th>命令</th><th>作用</th><th>常用示例</th></tr></thead><tbody><tr><td><strong>文件操作</strong></td><td><code>ls</code>, <code>cd</code>, <code>pwd</code>, <code>mkdir</code>, <code>rm</code>, <code>cp</code>, <code>mv</code></td><td>文件和目录基本操作</td><td><code>ls -la</code>, <code>rm -rf dir</code></td></tr><tr><td><strong>文件查看</strong></td><td><code>cat</code>, <code>less</code>, <code>head</code>, <code>tail</code>, <code>grep</code></td><td>查看和搜索文件内容</td><td><code>tail -f app.log</code>, <code>grep &quot;error&quot; *.log</code></td></tr><tr><td><strong>权限管理</strong></td><td><code>chmod</code>, <code>chown</code>, <code>chgrp</code></td><td>修改文件权限和所有者</td><td><code>chmod 755 script.sh</code></td></tr><tr><td><strong>压缩解压</strong></td><td><code>tar</code>, <code>zip</code>, <code>unzip</code>, <code>gzip</code></td><td>文件压缩和解压</td><td><code>tar -czf backup.tar.gz dir/</code></td></tr><tr><td><strong>网络工具</strong></td><td><code>ping</code>, <code>wget</code>, <code>curl</code>, <code>netstat</code>, <code>ss</code></td><td>网络连接和下载</td><td><code>netstat -tlnp</code>, <code>curl -I url</code></td></tr><tr><td><strong>系统监控</strong></td><td><code>top</code>, <code>htop</code>, <code>free</code>, <code>df</code>, <code>du</code></td><td>系统资源监控</td><td><code>top</code>, <code>df -h</code>, <code>free -m</code></td></tr></tbody></table><p><strong>查看进程命令详解：</strong></p><table><thead><tr><th>命令</th><th>作用</th><th>常用参数</th><th>实际应用</th></tr></thead><tbody><tr><td><strong><code>ps</code></strong></td><td>查看进程快照</td><td><code>-ef</code>(全格式), <code>-aux</code>(详细信息)</td><td><code>ps -ef | grep java</code></td></tr><tr><td><strong><code>top</code></strong></td><td>实时查看进程</td><td><code>-p PID</code>(指定进程), <code>-u user</code>(指定用户)</td><td><code>top -p 1234</code></td></tr><tr><td><strong><code>htop</code></strong></td><td>增强版top</td><td>交互式操作，彩色显示</td><td><code>htop</code></td></tr><tr><td><strong><code>pgrep</code></strong></td><td>按名称查找PID</td><td><code>-f</code>(完整命令行), <code>-u</code>(指定用户)</td><td><code>pgrep -f tomcat</code></td></tr><tr><td><strong><code>pidof</code></strong></td><td>查找程序PID</td><td>直接跟程序名</td><td><code>pidof nginx</code></td></tr><tr><td><strong><code>pstree</code></strong></td><td>树形显示进程关系</td><td><code>-p</code>(显示PID), <code>-u</code>(显示用户)</td><td><code>pstree -p</code></td></tr><tr><td><strong><code>jobs</code></strong></td><td>查看后台作业</td><td>当前shell的后台进程</td><td><code>jobs -l</code></td></tr></tbody></table><ul><li><code>lsof -i :80</code> 查看80端口被谁占用</li></ul><p><strong>进程管理命令：</strong></p><table><thead><tr><th>命令</th><th>作用</th><th>常用方式</th><th>说明</th></tr></thead><tbody><tr><td><strong><code>kill</code></strong></td><td>终止进程</td><td><code>kill PID</code>, <code>kill -9 PID</code></td><td>-9强制杀死</td></tr><tr><td><strong><code>killall</code></strong></td><td>按名称杀进程</td><td><code>killall processname</code></td><td>杀死所有同名进程</td></tr><tr><td><strong><code>nohup</code></strong></td><td>后台运行程序</td><td><code>nohup command &amp;</code></td><td>忽略挂断信号</td></tr><tr><td><strong><code>bg</code></strong></td><td>后台运行作业</td><td><code>bg %1</code></td><td>将暂停的作业放到后台</td></tr><tr><td><strong><code>fg</code></strong></td><td>前台运行作业</td><td><code>fg %1</code></td><td>将后台作业调到前台</td></tr></tbody></table><p><strong>面试重点回答：</strong></p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>Linux常用命令主要分几类：</span></span>\n<span class="line"><span>1. 文件操作：ls、cd、mkdir、rm、cp、mv</span></span>\n<span class="line"><span>2. 文件查看：cat、grep、tail、head  </span></span>\n<span class="line"><span>3. 系统监控：top、ps、free、df</span></span>\n<span class="line"><span>4. 网络工具：ping、curl、netstat</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>查看进程主要用：</span></span>\n<span class="line"><span>- ps -ef：查看所有进程详细信息</span></span>\n<span class="line"><span>- top：实时监控进程资源使用</span></span>\n<span class="line"><span>- pgrep：根据进程名快速查找PID</span></span>\n<span class="line"><span>- htop：增强版top，界面更友好</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>进程管理用kill杀进程，nohup后台运行程序。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>高频面试场景：</strong></p><table><thead><tr><th>场景</th><th>命令组合</th><th>解释</th></tr></thead><tbody><tr><td>查找并杀死进程</td><td><code>ps -ef | grep java | kill $(awk &#39;{print $2}&#39;)</code></td><td>查找java进程并杀死</td></tr><tr><td>查看端口占用</td><td><code>netstat -tlnp | grep :8080</code></td><td>查看8080端口被谁占用</td></tr><tr><td>查看日志尾部</td><td><code>tail -f app.log | grep ERROR</code></td><td>实时查看错误日志</td></tr><tr><td>查看磁盘使用</td><td><code>df -h &amp;&amp; du -sh /*</code></td><td>查看磁盘空间和目录大小</td></tr><tr><td>查看内存使用</td><td><code>free -m &amp;&amp; top -o %MEM</code></td><td>查看内存使用情况</td></tr></tbody></table><h3 id="_10-进程的状态和通信方法" tabindex="-1"><a class="header-anchor" href="#_10-进程的状态和通信方法"><span>10. 进程的状态和通信方法？</span></a></h3><h4 id="进程的主要状态" tabindex="-1"><a class="header-anchor" href="#进程的主要状态"><span>进程的主要状态</span></a></h4><ol><li><strong>就绪状态（Ready）</strong>：进程已获得除CPU外的所有必要资源，只要再获得CPU，就可以立即执行。此时进程处于就绪队列中，等待调度程序为其分配CPU。</li><li><strong>运行状态（Running）</strong>：进程正在CPU上执行指令。在单CPU系统中，同一时刻只有一个进程处于运行状态；在多CPU系统中，可能有多个进程同时处于运行状态。</li><li><strong>阻塞状态（Blocked）</strong>：也称为等待状态，进程因为等待某一事件（如等待I/O操作完成、等待同步信号等）而暂时不能执行，即使此时CPU空闲，该进程也无法运行。</li></ol><h4 id="进程间通信的主要手段和方法" tabindex="-1"><a class="header-anchor" href="#进程间通信的主要手段和方法"><span>进程间通信的主要手段和方法</span></a></h4><ol><li><strong>管道（Pipe）</strong>： <ul><li><strong>普通管道（匿名管道）</strong>：是一种半双工的通信方式，只能在具有亲缘关系的进程（如父子进程、兄弟进程）之间使用。数据只能单向流动，创建时会得到两个文件描述符，一个用于读，一个用于写。</li><li><strong>命名管道（FIFO）</strong>：允许无亲缘关系的进程间通信，它有一个路径名与之关联，以文件的形式存在于文件系统中，可双向通信。</li></ul></li><li><strong>消息队列（Message Queue）</strong>：是一种消息的链表，存放在内核中并由消息队列标识符标识。进程可以向消息队列中添加消息，也可以从消息队列中读取消息。消息队列克服了信号传递信息少、管道只能传递无格式字节流以及缓冲区大小受限等缺点。</li><li><strong>共享内存（Shared Memory）</strong>：是最快的一种进程间通信方式，它允许两个或多个进程共享同一块内存空间。进程可以直接对共享内存进行读写操作，不需要进行数据的复制，从而提高了通信效率。但共享内存需要与其他同步机制（如信号量）配合使用，以保证进程间的同步与互斥。</li><li><strong>信号量（Semaphore）</strong>：主要用于实现进程间的同步与互斥，而不是用于传递大量数据。它是一个计数器，可以控制多个进程对共享资源的访问。通过对信号量的P（等待）和V（释放）操作，实现进程间的同步与互斥，保证共享资源在同一时刻只有一个进程访问。</li><li><strong>套接字（Socket）</strong>：既可以用于同一台计算机上的进程间通信，也可以用于网络上不同计算机之间的进程通信。它提供了一种通用的网络编程接口，支持多种协议（如TCP、UDP等）。</li></ol><h2 id="设计模式" tabindex="-1"><a class="header-anchor" href="#设计模式"><span>设计模式</span></a></h2><h3 id="_1-spring中用到了哪些设计模式" tabindex="-1"><a class="header-anchor" href="#_1-spring中用到了哪些设计模式"><span>1. Spring中用到了哪些设计模式？</span></a></h3><table><thead><tr><th>设计模式</th><th>应用场景</th><th>具体实现</th><th>作用</th><th>好处</th></tr></thead><tbody><tr><td><strong>单例模式</strong></td><td>Bean容器管理</td><td>IoC容器</td><td>确保Bean唯一实例</td><td>节省内存，提高性能</td></tr><tr><td><strong>工厂模式</strong></td><td>Bean创建</td><td>BeanFactory、ApplicationContext</td><td>统一管理Bean的创建</td><td>解耦对象的创建和使用</td></tr><tr><td><strong>代理模式</strong></td><td>AOP切面编程</td><td>JDK动态代理、CGLIB</td><td>增强功能而不修改原代码</td><td>实现横切关注点</td></tr><tr><td><strong>模板方法</strong></td><td>数据访问</td><td>JdbcTemplate、HibernateTemplate</td><td>定义算法骨架</td><td>代码复用，减少重复</td></tr><tr><td><strong>策略模式</strong></td><td>配置选择</td><td>数据源配置、缓存策略</td><td>根据配置选择实现</td><td>易于扩展，符合开闭原则</td></tr><tr><td><strong>观察者模式</strong></td><td>事件机制</td><td>ApplicationEvent、ApplicationListener</td><td>组件间解耦通信</td><td>松耦合，易于维护</td></tr><tr><td><strong>适配器模式</strong></td><td>接口适配</td><td>HandlerAdapter、ViewResolver</td><td>让不兼容接口一起工作</td><td>提高系统灵活性</td></tr><tr><td><strong>装饰器模式</strong></td><td>功能增强</td><td>BeanPostProcessor、AOP</td><td>动态添加新功能</td><td>不改变原类扩展功能</td></tr><tr><td><strong>建造者模式</strong></td><td>复杂对象构建</td><td>BeanDefinitionBuilder</td><td>构建复杂对象</td><td>构建过程清晰，参数灵活</td></tr><tr><td><strong>责任链模式</strong></td><td>请求处理</td><td>Filter链、Interceptor链</td><td>解耦发送者和接收者</td><td>动态组合处理链</td></tr></tbody></table><p><strong>面试重点：</strong></p><ul><li><strong>核心模式</strong>：单例、工厂、代理</li><li><strong>主要作用</strong>：提供灵活性和可扩展性</li><li><strong>设计原则</strong>：遵循开闭原则，支持扩展</li><li><strong>实际价值</strong>：让Spring框架更加优雅和强大</li></ul><h3 id="_2-工厂模式" tabindex="-1"><a class="header-anchor" href="#_2-工厂模式"><span>2. 工厂模式？</span></a></h3><ul><li>工厂模式分为三种：简单工厂用一个工厂生产多类产品但违反开闭原则；工厂方法一个工厂对应一个产品，符合开闭原则；抽象工厂则是生产一族相关产品，保证兼容性但扩展困难。</li></ul><h3 id="_3-设计模式分类" tabindex="-1"><a class="header-anchor" href="#_3-设计模式分类"><span>3. 设计模式分类？</span></a></h3><ol><li>创建型模式 (Creational Patterns): 这些模式关注对象的创建机制，帮助解决对象的实例化过程。它们包括</li></ol><ul><li>单例模式 (Singleton Pattern): 确保一个类只有一个实例，并提是供全局访问点。</li><li>工厂模式 (Factory Pattern): 通过工厂方法或抽象工厂创建对象，将实例化逻辑与客户端代码分离。</li><li>抽象工厂模式 (Abstract Factory Pattern): 提供一个创建一系列相关或依赖对象的接口，而无需指定具体类。</li><li>建造者模式 (Builder Pattern): 将一个复杂对象的构建过程和表示分离，使得同样的构建过程可以创建不同的表示。</li></ul><ol start="2"><li>结构型模式 (Structural Patterns): 这些模式关注类和对象的组合，用于创建更大、更复杂的结构。它们包括</li></ol><ul><li>适配器模式 (Adapter Pattern): 将一个类的接口转换成客户端所期望的另一个接口。</li><li>装饰器模式 (Decorator Pattern): 动态地给对象添加额外的职责，不修改其结构。</li><li>代理模式 (Proxy Pattern): 控制对其他对象的访问，可以用于滋添加额外的逻辑，如懒加载、权限控制等。</li><li>外观模式 (Facade Pattern): 为复杂的子系统提供一个简化的接口，将客户端和子系统解耦。</li></ul><ol start="3"><li>行为型模式 (Behavioral Patterns): 这些模式关注双对象之间的通信和协作，用于定义对象之间的交互方式。它们包括</li></ol><ul><li>观察者模式 (Observer Pattern): 定义对象之间的一对多依赖关系，当一个对象状态改变时，其依赖对象会得到通知。</li><li>策略模式 (Strategy Pattern): 定义一系列算法，将它们封装成独立的策略类，并使得它们可以互相替换。</li><li>命令模式 (Command Pattern): 将一个请求封装成一个对象，人从而可以进行参数化、排队、记录请求等操作。</li><li>迭代器模式 (lterator Pattern): 提供一种顺序访问集合对象元素素的方法，而无需暴露其内部表示。</li><li>责任链模式 (Chain of Responsibility Pattern): 通过一系列处理器，将请求从一个处理器传递到下一个，直到被处理或结束。</li><li>状态模式 (State Pattern): 允许对象在其内部状态改变时改变其行为，使得状态转换可更加灵活。</li></ul><h2 id="云计算" tabindex="-1"><a class="header-anchor" href="#云计算"><span>云计算</span></a></h2><h3 id="_1-云和云原生的区别" tabindex="-1"><a class="header-anchor" href="#_1-云和云原生的区别"><span>1. 云和云原生的区别？</span></a></h3><p><strong>云（Cloud）：</strong></p><ul><li>是一种<strong>技术架构模式</strong>，将计算资源（服务器、存储、网络）通过互联网按需提供</li><li>主要特点：弹性伸缩、按需付费、资源共享</li><li>代表服务：IaaS（基础设施即服务）、PaaS（平台即服务）、SaaS（软件即服务）</li></ul><p><strong>云原生（Cloud Native）：</strong></p><ul><li>是一种<strong>应用开发和部署的方法论</strong>，专门为云环境设计</li><li>核心原则：微服务架构、容器化部署、自动化运维、持续交付</li><li>代表技术：Docker、Kubernetes、微服务、DevOps</li></ul><p><strong>简单理解：</strong></p><ul><li>云 = 基础设施（房子）</li><li>云原生 = 在云上构建应用的最佳实践（装修方案）</li></ul><h3 id="_2-虚拟机和容器的区别" tabindex="-1"><a class="header-anchor" href="#_2-虚拟机和容器的区别"><span>2. 虚拟机和容器的区别？</span></a></h3><table><thead><tr><th>维度</th><th>虚拟机</th><th>容器</th></tr></thead><tbody><tr><td><strong>隔离级别</strong></td><td>硬件级隔离（完整OS）</td><td>进程级隔离（共享OS内核）</td></tr><tr><td><strong>启动速度</strong></td><td>分钟级</td><td>秒级</td></tr><tr><td><strong>资源占用</strong></td><td>较大（GB级别）</td><td>较小（MB级别）</td></tr><tr><td><strong>性能开销</strong></td><td>较高（虚拟化层）</td><td>较低（直接调用）</td></tr><tr><td><strong>部署密度</strong></td><td>低（一台机器几个VM）</td><td>高（一台机器几百个容器）</td></tr><tr><td><strong>迁移性</strong></td><td>较差（依赖虚拟化平台）</td><td>好（标准格式，跨平台）</td></tr></tbody></table><p><strong>面试要点：</strong></p><ul><li>虚拟机：完整的操作系统 + 应用</li><li>容器：应用 + 依赖库，共享主机OS内核</li><li>容器更轻量、启动更快、资源利用率更高</li><li>虚拟机隔离性更强，安全性更高</li></ul><p><strong>实际应用：</strong></p><ul><li>虚拟机：传统应用、需要强隔离的场景</li><li>容器：微服务、云原生应用、快速部署场景</li></ul><h3 id="_3-k8s的常见组件" tabindex="-1"><a class="header-anchor" href="#_3-k8s的常见组件"><span>3. K8S的常见组件？</span></a></h3><h4 id="核心资源组件" tabindex="-1"><a class="header-anchor" href="#核心资源组件"><span><strong>核心资源组件</strong></span></a></h4><table><thead><tr><th>资源类型</th><th>作用</th><th>特点</th><th>使用场景</th></tr></thead><tbody><tr><td><strong>Pod</strong></td><td>最小部署单元，包含一个或多个容器</td><td>临时性，可被调度</td><td>运行应用程序</td></tr><tr><td><strong>Service</strong></td><td>为Pod提供固定访问点，负载均衡</td><td>稳定IP，服务发现</td><td>内部服务访问</td></tr><tr><td><strong>Deployment</strong></td><td>管理Pod副本，支持滚动更新</td><td>声明式，自动扩缩容</td><td>无状态应用</td></tr><tr><td><strong>StatefulSet</strong></td><td>管理有状态应用</td><td>固定网络标识，有序部署</td><td>数据库、存储应用</td></tr><tr><td><strong>DaemonSet</strong></td><td>每个节点运行一个Pod</td><td>节点级部署</td><td>监控、日志收集</td></tr><tr><td><strong>Job/CronJob</strong></td><td>执行一次性任务</td><td>任务完成后自动删除</td><td>批处理、定时任务</td></tr></tbody></table><h4 id="网络和存储组件" tabindex="-1"><a class="header-anchor" href="#网络和存储组件"><span><strong>网络和存储组件</strong></span></a></h4><table><thead><tr><th>资源类型</th><th>作用</th><th>特点</th><th>使用场景</th></tr></thead><tbody><tr><td><strong>Ingress</strong></td><td>外部访问入口，HTTP/HTTPS路由</td><td>七层负载均衡，SSL终止</td><td>外部流量接入</td></tr><tr><td><strong>ConfigMap</strong></td><td>配置管理</td><td>键值对，挂载到容器</td><td>应用配置</td></tr><tr><td><strong>Secret</strong></td><td>敏感信息管理</td><td>加密存储，base64编码</td><td>密码、证书</td></tr><tr><td><strong>PersistentVolume</strong></td><td>持久化存储</td><td>抽象存储接口</td><td>数据库存储</td></tr><tr><td><strong>Namespace</strong></td><td>资源隔离</td><td>逻辑分组，权限控制</td><td>多租户、环境隔离</td></tr></tbody></table><p><strong>核心理解：</strong></p><ul><li><strong>Pod</strong>：最小部署单元，临时性</li><li><strong>Service</strong>：为Pod提供稳定访问点</li><li><strong>Deployment</strong>：管理无状态应用</li><li><strong>StatefulSet</strong>：管理有状态应用</li><li><strong>Ingress</strong>：外部流量入口</li></ul><p><strong>使用场景：</strong></p><ul><li><strong>Web应用</strong>：Deployment + Service + Ingress</li><li><strong>数据库</strong>：StatefulSet + PersistentVolume</li><li><strong>监控系统</strong>：DaemonSet + ConfigMap</li><li><strong>批处理</strong>：Job/CronJob</li></ul><p><strong>关键概念：</strong></p><ul><li>服务发现通过Service实现</li><li>配置管理通过ConfigMap/Secret</li><li>存储通过PersistentVolume</li><li>网络隔离通过Namespace</li></ul><h2 id="elasticsearch" tabindex="-1"><a class="header-anchor" href="#elasticsearch"><span>ElasticSearch</span></a></h2><h3 id="_1-对es的理解" tabindex="-1"><a class="header-anchor" href="#_1-对es的理解"><span>1. 对ES的理解？</span></a></h3><p>ES是一个<strong>分布式搜索引擎</strong>，基于Lucene构建，专门解决大规模数据的<strong>搜索和分析</strong>问题。</p><h4 id="核心特性" tabindex="-1"><a class="header-anchor" href="#核心特性"><span><strong>核心特性</strong></span></a></h4><ul><li><strong>全文搜索</strong>：支持复杂的文本搜索和匹配</li><li><strong>分布式架构</strong>：通过分片机制支持水平扩展</li><li><strong>近实时搜索</strong>：1秒内可搜索到新数据</li><li><strong>聚合分析</strong>：强大的数据分析和统计能力</li></ul><h4 id="技术原理" tabindex="-1"><a class="header-anchor" href="#技术原理"><span><strong>技术原理</strong></span></a></h4><ul><li><strong>倒排索引</strong>：关键词到文档的映射，实现快速搜索</li><li><strong>分片机制</strong>：数据水平分割，支持并行处理</li><li><strong>副本机制</strong>：保证高可用和容错能力</li></ul><h4 id="应用场景" tabindex="-1"><a class="header-anchor" href="#应用场景"><span><strong>应用场景</strong></span></a></h4><ul><li><strong>日志分析</strong>：ELK Stack，实时监控</li><li><strong>电商搜索</strong>：商品搜索、智能推荐</li><li><strong>企业搜索</strong>：文档搜索、知识库</li></ul><h4 id="优势-1" tabindex="-1"><a class="header-anchor" href="#优势-1"><span><strong>优势</strong></span></a></h4><ul><li>搜索性能优秀（毫秒级响应）</li><li>支持大规模数据和高并发</li><li>生态丰富，工具链完善</li></ul><h4 id="挑战" tabindex="-1"><a class="header-anchor" href="#挑战"><span><strong>挑战</strong></span></a></h4><ul><li>学习曲线较陡</li><li>运维复杂，资源消耗大</li><li>最终一致性模型</li></ul><p><strong>总结：</strong> ES是搜索和分析场景的<strong>最佳选择</strong>，特别适合需要快速搜索和实时分析的场景。</p><h3 id="_2-es的核心概念" tabindex="-1"><a class="header-anchor" href="#_2-es的核心概念"><span>2. ES的核心概念</span></a></h3><ul><li><strong>索引（Index）</strong>：类似数据库表，是数据的逻辑容器</li><li><strong>分片（Shard）</strong>：数据分割的最小单位，支持水平扩展</li><li><strong>副本（Replica）</strong>：分片的备份，提供高可用和负载均衡</li></ul><h3 id="_3-倒排索引原理" tabindex="-1"><a class="header-anchor" href="#_3-倒排索引原理"><span>3. 倒排索引原理</span></a></h3><ul><li><strong>正向索引</strong>：文档ID → 内容</li><li><strong>倒排索引</strong>：关键词 → 文档ID列表</li><li><strong>优势</strong>：快速定位包含关键词的文档</li></ul><h3 id="_4-写入流程" tabindex="-1"><a class="header-anchor" href="#_4-写入流程"><span>4. 写入流程</span></a></h3><ol><li>写入内存缓冲区</li><li>写入事务日志</li><li>定期刷新到段文件（可搜索）</li><li>定期提交到磁盘（持久化）</li></ol><h3 id="_5-近实时搜索" tabindex="-1"><a class="header-anchor" href="#_5-近实时搜索"><span>5. 近实时搜索</span></a></h3><ul><li><strong>刷新间隔</strong>：默认1秒刷新一次</li><li><strong>平衡性能</strong>：减少刷新频率提高写入性能</li><li><strong>可配置</strong>：可以调整刷新间隔</li></ul><h3 id="_6-节点角色" tabindex="-1"><a class="header-anchor" href="#_6-节点角色"><span>6. 节点角色</span></a></h3><ul><li><strong>Master节点</strong>：集群管理，元数据维护</li><li><strong>Data节点</strong>：数据存储和搜索</li><li><strong>Ingest节点</strong>：数据预处理</li><li><strong>Coordinating节点</strong>：请求协调</li></ul><h3 id="_7-性能优化" tabindex="-1"><a class="header-anchor" href="#_7-性能优化"><span>7. 性能优化</span></a></h3><ul><li><strong>合理分片</strong>：根据数据量设置分片数</li><li><strong>内存配置</strong>：堆内存不超过50%</li><li><strong>索引优化</strong>：合理设置mapping</li><li><strong>查询优化</strong>：避免深度分页</li><li>对 Elasticsearch 查询性能，可通过合理建索引、使用 filter、分页优化和聚合优化来提升；</li><li>对写入性能，可通过 _bulk 批量写入、刷新策略调整、副本控制和文档映射优化来提升；</li><li>总体思路是 查询走索引、写入减少重复开销。</li></ul><h3 id="_8-高可用" tabindex="-1"><a class="header-anchor" href="#_8-高可用"><span>8. 高可用</span></a></h3><ul><li><strong>副本机制</strong>：每个分片有副本</li><li><strong>故障转移</strong>：节点故障时副本自动提升</li><li><strong>脑裂保护</strong>：多数派选举机制</li></ul><h3 id="_9-数据一致性" tabindex="-1"><a class="header-anchor" href="#_9-数据一致性"><span>9. 数据一致性</span></a></h3><ul><li><strong>写入一致性</strong>：主分片写入成功才返回</li><li><strong>读取一致性</strong>：可配置一致性级别</li><li><strong>最终一致性</strong>：副本间可能存在短暂不一致</li></ul><h2 id="其他" tabindex="-1"><a class="header-anchor" href="#其他"><span>其他</span></a></h2><h3 id="_1-介绍一下disruptor-为什么适合撮合引擎" tabindex="-1"><a class="header-anchor" href="#_1-介绍一下disruptor-为什么适合撮合引擎"><span>1. 介绍一下Disruptor？为什么适合撮合引擎？</span></a></h3><p>Disruptor 是一个基于 <strong>环形数组（RingBuffer）</strong> 的消息传递机制，替代传统队列（如 LinkedBlockingQueue）。</p><table><thead><tr><th>特性</th><th>描述</th></tr></thead><tbody><tr><td>无锁并发</td><td>通过 CAS、自旋等技术避免锁竞争</td></tr><tr><td>高性能</td><td>比传统阻塞队列高出 <strong>10~100 倍吞吐</strong></td></tr><tr><td>单写多读</td><td>多个消费者独立读取同一个事件流</td></tr><tr><td>内存预分配</td><td>数据结构全部在内存中完成初始化，避免 GC</td></tr><tr><td>避免伪共享</td><td>精心设计的缓存行对齐策略，避免 CPU 缓存伪共享问题</td></tr></tbody></table><h4 id="撮合引擎核心诉求" tabindex="-1"><a class="header-anchor" href="#撮合引擎核心诉求"><span>撮合引擎核心诉求：</span></a></h4><ul><li>极低延迟：买单卖单需要快速撮合</li><li>高并发处理：每秒可能成千上万订单</li><li>有序性强：事件顺序影响撮合结果</li><li>高吞吐量：吞吐瓶颈会直接影响撮合速度</li></ul><h4 id="disruptor-的优势在撮合中如何体现" tabindex="-1"><a class="header-anchor" href="#disruptor-的优势在撮合中如何体现"><span>Disruptor 的优势在撮合中如何体现？</span></a></h4><table><thead><tr><th>撮合痛点</th><th>Disruptor 优势</th><th>对应机制</th></tr></thead><tbody><tr><td>CPU竞争严重</td><td><strong>无锁并发</strong>，避免上下文切换</td><td>CAS + ringbuffer</td></tr><tr><td>撮合延迟高</td><td>极低延迟、支持批量处理</td><td>顺序写入+消费者批处理</td></tr><tr><td>撮合顺序乱</td><td>保证有序消费</td><td>单生产者模型下天然顺序</td></tr><tr><td>GC引发抖动</td><td><strong>内存预分配</strong>，减少GC</td><td>固定大小环形缓冲区</td></tr><tr><td>数据落地慢</td><td>支持异步消费者并发处理</td><td>多消费者模型，职责分离</td></tr></tbody></table><h4 id="举个简单例子-撮合系统架构图-基于-disruptor" tabindex="-1"><a class="header-anchor" href="#举个简单例子-撮合系统架构图-基于-disruptor"><span>举个简单例子：撮合系统架构图（基于 Disruptor）</span></a></h4><div class="language-text line-numbers-mode" data-highlighter="shiki" data-ext="text" data-title="text" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>                 ┌────────────┐</span></span>\n<span class="line"><span>                 │订单接收线程│ ← API请求、MQ、Socket 等</span></span>\n<span class="line"><span>                 └────┬───────┘</span></span>\n<span class="line"><span>                      │</span></span>\n<span class="line"><span>                      ▼</span></span>\n<span class="line"><span>             ┌────────────────┐</span></span>\n<span class="line"><span>             │ RingBuffer（订单事件） │ ← Disruptor核心</span></span>\n<span class="line"><span>             └────────────────┘</span></span>\n<span class="line"><span>               ▲        ▲         ▲</span></span>\n<span class="line"><span>         撮合器A   撮合器B     落库线程（异步）</span></span>\n<span class="line"><span>       (BTC撮合) (ETH撮合)     (写MySQL)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><strong>接收线程</strong>：将订单封装为 Event，发布到 RingBuffer</li><li><strong>多个消费者</strong>：根据币种或市场分配到对应撮合器</li><li><strong>落地线程</strong>：撮合完成的成交单异步写库，不阻塞撮合逻辑</li></ul><h4 id="和传统队列对比-如-linkedblockingqueue" tabindex="-1"><a class="header-anchor" href="#和传统队列对比-如-linkedblockingqueue"><span>和传统队列对比（如 LinkedBlockingQueue）</span></a></h4><table><thead><tr><th>特性</th><th>LinkedBlockingQueue</th><th>Disruptor</th></tr></thead><tbody><tr><td>锁机制</td><td>ReentrantLock（有锁）</td><td>CAS（无锁）</td></tr><tr><td>吞吐量</td><td>中等</td><td>极高</td></tr><tr><td>延迟</td><td>高</td><td>纳秒级延迟</td></tr><tr><td>内存分配</td><td>动态</td><td>预分配（无GC）</td></tr><tr><td>多消费者模式</td><td>支持但效率低</td><td>支持且高效</td></tr><tr><td>是否适合撮合系统</td><td>❌</td><td>✅ 强烈推荐</td></tr></tbody></table><h4 id="使用建议-实战中" tabindex="-1"><a class="header-anchor" href="#使用建议-实战中"><span>使用建议（实战中）</span></a></h4><ul><li><strong>生产者线程</strong>：接收请求或MQ，将订单发布到 ring buffer</li><li><strong>消费者线程</strong>：根据产品线、交易对划分多个消费者做撮合</li><li><strong>异步落库、推送</strong>：通过后置消费者链完成落库或推送消息（如 WebSocket）</li></ul><h3 id="_2-xxl-job路由策略有哪些-xxl-job任务执行失败怎么解决-如果有大数据量的任务同时都需要执行-怎么解决" tabindex="-1"><a class="header-anchor" href="#_2-xxl-job路由策略有哪些-xxl-job任务执行失败怎么解决-如果有大数据量的任务同时都需要执行-怎么解决"><span>2. xxl-job路由策略有哪些？xxl-job任务执行失败怎么解决？如果有大数据量的任务同时都需要执行，怎么解决？</span></a></h3><p>xxl-job支持多种路由策略，包括轮询、故障转移和分片广播等。</p><p>面对任务执行失败，我们可以：</p><ol><li>选择故障转移路由策略，优先使用健康的实例执行任务。</li><li>设置任务重试次数。</li><li>通过日志记录和邮件告警通知相关负责人。</li></ol><p>我们可以通过部署多个实例并使用<strong>分片广播路由</strong>策略来分散任务负载。在任务执行代码中，根据分片信息和总数对任务进行分配。</p><h3 id="_3-对xxl-job什么了解-如果你来实现一个分布式任务调度系统-你会怎么设计" tabindex="-1"><a class="header-anchor" href="#_3-对xxl-job什么了解-如果你来实现一个分布式任务调度系统-你会怎么设计"><span>3. 对xxl-job什么了解？如果你来实现一个分布式任务调度系统，你会怎么设计？</span></a></h3><p>一个开源的分布式任务调度平台，主要用于解决分布式环境下的定时任务调度问题。</p><p><strong>如果要实现分布式任务调度，我会这样设计：</strong></p><p><strong>核心架构：</strong></p><ol><li><strong>调度中心</strong>：负责任务调度、路由、监控</li><li><strong>执行器集群</strong>：实际执行任务的客户端</li><li><strong>任务存储</strong>：数据库存储任务配置和执行状态</li></ol><p><strong>关键技术点：</strong></p><ul><li><strong>任务调度</strong>：使用时间轮算法或Quartz实现定时调度</li><li><strong>负载均衡</strong>：执行器故障时自动故障转移</li><li><strong>任务分片</strong>：大数据量任务支持分片并行执行</li><li><strong>幂等性</strong>：通过任务ID和分片参数保证任务不重复执行</li><li><strong>监控告警</strong>：任务执行状态监控和异常告警</li></ul><p><strong>实现细节：</strong></p><ul><li>调度中心通过心跳机制监控执行器状态</li><li>任务执行结果异步回调更新状态</li><li>支持任务重试和超时控制</li><li>任务日志记录便于问题排查</li></ul><p><strong>优势：</strong></p><ul><li>高可用：支持集群部署</li><li>易扩展：执行器动态注册</li><li>易维护：Web界面管理任务</li></ul><p>这种设计能够很好地解决分布式环境下的任务调度问题，保证任务执行的可靠性和系统的可扩展性。</p><h3 id="_4-xxl-job底层如何调度" tabindex="-1"><a class="header-anchor" href="#_4-xxl-job底层如何调度"><span>4. xxl-job底层如何调度</span></a></h3><table><thead><tr><th>模块</th><th>功能</th><th>实现方式</th><th>特点 / 注意点</th></tr></thead><tbody><tr><td><strong>调度中心 (Admin)</strong></td><td>任务注册、管理、调度</td><td>数据库存储任务信息 (<code>xxl_job_info</code>)；调度线程池定期扫描任务</td><td>轻量、单点扫描、支持多实例但需处理一致性</td></tr><tr><td><strong>任务扫描</strong></td><td>找出需要执行的任务</td><td>定时扫描 DB（cron 时间 &lt;= 当前时间）</td><td>每秒扫描一次；通过行锁避免重复触发</td></tr><tr><td><strong>分片策略</strong></td><td>分配任务到 Executor</td><td>根据 Executor 列表和任务分片数进行 hash / 轮询</td><td>支持平均分片、广播任务，保证任务均衡分布</td></tr><tr><td><strong>执行器 (Executor)</strong></td><td>任务实际执行</td><td>Executor 注册到 Admin，通过 RPC/HTTP 接收任务；线程池控制并发</td><td>可横向扩展；支持失败重试；执行日志回写 Admin</td></tr><tr><td><strong>任务执行与回写</strong></td><td>记录执行结果</td><td>执行完成后上报结果到调度中心 DB (<code>xxl_job_log</code>)</td><td>记录成功/失败/异常信息；触发失败重试或告警</td></tr><tr><td><strong>调度特点</strong></td><td>分布式安全和可扩展性</td><td>DB 行锁 + 分片算法 + RPC 调度</td><td>保证任务不重复执行，支持伸缩和广播任务</td></tr></tbody></table><ul><li>Admin 负责扫描和分片，Executor 执行任务并回写结果，整个系统依赖 DB + RPC + 分片算法保证分布式安全与伸缩性。</li></ul><h3 id="_5-其他xxl-job的问题" tabindex="-1"><a class="header-anchor" href="#_5-其他xxl-job的问题"><span>5. 其他xxl-job的问题</span></a></h3><h4 id="架构设计类" tabindex="-1"><a class="header-anchor" href="#架构设计类"><span><strong>架构设计类：</strong></span></a></h4><ol><li><strong>调度中心如何保证高可用？</strong> 集群部署、数据库主从、故障转移机制</li><li><strong>执行器如何动态注册和发现？</strong> 心跳机制、注册表管理、负载均衡策略</li><li><strong>任务分片如何实现？</strong> 分片算法、数据一致性、失败重试机制</li></ol><h4 id="核心机制类" tabindex="-1"><a class="header-anchor" href="#核心机制类"><span><strong>核心机制类：</strong></span></a></h4><ol start="4"><li><strong>任务调度的时间轮算法如何实现？</strong> 时间精度、性能优化、内存占用</li><li><strong>任务执行状态如何同步？</strong> 异步回调、状态机设计、异常处理</li><li><strong>如何防止任务重复执行？</strong> 幂等性设计、分布式锁、任务ID生成</li></ol><h4 id="性能优化类" tabindex="-1"><a class="header-anchor" href="#性能优化类"><span><strong>性能优化类：</strong></span></a></h4><ol start="7"><li><strong>大量任务并发时如何优化？</strong> 线程池配置、队列策略、资源隔离</li><li><strong>任务执行超时如何处理？</strong> 超时控制、任务取消、资源清理</li><li><strong>如何优化数据库查询性能？</strong> 索引设计、分页查询、缓存策略</li></ol><h4 id="故障处理类" tabindex="-1"><a class="header-anchor" href="#故障处理类"><span><strong>故障处理类：</strong></span></a></h4><ol start="10"><li><strong>执行器宕机后任务如何恢复？</strong> 故障检测、任务重分配、数据一致性</li><li><strong>网络抖动导致的心跳异常如何处理？</strong> 重试机制、阈值设置、状态判断</li><li><strong>任务执行失败的重试策略？</strong> 重试次数、间隔时间、退避算法</li></ol><h4 id="扩展性类" tabindex="-1"><a class="header-anchor" href="#扩展性类"><span><strong>扩展性类：</strong></span></a></h4><ol start="13"><li><strong>如何支持多种任务类型？</strong> 插件化设计、任务适配器、扩展接口</li><li><strong>如何实现任务优先级？</strong> 优先级队列、抢占机制、资源分配</li><li><strong>如何支持动态任务配置？</strong> 热更新、配置中心、版本管理</li></ol><h4 id="监控运维类" tabindex="-1"><a class="header-anchor" href="#监控运维类"><span><strong>监控运维类：</strong></span></a></h4><ol start="16"><li><strong>任务执行监控指标有哪些？</strong> 成功率、耗时分布、资源使用率</li><li><strong>如何实现任务告警？</strong> 告警规则、通知渠道、告警抑制</li><li><strong>任务日志如何存储和查询？</strong> 日志格式、存储策略、查询优化</li></ol><h3 id="_6-netty的优点" tabindex="-1"><a class="header-anchor" href="#_6-netty的优点"><span>6. Netty的优点？</span></a></h3><table><thead><tr><th>优点分类</th><th>具体内容</th><th>说明</th></tr></thead><tbody><tr><td><strong>高性能</strong></td><td>基于 NIO / 异步非阻塞 IO</td><td>单线程多路复用，支持高并发，吞吐量高，延迟低</td></tr><tr><td></td><td>支持零拷贝（Zero-Copy）</td><td>减少用户态 ↔ 内核态的数据拷贝，提高 I/O 性能</td></tr><tr><td><strong>线程模型灵活</strong></td><td>支持单线程 / 多线程 Reactor / 自定义 EventLoopGroup</td><td>根据业务场景调优线程池，提高资源利用率</td></tr><tr><td><strong>可扩展性强</strong></td><td>Pipeline + Handler 模型</td><td>业务逻辑可解耦，便于协议栈定制</td></tr><tr><td><strong>多协议支持</strong></td><td>TCP、UDP、HTTP、WebSocket、SSL/TLS</td><td>还可实现自定义二进制协议</td></tr><tr><td><strong>可靠性高</strong></td><td>内置重连、心跳、异常处理</td><td>避免直接操作 NIO 的复杂性</td></tr><tr><td><strong>成熟生态</strong></td><td>社区活跃，案例丰富</td><td>广泛应用于 RPC 框架（Dubbo、gRPC-Java）、消息中间件（Kafka）等</td></tr></tbody></table><h3 id="_7-raft算法是什么" tabindex="-1"><a class="header-anchor" href="#_7-raft算法是什么"><span>7. Raft算法是什么？</span></a></h3>',1009)]))}]]),s=JSON.parse('{"path":"/zh/posts/review/%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9.html","title":"面试要点","lang":"zh-CN","frontmatter":{"icon":"pen-to-square","date":"2025-07-27T00:00:00.000Z","category":["Learning Records"],"tag":["Review"],"description":"面试要点 Java基础 1. equals() 和 == 的区别？如何正确重写 equals() 和 hashCode() 方法？为什么需要同时重写？ == 和 equals() 的区别 == 操作符：对于基本数据类型比较值，对于引用类型比较内存地址 equals() 方法：Object类默认实现是比较引用，String等类重写后比较内容 正确重写的五...","head":[["meta",{"property":"og:url","content":"https://crc011220.github.io/zh/posts/review/%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9.html"}],["meta",{"property":"og:site_name","content":"Ruochen Chen"}],["meta",{"property":"og:title","content":"面试要点"}],["meta",{"property":"og:description","content":"面试要点 Java基础 1. equals() 和 == 的区别？如何正确重写 equals() 和 hashCode() 方法？为什么需要同时重写？ == 和 equals() 的区别 == 操作符：对于基本数据类型比较值，对于引用类型比较内存地址 equals() 方法：Object类默认实现是比较引用，String等类重写后比较内容 正确重写的五..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-09-12T05:47:49.000Z"}],["meta",{"property":"article:tag","content":"Review"}],["meta",{"property":"article:published_time","content":"2025-07-27T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-09-12T05:47:49.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"面试要点\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-07-27T00:00:00.000Z\\",\\"dateModified\\":\\"2025-09-12T05:47:49.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Ruochen Chen\\"}]}"]]},"headers":[{"level":2,"title":"Java基础","slug":"java基础","link":"#java基础","children":[{"level":3,"title":"1. equals() 和 == 的区别？如何正确重写 equals() 和 hashCode() 方法？为什么需要同时重写？","slug":"_1-equals-和-的区别-如何正确重写-equals-和-hashcode-方法-为什么需要同时重写","link":"#_1-equals-和-的区别-如何正确重写-equals-和-hashcode-方法-为什么需要同时重写","children":[]},{"level":3,"title":"2. 接口和抽象类的区别？何时用接口？何时用抽象类？","slug":"_2-接口和抽象类的区别-何时用接口-何时用抽象类","link":"#_2-接口和抽象类的区别-何时用接口-何时用抽象类","children":[]},{"level":3,"title":"3. String vs StringBuffer vs StringBuilder？","slug":"_3-string-vs-stringbuffer-vs-stringbuilder","link":"#_3-string-vs-stringbuffer-vs-stringbuilder","children":[]},{"level":3,"title":"4. 自动装箱与拆箱原理及潜在问题","slug":"_4-自动装箱与拆箱原理及潜在问题","link":"#_4-自动装箱与拆箱原理及潜在问题","children":[]},{"level":3,"title":"5. BIO、NIO、AIO的区别？","slug":"_5-bio、nio、aio的区别","link":"#_5-bio、nio、aio的区别","children":[]},{"level":3,"title":"6. Select、Poll、Epoll的区别？","slug":"_6-select、poll、epoll的区别","link":"#_6-select、poll、epoll的区别","children":[]},{"level":3,"title":"7. Stream流的特性？","slug":"_7-stream流的特性","link":"#_7-stream流的特性","children":[]},{"level":3,"title":"8. Java异常？","slug":"_8-java异常","link":"#_8-java异常","children":[]},{"level":3,"title":"9. 阻塞队列？","slug":"_9-阻塞队列","link":"#_9-阻塞队列","children":[]},{"level":3,"title":"10. 泛型和类型擦除？","slug":"_10-泛型和类型擦除","link":"#_10-泛型和类型擦除","children":[]}]},{"level":2,"title":"集合","slug":"集合","link":"#集合","children":[{"level":3,"title":"1. HashMap 的实现原理？JDK 1.7和1.8的区别？hash()方法的作用？如何处理哈希冲突？","slug":"_1-hashmap-的实现原理-jdk-1-7和1-8的区别-hash-方法的作用-如何处理哈希冲突","link":"#_1-hashmap-的实现原理-jdk-1-7和1-8的区别-hash-方法的作用-如何处理哈希冲突","children":[]},{"level":3,"title":"2. ConcurrentHashMap 如何实现线程安全？","slug":"_2-concurrenthashmap-如何实现线程安全","link":"#_2-concurrenthashmap-如何实现线程安全","children":[]},{"level":3,"title":"3. ArrayList 和 LinkedList 的底层实现、时间复杂度？","slug":"_3-arraylist-和-linkedlist-的底层实现、时间复杂度","link":"#_3-arraylist-和-linkedlist-的底层实现、时间复杂度","children":[]},{"level":3,"title":"4. Iterator 和 ListIterator 的区别？fail-fast 和 fail-safe 机制？","slug":"_4-iterator-和-listiterator-的区别-fail-fast-和-fail-safe-机制","link":"#_4-iterator-和-listiterator-的区别-fail-fast-和-fail-safe-机制","children":[]},{"level":3,"title":"5. 如何保证集合的线程安全？","slug":"_5-如何保证集合的线程安全","link":"#_5-如何保证集合的线程安全","children":[]},{"level":3,"title":"6. Comparable 和 Comparator 接口的区别？","slug":"_6-comparable-和-comparator-接口的区别","link":"#_6-comparable-和-comparator-接口的区别","children":[]}]},{"level":2,"title":"多线程","slug":"多线程","link":"#多线程","children":[{"level":3,"title":"1. 进程和线程的区别？创建线程的几种方式？哪种更推荐？","slug":"_1-进程和线程的区别-创建线程的几种方式-哪种更推荐","link":"#_1-进程和线程的区别-创建线程的几种方式-哪种更推荐","children":[]},{"level":3,"title":"2. sleep(), wait(), yield(), join() 方法的区别？","slug":"_2-sleep-wait-yield-join-方法的区别","link":"#_2-sleep-wait-yield-join-方法的区别","children":[]},{"level":3,"title":"3. 上下文切换是什么？开销在哪里？","slug":"_3-上下文切换是什么-开销在哪里","link":"#_3-上下文切换是什么-开销在哪里","children":[]},{"level":3,"title":"4. 什么是线程安全？如何理解原子性、可见性、有序性？","slug":"_4-什么是线程安全-如何理解原子性、可见性、有序性","link":"#_4-什么是线程安全-如何理解原子性、可见性、有序性","children":[]},{"level":3,"title":"5. synchronized 关键字的原理？使用方式？锁升级过程？","slug":"_5-synchronized-关键字的原理-使用方式-锁升级过程","link":"#_5-synchronized-关键字的原理-使用方式-锁升级过程","children":[]},{"level":3,"title":"6. volatile 关键字的语义？原理？能保证原子性吗？适用场景？","slug":"_6-volatile-关键字的语义-原理-能保证原子性吗-适用场景","link":"#_6-volatile-关键字的语义-原理-能保证原子性吗-适用场景","children":[]},{"level":3,"title":"7. synchronized 和 volatile 的区别？","slug":"_7-synchronized-和-volatile-的区别","link":"#_7-synchronized-和-volatile-的区别","children":[]},{"level":3,"title":"8. CAS 操作的原理？Atomic类实现？ABA问题及解决方案？","slug":"_8-cas-操作的原理-atomic类实现-aba问题及解决方案","link":"#_8-cas-操作的原理-atomic类实现-aba问题及解决方案","children":[]},{"level":3,"title":"9. ThreadLocal 的原理？使用场景？内存泄漏问题及如何避免？","slug":"_9-threadlocal-的原理-使用场景-内存泄漏问题及如何避免","link":"#_9-threadlocal-的原理-使用场景-内存泄漏问题及如何避免","children":[]},{"level":3,"title":"10. AQS底层和他的一些实现？","slug":"_10-aqs底层和他的一些实现","link":"#_10-aqs底层和他的一些实现","children":[]},{"level":3,"title":"11. 线程同步的一些手段？使用时机？","slug":"_11-线程同步的一些手段-使用时机","link":"#_11-线程同步的一些手段-使用时机","children":[]}]},{"level":2,"title":"数据库","slug":"数据库","link":"#数据库","children":[{"level":3,"title":"1. SQL基础语法（DDL, DML, DQL, DCL）？常用函数？","slug":"_1-sql基础语法-ddl-dml-dql-dcl-常用函数","link":"#_1-sql基础语法-ddl-dml-dql-dcl-常用函数","children":[]},{"level":3,"title":"2. MySQL核心区别（事务、锁、外键、索引结构）？","slug":"_2-mysql核心区别-事务、锁、外键、索引结构","link":"#_2-mysql核心区别-事务、锁、外键、索引结构","children":[]},{"level":3,"title":"3. 索引：什么是索引？为什么能提高查询效率？索引的优缺点？","slug":"_3-索引-什么是索引-为什么能提高查询效率-索引的优缺点","link":"#_3-索引-什么是索引-为什么能提高查询效率-索引的优缺点","children":[]},{"level":3,"title":"4. B+树索引结构？为什么MySQL使用B+树而不是B树或哈希表？","slug":"_4-b-树索引结构-为什么mysql使用b-树而不是b树或哈希表","link":"#_4-b-树索引结构-为什么mysql使用b-树而不是b树或哈希表","children":[]},{"level":3,"title":"5. 聚集索引和非聚集索引的区别？InnoDB的主键索引结构？","slug":"_5-聚集索引和非聚集索引的区别-innodb的主键索引结构","link":"#_5-聚集索引和非聚集索引的区别-innodb的主键索引结构","children":[]},{"level":3,"title":"6. 索引类型分类？","slug":"_6-索引类型分类","link":"#_6-索引类型分类","children":[]},{"level":3,"title":"7. 索引失效的常见场景？","slug":"_7-索引失效的常见场景","link":"#_7-索引失效的常见场景","children":[]},{"level":3,"title":"8. EXPLAIN命令的作用？关键字段的含义？","slug":"_8-explain命令的作用-关键字段的含义","link":"#_8-explain命令的作用-关键字段的含义","children":[]},{"level":3,"title":"9. 锁：InnoDB的行锁、间隙锁、临键锁？MVCC的原理？如何解决幻读？","slug":"_9-锁-innodb的行锁、间隙锁、临键锁-mvcc的原理-如何解决幻读","link":"#_9-锁-innodb的行锁、间隙锁、临键锁-mvcc的原理-如何解决幻读","children":[]},{"level":3,"title":"10. 事务隔离级别？MySQL默认级别？不同级别解决的问题？","slug":"_10-事务隔离级别-mysql默认级别-不同级别解决的问题","link":"#_10-事务隔离级别-mysql默认级别-不同级别解决的问题","children":[]},{"level":3,"title":"11. 如何优化慢查询？","slug":"_11-如何优化慢查询","link":"#_11-如何优化慢查询","children":[]},{"level":3,"title":"12. MySQL日志：redo log、undo log、binlog","slug":"_12-mysql日志-redo-log、undo-log、binlog","link":"#_12-mysql日志-redo-log、undo-log、binlog","children":[]}]},{"level":2,"title":"Redis","slug":"redis","link":"#redis","children":[{"level":3,"title":"1. Redis是什么？常用数据类型及其底层实现和典型应用场景？","slug":"_1-redis是什么-常用数据类型及其底层实现和典型应用场景","link":"#_1-redis是什么-常用数据类型及其底层实现和典型应用场景","children":[]},{"level":3,"title":"2. Redis为什么快？","slug":"_2-redis为什么快","link":"#_2-redis为什么快","children":[]},{"level":3,"title":"3. Redis的持久化机制？优缺点？如何选择？","slug":"_3-redis的持久化机制-优缺点-如何选择","link":"#_3-redis的持久化机制-优缺点-如何选择","children":[]},{"level":3,"title":"4. Redis的过期键删除策略？","slug":"_4-redis的过期键删除策略","link":"#_4-redis的过期键删除策略","children":[]},{"level":3,"title":"5. 内存淘汰策略？","slug":"_5-内存淘汰策略","link":"#_5-内存淘汰策略","children":[]},{"level":3,"title":"6. 如何保证Redis的高可用？Redis Cluster的槽分配原理？","slug":"_6-如何保证redis的高可用-redis-cluster的槽分配原理","link":"#_6-如何保证redis的高可用-redis-cluster的槽分配原理","children":[]},{"level":3,"title":"7. 缓存穿透、缓存击穿、缓存雪崩的概念、原因及解决方案？","slug":"_7-缓存穿透、缓存击穿、缓存雪崩的概念、原因及解决方案","link":"#_7-缓存穿透、缓存击穿、缓存雪崩的概念、原因及解决方案","children":[]},{"level":3,"title":"8. 如何设计一个分布式锁？Watch Dog机制？","slug":"_8-如何设计一个分布式锁-watch-dog机制","link":"#_8-如何设计一个分布式锁-watch-dog机制","children":[]},{"level":3,"title":"9. Redis哨兵的原理？如何实现故障转移？","slug":"_9-redis哨兵的原理-如何实现故障转移","link":"#_9-redis哨兵的原理-如何实现故障转移","children":[]},{"level":3,"title":"10. 缓存和数据库的一致性？","slug":"_10-缓存和数据库的一致性","link":"#_10-缓存和数据库的一致性","children":[]},{"level":3,"title":"11. Zset排行榜？大Key问题如何解决？","slug":"_11-zset排行榜-大key问题如何解决","link":"#_11-zset排行榜-大key问题如何解决","children":[]}]},{"level":2,"title":"JVM","slug":"jvm","link":"#jvm","children":[{"level":3,"title":"1. JVM内存结构？各个区域的作用？","slug":"_1-jvm内存结构-各个区域的作用","link":"#_1-jvm内存结构-各个区域的作用","children":[]},{"level":3,"title":"2. 垃圾回收算法？各自的优缺点？","slug":"_2-垃圾回收算法-各自的优缺点","link":"#_2-垃圾回收算法-各自的优缺点","children":[]},{"level":3,"title":"3. 常见垃圾回收器？特点和使用场景？","slug":"_3-常见垃圾回收器-特点和使用场景","link":"#_3-常见垃圾回收器-特点和使用场景","children":[]},{"level":3,"title":"4. 类加载机制？双亲委派模型？","slug":"_4-类加载机制-双亲委派模型","link":"#_4-类加载机制-双亲委派模型","children":[]},{"level":3,"title":"5. JVM参数调优？常用参数？","slug":"_5-jvm参数调优-常用参数","link":"#_5-jvm参数调优-常用参数","children":[]},{"level":3,"title":"6. 内存泄漏vs内存溢出？如何排查？","slug":"_6-内存泄漏vs内存溢出-如何排查","link":"#_6-内存泄漏vs内存溢出-如何排查","children":[]},{"level":3,"title":"7. 强、软、弱、虚引用？","slug":"_7-强、软、弱、虚引用","link":"#_7-强、软、弱、虚引用","children":[]}]},{"level":2,"title":"分布式","slug":"分布式","link":"#分布式","children":[{"level":3,"title":"1. CAP理论？BASE理论？","slug":"_1-cap理论-base理论","link":"#_1-cap理论-base理论","children":[]},{"level":3,"title":"2. 分布式事务的解决方案？","slug":"_2-分布式事务的解决方案","link":"#_2-分布式事务的解决方案","children":[]},{"level":3,"title":"3. 分布式锁的实现？","slug":"_3-分布式锁的实现","link":"#_3-分布式锁的实现","children":[]},{"level":3,"title":"4. 分布式ID生成方案？","slug":"_4-分布式id生成方案","link":"#_4-分布式id生成方案","children":[]},{"level":3,"title":"5. 负载均衡算法？","slug":"_5-负载均衡算法","link":"#_5-负载均衡算法","children":[]},{"level":3,"title":"6. Seata 分布式事务？","slug":"_6-seata-分布式事务","link":"#_6-seata-分布式事务","children":[]},{"level":3,"title":"7. 分布式事务接口幂等？","slug":"_7-分布式事务接口幂等","link":"#_7-分布式事务接口幂等","children":[]}]},{"level":2,"title":"微服务","slug":"微服务","link":"#微服务","children":[{"level":3,"title":"1. 微服务的优势和挑战？","slug":"_1-微服务的优势和挑战","link":"#_1-微服务的优势和挑战","children":[]},{"level":3,"title":"2. 服务注册与发现：原理？常用组件？比较？","slug":"_2-服务注册与发现-原理-常用组件-比较","link":"#_2-服务注册与发现-原理-常用组件-比较","children":[]},{"level":3,"title":"3. 服务调用：RESTful API 和 RPC (Dubbo, gRPC)？比较？","slug":"_3-服务调用-restful-api-和-rpc-dubbo-grpc-比较","link":"#_3-服务调用-restful-api-和-rpc-dubbo-grpc-比较","children":[]},{"level":3,"title":"4. 服务网关 (API Gateway)：作用？常用组件？","slug":"_4-服务网关-api-gateway-作用-常用组件","link":"#_4-服务网关-api-gateway-作用-常用组件","children":[]},{"level":3,"title":"5. 配置中心：作用？常用组件？","slug":"_5-配置中心-作用-常用组件","link":"#_5-配置中心-作用-常用组件","children":[]},{"level":3,"title":"6. 服务容错：熔断、降级、限流 (令牌桶、漏桶)，Sentinel和Hystrix？","slug":"_6-服务容错-熔断、降级、限流-令牌桶、漏桶-sentinel和hystrix","link":"#_6-服务容错-熔断、降级、限流-令牌桶、漏桶-sentinel和hystrix","children":[]},{"level":3,"title":"7. 链路追踪：目的？原理？常用组件 (Zipkin, SkyWalking)？","slug":"_7-链路追踪-目的-原理-常用组件-zipkin-skywalking","link":"#_7-链路追踪-目的-原理-常用组件-zipkin-skywalking","children":[]},{"level":3,"title":"8. 微服务中的常见架构和组件有哪些？","slug":"_8-微服务中的常见架构和组件有哪些","link":"#_8-微服务中的常见架构和组件有哪些","children":[]},{"level":3,"title":"9. 负载均衡的机制","slug":"_9-负载均衡的机制","link":"#_9-负载均衡的机制","children":[]}]},{"level":2,"title":"消息队列","slug":"消息队列","link":"#消息队列","children":[{"level":3,"title":"1. 消息队列的作用？（解耦、异步、削峰填谷）","slug":"_1-消息队列的作用-解耦、异步、削峰填谷","link":"#_1-消息队列的作用-解耦、异步、削峰填谷","children":[]},{"level":3,"title":"2. 消息模型？（点对点Queue和发布/订阅Topic）","slug":"_2-消息模型-点对点queue和发布-订阅topic","link":"#_2-消息模型-点对点queue和发布-订阅topic","children":[]},{"level":3,"title":"3. 如何保证消息不丢失？","slug":"_3-如何保证消息不丢失","link":"#_3-如何保证消息不丢失","children":[]},{"level":3,"title":"4. 如何保证消息不被重复消费（幂等性）？","slug":"_4-如何保证消息不被重复消费-幂等性","link":"#_4-如何保证消息不被重复消费-幂等性","children":[]},{"level":3,"title":"5. 如何保证消息的顺序性？","slug":"_5-如何保证消息的顺序性","link":"#_5-如何保证消息的顺序性","children":[]},{"level":3,"title":"6. 常用消息队列比较？（Kafka、RabbitMQ、RocketMQ）队列的类型？","slug":"_6-常用消息队列比较-kafka、rabbitmq、rocketmq-队列的类型","link":"#_6-常用消息队列比较-kafka、rabbitmq、rocketmq-队列的类型","children":[]},{"level":3,"title":"7. RabbitMQ的高可用？仲裁队列？死信队列？","slug":"_7-rabbitmq的高可用-仲裁队列-死信队列","link":"#_7-rabbitmq的高可用-仲裁队列-死信队列","children":[]},{"level":3,"title":"8. Kafka的高可用和高性能？","slug":"_8-kafka的高可用和高性能","link":"#_8-kafka的高可用和高性能","children":[]},{"level":3,"title":"9. 单条消息阻塞了，如何处理？","slug":"_9-单条消息阻塞了-如何处理","link":"#_9-单条消息阻塞了-如何处理","children":[]}]},{"level":2,"title":"主流框架、系统设计、编码能力","slug":"主流框架、系统设计、编码能力","link":"#主流框架、系统设计、编码能力","children":[{"level":3,"title":"1. Spring方向 - (IoC - 控制反转 / DI - 依赖注入, AOP - 面向切面编程)","slug":"_1-spring方向-ioc-控制反转-di-依赖注入-aop-面向切面编程","link":"#_1-spring方向-ioc-控制反转-di-依赖注入-aop-面向切面编程","children":[]},{"level":3,"title":"2. AOP (面向切面编程)","slug":"_2-aop-面向切面编程","link":"#_2-aop-面向切面编程","children":[]},{"level":3,"title":"3. Spring事务管理","slug":"_3-spring事务管理","link":"#_3-spring事务管理","children":[]},{"level":3,"title":"4. Spring MVC的工作原理？核心组件？处理请求的流程？","slug":"_4-spring-mvc的工作原理-核心组件-处理请求的流程","link":"#_4-spring-mvc的工作原理-核心组件-处理请求的流程","children":[]},{"level":3,"title":"5. Spring如何解决循环依赖？","slug":"_5-spring如何解决循环依赖","link":"#_5-spring如何解决循环依赖","children":[]},{"level":3,"title":"6.1 一级缓存和二级缓存的区别？","slug":"_6-1-一级缓存和二级缓存的区别","link":"#_6-1-一级缓存和二级缓存的区别","children":[]},{"level":3,"title":"6.2 ResultMap 和 ResultType 的区别？","slug":"_6-2-resultmap-和-resulttype-的区别","link":"#_6-2-resultmap-和-resulttype-的区别","children":[]},{"level":3,"title":"6.3 延迟加载（懒加载）的原理和配置？","slug":"_6-3-延迟加载-懒加载-的原理和配置","link":"#_6-3-延迟加载-懒加载-的原理和配置","children":[]},{"level":3,"title":"6.4 如何实现分页？","slug":"_6-4-如何实现分页","link":"#_6-4-如何实现分页","children":[]},{"level":3,"title":"7. 设计一个秒杀系统","slug":"_7-设计一个秒杀系统","link":"#_7-设计一个秒杀系统","children":[]},{"level":3,"title":"8. 设计一个短链接系统","slug":"_8-设计一个短链接系统","link":"#_8-设计一个短链接系统","children":[]},{"level":3,"title":"9. 设计一个RPC框架","slug":"_9-设计一个rpc框架","link":"#_9-设计一个rpc框架","children":[]},{"level":3,"title":"10. 扫码登录如何实现？","slug":"_10-扫码登录如何实现","link":"#_10-扫码登录如何实现","children":[]},{"level":3,"title":"10. 设计一个内存池？","slug":"_10-设计一个内存池","link":"#_10-设计一个内存池","children":[]},{"level":3,"title":"11. 设计一个消息队列？","slug":"_11-设计一个消息队列","link":"#_11-设计一个消息队列","children":[]}]},{"level":2,"title":"计算机网络","slug":"计算机网络","link":"#计算机网络","children":[{"level":3,"title":"1. TCP和UDP的区别？TCP基于流和UDP基于数据包的区别？","slug":"_1-tcp和udp的区别-tcp基于流和udp基于数据包的区别","link":"#_1-tcp和udp的区别-tcp基于流和udp基于数据包的区别","children":[]},{"level":3,"title":"2. OSI七层模型和TCP/IP四层模型？","slug":"_2-osi七层模型和tcp-ip四层模型","link":"#_2-osi七层模型和tcp-ip四层模型","children":[]},{"level":3,"title":"3. HTTP和HTTPS的区别？","slug":"_3-http和https的区别","link":"#_3-http和https的区别","children":[]},{"level":3,"title":"4. TCP三次握手和四次挥手？","slug":"_4-tcp三次握手和四次挥手","link":"#_4-tcp三次握手和四次挥手","children":[]},{"level":3,"title":"5. 从输入URL到页面显示的完整过程？","slug":"_5-从输入url到页面显示的完整过程","link":"#_5-从输入url到页面显示的完整过程","children":[]},{"level":3,"title":"6. TCP粘包和拆包问题？","slug":"_6-tcp粘包和拆包问题","link":"#_6-tcp粘包和拆包问题","children":[]},{"level":3,"title":"7. DNS解析过程？","slug":"_7-dns解析过程","link":"#_7-dns解析过程","children":[]},{"level":3,"title":"8. Cookie、Session、LocalStorage、JWT对比","slug":"_8-cookie、session、localstorage、jwt对比","link":"#_8-cookie、session、localstorage、jwt对比","children":[]},{"level":3,"title":"9. WebSocket原理和应用？","slug":"_9-websocket原理和应用","link":"#_9-websocket原理和应用","children":[]},{"level":3,"title":"10. TCP如何保证可靠传输？","slug":"_10-tcp如何保证可靠传输","link":"#_10-tcp如何保证可靠传输","children":[]}]},{"level":2,"title":"操作系统","slug":"操作系统","link":"#操作系统","children":[{"level":3,"title":"1. 虚拟内存管理？","slug":"_1-虚拟内存管理","link":"#_1-虚拟内存管理","children":[]},{"level":3,"title":"2. 页面置换算法？","slug":"_2-页面置换算法","link":"#_2-页面置换算法","children":[]},{"level":3,"title":"3. 死锁问题？","slug":"_3-死锁问题","link":"#_3-死锁问题","children":[]},{"level":3,"title":"4. CPU调度算法？","slug":"_4-cpu调度算法","link":"#_4-cpu调度算法","children":[]},{"level":3,"title":"5. 同步与异步、阻塞与非阻塞？","slug":"_5-同步与异步、阻塞与非阻塞","link":"#_5-同步与异步、阻塞与非阻塞","children":[]},{"level":3,"title":"6. 内存分配算法？","slug":"_6-内存分配算法","link":"#_6-内存分配算法","children":[]},{"level":3,"title":"7. 文件系统？","slug":"_7-文件系统","link":"#_7-文件系统","children":[]},{"level":3,"title":"8. epoll 的原理及其 O(1) 查询速度？有哪两种工作模式？","slug":"_8-epoll-的原理及其-o-1-查询速度-有哪两种工作模式","link":"#_8-epoll-的原理及其-o-1-查询速度-有哪两种工作模式","children":[]},{"level":3,"title":"9. Linux常用命令？ 查看进程有哪些命令？","slug":"_9-linux常用命令-查看进程有哪些命令","link":"#_9-linux常用命令-查看进程有哪些命令","children":[]},{"level":3,"title":"10. 进程的状态和通信方法？","slug":"_10-进程的状态和通信方法","link":"#_10-进程的状态和通信方法","children":[]}]},{"level":2,"title":"设计模式","slug":"设计模式","link":"#设计模式","children":[{"level":3,"title":"1. Spring中用到了哪些设计模式？","slug":"_1-spring中用到了哪些设计模式","link":"#_1-spring中用到了哪些设计模式","children":[]},{"level":3,"title":"2. 工厂模式？","slug":"_2-工厂模式","link":"#_2-工厂模式","children":[]},{"level":3,"title":"3. 设计模式分类？","slug":"_3-设计模式分类","link":"#_3-设计模式分类","children":[]}]},{"level":2,"title":"云计算","slug":"云计算","link":"#云计算","children":[{"level":3,"title":"1. 云和云原生的区别？","slug":"_1-云和云原生的区别","link":"#_1-云和云原生的区别","children":[]},{"level":3,"title":"2. 虚拟机和容器的区别？","slug":"_2-虚拟机和容器的区别","link":"#_2-虚拟机和容器的区别","children":[]},{"level":3,"title":"3. K8S的常见组件？","slug":"_3-k8s的常见组件","link":"#_3-k8s的常见组件","children":[]}]},{"level":2,"title":"ElasticSearch","slug":"elasticsearch","link":"#elasticsearch","children":[{"level":3,"title":"1. 对ES的理解？","slug":"_1-对es的理解","link":"#_1-对es的理解","children":[]},{"level":3,"title":"2. ES的核心概念","slug":"_2-es的核心概念","link":"#_2-es的核心概念","children":[]},{"level":3,"title":"3. 倒排索引原理","slug":"_3-倒排索引原理","link":"#_3-倒排索引原理","children":[]},{"level":3,"title":"4. 写入流程","slug":"_4-写入流程","link":"#_4-写入流程","children":[]},{"level":3,"title":"5. 近实时搜索","slug":"_5-近实时搜索","link":"#_5-近实时搜索","children":[]},{"level":3,"title":"6. 节点角色","slug":"_6-节点角色","link":"#_6-节点角色","children":[]},{"level":3,"title":"7. 性能优化","slug":"_7-性能优化","link":"#_7-性能优化","children":[]},{"level":3,"title":"8. 高可用","slug":"_8-高可用","link":"#_8-高可用","children":[]},{"level":3,"title":"9. 数据一致性","slug":"_9-数据一致性","link":"#_9-数据一致性","children":[]}]},{"level":2,"title":"其他","slug":"其他","link":"#其他","children":[{"level":3,"title":"1. 介绍一下Disruptor？为什么适合撮合引擎？","slug":"_1-介绍一下disruptor-为什么适合撮合引擎","link":"#_1-介绍一下disruptor-为什么适合撮合引擎","children":[]},{"level":3,"title":"2. xxl-job路由策略有哪些？xxl-job任务执行失败怎么解决？如果有大数据量的任务同时都需要执行，怎么解决？","slug":"_2-xxl-job路由策略有哪些-xxl-job任务执行失败怎么解决-如果有大数据量的任务同时都需要执行-怎么解决","link":"#_2-xxl-job路由策略有哪些-xxl-job任务执行失败怎么解决-如果有大数据量的任务同时都需要执行-怎么解决","children":[]},{"level":3,"title":"3. 对xxl-job什么了解？如果你来实现一个分布式任务调度系统，你会怎么设计？","slug":"_3-对xxl-job什么了解-如果你来实现一个分布式任务调度系统-你会怎么设计","link":"#_3-对xxl-job什么了解-如果你来实现一个分布式任务调度系统-你会怎么设计","children":[]},{"level":3,"title":"4. xxl-job底层如何调度","slug":"_4-xxl-job底层如何调度","link":"#_4-xxl-job底层如何调度","children":[]},{"level":3,"title":"5. 其他xxl-job的问题","slug":"_5-其他xxl-job的问题","link":"#_5-其他xxl-job的问题","children":[]},{"level":3,"title":"6. Netty的优点？","slug":"_6-netty的优点","link":"#_6-netty的优点","children":[]},{"level":3,"title":"7. Raft算法是什么？","slug":"_7-raft算法是什么","link":"#_7-raft算法是什么","children":[]}]}],"git":{"createdTime":1753614346000,"updatedTime":1757656069000,"contributors":[{"name":"Ruochen Chen","email":"ruocchen1220@gmail.com","commits":40}]},"readingTime":{"minutes":170.65,"words":51196},"filePathRelative":"zh/posts/review/面试要点.md","localizedDate":"2025年7月27日","excerpt":"\\n<h2>Java基础</h2>\\n<h3>1. equals() 和 == 的区别？如何正确重写 equals() 和 hashCode() 方法？为什么需要同时重写？</h3>\\n<h4>== 和 equals() 的区别</h4>\\n<ul>\\n<li><strong>== 操作符</strong>：对于基本数据类型比较值，对于引用类型比较内存地址</li>\\n<li><strong>equals() 方法</strong>：Object类默认实现是比较引用，String等类重写后比较内容</li>\\n</ul>\\n<h4>正确重写的五个原则</h4>\\n<ol>\\n<li><strong>自反性</strong>：x.equals(x) 必须返回 true</li>\\n<li><strong>对称性</strong>：x.equals(y) 和 y.equals(x) 结果相同</li>\\n<li><strong>传递性</strong>：如果 x.equals(y) 且 y.equals(z)，则 x.equals(z)</li>\\n<li><strong>一致性</strong>：多次调用结果一致</li>\\n<li><strong>非空性</strong>：x.equals(null) 返回 false</li>\\n</ol>","autoDesc":true}')},6262:(t,d)=>{d.A=(t,d)=>{const r=t.__vccOpts||t;for(const[t,e]of d)r[t]=e;return r}}}]);