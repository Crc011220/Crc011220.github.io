"use strict";(self.webpackChunkpersonalweb=self.webpackChunkpersonalweb||[]).push([[434],{6262:(e,t)=>{t.A=(e,t)=>{const a=e.__vccOpts||e;for(const[e,i]of t)a[e]=i;return a}},8575:(e,t,a)=>{a.r(t),a.d(t,{comp:()=>f,data:()=>b});var i=a(641);const n=a.p+"assets/img/matrix-multiplication.014b9a1e.png",s=a.p+"assets/img/vector-norm.36eacd69.png",r=a.p+"assets/img/Inverse-Distance.857bdd2b.png",o=a.p+"assets/img/Marginalization.4e6857d9.png",l=a.p+"assets/img/Decision-Tree-Example.6ee2db6e.png",d=a.p+"assets/img/Entropy-Example.6d4874bc.png",c=a.p+"assets/img/Naive-Bayes-Example-1-1.2ea50406.png",h=a.p+"assets/img/Naive-Bayes-Example-1-2.b15986db.png",u=a.p+"assets/img/gradient-descent.587a0aa0.png",g=a.p+"assets/img/gd-algo.e7a8b6b4.png",p=a.p+"assets/img/margin.188baf72.png",m={},f=(0,a(6262).A)(m,[["render",function(e,t){return(0,i.uX)(),(0,i.CE)("div",null,t[0]||(t[0]=[(0,i.Fv)('<h1 id="introduction-to-machine-learning-comp90049" tabindex="-1"><a class="header-anchor" href="#introduction-to-machine-learning-comp90049"><span>Introduction to Machine Learning (COMP90049)</span></a></h1><h2 id="week-1" tabindex="-1"><a class="header-anchor" href="#week-1"><span>Week 1</span></a></h2><ul><li>Machine learning is a method of teaching software to learn from data and make decisions on their own, without being explicitly programmed.</li></ul><h3 id="three-ingredients-for-machine-learning" tabindex="-1"><a class="header-anchor" href="#three-ingredients-for-machine-learning"><span>Three ingredients for machine learning</span></a></h3><ol><li><p>Data • Discrete vs continuous vs ... • Big data vs small data • Labeled data vs unlabeled data • Public vs sensitive data</p></li><li><p>Models • function mapping from inputs to outputs • probabilistic machine learning models • geometric machine learning models • parameters of the function are unknown</p></li><li><p>Learning • Improving (on a task) after data is taken into account • Finding the best model parameters (for a given task) • Supervised vs. unsupervised learning</p></li></ol><div class="hint-container info"><p class="hint-container-title">Info</p><p>Supervised Learning:监督学习使用带有标签的数据进行训练，模型学习输入（features）到输出（labels）之间的映射关系。 Unsupervised Learning:无监督学习使用没有标签的数据，模型通过分析数据的模式和结构来进行学习。</p></div><h3 id="linear-algebra-review" tabindex="-1"><a class="header-anchor" href="#linear-algebra-review"><span>Linear Algebra Review</span></a></h3><h4 id="matrices" tabindex="-1"><a class="header-anchor" href="#matrices"><span>Matrices</span></a></h4><ul><li>Matrices addition/subtraction: Add(Subtract) correspond ingentries in A and B</li><li>Matrix multiplication: Multiply corresponding entries in A and B and sum the products <img src="'+n+'" alt="Matrix Multiplication" loading="lazy"></li><li>Matrix transpose: Transpose of a matrix is obtained by interchanging its rows and columns. Matrix is <strong>symmetric</strong> if it is equal to its transpose.</li><li>Matrix inverse: The inverse of a matrix A is denoted by A^-1 and is obtained by multiplying A by its inverse.</li><li>A matrix cannot be inverted if: More rows than columns, More columns than rows,Redundant rows/columns (linear independence)</li></ul><h4 id="vectors" tabindex="-1"><a class="header-anchor" href="#vectors"><span>Vectors</span></a></h4><ul><li>A vector is a matrix with several rows and <strong>one</strong> column</li><li>Vector addition/subtraction: Add(Subtract) corresponding entries in A and B</li><li>Vector inner product: Multiply corresponding entries in A and B and sum the products</li><li>Vector Euclidean norm: The square root of the sum of the squares of the entries in the vector. <img src="'+s+'" alt="Verctor Euclidean Norm" loading="lazy"></li><li>Vector inner product: The dot product of two vectors A and B is the sum of the products of their corresponding entries.</li><li>The cosine of the angle between two vectors can be found by using norms and the inner product</li></ul><h3 id="instances-attributes-and-learning-paradigms-supervised-vs-unsupervised-learning" tabindex="-1"><a class="header-anchor" href="#instances-attributes-and-learning-paradigms-supervised-vs-unsupervised-learning"><span>Instances, Attributes, and Learning Paradigms (Supervised vs. Unsupervised Learning)</span></a></h3><ul><li>In ML terminology examples are called Instances</li><li>Each instance can have some Features or Attributes</li><li>Concepts are things that we aim to learn. Generally, in the form of labels or classes</li></ul><h4 id="unsupervised-do-not-have-access-to-an-inventory-of-classes-and-instead-discover-groups-of-similar-examples-in-a-given-dataset" tabindex="-1"><a class="header-anchor" href="#unsupervised-do-not-have-access-to-an-inventory-of-classes-and-instead-discover-groups-of-similar-examples-in-a-given-dataset"><span>Unsupervised do not have access to an inventory of classes and instead discover groups of ‘similar’ examples in a given dataset.</span></a></h4><ul><li>Clustering is unsupervised — the learner operates without a set of labelled training data</li><li><strong>Success is often measured subjectively; evaluation is problematic</strong></li></ul><h4 id="supervised-methods-have-prior-knowledge-of-classes-and-set-out-to-discover-and-categorise-new-instances-according-to-those-classes" tabindex="-1"><a class="header-anchor" href="#supervised-methods-have-prior-knowledge-of-classes-and-set-out-to-discover-and-categorise-new-instances-according-to-those-classes"><span>Supervised methods have prior knowledge of classes and set out to discover and categorise new instances according to those classes</span></a></h4><ul><li>Classification learning is supervised • In Classification, we can exhaustively list/enumerate all possible labels for a given instance; a correct prediction entails mapping an instance to the label which is truly correct</li><li>Regression learning is supervised • In Regression,&quot;infinitely&quot; many labels are possible, we cannot conceivably enumerate them; a “correct” prediction is when the numeric value is acceptably close to the true value</li></ul><h3 id="featured-data-types" tabindex="-1"><a class="header-anchor" href="#featured-data-types"><span>Featured Data Types</span></a></h3><ol><li>Discrete: Nominal (Categorical)</li></ol><ul><li>Values are distinct symbols, values themselves serve only as labels or names</li><li>No relation is implied among nominal values (no ordering or distance measure)</li><li>Only equality tests can be performed</li><li>e.g. Student Number</li></ul><ol start="2"><li>Ordinal</li></ol><ul><li>An explicit order is imposed on the values</li><li>Addition and subtraction does not make sense</li><li>e.g. Educational Level</li></ul><ol start="3"><li>Continuous: Numeric</li></ol><ul><li>Numeric quantities are real-valued attributes</li><li>All mathematical operations are allowed</li></ul><h2 id="equal-width-vs-equal-frequency-vs-clustering" tabindex="-1"><a class="header-anchor" href="#equal-width-vs-equal-frequency-vs-clustering"><span>Equal Width vs. Equal Frequency vs. Clustering</span></a></h2><table><thead><tr><th>Method</th><th>Equal Width Binning</th><th>Equal Frequency Binning</th><th>Clustering</th></tr></thead><tbody><tr><td><strong>Definition</strong></td><td>Each bin has the same width</td><td>Each bin contains the same number of data points</td><td>Groups data points based on similarity</td></tr><tr><td><strong>Type</strong></td><td>Data discretization</td><td>Data discretization</td><td>Unsupervised learning</td></tr><tr><td><strong>Advantages</strong></td><td>Easy to compute, simple</td><td>Suitable for skewed distributions</td><td>Can detect natural groupings in data</td></tr><tr><td><strong>Disadvantages</strong></td><td>Sparse or dense bins if data density varies</td><td>Uneven bin width, harder to interpret</td><td>May require tuning (e.g., number of clusters)</td></tr><tr><td><strong>Common Algorithms</strong></td><td>Fixed width intervals</td><td>Quantiles-based binning</td><td>K-Means, DBSCAN, Hierarchical Clustering</td></tr><tr><td><strong>Use Cases</strong></td><td>Histogram creation, feature engineering</td><td>Handling skewed data in ML models</td><td>Customer segmentation, anomaly detection</td></tr></tbody></table><div class="hint-container info"><p class="hint-container-title">Info</p><p>Equal Width Binning：用于简单离散化，每个 bin 宽度相同，但可能会导致数据密度不均衡。 Equal Frequency Binning：每个 bin 的数据量相等，适合处理偏态数据，但 bin 的宽度不一致，可能难以解释。 Clustering（聚类）：用于无监督学习，根据数据点的相似性自动分组，适合发现隐藏模式，但通常需要调整参数（如 k 值）。</p></div><h2 id="standardization-vs-normalization" tabindex="-1"><a class="header-anchor" href="#standardization-vs-normalization"><span>Standardization vs. Normalization</span></a></h2><table><thead><tr><th><strong>Method</strong></th><th><strong>Standardization (Z-score)</strong></th><th><strong>Min-Max Normalization</strong></th></tr></thead><tbody><tr><td><strong>Formula</strong></td><td>( X&#39; = \\frac{X - \\mu}{\\sigma} )</td><td>( X&#39; = \\frac{X - X_{\\min}}{X_{\\max} - X_{\\min}} )</td></tr><tr><td><strong>Range</strong></td><td>Mean = 0, Std = 1</td><td>[0,1] or [-1,1]</td></tr><tr><td><strong>Best for</strong></td><td>Normally distributed data</td><td>Data with fixed bounds</td></tr><tr><td><strong>Sensitive to outliers?</strong></td><td>Less sensitive</td><td>More sensitive</td></tr><tr><td><strong>Formula</strong></td><td>(X - mean) / std</td><td>(X - min) / (max - min)</td></tr></tbody></table><div class="hint-container info"><p class="hint-container-title">Info</p><p>Standardization：将数据标准化到均值为 0，标准差为 1 的分布，适用于正态分布的数据。 Normalization：将数据缩放到 [0,1] 或 [-1,1] 范围内，适用于数据范围固定的数据。</p></div><h2 id="week-2" tabindex="-1"><a class="header-anchor" href="#week-2"><span>Week 2</span></a></h2><h3 id="k-nearest-neighbors-knn" tabindex="-1"><a class="header-anchor" href="#k-nearest-neighbors-knn"><span>K-Nearest Neighbors (KNN)</span></a></h3><ul><li>supervied learning algorithm</li></ul><h4 id="knn-classification" tabindex="-1"><a class="header-anchor" href="#knn-classification"><span>KNN Classification</span></a></h4><p>• Return the most common class label among neighbors • Example: cat vs dog images; text classification; ...</p><h4 id="knn-regression" tabindex="-1"><a class="header-anchor" href="#knn-regression"><span>KNN Regression</span></a></h4><p>• Return the average value of among K nearest neighbors • Example: housing price prediction;</p><h4 id="to-measure-categorical-distance-we-can-use" tabindex="-1"><a class="header-anchor" href="#to-measure-categorical-distance-we-can-use"><span>To measure categorical distance, we can use:</span></a></h4><ul><li>Hamming distance: number of positions where the two strings differ</li><li>Jaccard Similarity: intersection over union of two sets</li></ul><h4 id="to-measure-numerical-distance-we-can-use" tabindex="-1"><a class="header-anchor" href="#to-measure-numerical-distance-we-can-use"><span>To measure numerical distance, we can use:</span></a></h4><ul><li>Manhattan distance: sum of absolute differences between corresponding components</li><li>Euclidean distance: square root of the sum of the squares of the differences between corresponding components</li><li>Cosine distance: 1 minus the cosine of the angle between two vectors</li></ul><h4 id="to-measure-oridinal-distance-we-can-use" tabindex="-1"><a class="header-anchor" href="#to-measure-oridinal-distance-we-can-use"><span>To measure oridinal distance, we can use:</span></a></h4><ul><li>Normalized Ranks: rank each value and normalize them to [0, 1]</li></ul><h4 id="majority-vote" tabindex="-1"><a class="header-anchor" href="#majority-vote"><span>Majority Vote</span></a></h4><h4 id="inverse-distance" tabindex="-1"><a class="header-anchor" href="#inverse-distance"><span>Inverse Distance</span></a></h4><ul><li>Give more weight to the nearer neighbors rather than quantity.</li><li>The bigger the weight, the more important the neighbor is. <img src="'+r+'" alt="Inverse Distance" loading="lazy"></li></ul><h4 id="inverse-linear-distance" tabindex="-1"><a class="header-anchor" href="#inverse-linear-distance"><span>Inverse Linear Distance</span></a></h4><ul><li>Give more weight to the nearer neighbors, but with a decreasing slope.</li><li>The bigger the weight, the more important the neighbor is.</li></ul><h4 id="value-of-k" tabindex="-1"><a class="header-anchor" href="#value-of-k"><span>Value of K</span></a></h4><table><thead><tr><th><strong>K Value</strong></th><th><strong>Bias</strong></th><th><strong>Variance</strong></th><th><strong>Overfitting</strong></th><th><strong>Underfitting</strong></th><th><strong>Best For</strong></th></tr></thead><tbody><tr><td><strong>Small K</strong> (e.g., K=1, K=3)</td><td><strong>Low Bias</strong>: The model can closely follow the data.</td><td><strong>High Variance</strong>: Sensitive to noise and outliers.</td><td>Likely to overfit due to high sensitivity to small fluctuations in the training data.</td><td>Unlikely to underfit unless the data is too noisy or simple.</td><td>- Complex data with clear patterns<br> - When the dataset is relatively small.</td></tr><tr><td><strong>Large K</strong> (e.g., K=10, K=20)</td><td><strong>High Bias</strong>: The model becomes less sensitive to variations in the data.</td><td><strong>Low Variance</strong>: Smoothing out the noise by considering more neighbors.</td><td>Less likely to overfit as it smooths out fluctuations.</td><td>Might underfit if the data has complex relationships or non-linear patterns.</td><td>- Noisy data<br> - When a generalization is more important than capturing every detail.</td></tr><tr><td><strong>Medium K</strong> (e.g., K=5, K=7)</td><td>A balanced approach with moderate bias.</td><td>Balanced variance, aiming for generalization.</td><td>Minimizes both overfitting and underfitting.</td><td>Good compromise between bias and variance.</td><td>- Standard choice for most datasets, balancing generalization and accuracy.</td></tr></tbody></table><h4 id="why-knn" tabindex="-1"><a class="header-anchor" href="#why-knn"><span>Why KNN</span></a></h4><ul><li>Pros • Intuitive and simple • No assumptions • Supports classification and regression • No training: new data →evolve and adapt immediately</li><li>Cons • How to decide on best distance functions? • How to combine multiple neighbors? • How to select K ? • Expensive with large (or growing) data sets</li></ul><h4 id="lazy-learning-vs-eager-learning" tabindex="-1"><a class="header-anchor" href="#lazy-learning-vs-eager-learning"><span>Lazy Learning vs. Eager Learning</span></a></h4><table><thead><tr><th>Criteria</th><th>Lazy Learning (e.g., KNN)</th><th>Eager Learning</th></tr></thead><tbody><tr><td><strong>Definition</strong></td><td>Delays learning until a query is made</td><td>Learns from the training data immediately</td></tr><tr><td><strong>Training Phase</strong></td><td>Fast (no model building)</td><td>Slow (model is built during training)</td></tr><tr><td><strong>Prediction Phase</strong></td><td>Slow (requires processing the entire dataset)</td><td>Fast (uses the pre-built model)</td></tr><tr><td><strong>Memory Requirement</strong></td><td>High (stores the entire training dataset)</td><td>Lower (only stores the model)</td></tr><tr><td><strong>Flexibility</strong></td><td>High (can adapt to new data easily)</td><td>Low (requires retraining for new data)</td></tr><tr><td><strong>Example</strong></td><td>K-Nearest Neighbors (KNN)</td><td>Decision Trees, Neural Networks</td></tr></tbody></table><h3 id="probility" tabindex="-1"><a class="header-anchor" href="#probility"><span>Probility</span></a></h3><ul><li>P(A=a): the probability that random variable A takes value a</li><li>0 &lt;= P(A=a) &lt;= 1</li><li>P(True) = 1</li><li>P(False) = 0</li></ul><h4 id="joint-probability" tabindex="-1"><a class="header-anchor" href="#joint-probability"><span>Joint Probability</span></a></h4><ul><li>P(A, B): joint probability of two events A and B</li><li>the probability of both A and B occurring = P(A ∩ B)</li></ul><h4 id="conditional-probability" tabindex="-1"><a class="header-anchor" href="#conditional-probability"><span>Conditional Probability</span></a></h4><ul><li>P(A|B): the probability of A occurring given that B has occurred</li><li>P(A|B) = P(A ∩ B) / P(B)</li></ul><h4 id="independent-probability" tabindex="-1"><a class="header-anchor" href="#independent-probability"><span>Independent Probability</span></a></h4><ul><li>Two events A and B are independent if P(A|B) = P(A)</li><li>P(A, B) = P(A) * P(B)</li></ul><div class="hint-container info"><p class="hint-container-title">Info</p><h4 id="disjoint" tabindex="-1"><a class="header-anchor" href="#disjoint"><span>Disjoint</span></a></h4><ul><li>P(A∩B)=0</li></ul><h4 id="product-rule" tabindex="-1"><a class="header-anchor" href="#product-rule"><span>Product Rule</span></a></h4><ul><li>P(A, B) = P(A|B) * P(B) = P(B|A) * P(A)</li></ul><h4 id="chain-rule" tabindex="-1"><a class="header-anchor" href="#chain-rule"><span>Chain Rule</span></a></h4><ul><li>P(A,B,C)=P(A)⋅P(B∣A)⋅P(C∣A,B)</li></ul></div><h4 id="bayes-rule" tabindex="-1"><a class="header-anchor" href="#bayes-rule"><span>Bayes&#39; Rule</span></a></h4><ul><li>P(A|B) = ( P(B|A) * P(A) ) / P(B)</li><li>Bayes’ Rule allows us to compute P(A|B) given knowledge of the ‘inverse’ probability P(B|A).</li></ul><h4 id="marginalization" tabindex="-1"><a class="header-anchor" href="#marginalization"><span>Marginalization</span></a></h4><figure><img src="'+o+'" alt="Marginalization" tabindex="0" loading="lazy"><figcaption>Marginalization</figcaption></figure><h4 id="probability-distributions" tabindex="-1"><a class="header-anchor" href="#probability-distributions"><span>Probability Distributions</span></a></h4><ul><li>Probability distributions can be discrete or continuous.</li><li>Discrete Random Variable: Takes on a countable number of distinct values (e.g., number of heads in coin flips).</li><li>Continuous Random Variable: Takes on an infinite number of possible values (e.g., height of students).</li></ul><table><thead><tr><th><strong>Distribution</strong></th><th><strong>Type</strong></th><th><strong>Range</strong></th><th><strong>Parameters</strong></th><th><strong>Formula</strong></th><th><strong>Example</strong></th><th><strong>Use Cases</strong></th></tr></thead><tbody><tr><td><strong>Normal</strong></td><td>Continuous</td><td>−∞ to +∞</td><td>Mean μ, Variance σ²</td><td><code>P(x) = (1 / √(2πσ²)) * exp(-((x - μ)² / (2σ²)))</code></td><td>Human height, exam scores</td><td>Linear regression, Gaussian models</td></tr><tr><td><strong>Bernoulli</strong></td><td>Discrete</td><td>0, 1</td><td>Probability p</td><td><code>P(X = k) = p^k (1 - p)^(1 - k)</code></td><td>Coin flip</td><td>Binary classification</td></tr><tr><td><strong>Binomial</strong></td><td>Discrete</td><td>0 to n</td><td>Number of trials n, Success probability p</td><td><code>P(k) = C(n, k) * p^k * (1 - p)^(n - k)</code></td><td>Number of heads in 10 coin flips</td><td>Binary classification, hypothesis testing</td></tr><tr><td><strong>Multinomial</strong></td><td>Discrete</td><td>0 to n for each category</td><td>Number of trials n, Probabilities p₁, ..., pₖ</td><td><code>P(x₁, ..., xₖ) = (n! / (x₁!x₂!...xₖ!)) * ∏(pᵢ^xᵢ)</code></td><td>Rolling a dice multiple times</td><td>Text classification, NLP</td></tr><tr><td><strong>Categorical</strong></td><td>Discrete</td><td>1 to k</td><td>Probabilities p₁, ..., pₖ</td><td><code>P(X = i) = pᵢ</code></td><td>Choosing a color from a set of options</td><td>Classification, clustering</td></tr></tbody></table><h2 id="week-3" tabindex="-1"><a class="header-anchor" href="#week-3"><span>Week 3</span></a></h2><h3 id="zero-r" tabindex="-1"><a class="header-anchor" href="#zero-r"><span>Zero-R</span></a></h3><ul><li>A simple baseline model that predicts the most frequent class in the training data.</li></ul><h3 id="one-r" tabindex="-1"><a class="header-anchor" href="#one-r"><span>One-R</span></a></h3><ul><li>Also known as Decision stom</li><li>Uses only one feature (“best” feature) to build a model</li></ul><h3 id="desicion-trees" tabindex="-1"><a class="header-anchor" href="#desicion-trees"><span>Desicion Trees</span></a></h3><figure><img src="'+l+'" alt="Decision Tree Example" tabindex="0" loading="lazy"><figcaption>Decision Tree Example</figcaption></figure><h3 id="id3-iterative-dichotomiser-3" tabindex="-1"><a class="header-anchor" href="#id3-iterative-dichotomiser-3"><span>ID3 (Iterative Dichotomiser 3)</span></a></h3><ul><li>A top-down approach that splits the data into smaller subsets based on the value of a chosen feature.</li></ul><h4 id="entropy-measure-of-uncertainty-the-expected-average-level-of-uncertainty-surprise" tabindex="-1"><a class="header-anchor" href="#entropy-measure-of-uncertainty-the-expected-average-level-of-uncertainty-surprise"><span>Entropy (measure of uncertainty. The expected (average) level of uncertainty (surprise))</span></a></h4><ul><li>For a Low probability event: if it happens, it’s big news! Big surprise! <strong>High information!</strong></li><li>For a High probability event: it was likely to happen anyway. Not very surprising. <strong>Low information!</strong></li><li>Higher H means more uncertain. <img src="'+d+'" alt="Entropy Example" loading="lazy"></li></ul><h4 id="conditional-entropy-measures-the-amount-of-uncertainty-in-x-given-y" tabindex="-1"><a class="header-anchor" href="#conditional-entropy-measures-the-amount-of-uncertainty-in-x-given-y"><span>Conditional Entropy measures the amount of uncertainty in X given Y.</span></a></h4><h4 id="information-gain-measure-of-the-reduction-in-entropy-after-splitting" tabindex="-1"><a class="header-anchor" href="#information-gain-measure-of-the-reduction-in-entropy-after-splitting"><span>Information Gain (measure of the reduction in entropy after splitting)</span></a></h4><ul><li>Information gain measures the reduction in entropy about the target variable achieved by partitioning the data based on a given feature.</li><li>Choose the largest as information gain.</li></ul><h4 id="shortcomings-of-ig" tabindex="-1"><a class="header-anchor" href="#shortcomings-of-ig"><span>Shortcomings of IG</span></a></h4><ul><li>Overfitting: Greedy algorithm may choose a feature that is too specific and does not generalize well to unseen data.</li><li>Gain ratio (GR) reduces the bias for information gain towards highlybranching attributes by normalising relative to the split information</li><li>Split info (SI) is the entropy of a given split (evenness of the distribution ofinstances to attribute values)</li></ul><h3 id="naive-bayes-theory" tabindex="-1"><a class="header-anchor" href="#naive-bayes-theory"><span>Naive Bayes Theory</span></a></h3><div class="hint-container info"><p class="hint-container-title">Info</p><p>arg max: argument of maximum value</p></div><ul><li>Supervied ML method</li></ul><h4 id="example" tabindex="-1"><a class="header-anchor" href="#example"><span>Example:</span></a></h4><p><img src="'+c+'" alt="Naive Bayes Example1-1" loading="lazy"><img src="'+h+'" alt="Naive Bayes Example1-2" loading="lazy"></p><ul><li>If any term P(xm|y ) = 0 then the class probability P(y|x ) = 0</li><li>To solve this: use Laplace smoothing.</li></ul><ol><li>First Solution: We can assign a (small) positive probability 𝜀 to every unseen class-feature combination</li><li>Second Solution: We can add a “pseudocount” α to each feature count observed during training, often is 1.</li></ol><ul><li>Probabilities are changed drastically when there are few instances; with a large number of instances, the changes are small</li><li>Laplace smoothing (and smoothing in general) <strong>reduces variance</strong> of the NB classifier because it reduces sensitivity to individual (non-)observations in the training data</li></ul><h3 id="different-naive-bayes" tabindex="-1"><a class="header-anchor" href="#different-naive-bayes"><span>Different Naive Bayes</span></a></h3><p>Naïve Bayes classifiers have several key variants that differ based on how they model the distribution of features. Below is a comparison of the most common types:</p><table><thead><tr><th>Variant</th><th>Assumption on Feature Distribution</th><th>Use Case</th></tr></thead><tbody><tr><td><strong>Gaussian Naïve Bayes (GNB)</strong></td><td>Assumes features follow a Gaussian (normal) distribution.</td><td>Suitable for continuous data, often used in text classification and real-world datasets with normally distributed features.</td></tr><tr><td><strong>Multinomial Naïve Bayes (MNB)</strong></td><td>Assumes feature counts follow a multinomial distribution.</td><td>Best for text classification (e.g., spam detection, document classification) where features are word counts or term frequencies.</td></tr><tr><td><strong>Bernoulli Naïve Bayes (BNB)</strong></td><td>Assumes binary feature presence (1 = present, 0 = absent).</td><td>Used in binary text classification (e.g., sentiment analysis, spam filtering), where features represent whether a word appears in a document.</td></tr><tr><td><strong>Complement Naïve Bayes (CNB)</strong></td><td>A modification of Multinomial Naïve Bayes, designed to handle class imbalances.</td><td>Works better for imbalanced datasets and improves accuracy by adjusting feature probabilities.</td></tr><tr><td><strong>Categorical Naïve Bayes</strong></td><td>Assumes features are discrete categorical variables.</td><td>Used for classification tasks with categorical inputs that are not necessarily text-based.</td></tr></tbody></table><p>Each variant modifies the way probabilities are calculated based on the data&#39;s nature, making Naïve Bayes a flexible and effective algorithm for different types of classification tasks.</p><h3 id="conclusion-of-naive-bayes" tabindex="-1"><a class="header-anchor" href="#conclusion-of-naive-bayes"><span>Conclusion of Naive Bayes</span></a></h3><ol><li>Why does it work given that it’s a blatantly wrong model of the data?</li></ol><ul><li>we don’t need the true distribution over P(y|x ), we just need to be able to identify the most likely outcome</li></ul><ol start="2"><li>Advantages of Naive Bayes</li></ol><ul><li>easy to build and estimate</li><li>easy to scale to many feature dimensions (e.g., words in the vocabulary) and data sizes</li><li>reasonably easy to explain why a specific class was predicted</li><li>good starting point for a classification project</li></ul><h2 id="week-4" tabindex="-1"><a class="header-anchor" href="#week-4"><span>Week 4</span></a></h2><h3 id="linear-regression" tabindex="-1"><a class="header-anchor" href="#linear-regression"><span>Linear Regression</span></a></h3><ul><li>A supervised learning algorithm that models the relationship between a scalar dependent variable (y) and one or more explanatory variables (X1, X2,..., Xn).</li><li>The model assumes that the relationship between the dependent and independent variables is linear.</li><li>The goal is to find the best line that fits the data.</li></ul><h4 id="loss-function" tabindex="-1"><a class="header-anchor" href="#loss-function"><span>Loss Function</span></a></h4><ul><li>The loss function measures the error between the predicted values and the actual values.</li><li>The loss function is used to optimize the model parameters (i.e., the weights and biases) to minimize the loss.</li></ul><div class="hint-container info"><p class="hint-container-title">Info</p><ul><li>When using a regression model for prediction, it is important to only predict within the relevant range of data</li><li>We should not try to extrapolate beyond the range of observed X’s</li><li>Make sure independent variables are NOT highly correlated with each other, otherwise the model becomes unstable</li></ul></div><h3 id="optimization" tabindex="-1"><a class="header-anchor" href="#optimization"><span>Optimization</span></a></h3><ul><li>Find parameter values 𝜽 that maximize (or minimize) the value of a function f(𝜽)</li></ul><h3 id="iterative-optimization" tabindex="-1"><a class="header-anchor" href="#iterative-optimization"><span>Iterative Optimization</span></a></h3><h4 id="closed-form-solutions" tabindex="-1"><a class="header-anchor" href="#closed-form-solutions"><span>Closed-form solutions</span></a></h4><ul><li>Previously, we computed the closed form solution for the MLE of the binomial distribution</li><li>We follow our recipe, and arrive at a single solution</li></ul><h4 id="unfortunately-life-is-not-always-as-easy" tabindex="-1"><a class="header-anchor" href="#unfortunately-life-is-not-always-as-easy"><span>Unfortunately, life is not always as easy</span></a></h4><ul><li>Often, no closed-form solution exists</li><li>Instead, we have to iteratively improve our estimate of θˆ until we arrive at a satisfactory solution</li><li>Gradient descent is one popular iterative optimization method</li></ul><h3 id="gradient-descent" tabindex="-1"><a class="header-anchor" href="#gradient-descent"><span>Gradient Descent</span></a></h3><ul><li>Descending a mountain (aka. our function) as fast as possible: atevery position take the next step that takes you most directly into the valley</li></ul><p><img src="'+u+'" alt="Gradient Descent" loading="lazy"><img src="'+g+'" alt="Gradient Descent Algorithm" loading="lazy"></p><div class="hint-container info"><p class="hint-container-title">Info</p><ol><li>with an appropriate learning rate, GD will find the global minimum for differentiable convex functions</li><li>with an appropriate learning rate, GD will find a local minimum for differentiable non-convex functions</li></ol></div><h3 id="logistic-regression" tabindex="-1"><a class="header-anchor" href="#logistic-regression"><span>Logistic Regression</span></a></h3><table><thead><tr><th><strong>Comparison</strong></th><th><strong>Naïve Bayes</strong></th><th><strong>Logistic Regression</strong></th></tr></thead><tbody><tr><td><strong>Model Type</strong></td><td>Generative Model</td><td>Discriminative Model</td></tr><tr><td><strong>Probability Learned</strong></td><td>( P(x, y) ) (Joint Probability)</td><td>( P(y</td></tr><tr><td><strong>Assumptions</strong></td><td>Assumes feature independence</td><td>No specific feature independence assumption</td></tr><tr><td><strong>Computational Complexity</strong></td><td>Low, fast computation</td><td>Higher, requires gradient descent</td></tr><tr><td><strong>Use Cases</strong></td><td>Text classification (e.g., spam detection)</td><td>Tasks requiring feature relationship modeling</td></tr><tr><td><strong>Suitable for Large Datasets?</strong></td><td>Yes, simple computation</td><td>Yes, but computationally more intensive</td></tr></tbody></table><div class="hint-container info"><p class="hint-container-title">Info</p><h1 id="understanding-odds-and-log-odds-in-logistic-regression" tabindex="-1"><a class="header-anchor" href="#understanding-odds-and-log-odds-in-logistic-regression"><span>Understanding Odds and Log Odds in Logistic Regression</span></a></h1><h2 id="_1-what-are-odds" tabindex="-1"><a class="header-anchor" href="#_1-what-are-odds"><span>1. What are Odds?</span></a></h2><p>Odds represent the ratio of the probability of an event occurring to the probability of it not occurring. Mathematically, odds are defined as:</p><p>[ \\text{odds} = \\frac{P}{1 - P} ]</p><p>where:</p><ul><li>( P ) is the probability of the event occurring.</li><li>( 1 - P ) is the probability of the event not occurring.</li></ul><h3 id="types-of-odds" tabindex="-1"><a class="header-anchor" href="#types-of-odds"><span><strong>Types of Odds</strong></span></a></h3><ul><li><strong>Odds against an event</strong>: When ( 0 &lt; \\text{odds} &lt; 1 ), meaning the event is less likely to happen than not.</li><li><strong>Odds in favor of an event</strong>: When ( \\text{odds} &gt; 1 ), meaning the event is more likely to happen than not.</li></ul><p><strong>Example:</strong></p><ul><li>If an event has a <strong>60% chance</strong> of occurring (( P = 0.6 )), the odds are: [ \\text{odds} = \\frac{0.6}{1 - 0.6} = \\frac{0.6}{0.4} = 1.5 ] This means the event is <strong>1.5 times more likely</strong> to occur than not.</li></ul><h2 id="_2-why-use-log-odds-logit-function" tabindex="-1"><a class="header-anchor" href="#_2-why-use-log-odds-logit-function"><span>2. Why Use Log Odds (Logit Function)?</span></a></h2><p>Since odds can range from <strong>0 to infinity</strong>, they are not ideal for direct modeling in a regression setting. Instead, we take the <strong>logarithm of odds</strong>, known as the <strong>logit function</strong>:</p><p>[ \\text{log odds} = \\log \\left(\\frac{P}{1 - P}\\right) ]</p><h3 id="advantages-of-log-odds" tabindex="-1"><a class="header-anchor" href="#advantages-of-log-odds"><span><strong>Advantages of Log Odds:</strong></span></a></h3><ol><li><p><strong>Transforms probability into an unrestricted range</strong></p><ul><li>( P ) is always between ( 0 ) and ( 1 ), but log odds can take any value from <strong>(-\\infty) to (+\\infty)</strong>.</li><li>This makes it easier to model using linear regression techniques.</li></ul></li><li><p><strong>Handles Non-Linearity in Probability</strong></p><ul><li>The relationship between probability and log odds is <strong>non-linear</strong>, but when transformed to log odds, it becomes <strong>linear</strong>.</li></ul></li></ol><p><strong>Example Calculation:</strong></p><ul><li>If the event has a probability of ( P = 0.8 ): [ \\text{odds} = \\frac{0.8}{1 - 0.8} = \\frac{0.8}{0.2} = 4 ] <ul><li>Taking the natural logarithm: [ \\log(4) \\approx 1.386 ]</li><li>Now, instead of dealing with probabilities, we can work with a linear scale.</li></ul></li></ul><h2 id="_3-connection-to-logistic-regression" tabindex="-1"><a class="header-anchor" href="#_3-connection-to-logistic-regression"><span>3. Connection to Logistic Regression</span></a></h2><p>In <strong>logistic regression</strong>, we model the probability of an event occurring using the equation:</p><p>[ \\log \\left(\\frac{P}{1 - P}\\right) = \\theta_0 + \\theta_1 x_1 + \\theta_2 x_2 + ... + \\theta_n x_n ]</p><p>This means:</p><ul><li>Instead of predicting probabilities directly, logistic regression predicts <strong>log odds</strong>, which follow a linear relationship with input features.</li><li>We then use the <strong>sigmoid function</strong> to convert log odds back into probabilities.</li></ul><h2 id="_4-conclusion" tabindex="-1"><a class="header-anchor" href="#_4-conclusion"><span>4. Conclusion</span></a></h2><ul><li><strong>Odds</strong> measure how likely an event is compared to it not happening.</li><li><strong>Log odds (logit function)</strong> transform probabilities into a linear form, making them easier to model.</li><li>Logistic regression leverages log odds to predict probabilities effectively.</li></ul><p>Understanding this transformation is key to interpreting logistic regression results and making informed predictions.</p></div><ul><li>Logit function: The logarithm of the odds.</li></ul><h3 id="softmax-function-the-function-that-converts-a-vector-of-real-numbers-to-a-probability-distribution" tabindex="-1"><a class="header-anchor" href="#softmax-function-the-function-that-converts-a-vector-of-real-numbers-to-a-probability-distribution"><span>Softmax function: The function that converts a vector of real numbers to a probability distribution.</span></a></h3><h3 id="logistic-regression-summary" tabindex="-1"><a class="header-anchor" href="#logistic-regression-summary"><span>Logistic Regression Summary</span></a></h3><ol><li>Pros</li></ol><ul><li>Probabilistic interpretation</li><li>No restrictive assumptions on features</li><li>Often outperforms Naive Bayes</li><li>Particularly suited to frequency-based features (so, popular in NLP)</li></ul><ol start="2"><li>Cons</li></ol><ul><li>Can only learn linear feature-data relationships</li><li>Some feature scaling issues</li><li>Often needs a lot of data to work well</li><li>Regularisation a nuisance, but important since overfitting can be a big problem</li></ul><h2 id="week-5" tabindex="-1"><a class="header-anchor" href="#week-5"><span>Week 5</span></a></h2><h3 id="support-vector-machines-svm" tabindex="-1"><a class="header-anchor" href="#support-vector-machines-svm"><span>Support Vector Machines (SVM)</span></a></h3><h4 id="classifier" tabindex="-1"><a class="header-anchor" href="#classifier"><span>Classifier</span></a></h4><ul><li>A linear classifier (through origin) with parameters divides the space into positive and negative halves</li></ul><h3 id="hard-margin" tabindex="-1"><a class="header-anchor" href="#hard-margin"><span>Hard Margin</span></a></h3><figure><img src="'+p+'" alt="Hard Margin" tabindex="0" loading="lazy"><figcaption>Hard Margin</figcaption></figure><ul><li>The margin is the distance between the decision boundary and the closest data point.</li><li>The goal is to maximize the margin while keeping the data points as far away from the decision boundary as possible.</li><li>The decision boundary is the line that separates the positive and negative data points.</li><li>It is called hard margin because the data points must be correctly classified on both sides of the decision boundary.</li></ul><h4 id="soft-margin" tabindex="-1"><a class="header-anchor" href="#soft-margin"><span>Soft Margin</span></a></h4><ul><li>The margin is softened by introducing a penalty term that depends on the distance of the data points from the decision boundary.</li><li>The goal is to minimize the margin while keeping the data points as far away from the decision boundary as possible.</li><li>The decision boundary is the line that separates the positive and negative data points.</li><li>It is called soft margin because the data points can be misclassified on both sides of the decision boundary.</li></ul><div class="hint-container info"><p class="hint-container-title">Info</p><h3 id="kernel-trick" tabindex="-1"><a class="header-anchor" href="#kernel-trick"><span>Kernel Trick</span></a></h3><ul><li>The kernel trick is a way to transform non-linear data into a higher-dimensional space where it becomes linearly separable.</li><li>The kernel function is a similarity function that measures the similarity between two data points in the original space.</li><li>The kernel trick allows us to use non-linear models in a linear model.</li></ul></div><h3 id="applications-of-svm" tabindex="-1"><a class="header-anchor" href="#applications-of-svm"><span>Applications of SVM</span></a></h3><h4 id="multiclass-problems" tabindex="-1"><a class="header-anchor" href="#multiclass-problems"><span>Multiclass problems</span></a></h4><ol><li><strong>Introduce parameter vectors</strong>: If there are ( k ) categories, we introduce a parameter vector ( \\theta_1, \\theta_2, \\ldots, \\theta_k ) for each category.</li><li><strong>Jointly learn parameters</strong>: Jointly learn these parameters by ensuring that the discriminant function associated with the correct category has the highest value. The goal is to minimize the following expression: [ \\frac{1}{2} \\sum_{y=1}^{k} | \\theta_y |^2 ] The constraint is that for all ( y&#39; \\neq y_i ) and ( i = 1, \\ldots, n ), it satisfies: [ (\\theta_{y_i} \\cdot x_i) \\geq (\\theta_{y&#39;} \\cdot x_i) + 1 ]</li><li><strong>Predict new examples</strong>: Predict the label of a new example based on the following formula: [ \\hat{y} = \\arg\\max_{y=1,\\ldots,k} (\\theta^*_y \\cdot x) ]</li></ol><h4 id="rating-problems" tabindex="-1"><a class="header-anchor" href="#rating-problems"><span>Rating problems</span></a></h4><h4 id="ordinal-regression-problems" tabindex="-1"><a class="header-anchor" href="#ordinal-regression-problems"><span>Ordinal regression problems</span></a></h4><ul><li>Target variable: The target variable in ordinal regression is an ordinal variable, where the categories have a certain order, such as education level (elementary, middle school, high school, university, graduate) or movie ratings (1 star to 5 stars).</li><li>Model purpose: Unlike multiclass classification problems, ordinal regression models not only predict the correct category but also the order relationship between categories.</li></ul><h4 id="translate-each-rating-into-a-set-of-binary-labels" tabindex="-1"><a class="header-anchor" href="#translate-each-rating-into-a-set-of-binary-labels"><span>Translate each rating into a set of binary labels</span></a></h4><ul><li><p>We can convert these labels into binary labels. For example, we can divide the ratings into two categories: &quot;like&quot; and &quot;dislike&quot;. Here is a simple conversion example:</p></li><li><p>1 star and 2 stars: Dislike (represented by 0)</p></li><li><p>3 stars: May require additional processing as it can be considered neutral or context-dependent</p></li><li><p>4 stars and 5 stars: Like (represented by 1)</p></li><li><p>Alternatively, we can create a binary label for each rating level as follows:</p></li><li><p>1 star: [1, 0, 0, 0, 0]</p></li><li><p>2 stars: [0, 1, 0, 0, 0]</p></li><li><p>3 stars: [0, 0, 1, 0, 0]</p></li><li><p>4 stars: [0, 0, 0, 1, 0]</p></li><li><p>5 stars: [0, 0, 0, 0, 1]</p></li></ul><h3 id="ranking" tabindex="-1"><a class="header-anchor" href="#ranking"><span>Ranking</span></a></h3><ul><li>In machine learning, ranking tasks typically involve ordering a set of items such that certain items have higher priority over others. SVM can address ranking problems by modifying the standard binary classification SVM, a method commonly known as RankSVM. RankSVM learns a ranking function through pairwise comparisons, ensuring that positive examples rank higher than negative ones.</li></ul><h3 id="structured-prediction" tabindex="-1"><a class="header-anchor" href="#structured-prediction"><span>Structured prediction</span></a></h3><ul><li>Structured prediction is a branch of machine learning that involves predicting structured outputs, such as sequences, trees, or graphs. SVM can be extended to handle these problems through Structured SVM. Structured SVM learns a prediction function by maximizing the margin, which can output entire structures rather than simple class labels. This approach is particularly useful in fields like natural language processing, bioinformatics, and computer vision.</li></ul><p><strong>The core idea of Support Vector Machines (SVM) is to find an optimal hyperplane that best separates data points of different classes while maximizing the margin between the classes. This margin is the distance from the hyperplane to the nearest training data point. The goal of SVM is to find a hyperplane with the largest margin, which can improve the model&#39;s generalization ability and reduce the risk of overfitting.</strong></p><h2 id="week-6" tabindex="-1"><a class="header-anchor" href="#week-6"><span>Week 6</span></a></h2><h3 id="evaluation" tabindex="-1"><a class="header-anchor" href="#evaluation"><span>Evaluation</span></a></h3><p>if our model will perform effectively on unseen data</p><h4 id="holdout" tabindex="-1"><a class="header-anchor" href="#holdout"><span>Holdout</span></a></h4><ul><li>Split the data randomly into two parts: a training set and a test set.</li><li>Train the model on the training set and evaluate it on the test set.</li></ul><h4 id="holdout-weakness" tabindex="-1"><a class="header-anchor" href="#holdout-weakness"><span>Holdout Weakness</span></a></h4><ul><li>The size of the split affects the estimate of the model’s behaviour: Lots of test instances, and few training instances → , the learner doesn’t have enough information to build an accurate model. Lots of training instances, and few test instances → learner builds an accurate model, but test data might not be representative (so estimates of performance can be too high/too low)</li><li>Bias in Sampling: Random sampling of data can lead to different distribution in train and test datasets</li></ul><h4 id="stratification" tabindex="-1"><a class="header-anchor" href="#stratification"><span>Stratification</span></a></h4><ul><li>Stratification ensures that each fold or partition of the data maintains the same class distribution as the original dataset</li></ul><h4 id="stratification-weakness" tabindex="-1"><a class="header-anchor" href="#stratification-weakness"><span>Stratification Weakness</span></a></h4><ul><li>Complexity: Can be more complex to implement compared to simple random sampling.</li><li>Inefficient Resource Utilization: some data is only used for training and some only for testing</li></ul><h4 id="k-fold-cross-validation" tabindex="-1"><a class="header-anchor" href="#k-fold-cross-validation"><span>k-fold Cross-validation</span></a></h4><ul><li>Divide the data into k equal parts, and use k-1 parts for training and 1 part for testing.</li><li>Repeat k times, each time using a different part for testing and the remaining parts for training.</li><li>The average performance of the k models is the estimate of the performance of the model on the entire dataset.</li></ul><h4 id="k-fold-cross-validation-weakness" tabindex="-1"><a class="header-anchor" href="#k-fold-cross-validation-weakness"><span>k-fold Cross-validation Weakness</span></a></h4><ul><li>Fewer folds: more instances per partition, more variance in performance estimates</li><li>More folds: fewer instances per partition, less variance but slower</li></ul><h4 id="hyperparameter-tuning" tabindex="-1"><a class="header-anchor" href="#hyperparameter-tuning"><span>Hyperparameter Tuning</span></a></h4><ul><li>If the Decision Tree is too short (Depth is too small), The DT would be too simple (Something like 1-R)</li><li>If the Decision Tree is too long (Depth is too big), The DT would be too complex and cannot generalize well</li><li>To decide about the best depth for a tree (and other hyperparameters), we need a way to measure how well our tree can - edict labels for new, unseen data.</li><li>But… If we use our Test data for hyperparameter tuning, then we don’t have any other (unseen) data to test the performance of the final model (after the hyperparameter tuning) → It will cause data leakage</li><li>We need a third set → Validation data, or use cross-validation to split the data into training, validation, and test sets.</li></ul><h3 id="evaluation-metrics" tabindex="-1"><a class="header-anchor" href="#evaluation-metrics"><span>Evaluation Metrics</span></a></h3><ul><li>We can present all possible classification results a two-class problem in the following confusion matrix.</li><li>True Positive (TP): The model correctly predicts the positive class.</li><li>False Positive (FP): The model incorrectly predicts the positive class.</li><li>True Negative (TN): The model correctly predicts the negative class.</li><li>False Negative (FN): The model incorrectly predicts the negative class.</li></ul><h4 id="recall" tabindex="-1"><a class="header-anchor" href="#recall"><span>Recall</span></a></h4><ul><li>Recall: From the cases that are actually positive, what percentage has been correctly identified (predicted positive) by our classifier. Recall = TP / (TP + FN)</li></ul><h4 id="precision" tabindex="-1"><a class="header-anchor" href="#precision"><span>Precision</span></a></h4><ul><li>From the cases that are predicted positive, what percentage are actually positive. Precision = TP / (TP + FP)</li></ul><h4 id="f1-score" tabindex="-1"><a class="header-anchor" href="#f1-score"><span>F1-score</span></a></h4><ul><li>A popular metric that can help with finding a balance between Precision &amp; Recall is F1-Score. F1-Score is the harmonic mean of Precision and Recall. F1-Score = 2 * (Precision * Recall) / (Precision + Recall)</li></ul><h3 id="averaging-methods" tabindex="-1"><a class="header-anchor" href="#averaging-methods"><span>Averaging methods</span></a></h3><p>In multi-class problems, Macro Averaging, Micro Averaging, and Weighted Averaging are three methods for calculating the average precision or recall. These methods are particularly useful in evaluating the performance of classification models, especially in datasets with imbalanced classes. Here is a brief description of these three methods:</p><h3 id="_1-macro-averaging" tabindex="-1"><a class="header-anchor" href="#_1-macro-averaging"><span>1. Macro Averaging</span></a></h3><p>Macro Averaging first calculates the metrics (such as precision, recall, or F1 score) for each class, and then calculates the simple arithmetic average of these metrics. It treats each class as equally important, without considering the actual frequency or size of the classes. The calculation formula is as follows: $$ \\text{Macro Average} = \\frac{1}{N} \\sum_{i=1}^{N} \\text{metric}_i $$ Where, $N$ is the total number of classes, and $\\text{metric}_i$ is the value of the metric for the $i$-th class. <strong>Advantages</strong>: Each class is treated equally, so this may be a better metric for imbalanced datasets. <strong>Disadvantages</strong>: If some classes are very few, they may disproportionately affect the overall performance evaluation.</p><h3 id="_2-micro-averaging" tabindex="-1"><a class="header-anchor" href="#_2-micro-averaging"><span>2. Micro Averaging</span></a></h3><p>Micro Averaging first calculates the total precision, total recall, and total F1 score for all classes, and then calculates the arithmetic average of these totals. It calculates the metrics by considering individual predictions in each class, so it takes into account the actual frequency of the classes. The calculation formula is as follows: $$ \\text{Micro Average Precision} = \\frac{\\sum_{i=1}^{N} TP_i}{\\sum_{i=1}^{N} TP_i + \\sum_{i=1}^{N} FP_i} $$ $$ \\text{Micro Average Recall} = \\frac{\\sum_{i=1}^{N} TP_i}{\\sum_{i=1}^{N} TP_i + \\sum_{i=1}^{N} FN_i} $$ Where, $TP_i$, $FP_i$, and $FN_i$ are the numbers of true positives, false positives, and false negatives, respectively, for the $i$-th class. <strong>Advantages</strong>: It takes into account the true distribution of each class, so it is usually a more reliable metric for imbalanced datasets. <strong>Disadvantages</strong>: It may overlook the imbalance between classes, as the contributions of all classes are averaged.</p><h3 id="_3-weighted-averaging" tabindex="-1"><a class="header-anchor" href="#_3-weighted-averaging"><span>3. Weighted Averaging</span></a></h3>',185),(0,i.Lk)("p",null,[(0,i.eW)("Weighted Averaging is a variant of Macro Averaging, which takes into account the support of each class (i.e., the number of instances in each class). The value of the metric for each class is multiplied by the support of that class, and then the average of these weighted values is calculated. The calculation formula is as follows: $$ \\text{Weighted Average} = \\frac{\\sum_{i=1}^{N} (\\text{metric}_i \\times \\text{support}"),(0,i.Lk)("em",{i:"1"},"i)}{\\sum"),(0,i.eW)("^{N} \\text{support}_i} $$ Where, $\\text{metric}_i$ is the value of the metric for the $i$-th class, and $\\text{support}_i$ is the support of the $i$-th class. "),(0,i.Lk)("strong",null,"Advantages"),(0,i.eW)(": It takes into account the relative size of each class, so it is a fairer metric for imbalanced datasets. "),(0,i.Lk)("strong",null,"Disadvantages"),(0,i.eW)(": Like Macro Averaging, it may give disproportionate weight to minority classes, which may distort the overall performance evaluation. The choice of which averaging method to use depends on the specific application scenario and the characteristics of the dataset. In the case of class imbalance, Weighted Averaging is often considered the best choice, as it simultaneously considers the performance and relative importance of each class.")],-1),(0,i.Lk)("h3",{id:"regression-performance-metrics",tabindex:"-1"},[(0,i.Lk)("a",{class:"header-anchor",href:"#regression-performance-metrics"},[(0,i.Lk)("span",null,"Regression Performance Metrics")])],-1),(0,i.Lk)("h4",{id:"mse-rmse-and-mae-mean-squared-error-root-mean-squared-error-and-mean-absolute-error",tabindex:"-1"},[(0,i.Lk)("a",{class:"header-anchor",href:"#mse-rmse-and-mae-mean-squared-error-root-mean-squared-error-and-mean-absolute-error"},[(0,i.Lk)("span",null,"MSE, RMSE, and MAE (Mean Squared Error, Root Mean Squared Error, and Mean Absolute Error)")])],-1),(0,i.Lk)("ul",null,[(0,i.Lk)("li",null,"Sum of Squared Errors (SSE) is the sum of the squared differences between the predicted and actual values."),(0,i.Lk)("li",null,"MSE emphasizes larger errors due to squaring and is sensitive to outliers."),(0,i.Lk)("li",null,"RMSE is the square root of MSE, providing a more interpretable metric in the same units as the target variable."),(0,i.Lk)("li",null,"MAE treats all errors equally, is less sensitive to outliers, and provides a straightforward average error measure.")],-1)]))}]]),b=JSON.parse('{"path":"/posts/unimelb/COMP90049.html","title":"Introduction to Machine Learning (COMP90049)","lang":"en-US","frontmatter":{"icon":"pen-to-square","date":"2025-03-02T00:00:00.000Z","category":["Learning Records"],"tag":["Unimelb"],"description":"Introduction to Machine Learning (COMP90049) Week 1 Machine learning is a method of teaching software to learn from data and make decisions on their own, without being explicitl...","head":[["meta",{"property":"og:url","content":"https://crc011220.github.io/personalweb/personalweb/posts/unimelb/COMP90049.html"}],["meta",{"property":"og:site_name","content":"Richard Chen"}],["meta",{"property":"og:title","content":"Introduction to Machine Learning (COMP90049)"}],["meta",{"property":"og:description","content":"Introduction to Machine Learning (COMP90049) Week 1 Machine learning is a method of teaching software to learn from data and make decisions on their own, without being explicitl..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2025-04-09T09:24:43.000Z"}],["meta",{"property":"article:tag","content":"Unimelb"}],["meta",{"property":"article:published_time","content":"2025-03-02T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-04-09T09:24:43.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Introduction to Machine Learning (COMP90049)\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-03-02T00:00:00.000Z\\",\\"dateModified\\":\\"2025-04-09T09:24:43.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Richard Chen\\"}]}"]]},"headers":[{"level":2,"title":"Week 1","slug":"week-1","link":"#week-1","children":[{"level":3,"title":"Three ingredients for machine learning","slug":"three-ingredients-for-machine-learning","link":"#three-ingredients-for-machine-learning","children":[]},{"level":3,"title":"Linear Algebra Review","slug":"linear-algebra-review","link":"#linear-algebra-review","children":[]},{"level":3,"title":"Instances, Attributes, and Learning Paradigms (Supervised vs. Unsupervised Learning)","slug":"instances-attributes-and-learning-paradigms-supervised-vs-unsupervised-learning","link":"#instances-attributes-and-learning-paradigms-supervised-vs-unsupervised-learning","children":[]},{"level":3,"title":"Featured Data Types","slug":"featured-data-types","link":"#featured-data-types","children":[]}]},{"level":2,"title":"Equal Width vs. Equal Frequency vs. Clustering","slug":"equal-width-vs-equal-frequency-vs-clustering","link":"#equal-width-vs-equal-frequency-vs-clustering","children":[]},{"level":2,"title":"Standardization vs. Normalization","slug":"standardization-vs-normalization","link":"#standardization-vs-normalization","children":[]},{"level":2,"title":"Week 2","slug":"week-2","link":"#week-2","children":[{"level":3,"title":"K-Nearest Neighbors (KNN)","slug":"k-nearest-neighbors-knn","link":"#k-nearest-neighbors-knn","children":[]},{"level":3,"title":"Probility","slug":"probility","link":"#probility","children":[]}]},{"level":2,"title":"Week 3","slug":"week-3","link":"#week-3","children":[{"level":3,"title":"Zero-R","slug":"zero-r","link":"#zero-r","children":[]},{"level":3,"title":"One-R","slug":"one-r","link":"#one-r","children":[]},{"level":3,"title":"Desicion Trees","slug":"desicion-trees","link":"#desicion-trees","children":[]},{"level":3,"title":"ID3 (Iterative Dichotomiser 3)","slug":"id3-iterative-dichotomiser-3","link":"#id3-iterative-dichotomiser-3","children":[]},{"level":3,"title":"Naive Bayes Theory","slug":"naive-bayes-theory","link":"#naive-bayes-theory","children":[]},{"level":3,"title":"Different Naive Bayes","slug":"different-naive-bayes","link":"#different-naive-bayes","children":[]},{"level":3,"title":"Conclusion of Naive Bayes","slug":"conclusion-of-naive-bayes","link":"#conclusion-of-naive-bayes","children":[]}]},{"level":2,"title":"Week 4","slug":"week-4","link":"#week-4","children":[{"level":3,"title":"Linear Regression","slug":"linear-regression","link":"#linear-regression","children":[]},{"level":3,"title":"Optimization","slug":"optimization","link":"#optimization","children":[]},{"level":3,"title":"Iterative Optimization","slug":"iterative-optimization","link":"#iterative-optimization","children":[]},{"level":3,"title":"Gradient Descent","slug":"gradient-descent","link":"#gradient-descent","children":[]},{"level":3,"title":"Logistic Regression","slug":"logistic-regression","link":"#logistic-regression","children":[]},{"level":3,"title":"Softmax function: The function that converts a vector of real numbers to a probability distribution.","slug":"softmax-function-the-function-that-converts-a-vector-of-real-numbers-to-a-probability-distribution","link":"#softmax-function-the-function-that-converts-a-vector-of-real-numbers-to-a-probability-distribution","children":[]},{"level":3,"title":"Logistic Regression Summary","slug":"logistic-regression-summary","link":"#logistic-regression-summary","children":[]}]},{"level":2,"title":"Week 5","slug":"week-5","link":"#week-5","children":[{"level":3,"title":"Support Vector Machines (SVM)","slug":"support-vector-machines-svm","link":"#support-vector-machines-svm","children":[]},{"level":3,"title":"Hard Margin","slug":"hard-margin","link":"#hard-margin","children":[]},{"level":3,"title":"Applications of SVM","slug":"applications-of-svm","link":"#applications-of-svm","children":[]},{"level":3,"title":"Ranking","slug":"ranking","link":"#ranking","children":[]},{"level":3,"title":"Structured prediction","slug":"structured-prediction","link":"#structured-prediction","children":[]}]},{"level":2,"title":"Week 6","slug":"week-6","link":"#week-6","children":[{"level":3,"title":"Evaluation","slug":"evaluation","link":"#evaluation","children":[]},{"level":3,"title":"Evaluation Metrics","slug":"evaluation-metrics","link":"#evaluation-metrics","children":[]},{"level":3,"title":"Averaging methods","slug":"averaging-methods","link":"#averaging-methods","children":[]},{"level":3,"title":"1. Macro Averaging","slug":"_1-macro-averaging","link":"#_1-macro-averaging","children":[]},{"level":3,"title":"2. Micro Averaging","slug":"_2-micro-averaging","link":"#_2-micro-averaging","children":[]},{"level":3,"title":"3. Weighted Averaging","slug":"_3-weighted-averaging","link":"#_3-weighted-averaging","children":[]},{"level":3,"title":"Regression Performance Metrics","slug":"regression-performance-metrics","link":"#regression-performance-metrics","children":[]}]}],"git":{"createdTime":1740916663000,"updatedTime":1744190683000,"contributors":[{"name":"Ruochen Chen","email":"ruocchen1220@gmail.com","commits":8}]},"readingTime":{"minutes":17.19,"words":5157},"filePathRelative":"posts/unimelb/COMP90049.md","localizedDate":"March 2, 2025","excerpt":"\\n<h2>Week 1</h2>\\n<ul>\\n<li>Machine learning is a method of teaching software to learn from data and make decisions on their own, without being explicitly programmed.</li>\\n</ul>\\n<h3>Three ingredients for machine learning</h3>\\n<ol>\\n<li>\\n<p>Data\\n• Discrete vs continuous vs ...\\n• Big data vs small data\\n• Labeled data vs unlabeled data\\n• Public vs sensitive data</p>\\n</li>\\n<li>\\n<p>Models\\n• function mapping from inputs to outputs\\n• probabilistic machine learning models\\n• geometric machine learning models\\n• parameters of the function are unknown</p>\\n</li>\\n<li>\\n<p>Learning\\n• Improving (on a task) after data is taken into account\\n• Finding the best model parameters (for a given task)\\n• Supervised vs. unsupervised learning</p>\\n</li>\\n</ol>","autoDesc":true}')}}]);