"use strict";(self.webpackChunkpersonalweb=self.webpackChunkpersonalweb||[]).push([[9451],{6262:(e,t)=>{t.A=(e,t)=>{const i=e.__vccOpts||e;for(const[e,n]of t)i[e]=n;return i}},205:(e,t,i)=>{i.r(t),i.d(t,{comp:()=>o,data:()=>s});var n=i(641);const r={},o=(0,i(6262).A)(r,[["render",function(e,t){return(0,n.uX)(),(0,n.CE)("div",null,t[0]||(t[0]=[(0,n.Fv)('<h1 id="microservices-and-springcloud" tabindex="-1"><a class="header-anchor" href="#microservices-and-springcloud"><span>MicroServices and SpringCloud</span></a></h1><h2 id="_1-what-are-the-five-main-components-of-spring-cloud" tabindex="-1"><a class="header-anchor" href="#_1-what-are-the-five-main-components-of-spring-cloud"><span>1. What are the five main components of Spring Cloud?</span></a></h2><p><strong>Answer:</strong><br> Initially, the five key components of Spring Cloud were:</p><ul><li><strong>Eureka</strong>: Service registry.</li><li><strong>Ribbon</strong>: Client-side load balancer.</li><li><strong>Feign</strong>: Declarative service invocation.</li><li><strong>Hystrix</strong>: Circuit breaker.</li><li><strong>Zuul/Gateway</strong>: API gateway.</li></ul><p>With the rise of Spring Cloud Alibaba, some additional components were incorporated into our projects:</p><ul><li><strong>Service Registration and Configuration Center</strong>: Nacos.</li><li><strong>Load Balancing</strong>: Ribbon.</li><li><strong>Service Invocation</strong>: Feign.</li><li><strong>Service Protection</strong>: Sentinel.</li><li><strong>API Gateway</strong>: Gateway.</li></ul><hr><h2 id="_2-what-is-service-registration-and-discovery-how-does-spring-cloud-implement-it" tabindex="-1"><a class="header-anchor" href="#_2-what-is-service-registration-and-discovery-how-does-spring-cloud-implement-it"><span>2. What is service registration and discovery? How does Spring Cloud implement it?</span></a></h2><p><strong>Answer:</strong><br> Service registration and discovery encompass three core functions: <strong>service registration</strong>, <strong>service discovery</strong>, and <strong>service health monitoring</strong>.</p><p>In our project, we used <strong>Eureka</strong> as the service registry:</p><ul><li><strong>Service Registration</strong>: Providers register their service details (e.g., name, IP, port) with Eureka.</li><li><strong>Service Discovery</strong>: Consumers fetch service details from Eureka and use a load-balancing algorithm to call a service instance.</li><li><strong>Service Health Monitoring</strong>: Providers send regular heartbeats to Eureka to report their status; if no heartbeat is received within a certain time, the instance is removed.</li></ul><hr><h2 id="_3-what-are-the-differences-between-nacos-and-eureka" tabindex="-1"><a class="header-anchor" href="#_3-what-are-the-differences-between-nacos-and-eureka"><span>3. What are the differences between Nacos and Eureka?</span></a></h2><p><strong>Answer:</strong><br> From my experience using <strong>Nacos</strong> as a registry, the key similarities and differences between Nacos and Eureka are:</p><h4 id="similarities" tabindex="-1"><a class="header-anchor" href="#similarities"><span>Similarities:</span></a></h4><ul><li>Both support <strong>service registration</strong> and <strong>discovery</strong>.</li><li>Both use heartbeat checks for <strong>health monitoring</strong>.</li></ul><h4 id="differences" tabindex="-1"><a class="header-anchor" href="#differences"><span>Differences:</span></a></h4><ol><li><strong>Health Check</strong>: <ul><li>Nacos can actively probe the provider&#39;s health.</li><li>Eureka relies solely on client heartbeats.</li></ul></li><li><strong>Instance Types</strong>: <ul><li>Nacos distinguishes between temporary and non-temporary instances and uses different health-check strategies.</li></ul></li><li><strong>Change Notifications</strong>: <ul><li>Nacos supports service-list updates via <strong>push notifications</strong>.</li></ul></li><li><strong>Consistency Models</strong>: <ul><li>Nacos defaults to <strong>AP mode</strong>, switching to <strong>CP mode</strong> for non-temporary instances.</li><li>Eureka operates purely in <strong>AP mode</strong>.</li></ul></li></ol><hr><h2 id="_4-how-is-load-balancing-implemented-in-your-project" tabindex="-1"><a class="header-anchor" href="#_4-how-is-load-balancing-implemented-in-your-project"><span>4. How is load balancing implemented in your project?</span></a></h2><p><strong>Answer:</strong><br> We used <strong>Ribbon</strong> in Spring Cloud for client-side load balancing. The <strong>Feign client</strong> integrates Ribbon internally, simplifying its use.</p><p>During remote service calls, Ribbon:</p><ol><li>Fetches the service&#39;s instance list from the registry.</li><li>Selects an instance based on a routing strategy (default is round-robin).</li><li>Sends the request to the chosen instance.</li></ol><hr><h2 id="_5-what-are-the-load-balancing-strategies-provided-by-ribbon" tabindex="-1"><a class="header-anchor" href="#_5-what-are-the-load-balancing-strategies-provided-by-ribbon"><span>5. What are the load balancing strategies provided by Ribbon?</span></a></h2><p><strong>Answer:</strong><br> Ribbon supports several load balancing strategies, including:</p><ul><li><strong>RoundRobinRule</strong>: Default round-robin strategy.</li><li><strong>WeightedResponseTimeRule</strong>: Chooses based on server response time.</li><li><strong>RandomRule</strong>: Randomly selects a server.</li><li><strong>ZoneAvoidanceRule</strong>: Prefers servers in the same zone/region.</li></ul><hr><h2 id="_6-how-do-you-customize-ribbon-s-load-balancing-strategy" tabindex="-1"><a class="header-anchor" href="#_6-how-do-you-customize-ribbon-s-load-balancing-strategy"><span>6. How do you customize Ribbon&#39;s load balancing strategy?</span></a></h2><p><strong>Answer:</strong><br> To customize Ribbon&#39;s load-balancing strategy, there are two approaches:</p><ol><li>Create a class implementing the <code>IRule</code> interface to define a global strategy.</li><li>Specify a strategy for individual services in the client&#39;s configuration file.</li></ol><hr><h2 id="_7-what-is-service-avalanche-and-how-do-you-address-it" tabindex="-1"><a class="header-anchor" href="#_7-what-is-service-avalanche-and-how-do-you-address-it"><span>7. What is service avalanche, and how do you address it?</span></a></h2><p><strong>Answer:</strong><br> A <strong>service avalanche</strong> occurs when the failure of one service causes a cascading failure across the service chain.</p><p>To address this, we use:</p><ul><li><strong>Service Degradation</strong>: Reduce non-critical service loads during traffic spikes.</li><li><strong>Service Circuit Breaking</strong>: Enable a circuit breaker to halt requests when the failure rate exceeds a threshold.</li></ul><hr><h2 id="_8-how-do-you-monitor-your-microservices" tabindex="-1"><a class="header-anchor" href="#_8-how-do-you-monitor-your-microservices"><span>8. How do you monitor your microservices?</span></a></h2><p><strong>Answer:</strong><br> We use <strong>SkyWalking</strong> for monitoring:</p><ol><li>It tracks service interfaces, physical instances, and latency.</li><li>Alerts are configured to notify stakeholders via SMS or email when anomalies are detected.</li></ol><hr><h2 id="_9-have-you-implemented-rate-limiting-in-your-project-how" tabindex="-1"><a class="header-anchor" href="#_9-have-you-implemented-rate-limiting-in-your-project-how"><span>9. Have you implemented rate-limiting in your project? How?</span></a></h2><p><strong>Answer:</strong><br> Yes, we implemented rate-limiting to handle sudden traffic surges:</p><ol><li><strong>Version 1</strong>: Used <strong>Nginx</strong> for rate-limiting with a <strong>leaky bucket algorithm</strong>, limiting by IP.</li><li><strong>Version 2</strong>: Switched to Spring Cloud Gateway&#39;s <strong>RequestRateLimiter</strong> filter, which uses a <strong>token bucket algorithm</strong> and supports IP or path-based limiting.</li></ol><hr><h2 id="_10-what-are-common-rate-limiting-algorithms" tabindex="-1"><a class="header-anchor" href="#_10-what-are-common-rate-limiting-algorithms"><span>10. What are common rate-limiting algorithms?</span></a></h2><p><strong>Answer:</strong><br> Common rate-limiting algorithms include:</p><ul><li><strong>Leaky Bucket</strong>: Processes requests at a fixed rate, smoothing bursts.</li><li><strong>Token Bucket</strong>: Tokens are generated at a fixed rate, and requests require a token, accommodating fluctuations.</li></ul><hr><h2 id="_11-what-is-the-cap-theorem" tabindex="-1"><a class="header-anchor" href="#_11-what-is-the-cap-theorem"><span>11. What is the CAP theorem?</span></a></h2><p><strong>Answer:</strong><br> The <strong>CAP theorem</strong> is a foundational concept in distributed systems, stating that it is impossible to achieve all three of the following simultaneously:</p><ul><li><strong>Consistency (C)</strong>: All nodes see the same data at the same time.</li><li><strong>Availability (A)</strong>: Every request receives a response.</li><li><strong>Partition Tolerance (P)</strong>: The system continues to operate despite network partitions.</li></ul><hr><h2 id="_12-why-can-t-distributed-systems-guarantee-both-consistency-and-availability" tabindex="-1"><a class="header-anchor" href="#_12-why-can-t-distributed-systems-guarantee-both-consistency-and-availability"><span>12. Why can&#39;t distributed systems guarantee both consistency and availability?</span></a></h2><p><strong>Answer:</strong><br> In a distributed system, ensuring <strong>partition tolerance</strong> is essential. When a partition occurs:</p><ul><li>Guaranteeing <strong>consistency</strong> may require sacrificing <strong>availability</strong> (e.g., by rejecting reads/writes until consistency is restored).</li><li>Guaranteeing <strong>availability</strong> may lead to stale or inconsistent data.</li></ul><hr><h2 id="_13-what-is-the-base-theorem" tabindex="-1"><a class="header-anchor" href="#_13-what-is-the-base-theorem"><span>13. What is the BASE theorem?</span></a></h2><p><strong>Answer:</strong><br> The <strong>BASE theorem</strong> extends the <strong>AP model</strong> of the CAP theorem, prioritizing:</p><ol><li><strong>Basic Availability</strong>: The system remains operational during failures.</li><li><strong>Soft State</strong>: Data can be temporarily inconsistent.</li><li><strong>Eventual Consistency</strong>: Data becomes consistent over time.</li></ol><hr><h2 id="_14-what-distributed-transaction-solution-do-you-use" tabindex="-1"><a class="header-anchor" href="#_14-what-distributed-transaction-solution-do-you-use"><span>14. What distributed transaction solution do you use?</span></a></h2><p><strong>Answer:</strong><br> We use <strong>Seata</strong> in <strong>AT mode</strong> for distributed transactions. The AT mode ensures eventual consistency by logging business data changes and coordinating rollback/recovery if a transaction fails.</p><hr><h2 id="_15-how-do-you-ensure-idempotency-in-distributed-service-interfaces" tabindex="-1"><a class="header-anchor" href="#_15-how-do-you-ensure-idempotency-in-distributed-service-interfaces"><span>15. How do you ensure idempotency in distributed service interfaces?</span></a></h2><p><strong>Answer:</strong><br> We use <strong>tokens</strong> and <strong>Redis</strong> for idempotency:</p><ol><li>Generate a token and store it in Redis when the user initiates an action.</li><li>Validate the token during the request. If valid, process the request and delete the token.</li><li>Reject duplicate tokens to ensure each request is processed only once.</li></ol><hr><h2 id="_16-what-routing-strategies-does-xxl-job-support" tabindex="-1"><a class="header-anchor" href="#_16-what-routing-strategies-does-xxl-job-support"><span>16. What routing strategies does XXL-Job support?</span></a></h2><p><strong>Answer:</strong><br> XXL-Job supports routing strategies such as:</p><ul><li><strong>Round Robin</strong>: Distributes tasks evenly.</li><li><strong>Failover</strong>: Redirects tasks to healthy instances.</li><li><strong>Sharding Broadcast</strong>: Broadcasts tasks across shards.</li></ul><hr><h2 id="_17-how-do-you-handle-xxl-job-task-execution-failures" tabindex="-1"><a class="header-anchor" href="#_17-how-do-you-handle-xxl-job-task-execution-failures"><span>17. How do you handle XXL-Job task execution failures?</span></a></h2><p><strong>Answer:</strong><br> To handle failures, we:</p><ol><li>Use a <strong>failover routing strategy</strong> to retry tasks on healthy instances.</li><li>Configure task <strong>retry counts</strong>.</li><li>Enable logging and email alerts to notify stakeholders.</li></ol><hr><h2 id="_18-how-do-you-manage-tasks-with-high-data-volume-in-xxl-job" tabindex="-1"><a class="header-anchor" href="#_18-how-do-you-manage-tasks-with-high-data-volume-in-xxl-job"><span>18. How do you manage tasks with high data volume in XXL-Job?</span></a></h2><p><strong>Answer:</strong><br> We use <strong>sharding broadcast routing</strong> to distribute the workload across multiple instances. The task logic dynamically assigns data partitions based on the shard ID and total shards.</p>',78)]))}]]),s=JSON.parse('{"path":"/posts/interview/3.html","title":"MicroServices and SpringCloud","lang":"en-US","frontmatter":{"icon":"pen-to-square","date":"2024-11-19T00:00:00.000Z","category":["Learning Records"],"tag":["Technical Interview"],"description":"MicroServices and SpringCloud 1. What are the five main components of Spring Cloud? Answer: Initially, the five key components of Spring Cloud were: Eureka: Service registry. Ri...","head":[["meta",{"property":"og:url","content":"https://crc011220.github.io/personalweb/personalweb/posts/interview/3.html"}],["meta",{"property":"og:site_name","content":"Richard Chen"}],["meta",{"property":"og:title","content":"MicroServices and SpringCloud"}],["meta",{"property":"og:description","content":"MicroServices and SpringCloud 1. What are the five main components of Spring Cloud? Answer: Initially, the five key components of Spring Cloud were: Eureka: Service registry. Ri..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2024-11-21T12:08:12.000Z"}],["meta",{"property":"article:tag","content":"Technical Interview"}],["meta",{"property":"article:published_time","content":"2024-11-19T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-11-21T12:08:12.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"MicroServices and SpringCloud\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-11-19T00:00:00.000Z\\",\\"dateModified\\":\\"2024-11-21T12:08:12.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Richard Chen\\"}]}"]]},"headers":[{"level":2,"title":"1. What are the five main components of Spring Cloud?","slug":"_1-what-are-the-five-main-components-of-spring-cloud","link":"#_1-what-are-the-five-main-components-of-spring-cloud","children":[]},{"level":2,"title":"2. What is service registration and discovery? How does Spring Cloud implement it?","slug":"_2-what-is-service-registration-and-discovery-how-does-spring-cloud-implement-it","link":"#_2-what-is-service-registration-and-discovery-how-does-spring-cloud-implement-it","children":[]},{"level":2,"title":"3. What are the differences between Nacos and Eureka?","slug":"_3-what-are-the-differences-between-nacos-and-eureka","link":"#_3-what-are-the-differences-between-nacos-and-eureka","children":[]},{"level":2,"title":"4. How is load balancing implemented in your project?","slug":"_4-how-is-load-balancing-implemented-in-your-project","link":"#_4-how-is-load-balancing-implemented-in-your-project","children":[]},{"level":2,"title":"5. What are the load balancing strategies provided by Ribbon?","slug":"_5-what-are-the-load-balancing-strategies-provided-by-ribbon","link":"#_5-what-are-the-load-balancing-strategies-provided-by-ribbon","children":[]},{"level":2,"title":"6. How do you customize Ribbon\'s load balancing strategy?","slug":"_6-how-do-you-customize-ribbon-s-load-balancing-strategy","link":"#_6-how-do-you-customize-ribbon-s-load-balancing-strategy","children":[]},{"level":2,"title":"7. What is service avalanche, and how do you address it?","slug":"_7-what-is-service-avalanche-and-how-do-you-address-it","link":"#_7-what-is-service-avalanche-and-how-do-you-address-it","children":[]},{"level":2,"title":"8. How do you monitor your microservices?","slug":"_8-how-do-you-monitor-your-microservices","link":"#_8-how-do-you-monitor-your-microservices","children":[]},{"level":2,"title":"9. Have you implemented rate-limiting in your project? How?","slug":"_9-have-you-implemented-rate-limiting-in-your-project-how","link":"#_9-have-you-implemented-rate-limiting-in-your-project-how","children":[]},{"level":2,"title":"10. What are common rate-limiting algorithms?","slug":"_10-what-are-common-rate-limiting-algorithms","link":"#_10-what-are-common-rate-limiting-algorithms","children":[]},{"level":2,"title":"11. What is the CAP theorem?","slug":"_11-what-is-the-cap-theorem","link":"#_11-what-is-the-cap-theorem","children":[]},{"level":2,"title":"12. Why can\'t distributed systems guarantee both consistency and availability?","slug":"_12-why-can-t-distributed-systems-guarantee-both-consistency-and-availability","link":"#_12-why-can-t-distributed-systems-guarantee-both-consistency-and-availability","children":[]},{"level":2,"title":"13. What is the BASE theorem?","slug":"_13-what-is-the-base-theorem","link":"#_13-what-is-the-base-theorem","children":[]},{"level":2,"title":"14. What distributed transaction solution do you use?","slug":"_14-what-distributed-transaction-solution-do-you-use","link":"#_14-what-distributed-transaction-solution-do-you-use","children":[]},{"level":2,"title":"15. How do you ensure idempotency in distributed service interfaces?","slug":"_15-how-do-you-ensure-idempotency-in-distributed-service-interfaces","link":"#_15-how-do-you-ensure-idempotency-in-distributed-service-interfaces","children":[]},{"level":2,"title":"16. What routing strategies does XXL-Job support?","slug":"_16-what-routing-strategies-does-xxl-job-support","link":"#_16-what-routing-strategies-does-xxl-job-support","children":[]},{"level":2,"title":"17. How do you handle XXL-Job task execution failures?","slug":"_17-how-do-you-handle-xxl-job-task-execution-failures","link":"#_17-how-do-you-handle-xxl-job-task-execution-failures","children":[]},{"level":2,"title":"18. How do you manage tasks with high data volume in XXL-Job?","slug":"_18-how-do-you-manage-tasks-with-high-data-volume-in-xxl-job","link":"#_18-how-do-you-manage-tasks-with-high-data-volume-in-xxl-job","children":[]}],"git":{"createdTime":1732019655000,"updatedTime":1732190892000,"contributors":[{"name":"Ruochen Chen","email":"ruocchen1220@gmail.com","commits":2}]},"readingTime":{"minutes":3.41,"words":1023},"filePathRelative":"posts/interview/3.md","localizedDate":"November 19, 2024","excerpt":"\\n<h2>1. What are the five main components of Spring Cloud?</h2>\\n<p><strong>Answer:</strong><br>\\nInitially, the five key components of Spring Cloud were:</p>\\n<ul>\\n<li><strong>Eureka</strong>: Service registry.</li>\\n<li><strong>Ribbon</strong>: Client-side load balancer.</li>\\n<li><strong>Feign</strong>: Declarative service invocation.</li>\\n<li><strong>Hystrix</strong>: Circuit breaker.</li>\\n<li><strong>Zuul/Gateway</strong>: API gateway.</li>\\n</ul>","autoDesc":true}')}}]);