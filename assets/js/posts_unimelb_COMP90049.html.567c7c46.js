"use strict";(self.webpackChunkpersonalweb=self.webpackChunkpersonalweb||[]).push([[434],{3864:(e,t,a)=>{a.r(t),a.d(t,{comp:()=>g,data:()=>p});var i=a(641);const n=a.p+"assets/img/matrix-multiplication.014b9a1e.png",s=a.p+"assets/img/vector-norm.36eacd69.png",r=a.p+"assets/img/Inverse-Distance.857bdd2b.png",o=a.p+"assets/img/Marginalization.4e6857d9.png",l=a.p+"assets/img/Decision-Tree-Example.6ee2db6e.png",d=a.p+"assets/img/Entropy-Example.6d4874bc.png",c=a.p+"assets/img/Naive-Bayes-Example-1-1.2ea50406.png",h=a.p+"assets/img/Naive-Bayes-Example-1-2.b15986db.png",u={},g=(0,a(6262).A)(u,[["render",function(e,t){return(0,i.uX)(),(0,i.CE)("div",null,t[0]||(t[0]=[(0,i.Fv)('<h1 id="introduction-to-machine-learning-comp90049" tabindex="-1"><a class="header-anchor" href="#introduction-to-machine-learning-comp90049"><span>Introduction to Machine Learning (COMP90049)</span></a></h1><h2 id="week-1" tabindex="-1"><a class="header-anchor" href="#week-1"><span>Week 1</span></a></h2><ul><li>Machine learning is a method of teaching software to learn from data and make decisions on their own, without being explicitly programmed.</li></ul><h3 id="three-ingredients-for-machine-learning" tabindex="-1"><a class="header-anchor" href="#three-ingredients-for-machine-learning"><span>Three ingredients for machine learning</span></a></h3><ol><li><p>Data â€¢ Discrete vs continuous vs ... â€¢ Big data vs small data â€¢ Labeled data vs unlabeled data â€¢ Public vs sensitive data</p></li><li><p>Models â€¢ function mapping from inputs to outputs â€¢ probabilistic machine learning models â€¢ geometric machine learning models â€¢ parameters of the function are unknown</p></li><li><p>Learning â€¢ Improving (on a task) after data is taken into account â€¢ Finding the best model parameters (for a given task) â€¢ Supervised vs. unsupervised learning</p></li></ol><div class="hint-container info"><p class="hint-container-title">Info</p><p>Supervised Learning:ç›‘ç£å­¦ä¹ ä½¿ç”¨å¸¦æœ‰æ ‡ç­¾çš„æ•°æ®è¿›è¡Œè®­ç»ƒï¼Œæ¨¡å‹å­¦ä¹ è¾“å…¥ï¼ˆfeaturesï¼‰åˆ°è¾“å‡ºï¼ˆlabelsï¼‰ä¹‹é—´çš„æ˜ å°„å…³ç³»ã€‚ Unsupervised Learning:æ— ç›‘ç£å­¦ä¹ ä½¿ç”¨æ²¡æœ‰æ ‡ç­¾çš„æ•°æ®ï¼Œæ¨¡å‹é€šè¿‡åˆ†ææ•°æ®çš„æ¨¡å¼å’Œç»“æ„æ¥è¿›è¡Œå­¦ä¹ ã€‚</p></div><h3 id="linear-algebra-review" tabindex="-1"><a class="header-anchor" href="#linear-algebra-review"><span>Linear Algebra Review</span></a></h3><h4 id="matrices" tabindex="-1"><a class="header-anchor" href="#matrices"><span>Matrices</span></a></h4><ul><li>Matrices addition/subtraction: Add(Subtract) correspond ingentries in A and B</li><li>Matrix multiplication: Multiply corresponding entries in A and B and sum the products <img src="'+n+'" alt="Matrix Multiplication" loading="lazy"></li><li>Matrix transpose: Transpose of a matrix is obtained by interchanging its rows and columns. Matrix is <strong>symmetric</strong> if it is equal to its transpose.</li><li>Matrix inverse: The inverse of a matrix A is denoted by A^-1 and is obtained by multiplying A by its inverse.</li><li>A matrix cannot be inverted if: More rows than columns, More columns than rows,Redundant rows/columns (linear independence)</li></ul><h4 id="vectors" tabindex="-1"><a class="header-anchor" href="#vectors"><span>Vectors</span></a></h4><ul><li>A vector is a matrix with several rows and <strong>one</strong> column</li><li>Vector addition/subtraction: Add(Subtract) corresponding entries in A and B</li><li>Vector inner product: Multiply corresponding entries in A and B and sum the products</li><li>Vector Euclidean norm: The square root of the sum of the squares of the entries in the vector. <img src="'+s+'" alt="Verctor Euclidean Norm" loading="lazy"></li><li>Vector inner product: The dot product of two vectors A and B is the sum of the products of their corresponding entries.</li><li>The cosine of the angle between two vectors can be found by using norms and the inner product</li></ul><h3 id="instances-attributes-and-learning-paradigms-supervised-vs-unsupervised-learning" tabindex="-1"><a class="header-anchor" href="#instances-attributes-and-learning-paradigms-supervised-vs-unsupervised-learning"><span>Instances, Attributes, and Learning Paradigms (Supervised vs. Unsupervised Learning)</span></a></h3><ul><li>In ML terminology examples are called Instances</li><li>Each instance can have some Features or Attributes</li><li>Concepts are things that we aim to learn. Generally, in the form of labels or classes</li></ul><h4 id="unsupervised-do-not-have-access-to-an-inventory-of-classes-and-instead-discover-groups-of-similar-examples-in-a-given-dataset" tabindex="-1"><a class="header-anchor" href="#unsupervised-do-not-have-access-to-an-inventory-of-classes-and-instead-discover-groups-of-similar-examples-in-a-given-dataset"><span>Unsupervised do not have access to an inventory of classes and instead discover groups of â€˜similarâ€™ examples in a given dataset.</span></a></h4><ul><li>Clustering is unsupervised â€” the learner operates without a set of labelled training data</li><li><strong>Success is often measured subjectively; evaluation is problematic</strong></li></ul><h4 id="supervised-methods-have-prior-knowledge-of-classes-and-set-out-to-discover-and-categorise-new-instances-according-to-those-classes" tabindex="-1"><a class="header-anchor" href="#supervised-methods-have-prior-knowledge-of-classes-and-set-out-to-discover-and-categorise-new-instances-according-to-those-classes"><span>Supervised methods have prior knowledge of classes and set out to discover and categorise new instances according to those classes</span></a></h4><ul><li>Classification learning is supervised â€¢ In Classification, we can exhaustively list/enumerate all possible labels for a given instance; a correct prediction entails mapping an instance to the label which is truly correct</li><li>Regression learning is supervised â€¢ In Regression,&quot;infinitely&quot; many labels are possible, we cannot conceivably enumerate them; a â€œcorrectâ€ prediction is when the numeric value is acceptably close to the true value</li></ul><h3 id="featured-data-types" tabindex="-1"><a class="header-anchor" href="#featured-data-types"><span>Featured Data Types</span></a></h3><ol><li>Discrete: Nominal (Categorical)</li></ol><ul><li>Values are distinct symbols, values themselves serve only as labels or names</li><li>No relation is implied among nominal values (no ordering or distance measure)</li><li>Only equality tests can be performed</li><li>e.g. Student Number</li></ul><ol start="2"><li>Ordinal</li></ol><ul><li>An explicit order is imposed on the values</li><li>Addition and subtraction does not make sense</li><li>e.g. Educational Level</li></ul><ol start="3"><li>Continuous: Numeric</li></ol><ul><li>Numeric quantities are real-valued attributes</li><li>All mathematical operations are allowed</li></ul><h2 id="equal-width-vs-equal-frequency-vs-clustering" tabindex="-1"><a class="header-anchor" href="#equal-width-vs-equal-frequency-vs-clustering"><span>Equal Width vs. Equal Frequency vs. Clustering</span></a></h2><table><thead><tr><th>Method</th><th>Equal Width Binning</th><th>Equal Frequency Binning</th><th>Clustering</th></tr></thead><tbody><tr><td><strong>Definition</strong></td><td>Each bin has the same width</td><td>Each bin contains the same number of data points</td><td>Groups data points based on similarity</td></tr><tr><td><strong>Type</strong></td><td>Data discretization</td><td>Data discretization</td><td>Unsupervised learning</td></tr><tr><td><strong>Advantages</strong></td><td>Easy to compute, simple</td><td>Suitable for skewed distributions</td><td>Can detect natural groupings in data</td></tr><tr><td><strong>Disadvantages</strong></td><td>Sparse or dense bins if data density varies</td><td>Uneven bin width, harder to interpret</td><td>May require tuning (e.g., number of clusters)</td></tr><tr><td><strong>Common Algorithms</strong></td><td>Fixed width intervals</td><td>Quantiles-based binning</td><td>K-Means, DBSCAN, Hierarchical Clustering</td></tr><tr><td><strong>Use Cases</strong></td><td>Histogram creation, feature engineering</td><td>Handling skewed data in ML models</td><td>Customer segmentation, anomaly detection</td></tr></tbody></table><div class="hint-container info"><p class="hint-container-title">Info</p><p>Equal Width Binningï¼šç”¨äºç®€å•ç¦»æ•£åŒ–ï¼Œæ¯ä¸ª bin å®½åº¦ç›¸åŒï¼Œä½†å¯èƒ½ä¼šå¯¼è‡´æ•°æ®å¯†åº¦ä¸å‡è¡¡ã€‚ Equal Frequency Binningï¼šæ¯ä¸ª bin çš„æ•°æ®é‡ç›¸ç­‰ï¼Œé€‚åˆå¤„ç†åæ€æ•°æ®ï¼Œä½† bin çš„å®½åº¦ä¸ä¸€è‡´ï¼Œå¯èƒ½éš¾ä»¥è§£é‡Šã€‚ Clusteringï¼ˆèšç±»ï¼‰ï¼šç”¨äºæ— ç›‘ç£å­¦ä¹ ï¼Œæ ¹æ®æ•°æ®ç‚¹çš„ç›¸ä¼¼æ€§è‡ªåŠ¨åˆ†ç»„ï¼Œé€‚åˆå‘ç°éšè—æ¨¡å¼ï¼Œä½†é€šå¸¸éœ€è¦è°ƒæ•´å‚æ•°ï¼ˆå¦‚ k å€¼ï¼‰ã€‚</p></div><h2 id="standardization-vs-normalization" tabindex="-1"><a class="header-anchor" href="#standardization-vs-normalization"><span>Standardization vs. Normalization</span></a></h2><table><thead><tr><th><strong>Method</strong></th><th><strong>Standardization (Z-score)</strong></th><th><strong>Min-Max Normalization</strong></th></tr></thead><tbody><tr><td><strong>Formula</strong></td><td>( X&#39; = \\frac{X - \\mu}{\\sigma} )</td><td>( X&#39; = \\frac{X - X_{\\min}}{X_{\\max} - X_{\\min}} )</td></tr><tr><td><strong>Range</strong></td><td>Mean = 0, Std = 1</td><td>[0,1] or [-1,1]</td></tr><tr><td><strong>Best for</strong></td><td>Normally distributed data</td><td>Data with fixed bounds</td></tr><tr><td><strong>Sensitive to outliers?</strong></td><td>Less sensitive</td><td>More sensitive</td></tr><tr><td><strong>Formula</strong></td><td>(X - mean) / std</td><td>(X - min) / (max - min)</td></tr></tbody></table><div class="hint-container info"><p class="hint-container-title">Info</p><p>Standardizationï¼šå°†æ•°æ®æ ‡å‡†åŒ–åˆ°å‡å€¼ä¸º 0ï¼Œæ ‡å‡†å·®ä¸º 1 çš„åˆ†å¸ƒï¼Œé€‚ç”¨äºæ­£æ€åˆ†å¸ƒçš„æ•°æ®ã€‚ Normalizationï¼šå°†æ•°æ®ç¼©æ”¾åˆ° [0,1] æˆ– [-1,1] èŒƒå›´å†…ï¼Œé€‚ç”¨äºæ•°æ®èŒƒå›´å›ºå®šçš„æ•°æ®ã€‚</p></div><h2 id="week-2" tabindex="-1"><a class="header-anchor" href="#week-2"><span>Week 2</span></a></h2><h3 id="k-nearest-neighbors-knn" tabindex="-1"><a class="header-anchor" href="#k-nearest-neighbors-knn"><span>K-Nearest Neighbors (KNN)</span></a></h3><ul><li>supervied learning algorithm</li></ul><h4 id="knn-classification" tabindex="-1"><a class="header-anchor" href="#knn-classification"><span>KNN Classification</span></a></h4><p>â€¢ Return the most common class label among neighbors â€¢ Example: cat vs dog images; text classification; ...</p><h4 id="knn-regression" tabindex="-1"><a class="header-anchor" href="#knn-regression"><span>KNN Regression</span></a></h4><p>â€¢ Return the average value of among K nearest neighbors â€¢ Example: housing price prediction;</p><h4 id="to-measure-categorical-distance-we-can-use" tabindex="-1"><a class="header-anchor" href="#to-measure-categorical-distance-we-can-use"><span>To measure categorical distance, we can use:</span></a></h4><ul><li>Hamming distance: number of positions where the two strings differ</li><li>Jaccard Similarity: intersection over union of two sets</li></ul><h4 id="to-measure-numerical-distance-we-can-use" tabindex="-1"><a class="header-anchor" href="#to-measure-numerical-distance-we-can-use"><span>To measure numerical distance, we can use:</span></a></h4><ul><li>Manhattan distance: sum of absolute differences between corresponding components</li><li>Euclidean distance: square root of the sum of the squares of the differences between corresponding components</li><li>Cosine distance: 1 minus the cosine of the angle between two vectors</li></ul><h4 id="to-measure-oridinal-distance-we-can-use" tabindex="-1"><a class="header-anchor" href="#to-measure-oridinal-distance-we-can-use"><span>To measure oridinal distance, we can use:</span></a></h4><ul><li>Normalized Ranks: rank each value and normalize them to [0, 1]</li></ul><h4 id="majority-vote" tabindex="-1"><a class="header-anchor" href="#majority-vote"><span>Majority Vote</span></a></h4><h4 id="inverse-distance" tabindex="-1"><a class="header-anchor" href="#inverse-distance"><span>Inverse Distance</span></a></h4><ul><li>Give more weight to the nearer neighbors rather than quantity.</li><li>The bigger the weight, the more important the neighbor is. <img src="'+r+'" alt="Inverse Distance" loading="lazy"></li></ul><h4 id="inverse-linear-distance" tabindex="-1"><a class="header-anchor" href="#inverse-linear-distance"><span>Inverse Linear Distance</span></a></h4><ul><li>Give more weight to the nearer neighbors, but with a decreasing slope.</li><li>The bigger the weight, the more important the neighbor is.</li></ul><h4 id="value-of-k" tabindex="-1"><a class="header-anchor" href="#value-of-k"><span>Value of K</span></a></h4><table><thead><tr><th><strong>K Value</strong></th><th><strong>Bias</strong></th><th><strong>Variance</strong></th><th><strong>Overfitting</strong></th><th><strong>Underfitting</strong></th><th><strong>Best For</strong></th></tr></thead><tbody><tr><td><strong>Small K</strong> (e.g., K=1, K=3)</td><td><strong>Low Bias</strong>: The model can closely follow the data.</td><td><strong>High Variance</strong>: Sensitive to noise and outliers.</td><td>Likely to overfit due to high sensitivity to small fluctuations in the training data.</td><td>Unlikely to underfit unless the data is too noisy or simple.</td><td>- Complex data with clear patterns<br> - When the dataset is relatively small.</td></tr><tr><td><strong>Large K</strong> (e.g., K=10, K=20)</td><td><strong>High Bias</strong>: The model becomes less sensitive to variations in the data.</td><td><strong>Low Variance</strong>: Smoothing out the noise by considering more neighbors.</td><td>Less likely to overfit as it smooths out fluctuations.</td><td>Might underfit if the data has complex relationships or non-linear patterns.</td><td>- Noisy data<br> - When a generalization is more important than capturing every detail.</td></tr><tr><td><strong>Medium K</strong> (e.g., K=5, K=7)</td><td>A balanced approach with moderate bias.</td><td>Balanced variance, aiming for generalization.</td><td>Minimizes both overfitting and underfitting.</td><td>Good compromise between bias and variance.</td><td>- Standard choice for most datasets, balancing generalization and accuracy.</td></tr></tbody></table><h4 id="why-knn" tabindex="-1"><a class="header-anchor" href="#why-knn"><span>Why KNN</span></a></h4><ul><li>Pros â€¢ Intuitive and simple â€¢ No assumptions â€¢ Supports classification and regression â€¢ No training: new data â†’evolve and adapt immediately</li><li>Cons â€¢ How to decide on best distance functions? â€¢ How to combine multiple neighbors? â€¢ How to select K ? â€¢ Expensive with large (or growing) data sets</li></ul><h4 id="lazy-learning-vs-eager-learning" tabindex="-1"><a class="header-anchor" href="#lazy-learning-vs-eager-learning"><span>Lazy Learning vs. Eager Learning</span></a></h4><table><thead><tr><th>Criteria</th><th>Lazy Learning (e.g., KNN)</th><th>Eager Learning</th></tr></thead><tbody><tr><td><strong>Definition</strong></td><td>Delays learning until a query is made</td><td>Learns from the training data immediately</td></tr><tr><td><strong>Training Phase</strong></td><td>Fast (no model building)</td><td>Slow (model is built during training)</td></tr><tr><td><strong>Prediction Phase</strong></td><td>Slow (requires processing the entire dataset)</td><td>Fast (uses the pre-built model)</td></tr><tr><td><strong>Memory Requirement</strong></td><td>High (stores the entire training dataset)</td><td>Lower (only stores the model)</td></tr><tr><td><strong>Flexibility</strong></td><td>High (can adapt to new data easily)</td><td>Low (requires retraining for new data)</td></tr><tr><td><strong>Example</strong></td><td>K-Nearest Neighbors (KNN)</td><td>Decision Trees, Neural Networks</td></tr></tbody></table><h3 id="probility" tabindex="-1"><a class="header-anchor" href="#probility"><span>Probility</span></a></h3><ul><li>P(A=a): the probability that random variable A takes value a</li><li>0 &lt;= P(A=a) &lt;= 1</li><li>P(True) = 1</li><li>P(False) = 0</li></ul><h4 id="joint-probability" tabindex="-1"><a class="header-anchor" href="#joint-probability"><span>Joint Probability</span></a></h4><ul><li>P(A, B): joint probability of two events A and B</li><li>the probability of both A and B occurring = P(A âˆ© B)</li></ul><h4 id="conditional-probability" tabindex="-1"><a class="header-anchor" href="#conditional-probability"><span>Conditional Probability</span></a></h4><ul><li>P(A|B): the probability of A occurring given that B has occurred</li><li>P(A|B) = P(A âˆ© B) / P(B)</li></ul><h4 id="independent-probability" tabindex="-1"><a class="header-anchor" href="#independent-probability"><span>Independent Probability</span></a></h4><ul><li>Two events A and B are independent if P(A|B) = P(A)</li><li>P(A, B) = P(A) * P(B)</li></ul><div class="hint-container info"><p class="hint-container-title">Info</p><h4 id="disjoint" tabindex="-1"><a class="header-anchor" href="#disjoint"><span>Disjoint</span></a></h4><ul><li>P(Aâˆ©B)=0</li></ul><h4 id="product-rule" tabindex="-1"><a class="header-anchor" href="#product-rule"><span>Product Rule</span></a></h4><ul><li>P(A, B) = P(A|B) * P(B) = P(B|A) * P(A)</li></ul><h4 id="chain-rule" tabindex="-1"><a class="header-anchor" href="#chain-rule"><span>Chain Rule</span></a></h4><ul><li>P(A,B,C)=P(A)â‹…P(Bâˆ£A)â‹…P(Câˆ£A,B)</li></ul></div><h4 id="bayes-rule" tabindex="-1"><a class="header-anchor" href="#bayes-rule"><span>Bayes&#39; Rule</span></a></h4><ul><li>P(A|B) = ( P(B|A) * P(A) ) / P(B)</li><li>Bayesâ€™ Rule allows us to compute P(A|B) given knowledge of the â€˜inverseâ€™ probability P(B|A).</li></ul><h4 id="marginalization" tabindex="-1"><a class="header-anchor" href="#marginalization"><span>Marginalization</span></a></h4><figure><img src="'+o+'" alt="Marginalization" tabindex="0" loading="lazy"><figcaption>Marginalization</figcaption></figure><h4 id="probability-distributions" tabindex="-1"><a class="header-anchor" href="#probability-distributions"><span>Probability Distributions</span></a></h4><ul><li>Probability distributions can be discrete or continuous.</li><li>Discrete Random Variable: Takes on a countable number of distinct values (e.g., number of heads in coin flips).</li><li>Continuous Random Variable: Takes on an infinite number of possible values (e.g., height of students).</li></ul><table><thead><tr><th><strong>Distribution</strong></th><th><strong>Type</strong></th><th><strong>Range</strong></th><th><strong>Parameters</strong></th><th><strong>Formula</strong></th><th><strong>Example</strong></th><th><strong>Use Cases</strong></th></tr></thead><tbody><tr><td><strong>Normal</strong></td><td>Continuous</td><td>âˆ’âˆ to +âˆ</td><td>Mean Î¼, Variance ÏƒÂ²</td><td><code>P(x) = (1 / âˆš(2Ï€ÏƒÂ²)) * exp(-((x - Î¼)Â² / (2ÏƒÂ²)))</code></td><td>Human height, exam scores</td><td>Linear regression, Gaussian models</td></tr><tr><td><strong>Bernoulli</strong></td><td>Discrete</td><td>0, 1</td><td>Probability p</td><td><code>P(X = k) = p^k (1 - p)^(1 - k)</code></td><td>Coin flip</td><td>Binary classification</td></tr><tr><td><strong>Binomial</strong></td><td>Discrete</td><td>0 to n</td><td>Number of trials n, Success probability p</td><td><code>P(k) = C(n, k) * p^k * (1 - p)^(n - k)</code></td><td>Number of heads in 10 coin flips</td><td>Binary classification, hypothesis testing</td></tr><tr><td><strong>Multinomial</strong></td><td>Discrete</td><td>0 to n for each category</td><td>Number of trials n, Probabilities pâ‚, ..., pâ‚–</td><td><code>P(xâ‚, ..., xâ‚–) = (n! / (xâ‚!xâ‚‚!...xâ‚–!)) * âˆ(páµ¢^xáµ¢)</code></td><td>Rolling a dice multiple times</td><td>Text classification, NLP</td></tr><tr><td><strong>Categorical</strong></td><td>Discrete</td><td>1 to k</td><td>Probabilities pâ‚, ..., pâ‚–</td><td><code>P(X = i) = páµ¢</code></td><td>Choosing a color from a set of options</td><td>Classification, clustering</td></tr></tbody></table><h2 id="week-3" tabindex="-1"><a class="header-anchor" href="#week-3"><span>Week 3</span></a></h2><h3 id="zero-r" tabindex="-1"><a class="header-anchor" href="#zero-r"><span>Zero-R</span></a></h3><ul><li>A simple baseline model that predicts the most frequent class in the training data.</li></ul><h3 id="one-r" tabindex="-1"><a class="header-anchor" href="#one-r"><span>One-R</span></a></h3><ul><li>Also known as Decision stom</li><li>Uses only one feature (â€œbestâ€ feature) to build a model</li></ul><h3 id="desicion-trees" tabindex="-1"><a class="header-anchor" href="#desicion-trees"><span>Desicion Trees</span></a></h3><figure><img src="'+l+'" alt="Decision Tree Example" tabindex="0" loading="lazy"><figcaption>Decision Tree Example</figcaption></figure><h4 id="id3-iterative-dichotomiser-3" tabindex="-1"><a class="header-anchor" href="#id3-iterative-dichotomiser-3"><span>ID3 (Iterative Dichotomiser 3)</span></a></h4><ul><li>A top-down approach that splits the data into smaller subsets based on the value of a chosen feature.</li></ul><h4 id="entropy-measure-of-uncertainty-the-expected-average-level-of-uncertainty-surprise" tabindex="-1"><a class="header-anchor" href="#entropy-measure-of-uncertainty-the-expected-average-level-of-uncertainty-surprise"><span>Entropy (measure of uncertainty. The expected (average) level of uncertainty (surprise))</span></a></h4><ul><li>For a Low probability event: if it happens, itâ€™s big news! Big surprise! <strong>High information!</strong></li><li>For a High probability event: it was likely to happen anyway. Not very surprising. <strong>Low information!</strong></li><li>Higher H means more uncertain. <img src="'+d+'" alt="Entropy Example" loading="lazy"></li></ul><h4 id="conditional-entropy-measures-the-amount-of-uncertainty-in-x-given-y" tabindex="-1"><a class="header-anchor" href="#conditional-entropy-measures-the-amount-of-uncertainty-in-x-given-y"><span>Conditional Entropy measures the amount of uncertainty in X given Y.</span></a></h4><h4 id="information-gain-measure-of-the-reduction-in-entropy-after-splitting" tabindex="-1"><a class="header-anchor" href="#information-gain-measure-of-the-reduction-in-entropy-after-splitting"><span>Information Gain (measure of the reduction in entropy after splitting)</span></a></h4><ul><li>Information gain measures the reduction in entropy about the target variable achieved by partitioning the data based on a given feature.</li><li>Choose the largest as information gain.</li></ul><h4 id="shortcomings-of-ig" tabindex="-1"><a class="header-anchor" href="#shortcomings-of-ig"><span>Shortcomings of IG</span></a></h4><ul><li>Overfitting: Greedy algorithm may choose a feature that is too specific and does not generalize well to unseen data.</li><li>Gain ratio (GR) reduces the bias for information gain towards highlybranching attributes by normalising relative to the split information</li><li>Split info (SI) is the entropy of a given split (evenness of the distribution ofinstances to attribute values)</li></ul><h3 id="naive-bayes-theory" tabindex="-1"><a class="header-anchor" href="#naive-bayes-theory"><span>Naive Bayes Theory</span></a></h3><div class="hint-container info"><p class="hint-container-title">Info</p><p>arg max: argument of maximum value</p></div><ul><li>Supervied ML method</li></ul><h4 id="example" tabindex="-1"><a class="header-anchor" href="#example"><span>Example:</span></a></h4><p><img src="'+c+'" alt="Naive Bayes Example1-1" loading="lazy"><img src="'+h+'" alt="Naive Bayes Example1-2" loading="lazy"></p><ul><li>If any term P(xm|y ) = 0 then the class probability P(y|x ) = 0</li><li>To solve this: use Laplace smoothing.</li></ul><ol><li>First Solution: We can assign a (small) positive probability ğœ€ to every unseen class-feature combination</li><li>Second Solution: We can add a â€œpseudocountâ€ Î± to each feature count observed during training, often is 1.</li></ol><ul><li>Probabilities are changed drastically when there are few instances; with a large number of instances, the changes are small</li><li>Laplace smoothing (and smoothing in general) <strong>reduces variance</strong> of the NB classifier because it reduces sensitivity to individual (non-)observations in the training data</li></ul><h3 id="different-naive-bayes" tabindex="-1"><a class="header-anchor" href="#different-naive-bayes"><span>Different Naive Bayes</span></a></h3><p>NaÃ¯ve Bayes classifiers have several key variants that differ based on how they model the distribution of features. Below is a comparison of the most common types:</p><table><thead><tr><th>Variant</th><th>Assumption on Feature Distribution</th><th>Use Case</th></tr></thead><tbody><tr><td><strong>Gaussian NaÃ¯ve Bayes (GNB)</strong></td><td>Assumes features follow a Gaussian (normal) distribution.</td><td>Suitable for continuous data, often used in text classification and real-world datasets with normally distributed features.</td></tr><tr><td><strong>Multinomial NaÃ¯ve Bayes (MNB)</strong></td><td>Assumes feature counts follow a multinomial distribution.</td><td>Best for text classification (e.g., spam detection, document classification) where features are word counts or term frequencies.</td></tr><tr><td><strong>Bernoulli NaÃ¯ve Bayes (BNB)</strong></td><td>Assumes binary feature presence (1 = present, 0 = absent).</td><td>Used in binary text classification (e.g., sentiment analysis, spam filtering), where features represent whether a word appears in a document.</td></tr><tr><td><strong>Complement NaÃ¯ve Bayes (CNB)</strong></td><td>A modification of Multinomial NaÃ¯ve Bayes, designed to handle class imbalances.</td><td>Works better for imbalanced datasets and improves accuracy by adjusting feature probabilities.</td></tr><tr><td><strong>Categorical NaÃ¯ve Bayes</strong></td><td>Assumes features are discrete categorical variables.</td><td>Used for classification tasks with categorical inputs that are not necessarily text-based.</td></tr></tbody></table><p>Each variant modifies the way probabilities are calculated based on the data&#39;s nature, making NaÃ¯ve Bayes a flexible and effective algorithm for different types of classification tasks.</p><h3 id="conclusion-of-naive-bayes" tabindex="-1"><a class="header-anchor" href="#conclusion-of-naive-bayes"><span>Conclusion of Naive Bayes</span></a></h3><ol><li>Why does it work given that itâ€™s a blatantly wrong model of the data?</li></ol><ul><li>we donâ€™t need the true distribution over P(y|x ), we just need to be able to identify the most likely outcome</li></ul><ol start="2"><li>Advantages of Naive Bayes</li></ol><ul><li>easy to build and estimate</li><li>easy to scale to many feature dimensions (e.g., words in the vocabulary) and data sizes</li><li>reasonably easy to explain why a specific class was predicted</li><li>good starting point for a classification project</li></ul>',103)]))}]]),p=JSON.parse('{"path":"/posts/unimelb/COMP90049.html","title":"Introduction to Machine Learning (COMP90049)","lang":"en-US","frontmatter":{"icon":"pen-to-square","date":"2025-03-02T00:00:00.000Z","category":["Learning Records"],"tag":["Unimelb"],"description":"Introduction to Machine Learning (COMP90049) Week 1 Machine learning is a method of teaching software to learn from data and make decisions on their own, without being explicitl...","head":[["meta",{"property":"og:url","content":"https://crc011220.github.io/personalweb/personalweb/posts/unimelb/COMP90049.html"}],["meta",{"property":"og:site_name","content":"Richard Chen"}],["meta",{"property":"og:title","content":"Introduction to Machine Learning (COMP90049)"}],["meta",{"property":"og:description","content":"Introduction to Machine Learning (COMP90049) Week 1 Machine learning is a method of teaching software to learn from data and make decisions on their own, without being explicitl..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2025-03-24T06:44:56.000Z"}],["meta",{"property":"article:tag","content":"Unimelb"}],["meta",{"property":"article:published_time","content":"2025-03-02T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-24T06:44:56.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Introduction to Machine Learning (COMP90049)\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-03-02T00:00:00.000Z\\",\\"dateModified\\":\\"2025-03-24T06:44:56.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Richard Chen\\"}]}"]]},"headers":[{"level":2,"title":"Week 1","slug":"week-1","link":"#week-1","children":[{"level":3,"title":"Three ingredients for machine learning","slug":"three-ingredients-for-machine-learning","link":"#three-ingredients-for-machine-learning","children":[]},{"level":3,"title":"Linear Algebra Review","slug":"linear-algebra-review","link":"#linear-algebra-review","children":[]},{"level":3,"title":"Instances, Attributes, and Learning Paradigms (Supervised vs. Unsupervised Learning)","slug":"instances-attributes-and-learning-paradigms-supervised-vs-unsupervised-learning","link":"#instances-attributes-and-learning-paradigms-supervised-vs-unsupervised-learning","children":[]},{"level":3,"title":"Featured Data Types","slug":"featured-data-types","link":"#featured-data-types","children":[]}]},{"level":2,"title":"Equal Width vs. Equal Frequency vs. Clustering","slug":"equal-width-vs-equal-frequency-vs-clustering","link":"#equal-width-vs-equal-frequency-vs-clustering","children":[]},{"level":2,"title":"Standardization vs. Normalization","slug":"standardization-vs-normalization","link":"#standardization-vs-normalization","children":[]},{"level":2,"title":"Week 2","slug":"week-2","link":"#week-2","children":[{"level":3,"title":"K-Nearest Neighbors (KNN)","slug":"k-nearest-neighbors-knn","link":"#k-nearest-neighbors-knn","children":[]},{"level":3,"title":"Probility","slug":"probility","link":"#probility","children":[]}]},{"level":2,"title":"Week 3","slug":"week-3","link":"#week-3","children":[{"level":3,"title":"Zero-R","slug":"zero-r","link":"#zero-r","children":[]},{"level":3,"title":"One-R","slug":"one-r","link":"#one-r","children":[]},{"level":3,"title":"Desicion Trees","slug":"desicion-trees","link":"#desicion-trees","children":[]},{"level":3,"title":"Naive Bayes Theory","slug":"naive-bayes-theory","link":"#naive-bayes-theory","children":[]},{"level":3,"title":"Different Naive Bayes","slug":"different-naive-bayes","link":"#different-naive-bayes","children":[]},{"level":3,"title":"Conclusion of Naive Bayes","slug":"conclusion-of-naive-bayes","link":"#conclusion-of-naive-bayes","children":[]}]}],"git":{"createdTime":1740916663000,"updatedTime":1742798696000,"contributors":[{"name":"Ruochen Chen","email":"ruocchen1220@gmail.com","commits":5}]},"readingTime":{"minutes":8.15,"words":2446},"filePathRelative":"posts/unimelb/COMP90049.md","localizedDate":"March 2, 2025","excerpt":"\\n<h2>Week 1</h2>\\n<ul>\\n<li>Machine learning is a method of teaching software to learn from data and make decisions on their own, without being explicitly programmed.</li>\\n</ul>\\n<h3>Three ingredients for machine learning</h3>\\n<ol>\\n<li>\\n<p>Data\\nâ€¢ Discrete vs continuous vs ...\\nâ€¢ Big data vs small data\\nâ€¢ Labeled data vs unlabeled data\\nâ€¢ Public vs sensitive data</p>\\n</li>\\n<li>\\n<p>Models\\nâ€¢ function mapping from inputs to outputs\\nâ€¢ probabilistic machine learning models\\nâ€¢ geometric machine learning models\\nâ€¢ parameters of the function are unknown</p>\\n</li>\\n<li>\\n<p>Learning\\nâ€¢ Improving (on a task) after data is taken into account\\nâ€¢ Finding the best model parameters (for a given task)\\nâ€¢ Supervised vs. unsupervised learning</p>\\n</li>\\n</ol>","autoDesc":true}')},6262:(e,t)=>{t.A=(e,t)=>{const a=e.__vccOpts||e;for(const[e,i]of t)a[e]=i;return a}}}]);