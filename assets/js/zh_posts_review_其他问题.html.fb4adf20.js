"use strict";(self.webpackChunkpersonalweb=self.webpackChunkpersonalweb||[]).push([[4582],{4542:(t,s,i)=>{i.r(s),i.d(s,{comp:()=>l,data:()=>d});var a=i(641);const n={},l=(0,i(6262).A)(n,[["render",function(t,s){return(0,a.uX)(),(0,a.CE)("div",null,s[0]||(s[0]=[(0,a.Fv)('<h1 id="其他问题" tabindex="-1"><a class="header-anchor" href="#其他问题"><span>其他问题</span></a></h1><h2 id="mysql-buffer-pool里都有什么" tabindex="-1"><a class="header-anchor" href="#mysql-buffer-pool里都有什么"><span>MySQL Buffer Pool里都有什么？</span></a></h2><p>MySQL 的 Buffer Pool（缓冲池）是 InnoDB 存储引擎中<strong>最核心的内存区域</strong>，主要用于缓存磁盘上的数据页，加速数据读写。</p><table><thead><tr><th>类型</th><th>说明/作用</th></tr></thead><tbody><tr><td>数据页（Data Page）</td><td>存储表的实际数据行</td></tr><tr><td>索引页（Index Page）</td><td>存储 B+ 树索引节点</td></tr><tr><td>Undo 页</td><td>存储回滚日志，支持事务和 MVCC</td></tr><tr><td>Change Buffer 页</td><td>缓存二级索引的变更操作，提升插入效率</td></tr><tr><td>自适应哈希索引</td><td>热点数据自动生成哈希索引，加速查询</td></tr><tr><td>锁信息</td><td>记录锁定信息，支持并发控制</td></tr><tr><td>数据字典信息</td><td>缓存表结构、索引结构等元数据</td></tr></tbody></table><h2 id="redis底层相关数据结构了解吗" tabindex="-1"><a class="header-anchor" href="#redis底层相关数据结构了解吗"><span>Redis底层相关数据结构了解吗？</span></a></h2><table><thead><tr><th>底层结构</th><th>主要用途/描述</th><th>典型应用类型</th><th>优点</th><th>缺点</th><th>适用场景/切换条件</th></tr></thead><tbody><tr><td>SDS</td><td>动态字符串存储</td><td>string、key</td><td>安全高效，支持二进制（图片），长度可变</td><td>仅适合字符串</td><td>所有字符串、key 名称</td></tr><tr><td>ziplist</td><td>紧凑连续内存，存小对象</td><td>list、hash、zset</td><td>占用内存小，遍历快</td><td>插入/删除慢，数据多时效率低</td><td>元素数量少且小（如list&lt;8、元素&lt;64B）</td></tr><tr><td>listpack</td><td>新一代紧凑结构，比ziplist更高效</td><td>stream、list</td><td>更省空间，结构简单</td><td>只适合小数据量</td><td>stream entries、list小数据量</td></tr><tr><td>quicklist</td><td>ziplist/listpack链表混合体</td><td>list</td><td>插入/删除快，遍历快，省内存</td><td>结构复杂</td><td>list主力实现，数据量大或有频繁操作</td></tr><tr><td>intset</td><td>整数集合，内存连续</td><td>set</td><td>占用小，查找快</td><td>只支持整数，数量有限</td><td>set全为整数且数量少（&lt;512）</td></tr><tr><td>dict</td><td>哈希表，key-value结构</td><td>hash、set、zset</td><td>查找/插入/删除快，扩容灵活</td><td>内存占用大，哈希冲突需处理</td><td>hash/大set/zset、key管理</td></tr><tr><td>skiplist</td><td>多层链表，支持有序和范围查找</td><td>zset</td><td>查找/插入/删除O(logN)，有序遍历快</td><td>内存占用大，结构复杂</td><td>zset大数据量，需排序/范围查找</td></tr><tr><td>链表</td><td>节点指针串联，插入/删除快</td><td>早期list</td><td>插入/删除快，双向遍历</td><td>内存碎片多，查找慢</td><td>早期list实现，现已被quicklist替代</td></tr><tr><td>bitmap</td><td>位数组，布尔状态存储</td><td>签到、活跃统计</td><td>占用极小，适合大规模布尔统计</td><td>只适合0/1状态，操作需位运算</td><td>签到、活跃用户、布隆过滤器</td></tr><tr><td>HyperLogLog</td><td>概率型基数统计</td><td>UV（Unique Visitor）、去重</td><td>极省内存，统计大规模唯一数</td><td>只能估算，不能存具体元素</td><td>UV、去重计数</td></tr></tbody></table><ul><li><strong>压缩结构（ziplist、listpack）</strong>：适合小数据量，省空间。</li><li><strong>链表/quicklist/skiplist</strong>：适合大数据量，插入/删除/查找高效。</li><li><strong>dict/intset</strong>：哈希表和整数集合，分别适合大/小数据量的hash、set。</li><li><strong>bitmap/HyperLogLog</strong>：特殊统计场景，极省内存。</li><li><strong>SDS</strong>：所有字符串和key的底层实现。</li></ul><h2 id="可以基于udp实现可靠通信吗-http3知道吗" tabindex="-1"><a class="header-anchor" href="#可以基于udp实现可靠通信吗-http3知道吗"><span>可以基于UDP实现可靠通信吗？HTTP3知道吗？</span></a></h2><p>虽然 UDP（User Datagram Protocol）本身是<strong>无连接、不可靠</strong>的协议（不保证数据到达、不保证顺序、不重传），但<strong>可以在应用层或传输层之上，通过额外机制实现可靠通信</strong>，常见方法有：</p><ul><li><strong>序列号</strong>：每个数据包加上序号，接收方可检测丢包、乱序。</li><li><strong>确认应答（ACK）</strong>：接收方收到数据后回发确认，发送方未收到ACK则重传。</li><li><strong>超时重传</strong>：发送方在超时未收到ACK时重发数据包。</li><li><strong>滑动窗口</strong>：支持流量控制和有序传输。</li><li><strong>校验和</strong>：保证数据完整性。</li><li><strong>拥塞控制</strong>：防止网络拥堵。</li></ul><p><strong>实际例子</strong>：</p><ul><li>许多实时音视频、游戏、定制协议（如 TFTP、QUIC）都在 UDP 上实现了可靠性机制。</li><li>你可以把“可靠的UDP”理解为“自定义的TCP”。</li></ul><p><strong>HTTP/3 就是基于 UDP 实现可靠通信的典型代表。</strong></p><ul><li><strong>HTTP/3</strong> 是新一代 HTTP 协议，底层基于 <strong>QUIC</strong> 协议。</li><li><strong>QUIC</strong>（Quick UDP Internet Connections）是 Google 推出的基于 UDP 的传输层协议，<strong>实现了可靠传输、拥塞控制、顺序保证、加密等功能</strong>，本质上是“用UDP实现的更快的TCP+TLS”。</li><li>HTTP/3 用 QUIC 替代了 TCP，解决了 TCP 的队头阻塞、慢启动等问题，连接建立更快，抗丢包能力更强，适合现代互联网和移动场景。</li></ul><p><strong>UDP 本身不可靠，但可以通过协议设计实现可靠通信。</strong></p><p><strong>HTTP/3 就是用 UDP + QUIC 实现可靠、高效、安全的 Web 通信。</strong></p><h2 id="项目是基于http吗-为什么要基于http来做-tcp不行吗" tabindex="-1"><a class="header-anchor" href="#项目是基于http吗-为什么要基于http来做-tcp不行吗"><span>项目是基于HTTP吗，为什么要基于HTTP来做，TCP不行吗？</span></a></h2><table><thead><tr><th>对比项</th><th>HTTP（基于TCP之上的应用层协议）</th><th>直接用TCP（传输层协议）</th></tr></thead><tbody><tr><td>协议层级</td><td>应用层（基于TCP）</td><td>传输层</td></tr><tr><td>通用性/标准化</td><td>标准化，全球通用，跨平台、跨语言</td><td>需自定义协议，通用性差</td></tr><tr><td>开发难度</td><td>易用，框架/工具丰富，开发效率高</td><td>需自行处理数据格式、分包、粘包、重传等，开发难度大</td></tr><tr><td>兼容性</td><td>浏览器、APP、API、第三方服务等原生支持</td><td>需自定义客户端/服务端，兼容性差</td></tr><tr><td>网络穿透</td><td>80/443端口易穿透防火墙/代理</td><td>其他端口常被封锁，穿透难</td></tr><tr><td>安全性</td><td>支持HTTPS（加密、认证），安全性高</td><td>需自定义加密/认证，安全性难保障</td></tr><tr><td>生态/工具</td><td>丰富（Postman、curl、API网关、负载均衡等）</td><td>工具少，需自研</td></tr><tr><td>适用场景</td><td>Web开发、API、微服务、移动端、第三方集成等</td><td>游戏、物联网、金融等高性能/定制场景</td></tr><tr><td>典型应用</td><td>网站、RESTful API、微服务、Web应用等</td><td>游戏服务器、实时通信、专用协议等</td></tr></tbody></table><ul><li><strong>HTTP</strong>：开发效率高、通用性强、易于集成和维护，是Web和API开发的首选。</li><li><strong>TCP</strong>：更底层，适合对性能、实时性有极高要求且能自定义协议的特殊场景。</li><li><strong>绝大多数项目选HTTP，是因为它标准化、易用、安全、兼容性好，极大提升开发效率和系统可维护性。</strong></li></ul><h2 id="如果要在分布式中保持强一致性和最终一致性分别有什么做法" tabindex="-1"><a class="header-anchor" href="#如果要在分布式中保持强一致性和最终一致性分别有什么做法"><span>如果要在分布式中保持强一致性和最终一致性分别有什么做法？</span></a></h2><h3 id="一、强一致性-strong-consistency" tabindex="-1"><a class="header-anchor" href="#一、强一致性-strong-consistency"><span>一、强一致性（Strong Consistency）</span></a></h3><p><strong>定义</strong>：<br> 所有节点对同一份数据的读写顺序一致，任何时刻读到的数据都是最新的，像单机一样。</p><p><strong>常见实现方式：</strong></p><table><thead><tr><th>方案/协议</th><th>简要说明</th><th>典型应用场景</th></tr></thead><tbody><tr><td>两段式提交（2PC）</td><td>事务协调者分两阶段通知所有参与者提交或回滚，保证所有节点要么都成功要么都失败</td><td>分布式数据库、分布式事务</td></tr><tr><td>三段式提交（3PC）</td><td>在2PC基础上增加预提交阶段，进一步降低阻塞风险</td><td>理论为主，实际较少用</td></tr><tr><td>Paxos/Raft等一致性协议</td><td>多节点投票达成一致后再提交，保证分布式系统状态同步</td><td>分布式一致性存储、分布式锁</td></tr><tr><td>分布式锁</td><td>通过ZooKeeper、Redis等实现全局锁，保证同一时刻只有一个节点能操作关键资源</td><td>订单扣减、唯一性约束</td></tr><tr><td>单主写入</td><td>只允许一个主节点写入，其他节点只读，保证写入顺序一致</td><td>主从数据库、分布式缓存</td></tr></tbody></table><h3 id="二、最终一致性-eventual-consistency" tabindex="-1"><a class="header-anchor" href="#二、最终一致性-eventual-consistency"><span>二、最终一致性（Eventual Consistency）</span></a></h3><p><strong>定义</strong>：<br> 系统不要求实时一致，只要经过一段时间，所有节点最终能达到一致状态。</p><p><strong>常见实现方式：</strong></p><table><thead><tr><th>方案/协议</th><th>简要说明</th><th>典型应用场景</th></tr></thead><tbody><tr><td>消息队列+异步补偿</td><td>业务操作先写本地，异步通过消息队列通知其他系统，失败后可重试或补偿</td><td>电商订单、库存扣减</td></tr><tr><td>TCC（Try-Confirm-Cancel）</td><td>业务分为三步：预留资源、确认提交、取消补偿，允许部分失败后补偿</td><td>金融、支付、库存等</td></tr><tr><td>Saga模式</td><td>将大事务拆分为多个本地事务，每步有补偿操作，保证最终一致性</td><td>微服务长事务</td></tr><tr><td>本地消息表</td><td>业务操作和消息写入同一数据库事务，消息异步投递，保证消息可靠送达</td><td>订单、支付等</td></tr><tr><td>定时任务/对账</td><td>定期扫描、对账、补偿，修正不一致的数据</td><td>账务、积分、库存等</td></tr></tbody></table><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h3><table><thead><tr><th>一致性类型</th><th>典型方案/协议</th><th>适用场景/特点</th></tr></thead><tbody><tr><td>强一致性</td><td>2PC、3PC、Paxos、Raft、分布式锁</td><td>事务性强、金融、订单、核心数据</td></tr><tr><td>最终一致性</td><td>消息队列、TCC、Saga、本地消息表、定时补偿</td><td>高可用、可容忍短暂不一致、异步业务场景</td></tr></tbody></table><h2 id="redis的事务了解吗-redis的事务和mysql的事务最大的区别在什么地方" tabindex="-1"><a class="header-anchor" href="#redis的事务了解吗-redis的事务和mysql的事务最大的区别在什么地方"><span>Redis的事务了解吗，Redis的事务和MySQL的事务最大的区别在什么地方？</span></a></h2><h3 id="_1-redis-的事务" tabindex="-1"><a class="header-anchor" href="#_1-redis-的事务"><span>1. Redis 的事务</span></a></h3><ul><li><strong>基本命令</strong>：MULTI（开启事务）、EXEC（提交事务）、DISCARD（放弃事务）、WATCH（乐观锁）。</li><li><strong>执行方式</strong>： <ul><li>MULTI 后输入的一系列命令会被依次入队，等 EXEC 时一次性、顺序性地执行。</li><li>事务中的命令<strong>不会中途打断</strong>，但也<strong>不会回滚</strong>。</li></ul></li><li><strong>特性</strong>： <ul><li><strong>原子性</strong>：事务内的命令要么全部执行，要么都不执行（如果用 DISCARD 放弃）。</li><li><strong>不保证隔离性</strong>：事务执行前后，其他客户端可以修改数据（除非用 WATCH 实现乐观锁）。</li><li><strong>无回滚</strong>：事务中某条命令出错（如语法错），整个事务会被丢弃；但如果是运行时错误（如类型错误），其他命令仍会执行，<strong>不会回滚</strong>。</li><li><strong>不支持持久锁定</strong>：没有行级锁、表级锁。</li></ul></li></ul><h3 id="_2-mysql-的事务" tabindex="-1"><a class="header-anchor" href="#_2-mysql-的事务"><span>2. MySQL 的事务</span></a></h3><ul><li><strong>基本命令</strong>：BEGIN/START TRANSACTION、COMMIT、ROLLBACK。</li><li><strong>执行方式</strong>： <ul><li>事务内的 SQL 语句在提交前对外不可见，提交后才生效。</li></ul></li><li><strong>特性</strong>（ACID）： <ul><li><strong>原子性</strong>（Atomicity）：要么全部成功，要么全部失败。</li><li><strong>一致性</strong>（Consistency）：事务前后数据完整性不被破坏。</li><li><strong>隔离性</strong>（Isolation）：并发事务互不干扰（支持多种隔离级别）。</li><li><strong>持久性</strong>（Durability）：提交后数据永久保存。</li></ul></li></ul><h3 id="_3-最大区别" tabindex="-1"><a class="header-anchor" href="#_3-最大区别"><span>3. 最大区别</span></a></h3><table><thead><tr><th>对比项</th><th>Redis 事务</th><th>MySQL 事务</th></tr></thead><tbody><tr><td>原子性</td><td>只保证命令队列的原子性，不保证单条命令的原子性</td><td>保证整个事务的原子性</td></tr><tr><td>隔离性</td><td>无法保证，除非用 WATCH 实现乐观锁</td><td>支持多种隔离级别，强隔离性</td></tr><tr><td>回滚/错误处理</td><td>不支持回滚，命令出错不会自动撤销已执行命令</td><td>支持回滚，出错可撤销整个事务</td></tr><tr><td>持久性</td><td>依赖持久化配置（RDB/AOF），不如MySQL强</td><td>强持久性，写入磁盘保证数据不丢失</td></tr><tr><td>锁机制</td><td>无锁，乐观锁（WATCH）</td><td>支持行锁、表锁等多种锁机制</td></tr><tr><td>适用场景</td><td>高性能、简单原子操作、缓存、计数等</td><td>复杂业务逻辑、强一致性要求的数据操作</td></tr></tbody></table><p><strong>一句话总结</strong>：</p><blockquote><p>Redis 事务不支持回滚和强隔离，主要保证命令的批量顺序执行；MySQL 事务支持完整的ACID特性，能保证强一致性和回滚，是“真正的数据库事务”。</p></blockquote><h2 id="毒性反转是什么-是哪一层的概念" tabindex="-1"><a class="header-anchor" href="#毒性反转是什么-是哪一层的概念"><span>毒性反转是什么？是哪一层的概念？</span></a></h2><p><strong>毒性反转</strong>（Poison Reverse）是一种用于<strong>防止路由环路</strong>的机制，常见于<strong>距离矢量路由协议</strong>（如RIP）。</p><ul><li>当路由器A通过路由器B到达某个网络X时，A会告诉B：“我到X的距离是无穷大（不可达）”，即“把这条路‘毒死’”。</li><li>这样可以防止B再把到X的路由信息传回A，避免A、B之间形成路由环路。</li><li><strong>属于网络层（第三层，Network Layer</strong>的路由协议机制。</li><li>主要用于RIP等距离矢量型路由协议。</li></ul><p><strong>简要记忆</strong>：<br> 毒性反转是网络层的路由环路防止机制，常用于RIP协议。</p><h2 id="死锁和oom如何排查" tabindex="-1"><a class="header-anchor" href="#死锁和oom如何排查"><span>死锁和OOM如何排查</span></a></h2><table><thead><tr><th>问题类型</th><th>排查工具/方法</th><th>关键点/建议</th></tr></thead><tbody><tr><td>死锁</td><td>jstack、jconsole、Arthas、日志分析</td><td>查锁等待链、加锁顺序、避免嵌套锁、可视化分析</td></tr><tr><td>OOM</td><td>jmap、jvisualvm、MAT、GC日志</td><td>导出堆快照、分析大对象/泄漏、优化内存参数、代码审查</td></tr></tbody></table><h2 id="布隆过滤器的原理-什么情况下是误判" tabindex="-1"><a class="header-anchor" href="#布隆过滤器的原理-什么情况下是误判"><span>布隆过滤器的原理？什么情况下是误判？</span></a></h2><ul><li><strong>布隆过滤器（Bloom Filter）<strong>是一种</strong>空间效率极高的概率型数据结构</strong>，用于判断一个元素是否在集合中。 <ul><li>结构：一个很长的二进制位数组（bit array）+ 多个独立的哈希函数。</li></ul></li><li><strong>添加元素</strong>：将元素分别用k个哈希函数计算，得到k个位置，把这些位置的bit都置为1。</li><li><strong>查询元素</strong>：同样用k个哈希函数计算k个位置，只要有一个bit为0，说明元素一定不在集合中；如果都为1，则“可能在集合中”。</li><li><strong>误判（假阳性，False Positive）</strong>：布隆过滤器可能会把“不在集合中的元素”误判为“在集合中”。</li><li>原因：不同元素经过哈希后可能落在同一组bit上，导致查询时所有bit都为1，但其实这些1是其他元素置的。</li><li><strong>不会出现“假阴性”</strong>：即不会把“实际在集合中的元素”误判为“不在集合中”。</li></ul><p><strong>简要记忆</strong>：<br> 布隆过滤器通过多个哈希函数和位数组判断元素是否存在，可能出现“误判存在”，但不会漏判已存在的元素。</p><ul><li>如果数据量不大，直接 Redis 精确判断完全可以。</li><li>如果数据量非常大或者需要高性能判断，布隆过滤器更合适。</li><li>真实场景中常用 Redis + 布隆过滤器：布隆过滤器快速判断可能重复，再去 Redis 做精确判断，兼顾性能和精度。</li></ul><h2 id="jwt组成部分有哪些-怎么配合拦截器实现校验和刷新的-拦截器是怎么做的" tabindex="-1"><a class="header-anchor" href="#jwt组成部分有哪些-怎么配合拦截器实现校验和刷新的-拦截器是怎么做的"><span>JWT组成部分有哪些，怎么配合拦截器实现校验和刷新的，拦截器是怎么做的？</span></a></h2><table><thead><tr><th>步骤</th><th>说明/作用</th></tr></thead><tbody><tr><td>JWT组成</td><td>Header、Payload、Signature</td></tr><tr><td>校验流程</td><td>拦截器获取token，校验签名和过期，放行或拒绝</td></tr><tr><td>刷新机制</td><td>检查token快过期时刷新，或用refresh token换新token</td></tr><tr><td>拦截器实现</td><td>preHandle中解析校验token，失败返回401/403</td></tr></tbody></table><table><thead><tr><th>项目类型</th><th>推荐用法</th><th>原因/说明</th></tr></thead><tbody><tr><td>不用 Spring Security</td><td>拦截器（HandlerInterceptor）</td><td>简单好用，控制请求前置逻辑</td></tr><tr><td>用 Spring Security</td><td>自定义过滤器（Filter）</td><td>更标准，能控制认证与授权流程</td></tr></tbody></table><ul><li>如果你用了 Spring Security，那应该在过滤器链中处理 JWT，因为： <ul><li>拦截器晚于过滤器执行，无法控制 Spring Security 的认证过程</li><li>Spring Security 本身就有过滤器链机制，用来处理认证、授权、异常等</li></ul></li></ul><blockquote><p>JWT由Header、Payload、Signature三部分组成。拦截器通过解析和校验JWT实现接口安全控制，并可结合刷新机制保证用户体验和安全。拦截器一般在preHandle中校验token，校验通过放行，否则拒绝访问。</p></blockquote><h2 id="拦截器和过滤器有什么区别" tabindex="-1"><a class="header-anchor" href="#拦截器和过滤器有什么区别"><span>拦截器和过滤器有什么区别？</span></a></h2><table><thead><tr><th>对比项</th><th>过滤器（Filter）</th><th>拦截器（Interceptor）</th></tr></thead><tbody><tr><td>所属层级</td><td>Servlet规范/容器</td><td>Web框架（如Spring MVC）</td></tr><tr><td>作用范围</td><td>所有请求（包括静态资源）</td><td>仅Controller相关请求</td></tr><tr><td>典型用途</td><td>编码、日志、权限、XSS、CORS等</td><td>登录校验、权限、业务日志、数据预处理等</td></tr><tr><td>实现接口</td><td>javax.servlet.Filter</td><td>org.springframework.web.servlet.HandlerInterceptor</td></tr><tr><td>配置方式</td><td>web.xml/@WebFilter注解</td><td>Spring配置类/注解</td></tr><tr><td>执行时机</td><td>Servlet前后</td><td>Controller前后</td></tr><tr><td>静态资源拦截</td><td>可以</td><td>默认不拦截</td></tr></tbody></table><p><strong>简要记忆</strong>：</p><ul><li><strong>过滤器</strong>：Servlet层，作用广，适合通用处理。</li><li><strong>拦截器</strong>：框架层，作用于业务控制，适合业务相关的请求处理。</li></ul><table><thead><tr><th>阶段</th><th>类型</th><th>方法 / 行为</th></tr></thead><tbody><tr><td>请求到达服务器</td><td></td><td></td></tr><tr><td>🚦 过滤器前置处理</td><td><code>Filter#doFilter()</code>（前）</td><td>比拦截器先执行</td></tr><tr><td>🛡 拦截器前置处理</td><td><code>preHandle()</code></td><td>控制请求是否继续</td></tr><tr><td>🧭 控制器方法执行</td><td><code>@Controller</code></td><td>业务逻辑处理</td></tr><tr><td>🛡 拦截器后置处理</td><td><code>postHandle()</code></td><td>控制器执行完但视图未渲染</td></tr><tr><td>🛡 拦截器完成处理</td><td><code>afterCompletion()</code></td><td>请求完全结束，适合释放资源</td></tr><tr><td>🚦 过滤器收尾处理</td><td><code>Filter#doFilter()</code>（后）</td><td>最后执行</td></tr><tr><td>响应返回客户端</td><td></td><td></td></tr></tbody></table><h2 id="threadlocalmap-的-key-为什么是弱引用" tabindex="-1"><a class="header-anchor" href="#threadlocalmap-的-key-为什么是弱引用"><span>ThreadLocalMap 的 key 为什么是弱引用？</span></a></h2><ul><li><p><strong>防止内存泄漏</strong>。</p></li><li><p>ThreadLocalMap 的 key 是 ThreadLocal 对象的弱引用（WeakReference），value 是强引用。</p></li><li><p>如果 key（ThreadLocal对象）没有外部强引用，GC 时会被回收，避免 ThreadLocal 对象“遗留”在 ThreadLocalMap 里，导致 value 永远无法访问和回收，造成内存泄漏。</p></li><li><p>如果 key 是强引用，即使外部不再使用 ThreadLocal 对象，ThreadLocalMap 还持有它，GC 也不会回收，value 也不会被清理，<strong>内存泄漏风险极大</strong>。</p></li><li><p>用弱引用后，ThreadLocal 对象没外部引用时，key 会被GC回收，ThreadLocalMap 里的 entry 的 key 变成 null，虽然 value 还在，但下次访问/设置/扩容时会自动清理这些“key为null”的 entry，释放 value。</p></li></ul><table><thead><tr><th>设计点</th><th>作用/好处</th></tr></thead><tbody><tr><td>key用弱引用</td><td>ThreadLocal对象无引用时能被GC回收，防止内存泄漏</td></tr><tr><td>value用强引用</td><td>保证数据可用，直到手动remove或key被回收</td></tr></tbody></table><blockquote><p>ThreadLocalMap 的 key 用弱引用，是为了防止 ThreadLocal 对象失去外部引用后无法被GC，避免内存泄漏。ThreadLocalMap 的 key 用弱引用能缓解但不能彻底避免内存泄漏，正确做法是用完 ThreadLocal 后及时 remove()。</p></blockquote><h2 id="mysql锁的原理" tabindex="-1"><a class="header-anchor" href="#mysql锁的原理"><span>MySQL锁的原理</span></a></h2><h3 id="_1-mysql-常见锁类型" tabindex="-1"><a class="header-anchor" href="#_1-mysql-常见锁类型"><span>1. MySQL 常见锁类型</span></a></h3><table><thead><tr><th>锁类型</th><th>说明/作用</th><th>典型应用场景</th></tr></thead><tbody><tr><td>全局锁</td><td>锁住整个数据库实例</td><td>备份、维护等</td></tr><tr><td>表级锁</td><td>锁住整张表</td><td>MyISAM、DDL操作</td></tr><tr><td>行级锁</td><td>锁住单行数据</td><td>InnoDB、事务操作</td></tr><tr><td>意向锁</td><td>标记表中某些行将被加锁，辅助行锁管理</td><td>InnoDB</td></tr><tr><td>间隙锁</td><td>锁定索引区间，防止幻读</td><td>InnoDB、可重复读隔离级别</td></tr><tr><td>临键锁</td><td>行锁+间隙锁的组合，防止插入/幻读</td><td>InnoDB</td></tr></tbody></table><h3 id="_2-不同存储引擎的锁实现" tabindex="-1"><a class="header-anchor" href="#_2-不同存储引擎的锁实现"><span>2. 不同存储引擎的锁实现</span></a></h3><h4 id="myisam-表级锁" tabindex="-1"><a class="header-anchor" href="#myisam-表级锁"><span>MyISAM（表级锁）</span></a></h4><ul><li>只支持表级锁（读锁、写锁），不支持行级锁。</li><li>读写互斥，写锁独占，适合读多写少场景。</li></ul><h4 id="innodb-行级锁、表级锁、意向锁、间隙锁" tabindex="-1"><a class="header-anchor" href="#innodb-行级锁、表级锁、意向锁、间隙锁"><span>InnoDB（行级锁、表级锁、意向锁、间隙锁）</span></a></h4><ul><li><strong>行级锁</strong>：通过索引实现，锁定某一行数据，支持高并发。</li><li><strong>表级锁</strong>：如<code>LOCK TABLES</code>命令。</li><li><strong>意向锁</strong>：事务加行锁前，先加意向锁，标记本事务要对哪些行加锁，便于表锁和行锁兼容。</li><li><strong>间隙锁/临键锁</strong>：<strong>防止幻读</strong>，锁定索引区间，保证可重复读。</li></ul><h3 id="_3-行级锁的实现原理-innodb" tabindex="-1"><a class="header-anchor" href="#_3-行级锁的实现原理-innodb"><span>3. 行级锁的实现原理（InnoDB）</span></a></h3><ul><li><strong>基于索引实现</strong>：InnoDB 的行锁是加在索引上的，而不是加在物理行上。</li><li><strong>加锁方式</strong>： <ul><li><strong>共享锁（S锁）</strong>：允许多个事务读同一行，不能写。</li><li><strong>排他锁（X锁）</strong>：允许事务修改/删除一行，其他事务不能读写。</li></ul></li><li><strong>加锁粒度</strong>： <ul><li>精确到索引记录，非索引列加锁会退化为表锁。</li></ul></li><li><strong>锁的存储</strong>： <ul><li>InnoDB 通过<strong>锁信息结构</strong>在内存中维护锁状态，挂在事务对象上。</li></ul></li></ul><h3 id="_4-间隙锁-临键锁的实现原理" tabindex="-1"><a class="header-anchor" href="#_4-间隙锁-临键锁的实现原理"><span>4. 间隙锁/临键锁的实现原理</span></a></h3><ul><li><strong>间隙锁（Gap Lock）</strong>：锁定一个区间，防止其他事务在该区间插入新记录，解决幻读问题。</li><li><strong>临键锁（Next-Key Lock）</strong>：锁定当前索引记录+区间，防止并发插入/幻读。</li><li>只有在 **可重复读（REPEATABLE READ）**隔离级别下才会自动加间隙锁/临键锁。</li></ul><h3 id="_5-意向锁的实现原理" tabindex="-1"><a class="header-anchor" href="#_5-意向锁的实现原理"><span>5. 意向锁的实现原理</span></a></h3><ul><li><strong>表级的标记锁</strong>，用于标记事务将要对表中哪些行加锁。</li><li>便于表锁和行锁的兼容与冲突检测，提高加锁效率。</li></ul><h3 id="_6-死锁检测与处理" tabindex="-1"><a class="header-anchor" href="#_6-死锁检测与处理"><span>6. 死锁检测与处理</span></a></h3><ul><li>InnoDB 支持<strong>自动死锁检测</strong>，发现死锁会主动回滚部分事务，释放锁资源。</li></ul><h3 id="总结-1" tabindex="-1"><a class="header-anchor" href="#总结-1"><span>总结</span></a></h3><table><thead><tr><th>锁类型</th><th>实现方式/原理</th><th>适用场景/优缺点</th></tr></thead><tbody><tr><td>表级锁</td><td>MyISAM/DDL，整表加锁</td><td>实现简单，粒度大，冲突多，适合读多写少</td></tr><tr><td>行级锁</td><td>InnoDB，基于索引加锁</td><td>粒度小，支持高并发，开销大，死锁风险</td></tr><tr><td>意向锁</td><td>表级标记，辅助行锁管理</td><td>提高加锁效率，便于表锁与行锁兼容</td></tr><tr><td>间隙锁/临键锁</td><td>锁定索引区间，防止幻读</td><td>解决幻读，影响并发性能，只有可重复读隔离级别下用</td></tr></tbody></table><blockquote><p>MySQL 锁分为表级锁、行级锁、意向锁、间隙锁等。InnoDB 的行锁是基于索引实现的，支持高并发和事务隔离。间隙锁和临键锁用于防止幻读。意向锁用于优化表锁和行锁的兼容。InnoDB 支持自动死锁检测和回滚。</p></blockquote><h2 id="深拷贝和浅拷贝的区别" tabindex="-1"><a class="header-anchor" href="#深拷贝和浅拷贝的区别"><span>深拷贝和浅拷贝的区别？</span></a></h2><table><thead><tr><th>拷贝类型</th><th>含义</th><th>影响/特点</th></tr></thead><tbody><tr><td>浅拷贝</td><td>只复制对象的<strong>引用</strong>，不复制引用对象本身。新对象和原对象<strong>共享内部子对象</strong>。</td><td>改变子对象会互相影响，顶层对象是新，底层对象是同一个</td></tr><tr><td>深拷贝</td><td>复制对象<strong>以及其引用的所有子对象</strong>，完全独立。新对象和原对象<strong>没有任何共享部分</strong>。</td><td>改变任何一方都不会影响另一方，完全独立</td></tr></tbody></table><ul><li><strong>浅拷贝</strong>：适合对象结构简单、内部无可变引用类型，或只需复制顶层对象时。</li><li><strong>深拷贝</strong>：适合对象复杂、包含可变引用类型，且需要完全独立副本时。</li></ul><blockquote><p>浅拷贝只复制引用，深拷贝连引用对象本身都复制，深拷贝更彻底，互不影响。</p></blockquote><h2 id="知道协程吗" tabindex="-1"><a class="header-anchor" href="#知道协程吗"><span>知道协程吗？</span></a></h2><table><thead><tr><th>对比项</th><th>进程（Process）</th><th>线程（Thread）</th><th>协程（Coroutine）</th></tr></thead><tbody><tr><td>概念</td><td>操作系统资源分配的最小单位</td><td>程序执行的最小单位，属于进程</td><td>用户态的轻量级线程/可暂停函数</td></tr><tr><td>是否有独立内存</td><td>有，进程间内存隔离</td><td>共享进程内存空间</td><td>共享线程/进程内存空间</td></tr><tr><td>创建/切换开销</td><td>最大</td><td>较大</td><td>极小（用户态切换）</td></tr><tr><td>调度方式</td><td>操作系统调度</td><td>操作系统调度</td><td>程序/用户态调度</td></tr><tr><td>通信方式</td><td>进程间通信（IPC）</td><td>共享内存、同步机制</td><td>共享内存、消息传递</td></tr><tr><td>并发性</td><td>真并发（多核可并行）</td><td>真并发（多核可并行）</td><td>单线程内并发（伪并发）</td></tr><tr><td>适用场景</td><td>高隔离、高可靠、独立服务</td><td>高并发、并行计算</td><td>高并发、IO密集、异步编程</td></tr><tr><td>数量</td><td>少（资源消耗大）</td><td>多（受限于系统资源）</td><td>可成千上万（极轻量）</td></tr><tr><td>典型语言/支持</td><td>所有操作系统</td><td>所有主流语言/系统</td><td>Python、Go、JS等原生支持</td></tr></tbody></table><ul><li><strong>进程</strong>：最重，资源隔离最强，开销最大，适合独立服务。</li><li><strong>线程</strong>：比进程轻，能并发执行，资源共享，适合并行计算。</li><li><strong>协程</strong>：最轻，用户态切换，适合高并发、IO密集，单线程内实现并发。</li></ul><blockquote><p>进程最重，线程较轻，协程最轻；进程/线程由操作系统调度，协程由程序调度，协程适合高并发和异步场景。</p></blockquote><h2 id="spring中事务嵌套事务是怎么处理的" tabindex="-1"><a class="header-anchor" href="#spring中事务嵌套事务是怎么处理的"><span>Spring中事务嵌套事务是怎么处理的？</span></a></h2><ul><li>Spring 通过**事务传播行为（Propagation）**来控制“事务中套事务”的行为。</li><li>常见传播属性： <ul><li><code>REQUIRED</code>（默认）：如果当前有事务，就加入当前事务；没有就新建一个事务。</li><li><code>REQUIRES_NEW</code>：每次都新建一个新事务，原事务挂起。</li><li><code>NESTED</code>：嵌套事务，内层回滚不影响外层（需底层数据库支持）。</li><li>其他还有 SUPPORTS、NOT_SUPPORTED、MANDATORY、NEVER 等。</li></ul></li></ul><h3 id="如何保证事务不会出问题" tabindex="-1"><a class="header-anchor" href="#如何保证事务不会出问题"><span>如何保证事务不会出问题？</span></a></h3><h4 id="_1-同一个类内直接调用-事务可能不会生效" tabindex="-1"><a class="header-anchor" href="#_1-同一个类内直接调用-事务可能不会生效"><span>1）同一个类内直接调用，事务可能<strong>不会生效</strong>！</span></a></h4><ul><li>Spring 的事务是基于 AOP 代理实现的，<strong>只有通过代理对象调用，事务才会生效</strong>。</li><li>如果在同一个类里直接调用另一个 <code>@Transactional</code> 方法，实际上不会经过代理，内层事务注解失效，<strong>事务传播属性不会生效</strong>。比如：</li></ul><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// outer()直接调用inner()，inner()的事务注解不会生效，只有outer()的事务生效。</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Service</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> MyService</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    @</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Transactional</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> outer</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">        inner</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(); </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 直接调用，事务注解无效</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    @</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Transactional</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> inner</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 这里的事务注解不会生效</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 只有通过Spring容器管理的代理对象去调用@Transactional方法，Spring才能拦截到方法调用，事务才会生效。</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 通常做法是：把内层事务方法放到另一个Spring Bean里，通过注入调用。</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Service</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> InnerService</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    @</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Transactional</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> inner</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 事务生效</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Service</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> OuterService</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    @</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Autowired</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> InnerService</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> innerService</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    @</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Transactional</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> outer</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        innerService</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">inner</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(); </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 通过代理对象调用，事务生效</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>解决办法：</strong></p><ul><li>让内层事务方法在<strong>不同的类</strong>，通过 Spring 容器注入调用，确保走代理。</li></ul><h4 id="_2-合理设置传播属性" tabindex="-1"><a class="header-anchor" href="#_2-合理设置传播属性"><span>2）合理设置传播属性</span></a></h4><ul><li>如果希望内外方法共用一个事务（默认），用 <code>REQUIRED</code>。</li><li>如果希望内外方法各自独立，互不影响，用 <code>REQUIRES_NEW</code>。</li><li>如果需要嵌套事务（部分回滚），用 <code>NESTED</code>（需数据库支持）。</li></ul><h3 id="总结-2" tabindex="-1"><a class="header-anchor" href="#总结-2"><span>总结</span></a></h3><table><thead><tr><th>场景/方式</th><th>事务传播属性</th><th>事务行为说明</th></tr></thead><tbody><tr><td>默认（REQUIRED）</td><td>REQUIRED</td><td>内外方法共用一个事务，任何一个异常都整体回滚</td></tr><tr><td>新事务（REQUIRES_NEW）</td><td>REQUIRES_NEW</td><td>内外方法各自独立，内层异常只回滚自己，外层不受影响</td></tr><tr><td>嵌套事务（NESTED）</td><td>NESTED</td><td>内层异常只回滚自己，外层可选择是否回滚（需数据库支持）</td></tr><tr><td>同类内直接调用</td><td>任意</td><td>事务传播属性失效，内层事务注解无效，需通过代理对象调用</td></tr></tbody></table><blockquote><p>Spring 事务中套事务时，要通过事务传播属性（如REQUIRED、REQUIRES_NEW、NESTED）控制事务边界。注意同类内直接调用不会生效，需通过代理对象调用。合理设置传播属性和调用方式，才能保证事务不会出现问题。</p></blockquote><h2 id="ioc介绍-循环依赖如何解决-交给spring会不会出现内存溢出问题" tabindex="-1"><a class="header-anchor" href="#ioc介绍-循环依赖如何解决-交给spring会不会出现内存溢出问题"><span>IOC介绍 循环依赖如何解决？交给spring会不会出现内存溢出问题？</span></a></h2><h3 id="_1-ioc-介绍" tabindex="-1"><a class="header-anchor" href="#_1-ioc-介绍"><span>1. IOC 介绍</span></a></h3><ul><li><strong>IOC（Inversion of Control，控制反转）</strong>：把对象的创建和依赖关系的维护交给容器（如Spring），而不是在代码中手动new对象。</li><li><strong>核心思想</strong>：对象不再自己管理依赖，而是由容器统一注入（依赖注入，DI）。</li><li><strong>好处</strong>：解耦、易扩展、易测试、便于管理对象生命周期。</li></ul><h3 id="_2-spring-循环依赖如何解决" tabindex="-1"><a class="header-anchor" href="#_2-spring-循环依赖如何解决"><span>2. Spring 循环依赖如何解决？</span></a></h3><ul><li><p><strong>循环依赖</strong>：A依赖B，B又依赖A，构成闭环。</p></li><li><p><strong>Spring的三级缓存机制</strong>可以解决<strong>单例Bean的构造器循环依赖</strong>（即构造方法无参或只依赖属性注入的情况）：</p><ol><li><strong>singletonObjects</strong>：一级缓存，存放完全初始化好的单例Bean。</li><li><strong>earlySingletonObjects</strong>：二级缓存，存放早期暴露的Bean（未完成依赖注入）。</li><li><strong>singletonFactories</strong>：三级缓存，存放Bean工厂对象（ObjectFactory），用于创建早期Bean引用。</li></ol></li><li><p><strong>解决流程</strong>：</p><ul><li>创建A时，发现需要B，先把A的“半成品”放到三级缓存。</li><li>创建B时，发现需要A，从三级缓存拿到A的“半成品”引用，完成依赖注入。</li><li>最终A、B都能被正确创建。</li></ul></li><li><p><strong>注意</strong>：只能解决<strong>单例、属性注入</strong>的循环依赖，<strong>构造器注入的循环依赖无法解决</strong>，会抛出异常。</p></li></ul><h3 id="_3-交给spring会不会出现内存溢出问题" tabindex="-1"><a class="header-anchor" href="#_3-交给spring会不会出现内存溢出问题"><span>3. 交给Spring会不会出现内存溢出问题？</span></a></h3><ul><li><strong>正常情况下不会</strong>。Spring的三级缓存机制会在Bean创建完成后清理缓存，避免内存泄漏。</li><li><strong>但如果循环依赖链过长、Bean数量极大，或有自定义Bean生命周期管理不当，可能导致内存占用升高，极端情况下有OOM风险</strong>。</li><li><strong>常见OOM原因</strong>： <ul><li>循环依赖链过长，Bean未及时释放。</li><li>Bean作用域为prototype（原型），Spring不管理其生命周期，容易内存泄漏。</li><li>代码中有静态变量、线程等持有Bean引用，导致GC无法回收。</li></ul></li></ul><blockquote><p>IOC是控制反转，Spring通过依赖注入管理对象和依赖。Spring用三级缓存机制解决单例Bean的属性注入循环依赖，不能解决构造器注入的循环依赖。正常情况下不会导致内存溢出，但如果循环依赖链过长或Bean管理不当，极端情况下可能OOM。</p></blockquote><h2 id="icmp是什么知道吗" tabindex="-1"><a class="header-anchor" href="#icmp是什么知道吗"><span>ICMP是什么知道吗？</span></a></h2><p>是一种网络层协议，用于在主机、路由器之间传递控制消息和差错信息。</p><h2 id="atomicxxx类底层如何实现的" tabindex="-1"><a class="header-anchor" href="#atomicxxx类底层如何实现的"><span>AtomicXXX类底层如何实现的？</span></a></h2><p>以 Java 的 <code>AtomicInteger</code>（atomicxxx）为例，底层实现主要依赖于<strong>CAS（Compare And Swap，比较并交换）<strong>原语和</strong>CPU指令</strong>，实现无锁的原子操作。</p><h3 id="cas-compare-and-swap-原理" tabindex="-1"><a class="header-anchor" href="#cas-compare-and-swap-原理"><span>CAS（Compare And Swap）原理</span></a></h3><ul><li><p><strong>CAS</strong> 是一种原子操作指令，流程如下：</p><ol><li>读取变量的当前值（假设为A）。</li><li>比较当前值是否等于期望值（A）。</li><li>如果相等，则将变量值更新为新值（B）；否则不做任何操作。</li><li>整个过程是原子的，不会被线程切换中断。</li></ol></li><li><p><strong>伪代码：</strong></p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>if (value == expected) {</span></span>\n<span class="line"><span>    value = newValue;</span></span>\n<span class="line"><span>    return true;</span></span>\n<span class="line"><span>} else {</span></span>\n<span class="line"><span>    return false;</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h3 id="java-atomicinteger-的底层实现" tabindex="-1"><a class="header-anchor" href="#java-atomicinteger-的底层实现"><span>Java AtomicInteger 的底层实现</span></a></h3><ul><li><p><code>AtomicInteger</code> 内部用 <code>Unsafe</code> 类的 <code>compareAndSwapInt</code> 方法实现原子加法等操作。</p></li><li><p>该方法最终会调用<strong>CPU的原子指令</strong>（如 x86 的 <code>LOCK CMPXCHG</code>）。</p></li><li><p>以 <code>incrementAndGet()</code> 为例，底层是一个自旋CAS循环：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> final</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> incrementAndGet</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">() {</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    for</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> current </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> get</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> next </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> current </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">compareAndSet</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(current</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> next))</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">            return</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> next</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>如果CAS失败（变量被其他线程修改），会不断重试，直到成功。</p></li></ul><blockquote><p>atomicxxx底层通过CAS原语和CPU原子指令实现无锁原子操作，保证并发安全。</p></blockquote><h2 id="oom这种可以被catch吗-哪些可以" tabindex="-1"><a class="header-anchor" href="#oom这种可以被catch吗-哪些可以"><span>OOM这种可以被catch吗，哪些可以？</span></a></h2><ul><li>可以被catch，因为 OOM（java.lang.OutOfMemoryError）是 Error 的子类，理论上可以用 catch (Throwable t) 或 catch (Error e) 或 catch (OutOfMemoryError e) 捕获。</li><li>但<strong>不建议捕获和处理 OOM，因为 OOM 通常表示JVM已经无法分配内存，系统处于极不稳定状态</strong>，继续运行可能导致更多不可预期的问题（如线程无法创建、对象无法分配、GC失效等）。</li></ul><h2 id="动态代理的底层原理" tabindex="-1"><a class="header-anchor" href="#动态代理的底层原理"><span>动态代理的底层原理？</span></a></h2><blockquote><p>动态代理通过运行时生成代理类，<strong>JDK代理基于接口+反射，CGLIB代理基于继承+字节码增强</strong>，方法调用最终由代理逻辑统一处理。</p></blockquote><h2 id="多线程中的异常如何处理" tabindex="-1"><a class="header-anchor" href="#多线程中的异常如何处理"><span>多线程中的异常如何处理？</span></a></h2><h3 id="_1-普通线程的异常处理" tabindex="-1"><a class="header-anchor" href="#_1-普通线程的异常处理"><span>1. 普通线程的异常处理</span></a></h3><ul><li><strong>线程run()方法内的异常不会抛到主线程</strong>，如果不捕获，异常会导致该线程终止，但不会影响其他线程。</li><li><strong>最佳实践</strong>：在run()方法内部用try-catch捕获并处理异常，避免线程意外终止。</li></ul><p><strong>示例：</strong></p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> Thread</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(() </span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">-&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> {</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    try</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> {</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 业务代码</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    } </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">catch</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Exception</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> e</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 记录日志、报警、补偿等</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">})</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">start</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-线程池中的异常处理" tabindex="-1"><a class="header-anchor" href="#_2-线程池中的异常处理"><span>2. 线程池中的异常处理</span></a></h3><ul><li><strong>execute()提交的任务</strong>：如果任务抛出异常，异常会被吞掉，不会抛到主线程，也不会有任何提示。</li><li><strong>submit()提交的任务</strong>：异常会被封装在Future中，只有调用get()时才会抛出ExecutionException。</li></ul><p><strong>示例：</strong></p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// execute方式</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">executor</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">execute</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(() </span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">-&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    throw</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> RuntimeException</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;error&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">); </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 异常被吞掉</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">});</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// submit方式</span></span>\n<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Future</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">?</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> future </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> executor</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">submit</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(() </span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">-&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    throw</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> RuntimeException</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;error&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">});</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">try</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> {</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    future</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">get</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 这里会抛出异常</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">} </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">catch</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">ExecutionException</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> e</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 处理异常</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-统一异常处理方式" tabindex="-1"><a class="header-anchor" href="#_3-统一异常处理方式"><span>3. 统一异常处理方式</span></a></h3><ul><li><strong>自定义线程工厂</strong>，为线程设置UncaughtExceptionHandler，统一处理未捕获异常。</li><li><strong>线程池</strong>可通过ThreadFactory设置异常处理器。</li></ul><p><strong>示例：</strong></p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">ThreadFactory</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> factory </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> r </span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">-&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> {</span></span>\n<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">    Thread</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> t </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> Thread</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(r)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    t</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">setUncaughtExceptionHandler</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">((thread, e) </span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">-&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 统一异常处理，如日志、报警</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    });</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> t</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">ExecutorService</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> executor </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> Executors</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">newFixedThreadPool</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, factory);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_4-总结" tabindex="-1"><a class="header-anchor" href="#_4-总结"><span>4. 总结</span></a></h3><table><thead><tr><th>场景</th><th>异常处理方式</th><th>说明/建议</th></tr></thead><tbody><tr><td>普通线程</td><td>run()内try-catch</td><td>避免线程意外终止，记录日志/补偿</td></tr><tr><td>线程池execute</td><td>任务内try-catch或设置UncaughtExceptionHandler</td><td>否则异常被吞掉，需统一处理</td></tr><tr><td>线程池submit</td><td>get()时catch ExecutionException</td><td>不get则异常被吞掉，建议及时处理</td></tr></tbody></table><blockquote><p>多线程异常不会抛到主线程，需在线程内部catch或用UncaughtExceptionHandler统一处理，线程池submit还可通过Future.get()捕获异常。</p></blockquote><h2 id="submit和execute的区别" tabindex="-1"><a class="header-anchor" href="#submit和execute的区别"><span>submit和execute的区别？</span></a></h2><table><thead><tr><th>对比项</th><th>execute()</th><th>submit()</th></tr></thead><tbody><tr><td>定义</td><td>只接受Runnable任务</td><td>可接受Runnable和Callable任务</td></tr><tr><td>返回值</td><td>无（void）</td><td>返回Future对象，可获取结果/异常</td></tr><tr><td>异常处理</td><td>任务抛出异常会被吞掉，不会抛到主线程</td><td>任务抛出异常会封装在Future，get()时抛出ExecutionException</td></tr><tr><td>获取结果</td><td>无法获取</td><td>可通过Future.get()获取返回值/异常</td></tr><tr><td>适用场景</td><td>只需执行任务，无需结果/异常处理</td><td>需要获取任务结果或处理异常</td></tr></tbody></table><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// execute</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">executor</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">execute</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(() </span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">-&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 只执行任务，不能获取结果</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">});</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// submit</span></span>\n<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Future</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Integer</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> future </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> executor</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">submit</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(() </span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">-&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 123</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">});</span></span>\n<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Integer</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> result </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> future</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">get</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 获取结果或异常</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>execute只执行任务无返回值，submit能获取结果和异常，推荐用submit处理需要结果或异常的场景。</p></blockquote><h2 id="雪花算法-时钟回拨问题" tabindex="-1"><a class="header-anchor" href="#雪花算法-时钟回拨问题"><span>雪花算法？时钟回拨问题？</span></a></h2><h3 id="雪花算法" tabindex="-1"><a class="header-anchor" href="#雪花算法"><span>雪花算法</span></a></h3><p>雪花算法（Snowflake）是分布式系统中常用的<strong>全局唯一ID生成算法</strong>，最早由Twitter提出。</p><p>经典的Snowflake 64位ID结构如下：</p><table><thead><tr><th>位数</th><th>含义</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>符号位</td><td>固定为0，正数</td></tr><tr><td>41</td><td>时间戳</td><td>距某个起始时间的毫秒数（可用69年）</td></tr><tr><td>10</td><td>机器标识</td><td>数据中心ID+机器ID（支持1024台机器）</td></tr><tr><td>12</td><td>序列号（保证同一毫秒内生成多个ID时不重复）</td><td>同一毫秒内的自增序列（支持4096个ID）</td></tr></tbody></table><blockquote><p>雪花算法用时间戳+机器ID+序列号拼成64位唯一ID，支持高并发分布式唯一ID生成，且大致递增。</p></blockquote><h3 id="时钟回拨问题解决" tabindex="-1"><a class="header-anchor" href="#时钟回拨问题解决"><span>时钟回拨问题解决</span></a></h3><table><thead><tr><th>方案</th><th>适用场景</th><th>说明与优缺点</th></tr></thead><tbody><tr><td><strong>等待恢复</strong></td><td>对可用性要求不高</td><td>当发现系统时钟回拨时，程序<strong>暂停生成ID</strong>，等待系统时间恢复正常。<br>优点：实现简单，保证ID唯一且有序。<br>缺点：服务暂停，影响可用性，可能造成阻塞。</td></tr><tr><td><strong>备用序列号</strong></td><td>对ID递增性要求不高</td><td>当时钟回拨时，启用备用的序列号生成逻辑（比如增加序列号范围）以继续生成ID，保证服务不中断。<br>优点：服务不中断。<br>缺点：ID不再严格递增，可能导致顺序性下降，并发处理能力受影响。</td></tr><tr><td><strong>时间戳补偿</strong></td><td>对ID递增性要求高</td><td>通过逻辑维护一个补偿时间戳，人工或自动调节时间戳，使ID仍保持递增顺序。<br>优点：保持ID的递增性。<br>缺点：实现较复杂，代码和运维成本增加。</td></tr><tr><td><strong>多时钟源</strong></td><td>高可靠性要求</td><td>采用多个时间源（如NTP服务器、GPS时间等），确保系统时间准确且稳定。<br>优点：高可靠性，减少回拨风险。<br>缺点：系统设计复杂，硬件和维护成本高。</td></tr></tbody></table><h2 id="索引下推" tabindex="-1"><a class="header-anchor" href="#索引下推"><span>索引下推？</span></a></h2><p><strong>索引下推</strong>（Index Condition Pushdown，简称ICP）是 MySQL 5.6+ 引入的一种<strong>优化查询性能的技术</strong>，常用于InnoDB和MyISAM存储引擎。</p><h3 id="什么是索引下推" tabindex="-1"><a class="header-anchor" href="#什么是索引下推"><span>什么是索引下推？</span></a></h3><ul><li>在没有ICP之前，MySQL在用索引查找时，如果有多个条件（如<code>where a=1 and b=2</code>），只有<strong>最左前缀</strong>（如a=1）会用到索引，后续条件（如b=2）需要回表到数据行再判断。</li><li><strong>有了ICP后</strong>，MySQL会在索引遍历阶段，尽量把更多的where条件“下推”到索引层过滤，<strong>减少回表次数</strong>，提升查询效率。</li></ul><h3 id="工作原理" tabindex="-1"><a class="header-anchor" href="#工作原理"><span>工作原理</span></a></h3><ul><li>MySQL在扫描索引时，先用索引能判断的条件过滤一部分数据（如a=1）。</li><li>对于复合索引，能在索引中判断的其他条件（如b=2）也在索引遍历时判断。</li><li>只有通过所有下推条件的索引记录，才会回表读取完整数据行。</li></ul><h3 id="例子" tabindex="-1"><a class="header-anchor" href="#例子"><span>例子</span></a></h3><p>假设有如下表和索引：</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">CREATE</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> TABLE</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> t</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  a </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">INT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  b </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">INT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  c </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">INT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  INDEX</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> idx_ab(a, b)</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>查询语句：</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">SELECT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> * </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">FROM</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> t </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">WHERE</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> a</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> AND</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> b</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> AND</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> c</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">3</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li><strong>没有ICP</strong>：a=1用索引，b=2和c=3要回表判断。</li><li><strong>有ICP</strong>：a=1和b=2都在索引遍历时判断，只有b=2通过的才回表判断c=3。</li></ul><h3 id="优点" tabindex="-1"><a class="header-anchor" href="#优点"><span>优点</span></a></h3><ul><li><strong>减少回表次数</strong>，提升查询性能，尤其是大表和复合索引场景。</li><li>对于只用到索引字段的查询，甚至可以做到<strong>覆盖索引</strong>，无需回表。</li></ul><h3 id="如何查看是否用到icp" tabindex="-1"><a class="header-anchor" href="#如何查看是否用到icp"><span>如何查看是否用到ICP？</span></a></h3><ul><li>执行<code>EXPLAIN</code>，如果<code>Extra</code>列出现<code>Using index condition</code>，说明用到了索引下推。</li></ul><blockquote><p>索引下推是MySQL把更多where条件下推到索引遍历阶段过滤，减少回表次数，提高查询效率的优化技术。</p></blockquote><h2 id="innodb和myisam的区别" tabindex="-1"><a class="header-anchor" href="#innodb和myisam的区别"><span>InnoDB和MyISAM的区别？</span></a></h2><table><thead><tr><th>对比项</th><th>InnoDB</th><th>MyISAM</th></tr></thead><tbody><tr><td>存储结构</td><td>行存储（Row-based）</td><td>行存储（Row-based）</td></tr><tr><td>事务支持</td><td>支持事务（ACID）</td><td>不支持事务（非ACID）</td></tr><tr><td>锁机制</td><td>行级锁（Row-level）</td><td>表级锁（Table-level）</td></tr><tr><td>索引</td><td>支持B+树索引（主键、唯一、普通）</td><td>支持B+树索引（主键、唯一、普通）</td></tr><tr><td>索引实现</td><td>支持全文索引（Full-text）</td><td>不支持全文索引（Full-text）</td></tr><tr><td>外键支持</td><td>支持外键（Foreign Key）</td><td>不支持外键（Foreign Key）</td></tr></tbody></table><h2 id="tcp已建立连接时客户端突然断电-进程崩溃会怎样" tabindex="-1"><a class="header-anchor" href="#tcp已建立连接时客户端突然断电-进程崩溃会怎样"><span>TCP已建立连接时客户端突然断电 / 进程崩溃会怎样？</span></a></h2><table><thead><tr><th>检测方式</th><th>是否默认启用</th><th>检测原理</th><th>响应速度</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td><strong>无任何操作</strong></td><td>✅ 是</td><td>TCP 不主动检测</td><td>❌ 极慢（永久挂住）</td><td>简单</td><td>无法感知对端异常断开</td></tr><tr><td><strong>应用层心跳机制</strong></td><td>❌ 否（需手动）</td><td>应用每隔 T 秒发送 ping 或请求</td><td>✅ 快（自定义）</td><td>快速准确、可控</td><td>实现复杂度稍高</td></tr><tr><td><strong>主动读/写操作</strong></td><td>✅ 是</td><td>调用 read/write 发现异常</td><td>✅ 中等</td><td>实现简单</td><td>必须有数据交互触发，空闲时无效</td></tr><tr><td><strong>TCP KeepAlive</strong></td><td>❌ 否（默认关闭）</td><td>内核发送探测包检测连接状态</td><td>❌ 慢（默认2h+）</td><td>自动完成</td><td>开启麻烦，默认超时时间非常长</td></tr></tbody></table><table><thead><tr><th>场景</th><th>建议做法</th></tr></thead><tbody><tr><td>通信频繁（如游戏/推送系统）</td><td>主动读写结合心跳机制</td></tr><tr><td>长连接但低频通信（如RPC）</td><td>开启 TCP keepalive + 应用层超时</td></tr><tr><td>重要服务/金融级稳定性需求</td><td>心跳 + 超时 + TCP keepalive 三重保障</td></tr></tbody></table><h2 id="raft介绍一下-和paxos区别" tabindex="-1"><a class="header-anchor" href="#raft介绍一下-和paxos区别"><span>Raft介绍一下 和Paxos区别？</span></a></h2><p><strong>Raft</strong>是一个<strong>分布式一致性算法</strong>，用来保证多个节点之间的数据一致性。简单说就是：多个服务器如何达成共识，选出一个&quot;老大&quot;来管理数据。</p><h3 id="核心概念" tabindex="-1"><a class="header-anchor" href="#核心概念"><span>核心概念</span></a></h3><h4 id="三种角色" tabindex="-1"><a class="header-anchor" href="#三种角色"><span>三种角色</span></a></h4><ul><li><strong>Leader（领导者）</strong>：处理所有客户端请求，管理数据复制</li><li><strong>Follower（跟随者）</strong>：被动响应Leader和Candidate的请求</li><li><strong>Candidate（候选人）</strong>：选举过程中的临时角色</li></ul><h4 id="任期-term" tabindex="-1"><a class="header-anchor" href="#任期-term"><span>任期（Term）</span></a></h4><ul><li>每个任期都有一个数字标识（1, 2, 3...）</li><li>每个任期最多只能有一个Leader</li><li>任期是递增的，不会回退</li></ul><h3 id="选举过程-leader-election" tabindex="-1"><a class="header-anchor" href="#选举过程-leader-election"><span>选举过程（Leader Election）</span></a></h3><h4 id="触发条件" tabindex="-1"><a class="header-anchor" href="#触发条件"><span>触发条件</span></a></h4><ul><li>节点启动时</li><li>Leader宕机时</li><li>Follower超时未收到Leader心跳时</li></ul><h4 id="选举步骤" tabindex="-1"><a class="header-anchor" href="#选举步骤"><span>选举步骤</span></a></h4><ol><li><strong>Follower → Candidate</strong>：超时后发起选举</li><li><strong>投票阶段</strong>： <ul><li>Candidate给自己投票</li><li>向其他节点请求投票</li><li>其他节点只能投给任期号更大的Candidate</li></ul></li><li><strong>结果</strong>： <ul><li>获得多数票 → 成为Leader</li><li>收到更高任期号 → 变回Follower</li><li>超时未获得多数票 → 重新选举</li></ul></li></ol><h3 id="日志复制-log-replication" tabindex="-1"><a class="header-anchor" href="#日志复制-log-replication"><span>日志复制（Log Replication）</span></a></h3><h4 id="基本流程" tabindex="-1"><a class="header-anchor" href="#基本流程"><span>基本流程</span></a></h4><ol><li><strong>客户端请求</strong> → Leader</li><li><strong>Leader记录日志</strong> → 本地</li><li><strong>并行发送</strong> → 所有Follower</li><li><strong>Follower确认</strong> → 回复Leader</li><li><strong>Leader提交</strong> → 通知Follower提交</li><li><strong>返回结果</strong> → 客户端</li></ol><h4 id="日志一致性" tabindex="-1"><a class="header-anchor" href="#日志一致性"><span>日志一致性</span></a></h4><ul><li>每个日志条目都有<strong>任期号</strong>和<strong>索引号</strong></li><li>Leader确保所有Follower的日志与自己一致</li><li>通过<strong>AppendEntries RPC</strong>同步日志</li></ul><h3 id="安全性保证" tabindex="-1"><a class="header-anchor" href="#安全性保证"><span>安全性保证</span></a></h3><h4 id="选举限制" tabindex="-1"><a class="header-anchor" href="#选举限制"><span>选举限制</span></a></h4><ul><li>只有包含所有已提交日志的节点才能成为Leader</li><li>确保新Leader不会丢失已提交的数据</li></ul><h4 id="日志匹配" tabindex="-1"><a class="header-anchor" href="#日志匹配"><span>日志匹配</span></a></h4><ul><li>如果两个日志在相同索引位置有相同任期号，则它们包含相同的命令</li><li>如果两个日志在相同索引位置有相同任期号，则它们之前的所有日志条目都相同</li></ul><h3 id="简单示例" tabindex="-1"><a class="header-anchor" href="#简单示例"><span>简单示例</span></a></h3><p><strong>场景：5个节点的集群</strong></p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>初始状态：所有节点都是Follower</span></span>\n<span class="line"><span>Term 1: 节点A超时 → 发起选举 → 获得3票 → 成为Leader</span></span>\n<span class="line"><span>Term 1: 客户端写请求 → Leader A处理 → 复制到其他节点 → 提交成功</span></span>\n<span class="line"><span>Term 2: Leader A宕机 → 节点B超时 → 发起选举 → 成为新Leader</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="与paxos的区别" tabindex="-1"><a class="header-anchor" href="#与paxos的区别"><span>与Paxos的区别</span></a></h3><table><thead><tr><th>特性</th><th>Raft</th><th>Paxos</th></tr></thead><tbody><tr><td><strong>理解难度</strong></td><td>相对简单</td><td>复杂</td></tr><tr><td><strong>角色划分</strong></td><td>明确（Leader/Follower/Candidate）</td><td>角色不固定</td></tr><tr><td><strong>日志管理</strong></td><td>有明确的日志复制机制</td><td>需要额外实现</td></tr><tr><td><strong>实现复杂度</strong></td><td>较低</td><td>较高</td></tr></tbody></table><h3 id="实际应用" tabindex="-1"><a class="header-anchor" href="#实际应用"><span>实际应用</span></a></h3><ul><li><strong>etcd</strong>：Kubernetes的配置存储</li><li><strong>Consul</strong>：服务发现和配置管理</li><li><strong>TiKV</strong>：分布式数据库</li><li><strong>CockroachDB</strong>：分布式SQL数据库</li></ul><h3 id="要点" tabindex="-1"><a class="header-anchor" href="#要点"><span>要点</span></a></h3><blockquote><p>Raft通过明确的Leader选举和日志复制机制，保证分布式系统中的数据一致性，相比Paxos更容易理解和实现。</p></blockquote><ul><li>强一致性保证</li><li>易于理解和实现</li><li>自动故障恢复</li><li>支持动态成员变更</li></ul><blockquote><p>选举选老大，复制保一致，任期防冲突，日志要匹配。</p></blockquote><h2 id="hashcode-和equals-的区别-为什么重写equals-就要重写hashcode" tabindex="-1"><a class="header-anchor" href="#hashcode-和equals-的区别-为什么重写equals-就要重写hashcode"><span>hashCode()和equals()的区别,为什么重写equals()就要重写hashCode()？</span></a></h2><ul><li>Java 对 equals() 和 hashCode() 的契约如下： <ul><li>如果两个对象通过 equals() 比较相等，则它们的 hashCode() 必须相等</li><li>如果两个对象 hashCode() 相等，它们不一定 equals() 相等（哈希冲突是允许的）</li></ul></li></ul><table><thead><tr><th>问题</th><th>结论</th></tr></thead><tbody><tr><td><code>equals()</code> 比较什么？</td><td>值是否相等</td></tr><tr><td><code>hashCode()</code> 用来干嘛？</td><td>快速查找桶</td></tr><tr><td>为什么要同时重写？</td><td>保证集合类正常工作，避免逻辑错误</td></tr><tr><td>不重写会怎样？</td><td>数据重复、查找失败、逻辑异常</td></tr></tbody></table><h2 id="你对反射的了解" tabindex="-1"><a class="header-anchor" href="#你对反射的了解"><span>你对反射的了解？</span></a></h2><p>反射就是在程序运行期间动态的获取对象的属性和方法的功能叫做反射。它能够在程序运行期间，对于任意一个类，都能知道它所有的方法和属性，对于任意一个对象，都能知道他的属性和方法。 获取Class对象的三种方式：getClass();xx.class;Class.forName(&quot;xxx&quot;); 反射的优缺点： 优点：运行期间能够动态的获取类，提高代码的灵活性。 缺点：性能比直接的Java代码要慢很多。 应用场景：spring的xml配置模式，以及动态代理模式都用到了反射。</p><h2 id="优先队列" tabindex="-1"><a class="header-anchor" href="#优先队列"><span>优先队列</span></a></h2><p>PriorityQueue不是线程安全的，线程安全适用PriorityBlockingQueue，使用了ReentrantLock实现线程安全</p><h2 id="spring-boot用哪个动态代理" tabindex="-1"><a class="header-anchor" href="#spring-boot用哪个动态代理"><span>Spring Boot用哪个动态代理？</span></a></h2><table><thead><tr><th>特性</th><th>JDK 动态代理</th><th>CGLIB 动态代理</th></tr></thead><tbody><tr><td>是否需要接口</td><td>✅ 必须实现接口</td><td>❌ 不需要接口</td></tr><tr><td>实现方式</td><td>Java 反射 + 接口</td><td>继承目标类 + 字节码增强（ASM）</td></tr><tr><td>性能</td><td>JDK 1.6 之前慢，之后较快</td><td>创建代理时稍慢，执行时更快</td></tr><tr><td>final 方法支持</td><td>❌ 无法代理 final 方法</td><td>❌ final 方法无法代理</td></tr><tr><td>原理</td><td><code>Proxy.newProxyInstance()</code></td><td><code>Enhancer.create()</code></td></tr></tbody></table><ul><li>Spring AOP 默认使用： <ul><li>JDK 动态代理：如果目标类实现了接口</li><li>CGLIB 动态代理：如果目标类没有实现接口</li></ul></li></ul><h2 id="消息队列的推拉模式知道吗" tabindex="-1"><a class="header-anchor" href="#消息队列的推拉模式知道吗"><span>消息队列的推拉模式知道吗？</span></a></h2><table><thead><tr><th>对比项</th><th>推（Push）</th><th>拉（Pull）</th></tr></thead><tbody><tr><td><strong>消息发送</strong></td><td>队列主动将消息推送给消费者</td><td>消费者主动向队列轮询拉取消息</td></tr><tr><td><strong>实时性</strong></td><td>高（消息到达即发送）</td><td>相对低（轮询间隔影响）</td></tr><tr><td><strong>控制权</strong></td><td>队列控制（可能导致消费者过载）</td><td>消费者控制拉取频率、数量</td></tr><tr><td><strong>复杂性</strong></td><td>需要处理消费者负载问题</td><td>需设计合适的拉取策略</td></tr><tr><td><strong>可靠性</strong></td><td>可能消息丢失（若未确认即宕机）</td><td>更容易处理确认机制与重试</td></tr></tbody></table><h3 id="✅-推-push-适用场景" tabindex="-1"><a class="header-anchor" href="#✅-推-push-适用场景"><span>✅ 推（Push）适用场景：</span></a></h3><table><thead><tr><th>典型场景</th><th>原因</th></tr></thead><tbody><tr><td><strong>即时消息通知系统</strong>（如短信、邮件、推送）</td><td>实时性要求高，用户操作立刻响应</td></tr><tr><td><strong>服务调用或RPC结果通知</strong></td><td>一旦有消息，立即通知消费者执行</td></tr><tr><td><strong>低并发高实时</strong></td><td>消息不多，立刻推送能带来更快响应体验</td></tr></tbody></table><p>👉 <strong>代表系统：</strong> RabbitMQ 默认使用 Push 模式</p><h3 id="✅-拉-pull-适用场景" tabindex="-1"><a class="header-anchor" href="#✅-拉-pull-适用场景"><span>✅ 拉（Pull）适用场景：</span></a></h3><table><thead><tr><th>典型场景</th><th>原因</th></tr></thead><tbody><tr><td><strong>大数据/日志分析系统</strong></td><td>需要按批处理、避免频繁中断</td></tr><tr><td><strong>爬虫/异步任务系统</strong></td><td>任务处理复杂，消费者需要自己调度</td></tr><tr><td><strong>消费速率不均/波动大</strong></td><td>避免消费者压力过大，自控节奏</td></tr><tr><td><strong>离线处理</strong>（如电商大促后统计）</td><td>没有强实时性要求，按需拉取更高效</td></tr></tbody></table><p>👉 <strong>代表系统：</strong> Kafka 默认使用 Pull 模式</p><table><thead><tr><th>条件</th><th>建议使用方式</th></tr></thead><tbody><tr><td>实时性优先</td><td>推</td></tr><tr><td>控制消费节奏</td><td>拉</td></tr><tr><td>消息量大</td><td>拉（避免推爆消费者）</td></tr><tr><td>网络不稳定</td><td>拉（消费者可断点续拉）</td></tr><tr><td>消费者数量不定</td><td>推（结合队列分发）</td></tr></tbody></table><p>一些中间件（如 Kafka Connect 或 Redis Stream）可以：</p><ul><li><strong>推送消息到缓冲队列</strong></li><li><strong>消费者从缓冲中拉取处理</strong></li></ul><p>这样可以<strong>兼顾实时性和负载控制</strong>。</p><h2 id="负载均衡算法有哪些" tabindex="-1"><a class="header-anchor" href="#负载均衡算法有哪些"><span>负载均衡算法有哪些？</span></a></h2><table><thead><tr><th>算法名称</th><th>类型</th><th>核心原理</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>轮询（Round Robin）</td><td>静态</td><td>请求依次分配到后端服务器</td><td>实现简单、请求均衡</td><td>忽略服务器性能、负载差异</td></tr><tr><td>加权轮询</td><td>静态</td><td>根据权重分配请求，权重大者分得多</td><td>考虑性能差异，灵活配置</td><td>需人工设定权重，不够智能</td></tr><tr><td>随机（Random）</td><td>静态</td><td>随机选择一台服务器</td><td>实现简单，适合节点性能相近</td><td>容易负载不均</td></tr><tr><td>加权随机</td><td>静态</td><td>按权重进行随机分配</td><td>随机性+性能考虑</td><td>同样需人工设定权重</td></tr><tr><td>源地址哈希</td><td>静态</td><td>根据请求源 IP 哈希分配，保证同一客户端命中相同节点</td><td>保持会话一致性（粘性会话）</td><td>不利于动态扩容</td></tr><tr><td>最少连接（Least Connections）</td><td>动态</td><td>分配到当前连接数最少的服务器</td><td>动态反映负载状态，分配合理</td><td>实现复杂，需要连接状态监控</td></tr><tr><td>加权最少连接</td><td>动态</td><td>综合考虑权重与连接数</td><td>更精细的负载控制</td><td>权重设置复杂</td></tr><tr><td>响应时间优先（Fastest Response）</td><td>动态</td><td>分配到响应时间最短的节点</td><td>高性能优先</td><td>需要实时采样响应时间</td></tr><tr><td>一致性哈希</td><td>静态/分布式</td><td>哈希请求 key 映射到 hash 环，适用于缓存或服务治理等场景</td><td>缓存命中率高，节点变化影响小</td><td>实现复杂，适合特定应用</td></tr></tbody></table><h2 id="redis哨兵运行的时候如果主节点抖了一下咋办-假如抖的时候来请求了咋办-刚好没有超过超时配置" tabindex="-1"><a class="header-anchor" href="#redis哨兵运行的时候如果主节点抖了一下咋办-假如抖的时候来请求了咋办-刚好没有超过超时配置"><span>Redis哨兵运行的时候如果主节点抖了一下咋办 假如抖的时候来请求了咋办 刚好没有超过超时配置？</span></a></h2><h3 id="情况描述" tabindex="-1"><a class="header-anchor" href="#情况描述"><span>情况描述</span></a></h3><ul><li>主节点短暂“抖动”或响应延迟，但没有完全宕机，且延迟时间没超过哨兵的**故障判定超时（<code>down-after-milliseconds</code>）**配置。</li><li>这个时候，有客户端请求打到主节点。</li></ul><h3 id="哨兵和请求处理过程" tabindex="-1"><a class="header-anchor" href="#哨兵和请求处理过程"><span>哨兵和请求处理过程</span></a></h3><ol><li><p><strong>哨兵对主节点的健康检查是周期性的，只有连续超过配置时间的不可用才认定为主节点宕机</strong></p><ul><li>例如 <code>down-after-milliseconds</code> = 30秒，主节点延迟10秒响应，哨兵不会立即判定它挂掉。</li></ul></li><li><p><strong>如果抖动时间没超过超时，哨兵认为主节点仍然正常</strong></p><ul><li>哨兵不会触发故障转移（failover）。</li></ul></li><li><p><strong>客户端请求会继续发给主节点</strong></p><ul><li>如果主节点还能响应请求，客户端会等待响应，可能会体验到延迟。</li><li>如果主节点真的卡死或拒绝请求，客户端会报错或超时。</li></ul></li><li><p><strong>哨兵只会在确定主节点“下线”后启动故障转移流程</strong></p><ul><li>故障转移会选举新的主节点，通知客户端（或客户端通过哨兵获取新主节点信息）。</li></ul></li></ol><h3 id="综上-抖动情况下请求表现" tabindex="-1"><a class="header-anchor" href="#综上-抖动情况下请求表现"><span>综上，抖动情况下请求表现</span></a></h3><table><thead><tr><th>事件</th><th>影响与处理</th></tr></thead><tbody><tr><td>抖动时间 &lt; 哨兵判定时间</td><td>哨兵认为主节点正常，请求继续发往主节点，可能有响应延迟</td></tr><tr><td>抖动时间 &gt; 哨兵判定时间</td><td>哨兵判定主节点故障，启动故障转移，客户端请求转向新主节点</td></tr><tr><td>主节点完全不可用</td><td>请求失败或超时，等待哨兵切换主节点</td></tr></tbody></table><h3 id="如何降低抖动带来的影响" tabindex="-1"><a class="header-anchor" href="#如何降低抖动带来的影响"><span>如何降低抖动带来的影响？</span></a></h3><ul><li><strong>调优哨兵故障判定参数</strong>，比如 <code>down-after-milliseconds</code>，根据业务对延迟和可用性的容忍度权衡设置。</li><li><strong>客户端设置合理的超时和重试机制</strong>。</li><li><strong>使用哨兵集群监控多个节点，避免单点误判</strong>。</li><li><strong>主节点性能调优，避免抖动</strong>。</li></ul><h2 id="如何实现防抖和节流" tabindex="-1"><a class="header-anchor" href="#如何实现防抖和节流"><span>如何实现防抖和节流？</span></a></h2><ul><li>前端实现</li></ul><table><thead><tr><th>特性</th><th>防抖（Debounce）</th><th>节流（Throttle）</th></tr></thead><tbody><tr><td>执行时机</td><td>事件停止触发后执行一次</td><td>按固定时间间隔执行一次</td></tr><tr><td>执行频率</td><td>多次触发只执行一次</td><td>多次触发按间隔执行多次</td></tr><tr><td>适用场景</td><td>输入框防抖、搜索、窗口大小调整完成后执行</td><td>滚动事件、窗口大小实时变化处理</td></tr><tr><td>触发函数次数</td><td>一定时间内只执行一次</td><td>一定时间内按频率执行多次</td></tr></tbody></table><h2 id="进程之间的通信方式" tabindex="-1"><a class="header-anchor" href="#进程之间的通信方式"><span>进程之间的通信方式？</span></a></h2><table><thead><tr><th>通信方式</th><th>是否共享内存</th><th>特点</th><th>应用场景</th></tr></thead><tbody><tr><td>管道（Pipe）</td><td>否</td><td>单向通信，父子进程之间使用</td><td>简单通信</td></tr><tr><td>命名管道（FIFO）</td><td>否</td><td>支持无亲缘关系的进程</td><td>本地通信</td></tr><tr><td>信号（Signal）</td><td>否</td><td>传递少量信号，用于进程控制</td><td>通知或中断</td></tr><tr><td>消息队列</td><td>否</td><td>结构化数据传递，有消息格式</td><td>解耦通信</td></tr><tr><td>共享内存</td><td>是</td><td>速度最快，需配合同步机制（如信号量）</td><td>大数据通信</td></tr><tr><td>信号量（Semaphore）</td><td>是/否</td><td>主要用于进程同步（可辅助共享内存）</td><td>同步控制</td></tr><tr><td>套接字（Socket）</td><td>否（可远程）</td><td>支持网络通信，<strong>可跨主机</strong></td><td>分布式系统</td></tr><tr><td>内存映射文件（mmap）</td><td>是</td><td>将文件映射进内存供多个进程访问</td><td>文件共享</td></tr></tbody></table><h2 id="linux查看进程有哪些命令" tabindex="-1"><a class="header-anchor" href="#linux查看进程有哪些命令"><span>Linux查看进程有哪些命令？</span></a></h2><p><strong>常用进程查看命令：</strong></p><table><thead><tr><th>命令</th><th>作用</th><th>常用参数</th><th>示例</th></tr></thead><tbody><tr><td><code>ps</code></td><td>查看进程快照</td><td><code>-ef</code>, <code>-aux</code></td><td><code>ps -ef | grep java</code></td></tr><tr><td><code>top</code></td><td>实时查看进程</td><td><code>-p PID</code></td><td><code>top -p 1234</code></td></tr><tr><td><code>htop</code></td><td>增强版top</td><td>交互式操作</td><td><code>htop</code></td></tr><tr><td><code>pgrep</code></td><td>按名称查找PID</td><td><code>-f</code> 完整命令行</td><td><code>pgrep -f tomcat</code></td></tr><tr><td><code>pidof</code></td><td>查找程序PID</td><td>程序名</td><td><code>pidof nginx</code></td></tr><tr><td><code>pstree</code></td><td>树形显示进程</td><td><code>-p</code> 显示PID</td><td><code>pstree -p</code></td></tr></tbody></table><p><strong>面试重点回答：</strong></p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>最常用的是ps和top：</span></span>\n<span class="line"><span>- ps -ef：查看所有进程的完整信息</span></span>\n<span class="line"><span>- ps -aux：显示详细的资源使用情况  </span></span>\n<span class="line"><span>- top：实时监控进程CPU、内存使用</span></span>\n<span class="line"><span>- pgrep：快速根据进程名查找PID</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="db一次请求正常时间应该是多少-redis呢" tabindex="-1"><a class="header-anchor" href="#db一次请求正常时间应该是多少-redis呢"><span>DB一次请求正常时间应该是多少？Redis呢？</span></a></h2><p><strong>数据库请求响应时间标准：</strong></p><table><thead><tr><th>数据库类型</th><th>正常响应时间</th><th>优秀水平</th><th>告警阈值</th><th>说明</th></tr></thead><tbody><tr><td><strong>MySQL</strong></td><td>10-50ms</td><td>&lt;10ms</td><td>&gt;100ms</td><td>简单查询，有索引</td></tr><tr><td><strong>PostgreSQL</strong></td><td>10-50ms</td><td>&lt;10ms</td><td>&gt;100ms</td><td>简单查询，有索引</td></tr><tr><td><strong>Redis</strong></td><td>0.1-1ms</td><td>&lt;0.5ms</td><td>&gt;5ms</td><td>内存操作，单线程</td></tr><tr><td><strong>MongoDB</strong></td><td>5-20ms</td><td>&lt;5ms</td><td>&gt;50ms</td><td>文档查询</td></tr></tbody></table><p><strong>影响因素：</strong></p><table><thead><tr><th>因素</th><th>MySQL影响</th><th>Redis影响</th><th>优化建议</th></tr></thead><tbody><tr><td>网络延迟</td><td>1-5ms</td><td>0.1-0.5ms</td><td>内网部署，减少跳数</td></tr><tr><td>查询复杂度</td><td>较大</td><td>很小</td><td>优化SQL，添加索引</td></tr><tr><td>数据量大小</td><td>较大</td><td>一般</td><td>分页查询，数据分片</td></tr><tr><td>并发连接数</td><td>较大</td><td>一般</td><td>连接池管理</td></tr></tbody></table><p><strong>面试重点回答：</strong></p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>- MySQL简单查询：10-50ms正常，超过100ms需要优化</span></span>\n<span class="line"><span>- Redis操作：0.1-1ms正常，超过5ms有问题</span></span>\n<span class="line"><span>- 复杂查询可能需要几百毫秒，需要优化SQL和索引</span></span>\n<span class="line"><span>- 网络延迟通常占1-5ms，内网部署可以降低</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="数据库orm连接池有哪些点需要考量" tabindex="-1"><a class="header-anchor" href="#数据库orm连接池有哪些点需要考量"><span>数据库ORM连接池有哪些点需要考量？</span></a></h2><p><strong>连接池核心参数：</strong></p><table><thead><tr><th>参数</th><th>作用</th><th>推荐值</th><th>设置依据</th></tr></thead><tbody><tr><td><strong>初始连接数</strong></td><td>启动时创建的连接数</td><td>5-10</td><td>避免冷启动，不宜过大</td></tr><tr><td><strong>最大连接数</strong></td><td>连接池最大容量</td><td>CPU核数×2</td><td>数据库承载能力</td></tr><tr><td><strong>最小空闲连接</strong></td><td>保持的最少连接数</td><td>5</td><td>保证响应速度</td></tr><tr><td><strong>最大空闲时间</strong></td><td>连接空闲多久被回收</td><td>10-30分钟</td><td>平衡资源利用和响应</td></tr><tr><td><strong>连接超时时间</strong></td><td>获取连接的超时时间</td><td>30秒</td><td>避免请求长时间等待</td></tr><tr><td><strong>验证查询</strong></td><td>检测连接有效性</td><td><code>SELECT 1</code></td><td>确保连接可用</td></tr></tbody></table><p><strong>连接池选型对比：</strong></p><table><thead><tr><th>连接池</th><th>特点</th><th>性能</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>HikariCP</strong></td><td>轻量级，启动快</td><td>最优</td><td>Spring Boot默认推荐</td></tr><tr><td><strong>Druid</strong></td><td>功能丰富，监控强</td><td>良好</td><td>需要详细监控的场景</td></tr><tr><td><strong>C3P0</strong></td><td>老牌稳定</td><td>一般</td><td>传统项目</td></tr><tr><td><strong>DBCP</strong></td><td>Apache出品</td><td>一般</td><td>简单场景</td></tr></tbody></table><p><strong>关键考量点：</strong></p><table><thead><tr><th>考量维度</th><th>关键问题</th><th>最佳实践</th></tr></thead><tbody><tr><td><strong>性能</strong></td><td>连接获取速度、资源消耗</td><td>选择HikariCP，合理设置连接数</td></tr><tr><td><strong>稳定性</strong></td><td>连接泄漏、死锁检测</td><td>启用连接验证，设置超时时间</td></tr><tr><td><strong>监控</strong></td><td>连接使用情况、异常统计</td><td>集成监控，设置告警</td></tr><tr><td><strong>扩展性</strong></td><td>动态调整连接数</td><td>支持运行时参数调整</td></tr></tbody></table><p><strong>面试重点回答：</strong></p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>主要考虑四个方面：</span></span>\n<span class="line"><span>1. 连接数设置：最大连接数=CPU核数×2，避免过大造成数据库压力</span></span>\n<span class="line"><span>2. 超时管理：连接超时、空闲超时要合理设置</span></span>\n<span class="line"><span>3. 连接验证：定期检查连接有效性，避免使用无效连接</span></span>\n<span class="line"><span>4. 监控告警：监控连接池使用情况，及时发现问题</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>推荐使用HikariCP，性能最优，Spring Boot默认选择。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="ip-分片-ip-fragmentation" tabindex="-1"><a class="header-anchor" href="#ip-分片-ip-fragmentation"><span>IP 分片（IP Fragmentation）</span></a></h2><h3 id="💡-背景" tabindex="-1"><a class="header-anchor" href="#💡-背景"><span>💡 背景：</span></a></h3><p>IP 层最大传输单元（MTU）是有限的。以太网典型 MTU 为 <strong>1500 字节</strong>。若上层数据超过 MTU，<strong>IP 层会自动分片</strong>。</p><h3 id="📦-分片原理" tabindex="-1"><a class="header-anchor" href="#📦-分片原理"><span>📦 分片原理：</span></a></h3><ul><li><p>IP 会将大的报文分成多个「分片片段（Fragment）」发送。</p></li><li><p>每个分片都有自己的 IP 头，其中含有如下关键字段：</p><ul><li><code>Identification</code>：表示这些分片属于同一 IP 报文</li><li><code>Fragment Offset</code>：表示当前分片在原始数据中的偏移量（单位是 8 字节）</li><li><code>MF (More Fragments)</code>：如果为 1 表示后面还有分片，为 0 表示这是最后一片</li></ul></li></ul><h3 id="📌-特点" tabindex="-1"><a class="header-anchor" href="#📌-特点"><span>📌 特点：</span></a></h3><ul><li><strong>由发送端进行分片，接收端重组（组装）</strong></li><li>一旦有任何一个分片丢失，整个 IP 报文重组失败</li></ul><h3 id="❗问题" tabindex="-1"><a class="header-anchor" href="#❗问题"><span>❗问题：</span></a></h3><ul><li>分片降低性能，增加丢包风险</li><li>TCP 尽量避免分片（通过 MSS 协商）</li></ul><h2 id="tcp-报文长度管理" tabindex="-1"><a class="header-anchor" href="#tcp-报文长度管理"><span>TCP 报文长度管理</span></a></h2><p>TCP 是<strong>面向字节流</strong>的协议，不关心「一次发送」对应「一次接收」，但必须控制每个报文长度。</p><h3 id="🚧-方式" tabindex="-1"><a class="header-anchor" href="#🚧-方式"><span>🚧 方式：</span></a></h3><ol><li><p><strong>MSS（Maximum Segment Size）最大报文段长度</strong></p><ul><li>MSS = MTU - IP头(20B) - TCP头(20B) ≈ <strong>1460 字节</strong></li><li>双方在三次握手时协商</li></ul></li><li><p><strong>TCP 头中的字段</strong></p><ul><li><code>Sequence Number</code>: 表示当前报文的起始字节序号</li><li><code>ACK Number</code>: 表示期望接收对方下一个字节</li><li><code>Window Size</code>: 表示本端还能接受多少字节（用于流控）</li></ul></li><li><p><strong>应用层的分段（Segmenting）</strong></p><ul><li>上层写入多大，TCP 可能<strong>按需拆分为多个段</strong>，或者<strong>合并多个小数据包</strong>（Nagle 算法）</li></ul></li></ol><h2 id="udp-最长报文长度是多少" tabindex="-1"><a class="header-anchor" href="#udp-最长报文长度是多少"><span>UDP 最长报文长度是多少？</span></a></h2><p>UDP 头部只有 8 字节，非常轻量。</p><h3 id="🧱-udp-报文长度" tabindex="-1"><a class="header-anchor" href="#🧱-udp-报文长度"><span>🧱 UDP 报文长度：</span></a></h3><ul><li>UDP 报文长度字段是 16 位 → 最大长度为 <strong>65535 字节</strong></li><li>UDP 报文 = UDP头（8字节）+ 数据</li><li>所以 UDP <strong>有效负载最大为 65507 字节</strong></li></ul><h3 id="❗但注意" tabindex="-1"><a class="header-anchor" href="#❗但注意"><span>❗但注意：</span></a></h3><ul><li>实际中大多数链路 MTU 限制了 UDP 报文大小</li><li>典型情况下 UDP 报文应 ≤ <strong>1472 字节</strong>，否则容易被分片</li></ul><h2 id="udp-和-tcp-报文头细节对比" tabindex="-1"><a class="header-anchor" href="#udp-和-tcp-报文头细节对比"><span>UDP 和 TCP 报文头细节对比</span></a></h2><table><thead><tr><th>项目</th><th>TCP 报文头</th><th>UDP 报文头</th></tr></thead><tbody><tr><td>头部长度</td><td>最小 20 字节（可变）</td><td>固定 8 字节</td></tr><tr><td>是否有连接</td><td>有（面向连接）</td><td>无（无连接）</td></tr><tr><td>是否可靠传输</td><td>是（重传、校验、确认）</td><td>否</td></tr><tr><td>流控/拥塞控制</td><td>有</td><td>无</td></tr><tr><td>分段处理</td><td>自动处理，保证顺序</td><td>无序、应用层处理</td></tr><tr><td>头部字段</td><td>复杂，包含序号、确认号、窗口、标志位等</td><td>简单，只包含端口和长度等</td></tr></tbody></table><h3 id="📌-tcp-报文头结构-20-字节起" tabindex="-1"><a class="header-anchor" href="#📌-tcp-报文头结构-20-字节起"><span>📌 TCP 报文头结构（20 字节起）：</span></a></h3><table><thead><tr><th>字段</th><th>描述</th></tr></thead><tbody><tr><td>Source Port</td><td>源端口</td></tr><tr><td>Destination Port</td><td>目标端口</td></tr><tr><td>Sequence Number</td><td>序列号（字节编号）</td></tr><tr><td>Acknowledgment Number</td><td>确认号</td></tr><tr><td>Data Offset</td><td>头部长度</td></tr><tr><td>Flags</td><td>如 SYN/ACK/FIN 等</td></tr><tr><td>Window Size</td><td>滑动窗口大小</td></tr><tr><td>Checksum</td><td>校验和</td></tr><tr><td>Urgent Pointer</td><td>紧急数据指针</td></tr><tr><td>Options</td><td>可选字段，如 MSS、窗口扩大等（可变长度）</td></tr></tbody></table><h3 id="📌-udp-报文头结构-固定-8-字节" tabindex="-1"><a class="header-anchor" href="#📌-udp-报文头结构-固定-8-字节"><span>📌 UDP 报文头结构（固定 8 字节）：</span></a></h3><table><thead><tr><th>字段</th><th>描述</th></tr></thead><tbody><tr><td>Source Port</td><td>源端口</td></tr><tr><td>Destination Port</td><td>目标端口</td></tr><tr><td>Length</td><td>UDP 报文长度</td></tr><tr><td>Checksum</td><td>校验和（IPv6 中必须）</td></tr></tbody></table><h2 id="消息队列如何实现分布式事务的" tabindex="-1"><a class="header-anchor" href="#消息队列如何实现分布式事务的"><span>消息队列如何实现分布式事务的？</span></a></h2><blockquote><p>分布式事务：多个系统（服务 A、服务 B、数据库、消息队列）需要在一个事务中「要么全部成功，要么全部失败」。</p></blockquote><p>⚠️ 问题是：</p><ul><li>每个服务/组件是独立系统，<strong>没有统一的事务管理器</strong></li><li>网络异常、系统崩溃很常见，传统两阶段提交（2PC）效率低、风险高</li></ul><h3 id="🎯-解决目标" tabindex="-1"><a class="header-anchor" href="#🎯-解决目标"><span>🎯 解决目标：</span></a></h3><blockquote><p>保证 <strong>最终一致性</strong>（而不是强一致性）</p></blockquote><p>即：各系统最终都会到达正确状态，中间可能短暂不一致。</p><h3 id="💡-消息队列的作用" tabindex="-1"><a class="header-anchor" href="#💡-消息队列的作用"><span>💡 消息队列的作用</span></a></h3><p>消息队列（如 Kafka、RabbitMQ、RocketMQ）是<strong>实现分布式事务的核心中间件</strong>，它不直接帮你做事务控制，而是：</p><ul><li><strong>解耦系统</strong></li><li><strong>通过可靠消息机制</strong>，让各系统异步处理</li><li><strong>引入消息状态回查机制</strong>，确保最终一致性</li></ul><h3 id="🧠-主流方案一-本地事务-消息发送-异步保证一致性" tabindex="-1"><a class="header-anchor" href="#🧠-主流方案一-本地事务-消息发送-异步保证一致性"><span>🧠 主流方案一：<strong>本地事务 + 消息发送（异步保证一致性）</strong></span></a></h3><h4 id="示例场景" tabindex="-1"><a class="header-anchor" href="#示例场景"><span>示例场景：</span></a></h4><p>订单系统下单后，异步通知库存系统扣减库存。</p><h4 id="流程图" tabindex="-1"><a class="header-anchor" href="#流程图"><span>流程图：</span></a></h4><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>[订单服务]</span></span>\n<span class="line"><span>1. 本地事务：写订单数据库</span></span>\n<span class="line"><span>2. 同时发送 MQ 消息（半消息）</span></span>\n<span class="line"><span>3. 本地事务成功后提交消息</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>[库存服务]</span></span>\n<span class="line"><span>4. 收到消息 → 执行扣库存逻辑</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="rocketmq-的典型实现-事务消息机制" tabindex="-1"><a class="header-anchor" href="#rocketmq-的典型实现-事务消息机制"><span>RocketMQ 的典型实现（事务消息机制）</span></a></h4><ol><li><p><strong>Producer 发送 prepare 消息（Half Message）</strong></p></li><li><p><strong>Broker 持久化但不投递</strong></p></li><li><p><strong>Producer 执行本地事务（如写订单库）</strong></p></li><li><p>根据结果：</p><ul><li>成功 → 提交消息（Broker 投递给 Consumer）</li><li>失败 → 回滚消息（丢弃）</li></ul></li></ol><p>💡 如果消息长时间未提交，Broker 会<strong>回查事务状态</strong>。</p><h3 id="🔁-主流方案二-可靠消息-本地事务-最终一致性" tabindex="-1"><a class="header-anchor" href="#🔁-主流方案二-可靠消息-本地事务-最终一致性"><span>🔁 主流方案二：<strong>可靠消息 + 本地事务（最终一致性）</strong></span></a></h3><p>这个方式更适用于不支持“半消息”的队列，比如 Kafka、RabbitMQ。</p><h4 id="步骤" tabindex="-1"><a class="header-anchor" href="#步骤"><span>步骤：</span></a></h4><ol><li>写一条本地“<strong>事务消息表（Outbox Table）</strong>”</li><li>与业务操作一起放入数据库事务中提交 ✅</li><li>后台定时任务或消息中间件扫描消息表 → 推送到 MQ</li><li>发送成功后将消息标记为“已发送”</li><li>消费方处理成功后 → 发确认回执</li></ol><p>🟢 这种方式不依赖消息中间件支持事务，适配性强。</p><h4 id="✨-核心技术点总结" tabindex="-1"><a class="header-anchor" href="#✨-核心技术点总结"><span>✨ 核心技术点总结</span></a></h4><table><thead><tr><th>技术</th><th>说明</th></tr></thead><tbody><tr><td><strong>事务消息</strong></td><td>支持半消息机制（如 RocketMQ）</td></tr><tr><td><strong>本地消息表 + 定时投递</strong></td><td>异步发送 + 手动投递，兼容性高</td></tr><tr><td><strong>幂等消费</strong></td><td>防止消息重复投递导致重复操作（如扣库存）</td></tr><tr><td><strong>消息回查机制</strong></td><td>Broker 超时未收到提交 → 主动询问事务状态</td></tr><tr><td><strong>最终一致性保障</strong></td><td>即使部分失败，可通过补偿、重试实现修复</td></tr></tbody></table><h4 id="🧪-示例-下单-扣减库存分布式事务" tabindex="-1"><a class="header-anchor" href="#🧪-示例-下单-扣减库存分布式事务"><span>🧪 示例：下单 + 扣减库存分布式事务</span></a></h4><div class="language-text line-numbers-mode" data-highlighter="shiki" data-ext="text" data-title="text" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>订单服务：</span></span>\n<span class="line"><span>BEGIN</span></span>\n<span class="line"><span>  1. 插入订单记录</span></span>\n<span class="line"><span>  2. 插入事务消息表（库存扣减消息）</span></span>\n<span class="line"><span>COMMIT</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>后台任务：</span></span>\n<span class="line"><span>  3. 轮询消息表，发送消息给 MQ</span></span>\n<span class="line"><span>  4. 更新消息状态为已投递</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>库存服务：</span></span>\n<span class="line"><span>  5. 接收消息，扣减库存</span></span>\n<span class="line"><span>  6. 消费成功，记录日志用于幂等控制</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="✅-总结-消息队列实现分布式事务的-2-大核心模式" tabindex="-1"><a class="header-anchor" href="#✅-总结-消息队列实现分布式事务的-2-大核心模式"><span>✅ 总结：消息队列实现分布式事务的 2 大核心模式</span></a></h3><table><thead><tr><th>模式</th><th>是否强依赖 MQ 支持</th><th>适用场景</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>事务消息（Half Message）</td><td>✅ 是（如 RocketMQ）</td><td>核心业务流程</td><td>原子性强，机制健全</td><td>实现复杂，MQ耦合</td></tr><tr><td>本地消息表（Outbox）</td><td>❌ 否</td><td>兼容任意 MQ</td><td>可控、兼容性好</td><td>需要开发定时投递逻辑</td></tr></tbody></table><h2 id="判断丢包" tabindex="-1"><a class="header-anchor" href="#判断丢包"><span>判断丢包</span></a></h2><h3 id="tcp层面" tabindex="-1"><a class="header-anchor" href="#tcp层面"><span>TCP层面</span></a></h3><ul><li>序列号机制：通过序列号检测丢包</li><li>重传机制：丢包后自动重传</li><li>RTT计算：往返时间计算</li></ul><h3 id="应用层面" tabindex="-1"><a class="header-anchor" href="#应用层面"><span>应用层面</span></a></h3><ul><li>心跳机制：定期发送心跳包</li><li>确认机制：应用层确认机制</li><li>超时重传：超时后重传数据</li></ul><h3 id="网络层面" tabindex="-1"><a class="header-anchor" href="#网络层面"><span>网络层面</span></a></h3><ul><li>ICMP：网络层丢包检测</li><li>ping命令：测试网络连通性</li><li>traceroute：路由路径检测</li></ul><h2 id="tcp服务器创建过程中的socket系统调用" tabindex="-1"><a class="header-anchor" href="#tcp服务器创建过程中的socket系统调用"><span>TCP服务器创建过程中的socket系统调用</span></a></h2><ul><li><strong>socket()</strong>：创建socket文件描述符</li><li><strong>bind()</strong>：绑定IP地址和端口</li><li><strong>listen()</strong>：开始监听连接</li><li><strong>accept()</strong>：接受客户端连接</li><li><strong>close()</strong>：关闭socket</li></ul><h2 id="整个流程详解" tabindex="-1"><a class="header-anchor" href="#整个流程详解"><span>整个流程详解</span></a></h2><h3 id="服务器端流程" tabindex="-1"><a class="header-anchor" href="#服务器端流程"><span>服务器端流程</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>1. socket() → 2. bind() → 3. listen() → 4. accept() → 5. 处理连接</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="详细步骤" tabindex="-1"><a class="header-anchor" href="#详细步骤"><span>详细步骤</span></a></h3><ol><li><strong>socket()</strong>：创建TCP socket</li><li><strong>bind()</strong>：绑定IP和端口</li><li><strong>listen()</strong>：设置监听队列</li><li><strong>accept()</strong>：等待客户端连接</li><li><strong>数据收发</strong>：read()/write()或send()/recv()</li><li><strong>close()</strong>：关闭连接</li></ol><h3 id="客户端流程" tabindex="-1"><a class="header-anchor" href="#客户端流程"><span>客户端流程</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>1. socket() → 2. connect() → 3. 数据收发 → 4. close()</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h2 id="应用层解决udp错包问题" tabindex="-1"><a class="header-anchor" href="#应用层解决udp错包问题"><span>应用层解决UDP错包问题</span></a></h2><h3 id="udp的不可靠性" tabindex="-1"><a class="header-anchor" href="#udp的不可靠性"><span>UDP的不可靠性</span></a></h3><ul><li><strong>丢包</strong>：网络拥塞导致数据包丢失</li><li><strong>乱序</strong>：数据包到达顺序不确定</li><li><strong>重复</strong>：网络重传导致重复包</li></ul><h3 id="具体实现策略" tabindex="-1"><a class="header-anchor" href="#具体实现策略"><span>具体实现策略</span></a></h3><table><thead><tr><th>策略</th><th>实现方式</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td><strong>序列号</strong></td><td>每个包分配唯一序列号</td><td>检测丢包和乱序</td><td>增加包头开销</td></tr><tr><td><strong>确认机制</strong></td><td>接收方发送ACK</td><td>可靠传输</td><td>增加网络开销</td></tr><tr><td><strong>超时重传</strong></td><td>超时后重传数据包</td><td>保证数据到达</td><td>增加延迟</td></tr><tr><td><strong>滑动窗口</strong></td><td>控制发送窗口大小</td><td>流量控制</td><td>实现复杂</td></tr></tbody></table><h2 id="epoll用红黑树为什么没有fd2048数量限制" tabindex="-1"><a class="header-anchor" href="#epoll用红黑树为什么没有fd2048数量限制"><span>epoll用红黑树为什么没有FD2048数量限制？</span></a></h2><h3 id="select的限制" tabindex="-1"><a class="header-anchor" href="#select的限制"><span><strong>select的限制</strong></span></a></h3><ul><li><strong>FD_SETSIZE</strong>：默认1024，最大2048</li><li><strong>位图结构</strong>：使用位图表示FD集合</li><li><strong>轮询机制</strong>：需要遍历所有FD</li></ul><h3 id="epoll的优势" tabindex="-1"><a class="header-anchor" href="#epoll的优势"><span><strong>epoll的优势</strong></span></a></h3><ul><li><strong>红黑树</strong>：高效的数据结构，O(log n)复杂度</li><li><strong>事件驱动</strong>：只处理就绪的FD</li><li><strong>无数量限制</strong>：受系统资源限制，理论上无上限</li></ul><h3 id="数据结构对比" tabindex="-1"><a class="header-anchor" href="#数据结构对比"><span><strong>数据结构对比</strong></span></a></h3><table><thead><tr><th>特性</th><th>select</th><th>epoll</th></tr></thead><tbody><tr><td><strong>数据结构</strong></td><td>位图</td><td>红黑树</td></tr><tr><td><strong>时间复杂度</strong></td><td>O(n)</td><td>O(log n)</td></tr><tr><td><strong>FD数量限制</strong></td><td>2048</td><td>无限制</td></tr><tr><td><strong>效率</strong></td><td>低</td><td>高</td></tr></tbody></table><h2 id="网络包拆包是在哪一层" tabindex="-1"><a class="header-anchor" href="#网络包拆包是在哪一层"><span>网络包拆包是在哪一层？</span></a></h2><table><thead><tr><th>层级</th><th>是否拆包</th><th>原因</th></tr></thead><tbody><tr><td><strong>数据链路层（第 2 层）</strong></td><td>✅ 是</td><td>Ethernet 最大帧长为 1500 字节，超出会被拆分成多个帧发送（MTU 限制）</td></tr><tr><td><strong>网络层（第 3 层）</strong></td><td>✅ 是</td><td>IP 协议支持“分片”（Fragmentation），当数据包超过 MTU 时发生</td></tr><tr><td><strong>传输层（第 4 层）</strong></td><td>✅ 是</td><td>TCP 有“报文段（segment）”，应用层数据会被拆成多个 TCP 段发送</td></tr></tbody></table><h2 id="redis集群如果多个-key-是连续的或相关的-是否可以插入到同一个节点" tabindex="-1"><a class="header-anchor" href="#redis集群如果多个-key-是连续的或相关的-是否可以插入到同一个节点"><span>Redis集群如果多个 key 是连续的或相关的，是否可以插入到同一个节点？</span></a></h2><ul><li>策略：使用 “hash tag” 让相关 key 落在同一个 slot</li></ul><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>key1 = user:{123}:name</span></span>\n<span class="line"><span>key2 = user:{123}:age</span></span>\n<span class="line"><span>key3 = user:{123}:email</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>Redis Cluster 只会对大括号 {} 中的内容做哈希</li><li>上面三个 key 都会使用 123 作为 hash tag → 落在相同的 slot → 插入同一节点</li></ul><p>✅ 场景好处：</p><ul><li>可以批量操作这些 key（如 MGET、MSET）</li><li>可以减少跨节点操作，提高性能</li><li>避免 CROSSSLOT 错误</li></ul><h2 id="两个地址在网络中的通信流程" tabindex="-1"><a class="header-anchor" href="#两个地址在网络中的通信流程"><span>两个地址在网络中的通信流程？</span></a></h2><ul><li>应用层（HTTP / FTP 等） <ul><li>应用发起请求（如浏览器访问网站）</li></ul></li><li>传输层（TCP / UDP） <ul><li>把数据切成若干“段”，加上源端口和目标端口（如 TCP 80）</li></ul></li><li>网络层（IP） <ul><li>给包加上源 IP、目标 IP → 决定目标地址是谁</li></ul></li><li>数据链路层（Ethernet） <ul><li>把数据封装成帧，加上 MAC 地址，准备发送</li></ul></li><li>物理层（网线/无线） <ul><li>以比特流的形式通过电信号/光信号等传输出去</li></ul></li></ul><h2 id="大数据去重" tabindex="-1"><a class="header-anchor" href="#大数据去重"><span>大数据去重？</span></a></h2><h3 id="bitmap" tabindex="-1"><a class="header-anchor" href="#bitmap"><span>BitMap</span></a></h3><ul><li>空间效率极高 <ul><li>传统方法：存储每个元素需要4-8字节</li><li>BitMap：每个元素只需要1位（bit）</li><li>空间节省：节省32-64倍存储空间</li></ul></li><li>时间复杂度优秀 <ul><li>插入操作：O(1) - 直接设置对应位</li><li>查询操作：O(1) - 直接检查对应位</li><li>去重操作：O(n) - 遍历一次即可</li></ul></li></ul><h2 id="ddd架构" tabindex="-1"><a class="header-anchor" href="#ddd架构"><span>DDD架构</span></a></h2><h4 id="核心概念-1" tabindex="-1"><a class="header-anchor" href="#核心概念-1"><span><strong>核心概念</strong></span></a></h4><ul><li><strong>领域驱动设计</strong>：以业务领域为核心，通过领域模型驱动软件设计</li><li><strong>领域模型</strong>：反映业务概念和规则的抽象模型</li><li><strong>分层架构</strong>：按业务领域分层，而非技术分层</li></ul><h4 id="ddd分层架构" tabindex="-1"><a class="header-anchor" href="#ddd分层架构"><span><strong>DDD分层架构</strong></span></a></h4><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>用户界面层（Interface/User Interface）</span></span>\n<span class="line"><span>    ↓</span></span>\n<span class="line"><span>应用层（Application）</span></span>\n<span class="line"><span>    ↓</span></span>\n<span class="line"><span>领域层（Domain）</span></span>\n<span class="line"><span>    ↓</span></span>\n<span class="line"><span>基础设施层（Infrastructure）</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="ddd-vs-传统架构对比" tabindex="-1"><a class="header-anchor" href="#ddd-vs-传统架构对比"><span><strong>DDD vs 传统架构对比</strong></span></a></h3><h4 id="_1-分层方式" tabindex="-1"><a class="header-anchor" href="#_1-分层方式"><span><strong>1. 分层方式</strong></span></a></h4><table><thead><tr><th>维度</th><th>传统三层架构</th><th>DDD架构</th></tr></thead><tbody><tr><td><strong>分层依据</strong></td><td>技术职责</td><td>业务领域</td></tr><tr><td><strong>核心层</strong></td><td>业务逻辑层</td><td>领域层</td></tr><tr><td><strong>依赖方向</strong></td><td>上层依赖下层</td><td>内层不依赖外层</td></tr><tr><td><strong>关注点</strong></td><td>技术实现</td><td>业务价值</td></tr></tbody></table><h4 id="_2-设计思路" tabindex="-1"><a class="header-anchor" href="#_2-设计思路"><span><strong>2. 设计思路</strong></span></a></h4><h5 id="传统三层架构" tabindex="-1"><a class="header-anchor" href="#传统三层架构"><span><strong>传统三层架构</strong></span></a></h5><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>表现层 → 业务逻辑层 → 数据访问层</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li><strong>技术导向</strong>：按技术职责分层</li><li><strong>数据驱动</strong>：以数据为中心</li><li><strong>贫血模型</strong>：实体类只有getter/setter</li></ul><h5 id="ddd架构-1" tabindex="-1"><a class="header-anchor" href="#ddd架构-1"><span><strong>DDD架构</strong></span></a></h5><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>用户界面层 → 应用层 → 领域层 → 基础设施层</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li><strong>业务导向</strong>：按业务领域分层</li><li><strong>领域驱动</strong>：以领域模型为中心</li><li><strong>充血模型</strong>：实体类包含业务逻辑</li></ul><h3 id="ddd核心组件" tabindex="-1"><a class="header-anchor" href="#ddd核心组件"><span><strong>DDD核心组件</strong></span></a></h3><h4 id="_1-领域层-domain-layer" tabindex="-1"><a class="header-anchor" href="#_1-领域层-domain-layer"><span><strong>1. 领域层（Domain Layer）</strong></span></a></h4><ul><li><strong>实体（Entity）</strong>：有唯一标识的对象</li><li><strong>值对象（Value Object）</strong>：无唯一标识的对象</li><li><strong>领域服务（Domain Service）</strong>：跨实体的业务逻辑</li><li><strong>聚合（Aggregate）</strong>：业务边界内的对象集合</li><li><strong>仓储（Repository）</strong>：数据访问抽象</li></ul><h4 id="_2-应用层-application-layer" tabindex="-1"><a class="header-anchor" href="#_2-应用层-application-layer"><span><strong>2. 应用层（Application Layer）</strong></span></a></h4><ul><li><strong>应用服务（Application Service）</strong>：协调领域对象</li><li><strong>DTO</strong>：数据传输对象</li><li><strong>命令/查询</strong>：CQRS模式</li></ul><h4 id="_3-基础设施层-infrastructure-layer" tabindex="-1"><a class="header-anchor" href="#_3-基础设施层-infrastructure-layer"><span><strong>3. 基础设施层（Infrastructure Layer）</strong></span></a></h4><ul><li><strong>仓储实现</strong>：具体的数据访问实现</li><li><strong>外部服务</strong>：第三方服务集成</li><li><strong>消息队列</strong>：异步消息处理</li></ul><h3 id="架构特点对比" tabindex="-1"><a class="header-anchor" href="#架构特点对比"><span><strong>架构特点对比</strong></span></a></h3><table><thead><tr><th>特性</th><th>传统三层架构</th><th>DDD架构</th></tr></thead><tbody><tr><td><strong>设计导向</strong></td><td>技术导向</td><td>业务导向</td></tr><tr><td><strong>模型设计</strong></td><td>贫血模型</td><td>充血模型</td></tr><tr><td><strong>业务逻辑</strong></td><td>服务层</td><td>领域层</td></tr><tr><td><strong>数据访问</strong></td><td>DAO模式</td><td>仓储模式</td></tr><tr><td><strong>依赖关系</strong></td><td>上层依赖下层</td><td>内层不依赖外层</td></tr><tr><td><strong>可维护性</strong></td><td>中等</td><td>高</td></tr><tr><td><strong>可扩展性</strong></td><td>中等</td><td>高</td></tr><tr><td><strong>学习成本</strong></td><td>低</td><td>高</td></tr></tbody></table><h3 id="适用场景对比" tabindex="-1"><a class="header-anchor" href="#适用场景对比"><span><strong>适用场景对比</strong></span></a></h3><h4 id="传统三层架构适用场景" tabindex="-1"><a class="header-anchor" href="#传统三层架构适用场景"><span><strong>传统三层架构适用场景</strong></span></a></h4><ul><li><strong>简单业务</strong>：业务逻辑相对简单</li><li><strong>快速开发</strong>：需要快速交付</li><li><strong>团队技能</strong>：团队对DDD不熟悉</li><li><strong>遗留系统</strong>：维护现有系统</li></ul><h4 id="ddd架构适用场景" tabindex="-1"><a class="header-anchor" href="#ddd架构适用场景"><span><strong>DDD架构适用场景</strong></span></a></h4><ul><li><strong>复杂业务</strong>：业务逻辑复杂</li><li><strong>长期维护</strong>：需要长期维护和演进</li><li><strong>团队技能</strong>：团队具备DDD经验</li><li><strong>新系统</strong>：从零开始设计</li></ul><h3 id="优势劣势对比" tabindex="-1"><a class="header-anchor" href="#优势劣势对比"><span><strong>优势劣势对比</strong></span></a></h3><h4 id="ddd优势" tabindex="-1"><a class="header-anchor" href="#ddd优势"><span><strong>DDD优势</strong></span></a></h4><ul><li><strong>业务导向</strong>：以业务价值为核心</li><li><strong>可维护性</strong>：业务逻辑集中，易于维护</li><li><strong>可扩展性</strong>：领域模型清晰，易于扩展</li><li><strong>团队协作</strong>：业务和技术团队沟通顺畅</li></ul><h4 id="ddd劣势" tabindex="-1"><a class="header-anchor" href="#ddd劣势"><span><strong>DDD劣势</strong></span></a></h4><ul><li><strong>学习成本</strong>：概念多，学习曲线陡峭</li><li><strong>开发成本</strong>：初期开发成本高</li><li><strong>过度设计</strong>：简单业务可能过度设计</li><li><strong>团队要求</strong>：需要团队具备DDD经验</li></ul><h3 id="ddd核心思想" tabindex="-1"><a class="header-anchor" href="#ddd核心思想"><span><strong>DDD核心思想：</strong></span></a></h3><ul><li>以业务领域为核心，通过领域模型驱动设计</li><li>按业务领域分层，而非技术分层</li><li>充血模型，实体包含业务逻辑</li><li>内层不依赖外层，依赖倒置</li></ul><p><strong>与传统架构对比：</strong></p><ul><li>传统架构：技术导向，贫血模型，三层架构</li><li>DDD架构：业务导向，充血模型，分层架构</li></ul><p><strong>选择建议：</strong></p><ul><li>简单业务、快速开发 → 传统三层架构</li><li>复杂业务、长期维护 → DDD架构</li></ul><h2 id="linux管道是什么" tabindex="-1"><a class="header-anchor" href="#linux管道是什么"><span>Linux管道是什么？</span></a></h2><h2 id="mysql架构分层及工作流程" tabindex="-1"><a class="header-anchor" href="#mysql架构分层及工作流程"><span>MySQL架构分层及工作流程</span></a></h2><ul><li>连接管理层：处理客户端连接认证，线程管理。</li><li>SQL解析层：解析SQL语句成解析树。</li><li>优化器层：基于统计信息生成执行计划，决定使用哪些索引，JOIN顺序。</li><li>执行引擎层：根据执行计划，调用存储引擎接口执行。</li><li>存储引擎层：负责数据存储，读取，索引操作（如 InnoDB）。</li></ul><h2 id="mysql执行sql时如何知道扫描行数-执行计划" tabindex="-1"><a class="header-anchor" href="#mysql执行sql时如何知道扫描行数-执行计划"><span>MySQL执行SQL时如何知道扫描行数（执行计划）</span></a></h2><ul><li>通过 EXPLAIN 命令查看执行计划，包含： <ul><li>访问类型（全表扫描、索引扫描等）</li><li>预计扫描的行数（rows字段）</li><li>使用的索引</li></ul></li><li>优化器基于统计信息和索引信息估算扫描行数。</li></ul><h2 id="性能毛刺及死锁原因" tabindex="-1"><a class="header-anchor" href="#性能毛刺及死锁原因"><span>性能毛刺及死锁原因</span></a></h2><ul><li>性能毛刺：CPU突发高负载、缓存失效、慢查询、锁竞争、I/O瓶颈。</li><li>死锁原因：两个或多个事务互相等待对方持有的锁，导致永远等待。常见于多表复杂事务或索引不合理。</li></ul><h2 id="mysql连接池状态查看" tabindex="-1"><a class="header-anchor" href="#mysql连接池状态查看"><span>MySQL连接池状态查看</span></a></h2><ul><li>通过连接池管理工具或应用日志查看连接池参数。 在数据库端可查看当前活动连接：</li></ul><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">SHOW PROCESSLIST;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">SHOW </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">STATUS</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> LIKE</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;Threads_connected&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>结合应用端连接池监控（如 HikariCP、Druid）查看连接池使用情况。</p><h2 id="静态代码块加载顺序" tabindex="-1"><a class="header-anchor" href="#静态代码块加载顺序"><span>静态代码块加载顺序</span></a></h2><ol><li><p><strong>类加载时执行</strong></p><ul><li>类第一次被加载到 JVM 中时，静态代码块会被执行。</li><li>执行时机是在<strong>类的静态变量初始化之前或之后（按代码顺序）</strong>，且只执行一次。</li></ul></li><li><p><strong>多个静态代码块按顺序执行</strong></p><ul><li>如果一个类中有多个静态代码块，它们会按照<strong>在类中出现的先后顺序依次执行</strong>。</li><li>与静态变量初始化按代码顺序交叉执行。</li></ul></li><li><p><strong>子类加载时，先执行父类静态代码块，再执行子类的</strong></p><ul><li>JVM 加载子类时，先加载父类，父类的静态代码块先执行，之后执行子类的。</li></ul></li></ol><h3 id="例子说明" tabindex="-1"><a class="header-anchor" href="#例子说明"><span>例子说明</span></a></h3><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Test</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    static</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> {</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;静态代码块1&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> x </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> initializeX</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    static</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> {</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;静态代码块2&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> initializeX</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;静态变量初始化&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 5</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> main</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[] </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">args</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;main方法执行&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>输出顺序：</strong></p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>静态代码块1</span></span>\n<span class="line"><span>静态变量初始化</span></span>\n<span class="line"><span>静态代码块2</span></span>\n<span class="line"><span>main方法执行</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="二叉树类型" tabindex="-1"><a class="header-anchor" href="#二叉树类型"><span>二叉树类型</span></a></h2><table><thead><tr><th>二叉树类型</th><th>说明</th><th>查找/插入/删除平均时间复杂度</th><th>备注</th></tr></thead><tbody><tr><td><strong>普通二叉树</strong></td><td>每个节点最多有两个子节点，结构不限</td><td>O(n)</td><td>没有顺序限制，遍历时最坏是全部节点</td></tr><tr><td><strong>二叉搜索树 (BST)</strong></td><td>左子树所有节点 &lt; 根节点 &lt; 右子树所有节点</td><td>平均 O(log n)，最坏 O(n)</td><td>若退化成链表，性能退化</td></tr><tr><td><strong>平衡二叉搜索树</strong></td><td>自平衡的 BST，如 AVL 树、红黑树</td><td>O(log n)</td><td>保证树高是 O(log n)，性能稳定</td></tr><tr><td><strong>满二叉树</strong></td><td>除了叶子节点，每个节点都有两个子节点</td><td>与普通二叉树类似</td><td>结构紧凑，节点数量固定</td></tr><tr><td><strong>完全二叉树</strong></td><td>除了最底层外，其他层节点数都满，且叶子尽可能左对齐</td><td>与普通二叉树类似</td><td>常用于堆的实现</td></tr><tr><td><strong>平衡二叉树</strong></td><td>任意节点左右子树高度差 ≤ 1</td><td>O(log n)</td><td>AVL 是典型平衡二叉树</td></tr></tbody></table><h2 id="消息队列的投递机制-至多一次-至少一次-恰好一次" tabindex="-1"><a class="header-anchor" href="#消息队列的投递机制-至多一次-至少一次-恰好一次"><span>消息队列的投递机制？至多一次，至少一次，恰好一次？</span></a></h2><table><thead><tr><th>投递语义</th><th>说明</th><th>优点</th><th>缺点</th><th>实现关键点</th></tr></thead><tbody><tr><td><strong>At most once（至多一次）</strong></td><td>消息最多被投递一次，不会重复，但可能丢失。</td><td>延迟低，性能高</td><td>消息可能丢失</td><td>不做确认（ACK），或 ACK 在处理前就发出</td></tr><tr><td><strong>At least once（至少一次）</strong></td><td>消息至少被投递一次，不会丢失，但可能重复。</td><td>不丢消息</td><td>可能重复，需要去重</td><td>ACK 在处理完成后发送，失败会重试</td></tr><tr><td><strong>Exactly once（恰好一次）</strong></td><td>消息恰好投递一次，既不丢失，也不重复。</td><td>数据一致性最佳</td><td>实现复杂，性能开销大</td><td>去重 + 幂等 + 两阶段提交/事务</td></tr></tbody></table><h2 id="设计银行存取款和转账业务的具体实现-除了加锁还有什么" tabindex="-1"><a class="header-anchor" href="#设计银行存取款和转账业务的具体实现-除了加锁还有什么"><span>设计银行存取款和转账业务的具体实现，除了加锁还有什么？</span></a></h2><table><thead><tr><th>方法</th><th>作用</th><th>优缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>数据库事务</td><td>保证操作原子性</td><td>简单可靠，性能有限</td><td>单库操作，简单转账</td></tr><tr><td>分布式事务</td><td>跨系统保证一致性</td><td>实现复杂，性能开销大</td><td>跨库或跨系统转账</td></tr><tr><td>乐观锁</td><td>减少锁竞争，适合高并发</td><td>可能需要重试，写冲突时失败</td><td>高并发写操作</td></tr><tr><td>悲观锁</td><td>严格控制并发访问</td><td>可能导致阻塞、死锁</td><td>冲突高且必须保证绝对一致性</td></tr><tr><td>幂等设计</td><td>防止重复执行</td><td>需要额外设计和存储请求ID</td><td>网络重试、重复请求防护</td></tr><tr><td>异步消息+补偿</td><td>提升吞吐，保证最终一致</td><td>复杂，开发成本高</td><td>分布式环境，高吞吐</td></tr><tr><td>分库分片</td><td>降低单点压力</td><td>复杂度高，跨库操作复杂</td><td>超大规模账户系统</td></tr><tr><td>并发限流</td><td>防止流量暴涨导致系统崩溃</td><td>可能导致请求拒绝或延迟</td><td>高峰期流量控制</td></tr><tr><td>业务校验和风控</td><td>保证合法性和安全</td><td>业务复杂，需维护规则</td><td>所有业务流程</td></tr></tbody></table><h2 id="_2pc和3pc的区别" tabindex="-1"><a class="header-anchor" href="#_2pc和3pc的区别"><span>2PC和3PC的区别</span></a></h2><table><thead><tr><th>比较维度</th><th>两阶段提交（2PC）</th><th>三阶段提交（3PC）</th></tr></thead><tbody><tr><td><strong>阶段数</strong></td><td>2阶段：准备（Prepare）、提交（Commit）</td><td>3阶段：询问（CanCommit）、预提交（PreCommit）、提交（DoCommit）</td></tr><tr><td><strong>通信次数</strong></td><td>2次往返（协调者→参与者，参与者→协调者）</td><td>3次往返</td></tr><tr><td><strong>阻塞风险</strong></td><td>存在阻塞风险；协调者崩溃，参与者可能无限等待</td><td>阻塞风险降低；增加预提交阶段，参与者状态更明确</td></tr><tr><td><strong>协调者崩溃处理</strong></td><td>协调者崩溃时，参与者状态不确定，可能阻塞</td><td>协调者崩溃时，参与者通过超时自动决定回滚或提交</td></tr><tr><td><strong>参与者崩溃处理</strong></td><td>参与者崩溃可通过重启恢复</td><td>参与者崩溃恢复策略相同</td></tr><tr><td><strong>协议复杂度</strong></td><td>简单，易实现</td><td>较复杂，增加了预提交阶段和状态管理</td></tr><tr><td><strong>实时性</strong></td><td>较高，阶段较少</td><td>较低，因多一阶段通信</td></tr><tr><td><strong>适用场景</strong></td><td>适合对阻塞可接受、实现简单的分布式事务</td><td>适合对可用性和非阻塞有更高要求的分布式系统</td></tr><tr><td><strong>安全性</strong></td><td>有阻塞死锁隐患</td><td>改善了阻塞死锁问题，但不能完全避免网络分区</td></tr></tbody></table>',426)]))}]]),d=JSON.parse('{"path":"/zh/posts/review/%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98.html","title":"其他问题","lang":"zh-CN","frontmatter":{"icon":"pen-to-square","date":"2025-07-24T00:00:00.000Z","category":["Learning Records"],"tag":["Review"],"description":"其他问题 MySQL Buffer Pool里都有什么？ MySQL 的 Buffer Pool（缓冲池）是 InnoDB 存储引擎中最核心的内存区域，主要用于缓存磁盘上的数据页，加速数据读写。 Redis底层相关数据结构了解吗？ 压缩结构（ziplist、listpack）：适合小数据量，省空间。 链表/quicklist/skiplist：适合大数...","head":[["meta",{"property":"og:url","content":"https://crc011220.github.io/zh/posts/review/%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98.html"}],["meta",{"property":"og:site_name","content":"Ruochen Chen"}],["meta",{"property":"og:title","content":"其他问题"}],["meta",{"property":"og:description","content":"其他问题 MySQL Buffer Pool里都有什么？ MySQL 的 Buffer Pool（缓冲池）是 InnoDB 存储引擎中最核心的内存区域，主要用于缓存磁盘上的数据页，加速数据读写。 Redis底层相关数据结构了解吗？ 压缩结构（ziplist、listpack）：适合小数据量，省空间。 链表/quicklist/skiplist：适合大数..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-20T01:23:49.000Z"}],["meta",{"property":"article:tag","content":"Review"}],["meta",{"property":"article:published_time","content":"2025-07-24T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-20T01:23:49.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"其他问题\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-07-24T00:00:00.000Z\\",\\"dateModified\\":\\"2025-08-20T01:23:49.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Ruochen Chen\\"}]}"]]},"headers":[{"level":2,"title":"MySQL Buffer Pool里都有什么？","slug":"mysql-buffer-pool里都有什么","link":"#mysql-buffer-pool里都有什么","children":[]},{"level":2,"title":"Redis底层相关数据结构了解吗？","slug":"redis底层相关数据结构了解吗","link":"#redis底层相关数据结构了解吗","children":[]},{"level":2,"title":"可以基于UDP实现可靠通信吗？HTTP3知道吗？","slug":"可以基于udp实现可靠通信吗-http3知道吗","link":"#可以基于udp实现可靠通信吗-http3知道吗","children":[]},{"level":2,"title":"项目是基于HTTP吗，为什么要基于HTTP来做，TCP不行吗？","slug":"项目是基于http吗-为什么要基于http来做-tcp不行吗","link":"#项目是基于http吗-为什么要基于http来做-tcp不行吗","children":[]},{"level":2,"title":"如果要在分布式中保持强一致性和最终一致性分别有什么做法？","slug":"如果要在分布式中保持强一致性和最终一致性分别有什么做法","link":"#如果要在分布式中保持强一致性和最终一致性分别有什么做法","children":[{"level":3,"title":"一、强一致性（Strong Consistency）","slug":"一、强一致性-strong-consistency","link":"#一、强一致性-strong-consistency","children":[]},{"level":3,"title":"二、最终一致性（Eventual Consistency）","slug":"二、最终一致性-eventual-consistency","link":"#二、最终一致性-eventual-consistency","children":[]},{"level":3,"title":"总结","slug":"总结","link":"#总结","children":[]}]},{"level":2,"title":"Redis的事务了解吗，Redis的事务和MySQL的事务最大的区别在什么地方？","slug":"redis的事务了解吗-redis的事务和mysql的事务最大的区别在什么地方","link":"#redis的事务了解吗-redis的事务和mysql的事务最大的区别在什么地方","children":[{"level":3,"title":"1. Redis 的事务","slug":"_1-redis-的事务","link":"#_1-redis-的事务","children":[]},{"level":3,"title":"2. MySQL 的事务","slug":"_2-mysql-的事务","link":"#_2-mysql-的事务","children":[]},{"level":3,"title":"3. 最大区别","slug":"_3-最大区别","link":"#_3-最大区别","children":[]}]},{"level":2,"title":"毒性反转是什么？是哪一层的概念？","slug":"毒性反转是什么-是哪一层的概念","link":"#毒性反转是什么-是哪一层的概念","children":[]},{"level":2,"title":"死锁和OOM如何排查","slug":"死锁和oom如何排查","link":"#死锁和oom如何排查","children":[]},{"level":2,"title":"布隆过滤器的原理？什么情况下是误判？","slug":"布隆过滤器的原理-什么情况下是误判","link":"#布隆过滤器的原理-什么情况下是误判","children":[]},{"level":2,"title":"JWT组成部分有哪些，怎么配合拦截器实现校验和刷新的，拦截器是怎么做的？","slug":"jwt组成部分有哪些-怎么配合拦截器实现校验和刷新的-拦截器是怎么做的","link":"#jwt组成部分有哪些-怎么配合拦截器实现校验和刷新的-拦截器是怎么做的","children":[]},{"level":2,"title":"拦截器和过滤器有什么区别？","slug":"拦截器和过滤器有什么区别","link":"#拦截器和过滤器有什么区别","children":[]},{"level":2,"title":"ThreadLocalMap 的 key 为什么是弱引用？","slug":"threadlocalmap-的-key-为什么是弱引用","link":"#threadlocalmap-的-key-为什么是弱引用","children":[]},{"level":2,"title":"MySQL锁的原理","slug":"mysql锁的原理","link":"#mysql锁的原理","children":[{"level":3,"title":"1. MySQL 常见锁类型","slug":"_1-mysql-常见锁类型","link":"#_1-mysql-常见锁类型","children":[]},{"level":3,"title":"2. 不同存储引擎的锁实现","slug":"_2-不同存储引擎的锁实现","link":"#_2-不同存储引擎的锁实现","children":[]},{"level":3,"title":"3. 行级锁的实现原理（InnoDB）","slug":"_3-行级锁的实现原理-innodb","link":"#_3-行级锁的实现原理-innodb","children":[]},{"level":3,"title":"4. 间隙锁/临键锁的实现原理","slug":"_4-间隙锁-临键锁的实现原理","link":"#_4-间隙锁-临键锁的实现原理","children":[]},{"level":3,"title":"5. 意向锁的实现原理","slug":"_5-意向锁的实现原理","link":"#_5-意向锁的实现原理","children":[]},{"level":3,"title":"6. 死锁检测与处理","slug":"_6-死锁检测与处理","link":"#_6-死锁检测与处理","children":[]},{"level":3,"title":"总结","slug":"总结-1","link":"#总结-1","children":[]}]},{"level":2,"title":"深拷贝和浅拷贝的区别？","slug":"深拷贝和浅拷贝的区别","link":"#深拷贝和浅拷贝的区别","children":[]},{"level":2,"title":"知道协程吗？","slug":"知道协程吗","link":"#知道协程吗","children":[]},{"level":2,"title":"Spring中事务嵌套事务是怎么处理的？","slug":"spring中事务嵌套事务是怎么处理的","link":"#spring中事务嵌套事务是怎么处理的","children":[{"level":3,"title":"如何保证事务不会出问题？","slug":"如何保证事务不会出问题","link":"#如何保证事务不会出问题","children":[]},{"level":3,"title":"总结","slug":"总结-2","link":"#总结-2","children":[]}]},{"level":2,"title":"IOC介绍 循环依赖如何解决？交给spring会不会出现内存溢出问题？","slug":"ioc介绍-循环依赖如何解决-交给spring会不会出现内存溢出问题","link":"#ioc介绍-循环依赖如何解决-交给spring会不会出现内存溢出问题","children":[{"level":3,"title":"1. IOC 介绍","slug":"_1-ioc-介绍","link":"#_1-ioc-介绍","children":[]},{"level":3,"title":"2. Spring 循环依赖如何解决？","slug":"_2-spring-循环依赖如何解决","link":"#_2-spring-循环依赖如何解决","children":[]},{"level":3,"title":"3. 交给Spring会不会出现内存溢出问题？","slug":"_3-交给spring会不会出现内存溢出问题","link":"#_3-交给spring会不会出现内存溢出问题","children":[]}]},{"level":2,"title":"ICMP是什么知道吗？","slug":"icmp是什么知道吗","link":"#icmp是什么知道吗","children":[]},{"level":2,"title":"AtomicXXX类底层如何实现的？","slug":"atomicxxx类底层如何实现的","link":"#atomicxxx类底层如何实现的","children":[{"level":3,"title":"CAS（Compare And Swap）原理","slug":"cas-compare-and-swap-原理","link":"#cas-compare-and-swap-原理","children":[]},{"level":3,"title":"Java AtomicInteger 的底层实现","slug":"java-atomicinteger-的底层实现","link":"#java-atomicinteger-的底层实现","children":[]}]},{"level":2,"title":"OOM这种可以被catch吗，哪些可以？","slug":"oom这种可以被catch吗-哪些可以","link":"#oom这种可以被catch吗-哪些可以","children":[]},{"level":2,"title":"动态代理的底层原理？","slug":"动态代理的底层原理","link":"#动态代理的底层原理","children":[]},{"level":2,"title":"多线程中的异常如何处理？","slug":"多线程中的异常如何处理","link":"#多线程中的异常如何处理","children":[{"level":3,"title":"1. 普通线程的异常处理","slug":"_1-普通线程的异常处理","link":"#_1-普通线程的异常处理","children":[]},{"level":3,"title":"2. 线程池中的异常处理","slug":"_2-线程池中的异常处理","link":"#_2-线程池中的异常处理","children":[]},{"level":3,"title":"3. 统一异常处理方式","slug":"_3-统一异常处理方式","link":"#_3-统一异常处理方式","children":[]},{"level":3,"title":"4. 总结","slug":"_4-总结","link":"#_4-总结","children":[]}]},{"level":2,"title":"submit和execute的区别？","slug":"submit和execute的区别","link":"#submit和execute的区别","children":[]},{"level":2,"title":"雪花算法？时钟回拨问题？","slug":"雪花算法-时钟回拨问题","link":"#雪花算法-时钟回拨问题","children":[{"level":3,"title":"雪花算法","slug":"雪花算法","link":"#雪花算法","children":[]},{"level":3,"title":"时钟回拨问题解决","slug":"时钟回拨问题解决","link":"#时钟回拨问题解决","children":[]}]},{"level":2,"title":"索引下推？","slug":"索引下推","link":"#索引下推","children":[{"level":3,"title":"什么是索引下推？","slug":"什么是索引下推","link":"#什么是索引下推","children":[]},{"level":3,"title":"工作原理","slug":"工作原理","link":"#工作原理","children":[]},{"level":3,"title":"例子","slug":"例子","link":"#例子","children":[]},{"level":3,"title":"优点","slug":"优点","link":"#优点","children":[]},{"level":3,"title":"如何查看是否用到ICP？","slug":"如何查看是否用到icp","link":"#如何查看是否用到icp","children":[]}]},{"level":2,"title":"InnoDB和MyISAM的区别？","slug":"innodb和myisam的区别","link":"#innodb和myisam的区别","children":[]},{"level":2,"title":"TCP已建立连接时客户端突然断电 / 进程崩溃会怎样？","slug":"tcp已建立连接时客户端突然断电-进程崩溃会怎样","link":"#tcp已建立连接时客户端突然断电-进程崩溃会怎样","children":[]},{"level":2,"title":"Raft介绍一下 和Paxos区别？","slug":"raft介绍一下-和paxos区别","link":"#raft介绍一下-和paxos区别","children":[{"level":3,"title":"核心概念","slug":"核心概念","link":"#核心概念","children":[]},{"level":3,"title":"选举过程（Leader Election）","slug":"选举过程-leader-election","link":"#选举过程-leader-election","children":[]},{"level":3,"title":"日志复制（Log Replication）","slug":"日志复制-log-replication","link":"#日志复制-log-replication","children":[]},{"level":3,"title":"安全性保证","slug":"安全性保证","link":"#安全性保证","children":[]},{"level":3,"title":"简单示例","slug":"简单示例","link":"#简单示例","children":[]},{"level":3,"title":"与Paxos的区别","slug":"与paxos的区别","link":"#与paxos的区别","children":[]},{"level":3,"title":"实际应用","slug":"实际应用","link":"#实际应用","children":[]},{"level":3,"title":"要点","slug":"要点","link":"#要点","children":[]}]},{"level":2,"title":"hashCode()和equals()的区别,为什么重写equals()就要重写hashCode()？","slug":"hashcode-和equals-的区别-为什么重写equals-就要重写hashcode","link":"#hashcode-和equals-的区别-为什么重写equals-就要重写hashcode","children":[]},{"level":2,"title":"你对反射的了解？","slug":"你对反射的了解","link":"#你对反射的了解","children":[]},{"level":2,"title":"优先队列","slug":"优先队列","link":"#优先队列","children":[]},{"level":2,"title":"Spring Boot用哪个动态代理？","slug":"spring-boot用哪个动态代理","link":"#spring-boot用哪个动态代理","children":[]},{"level":2,"title":"消息队列的推拉模式知道吗？","slug":"消息队列的推拉模式知道吗","link":"#消息队列的推拉模式知道吗","children":[{"level":3,"title":"✅ 推（Push）适用场景：","slug":"✅-推-push-适用场景","link":"#✅-推-push-适用场景","children":[]},{"level":3,"title":"✅ 拉（Pull）适用场景：","slug":"✅-拉-pull-适用场景","link":"#✅-拉-pull-适用场景","children":[]}]},{"level":2,"title":"负载均衡算法有哪些？","slug":"负载均衡算法有哪些","link":"#负载均衡算法有哪些","children":[]},{"level":2,"title":"Redis哨兵运行的时候如果主节点抖了一下咋办 假如抖的时候来请求了咋办 刚好没有超过超时配置？","slug":"redis哨兵运行的时候如果主节点抖了一下咋办-假如抖的时候来请求了咋办-刚好没有超过超时配置","link":"#redis哨兵运行的时候如果主节点抖了一下咋办-假如抖的时候来请求了咋办-刚好没有超过超时配置","children":[{"level":3,"title":"情况描述","slug":"情况描述","link":"#情况描述","children":[]},{"level":3,"title":"哨兵和请求处理过程","slug":"哨兵和请求处理过程","link":"#哨兵和请求处理过程","children":[]},{"level":3,"title":"综上，抖动情况下请求表现","slug":"综上-抖动情况下请求表现","link":"#综上-抖动情况下请求表现","children":[]},{"level":3,"title":"如何降低抖动带来的影响？","slug":"如何降低抖动带来的影响","link":"#如何降低抖动带来的影响","children":[]}]},{"level":2,"title":"如何实现防抖和节流？","slug":"如何实现防抖和节流","link":"#如何实现防抖和节流","children":[]},{"level":2,"title":"进程之间的通信方式？","slug":"进程之间的通信方式","link":"#进程之间的通信方式","children":[]},{"level":2,"title":"Linux查看进程有哪些命令？","slug":"linux查看进程有哪些命令","link":"#linux查看进程有哪些命令","children":[]},{"level":2,"title":"DB一次请求正常时间应该是多少？Redis呢？","slug":"db一次请求正常时间应该是多少-redis呢","link":"#db一次请求正常时间应该是多少-redis呢","children":[]},{"level":2,"title":"数据库ORM连接池有哪些点需要考量？","slug":"数据库orm连接池有哪些点需要考量","link":"#数据库orm连接池有哪些点需要考量","children":[]},{"level":2,"title":"IP 分片（IP Fragmentation）","slug":"ip-分片-ip-fragmentation","link":"#ip-分片-ip-fragmentation","children":[{"level":3,"title":"💡 背景：","slug":"💡-背景","link":"#💡-背景","children":[]},{"level":3,"title":"📦 分片原理：","slug":"📦-分片原理","link":"#📦-分片原理","children":[]},{"level":3,"title":"📌 特点：","slug":"📌-特点","link":"#📌-特点","children":[]},{"level":3,"title":"❗问题：","slug":"❗问题","link":"#❗问题","children":[]}]},{"level":2,"title":"TCP 报文长度管理","slug":"tcp-报文长度管理","link":"#tcp-报文长度管理","children":[{"level":3,"title":"🚧 方式：","slug":"🚧-方式","link":"#🚧-方式","children":[]}]},{"level":2,"title":"UDP 最长报文长度是多少？","slug":"udp-最长报文长度是多少","link":"#udp-最长报文长度是多少","children":[{"level":3,"title":"🧱 UDP 报文长度：","slug":"🧱-udp-报文长度","link":"#🧱-udp-报文长度","children":[]},{"level":3,"title":"❗但注意：","slug":"❗但注意","link":"#❗但注意","children":[]}]},{"level":2,"title":"UDP 和 TCP 报文头细节对比","slug":"udp-和-tcp-报文头细节对比","link":"#udp-和-tcp-报文头细节对比","children":[{"level":3,"title":"📌 TCP 报文头结构（20 字节起）：","slug":"📌-tcp-报文头结构-20-字节起","link":"#📌-tcp-报文头结构-20-字节起","children":[]},{"level":3,"title":"📌 UDP 报文头结构（固定 8 字节）：","slug":"📌-udp-报文头结构-固定-8-字节","link":"#📌-udp-报文头结构-固定-8-字节","children":[]}]},{"level":2,"title":"消息队列如何实现分布式事务的？","slug":"消息队列如何实现分布式事务的","link":"#消息队列如何实现分布式事务的","children":[{"level":3,"title":"🎯 解决目标：","slug":"🎯-解决目标","link":"#🎯-解决目标","children":[]},{"level":3,"title":"💡 消息队列的作用","slug":"💡-消息队列的作用","link":"#💡-消息队列的作用","children":[]},{"level":3,"title":"🧠 主流方案一：本地事务 + 消息发送（异步保证一致性）","slug":"🧠-主流方案一-本地事务-消息发送-异步保证一致性","link":"#🧠-主流方案一-本地事务-消息发送-异步保证一致性","children":[]},{"level":3,"title":"🔁 主流方案二：可靠消息 + 本地事务（最终一致性）","slug":"🔁-主流方案二-可靠消息-本地事务-最终一致性","link":"#🔁-主流方案二-可靠消息-本地事务-最终一致性","children":[]},{"level":3,"title":"✅ 总结：消息队列实现分布式事务的 2 大核心模式","slug":"✅-总结-消息队列实现分布式事务的-2-大核心模式","link":"#✅-总结-消息队列实现分布式事务的-2-大核心模式","children":[]}]},{"level":2,"title":"判断丢包","slug":"判断丢包","link":"#判断丢包","children":[{"level":3,"title":"TCP层面","slug":"tcp层面","link":"#tcp层面","children":[]},{"level":3,"title":"应用层面","slug":"应用层面","link":"#应用层面","children":[]},{"level":3,"title":"网络层面","slug":"网络层面","link":"#网络层面","children":[]}]},{"level":2,"title":"TCP服务器创建过程中的socket系统调用","slug":"tcp服务器创建过程中的socket系统调用","link":"#tcp服务器创建过程中的socket系统调用","children":[]},{"level":2,"title":"整个流程详解","slug":"整个流程详解","link":"#整个流程详解","children":[{"level":3,"title":"服务器端流程","slug":"服务器端流程","link":"#服务器端流程","children":[]},{"level":3,"title":"详细步骤","slug":"详细步骤","link":"#详细步骤","children":[]},{"level":3,"title":"客户端流程","slug":"客户端流程","link":"#客户端流程","children":[]}]},{"level":2,"title":"应用层解决UDP错包问题","slug":"应用层解决udp错包问题","link":"#应用层解决udp错包问题","children":[{"level":3,"title":"UDP的不可靠性","slug":"udp的不可靠性","link":"#udp的不可靠性","children":[]},{"level":3,"title":"具体实现策略","slug":"具体实现策略","link":"#具体实现策略","children":[]}]},{"level":2,"title":"epoll用红黑树为什么没有FD2048数量限制？","slug":"epoll用红黑树为什么没有fd2048数量限制","link":"#epoll用红黑树为什么没有fd2048数量限制","children":[{"level":3,"title":"select的限制","slug":"select的限制","link":"#select的限制","children":[]},{"level":3,"title":"epoll的优势","slug":"epoll的优势","link":"#epoll的优势","children":[]},{"level":3,"title":"数据结构对比","slug":"数据结构对比","link":"#数据结构对比","children":[]}]},{"level":2,"title":"网络包拆包是在哪一层？","slug":"网络包拆包是在哪一层","link":"#网络包拆包是在哪一层","children":[]},{"level":2,"title":"Redis集群如果多个 key 是连续的或相关的，是否可以插入到同一个节点？","slug":"redis集群如果多个-key-是连续的或相关的-是否可以插入到同一个节点","link":"#redis集群如果多个-key-是连续的或相关的-是否可以插入到同一个节点","children":[]},{"level":2,"title":"两个地址在网络中的通信流程？","slug":"两个地址在网络中的通信流程","link":"#两个地址在网络中的通信流程","children":[]},{"level":2,"title":"大数据去重？","slug":"大数据去重","link":"#大数据去重","children":[{"level":3,"title":"BitMap","slug":"bitmap","link":"#bitmap","children":[]}]},{"level":2,"title":"DDD架构","slug":"ddd架构","link":"#ddd架构","children":[{"level":3,"title":"DDD vs 传统架构对比","slug":"ddd-vs-传统架构对比","link":"#ddd-vs-传统架构对比","children":[]},{"level":3,"title":"DDD核心组件","slug":"ddd核心组件","link":"#ddd核心组件","children":[]},{"level":3,"title":"架构特点对比","slug":"架构特点对比","link":"#架构特点对比","children":[]},{"level":3,"title":"适用场景对比","slug":"适用场景对比","link":"#适用场景对比","children":[]},{"level":3,"title":"优势劣势对比","slug":"优势劣势对比","link":"#优势劣势对比","children":[]},{"level":3,"title":"DDD核心思想：","slug":"ddd核心思想","link":"#ddd核心思想","children":[]}]},{"level":2,"title":"Linux管道是什么？","slug":"linux管道是什么","link":"#linux管道是什么","children":[]},{"level":2,"title":"MySQL架构分层及工作流程","slug":"mysql架构分层及工作流程","link":"#mysql架构分层及工作流程","children":[]},{"level":2,"title":"MySQL执行SQL时如何知道扫描行数（执行计划）","slug":"mysql执行sql时如何知道扫描行数-执行计划","link":"#mysql执行sql时如何知道扫描行数-执行计划","children":[]},{"level":2,"title":"性能毛刺及死锁原因","slug":"性能毛刺及死锁原因","link":"#性能毛刺及死锁原因","children":[]},{"level":2,"title":"MySQL连接池状态查看","slug":"mysql连接池状态查看","link":"#mysql连接池状态查看","children":[]},{"level":2,"title":"静态代码块加载顺序","slug":"静态代码块加载顺序","link":"#静态代码块加载顺序","children":[{"level":3,"title":"例子说明","slug":"例子说明","link":"#例子说明","children":[]}]},{"level":2,"title":"二叉树类型","slug":"二叉树类型","link":"#二叉树类型","children":[]},{"level":2,"title":"消息队列的投递机制？至多一次，至少一次，恰好一次？","slug":"消息队列的投递机制-至多一次-至少一次-恰好一次","link":"#消息队列的投递机制-至多一次-至少一次-恰好一次","children":[]},{"level":2,"title":"设计银行存取款和转账业务的具体实现，除了加锁还有什么？","slug":"设计银行存取款和转账业务的具体实现-除了加锁还有什么","link":"#设计银行存取款和转账业务的具体实现-除了加锁还有什么","children":[]},{"level":2,"title":"2PC和3PC的区别","slug":"_2pc和3pc的区别","link":"#_2pc和3pc的区别","children":[]}],"git":{"createdTime":1753435299000,"updatedTime":1755653029000,"contributors":[{"name":"Ruochen Chen","email":"ruocchen1220@gmail.com","commits":10}]},"readingTime":{"minutes":61.64,"words":18492},"filePathRelative":"zh/posts/review/其他问题.md","localizedDate":"2025年7月24日","excerpt":"\\n<h2>MySQL Buffer Pool里都有什么？</h2>\\n<p>MySQL 的 Buffer Pool（缓冲池）是 InnoDB 存储引擎中<strong>最核心的内存区域</strong>，主要用于缓存磁盘上的数据页，加速数据读写。</p>\\n<table>\\n<thead>\\n<tr>\\n<th>类型</th>\\n<th>说明/作用</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>数据页（Data Page）</td>\\n<td>存储表的实际数据行</td>\\n</tr>\\n<tr>\\n<td>索引页（Index Page）</td>\\n<td>存储 B+ 树索引节点</td>\\n</tr>\\n<tr>\\n<td>Undo 页</td>\\n<td>存储回滚日志，支持事务和 MVCC</td>\\n</tr>\\n<tr>\\n<td>Change Buffer 页</td>\\n<td>缓存二级索引的变更操作，提升插入效率</td>\\n</tr>\\n<tr>\\n<td>自适应哈希索引</td>\\n<td>热点数据自动生成哈希索引，加速查询</td>\\n</tr>\\n<tr>\\n<td>锁信息</td>\\n<td>记录锁定信息，支持并发控制</td>\\n</tr>\\n<tr>\\n<td>数据字典信息</td>\\n<td>缓存表结构、索引结构等元数据</td>\\n</tr>\\n</tbody>\\n</table>","autoDesc":true}')},6262:(t,s)=>{s.A=(t,s)=>{const i=t.__vccOpts||t;for(const[t,a]of s)i[t]=a;return i}}}]);