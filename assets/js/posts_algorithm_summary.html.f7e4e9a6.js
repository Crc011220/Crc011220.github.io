"use strict";(self.webpackChunkpersonalweb=self.webpackChunkpersonalweb||[]).push([[6852],{4836:(e,a,r)=>{r.r(a),r.d(a,{comp:()=>s,data:()=>l});var t=r(641);const n=r.p+"assets/img/stack_and_queue.f6d7e90c.png",i={},s=(0,r(6262).A)(i,[["render",function(e,a){return(0,t.uX)(),(0,t.CE)("div",null,a[0]||(a[0]=[(0,t.Fv)('<h1 id="leetcode-summary" tabindex="-1"><a class="header-anchor" href="#leetcode-summary"><span>LeetCode Summary</span></a></h1><h2 id="array" tabindex="-1"><a class="header-anchor" href="#array"><span>Array</span></a></h2><h2 id="hashmap" tabindex="-1"><a class="header-anchor" href="#hashmap"><span>HashMap</span></a></h2><h2 id="stack-and-queue" tabindex="-1"><a class="header-anchor" href="#stack-and-queue"><span>Stack and Queue</span></a></h2><figure><img src="'+n+'" alt="Stack and Queue" tabindex="0" loading="lazy"><figcaption>Stack and Queue</figcaption></figure><h2 id="binary-tree" tabindex="-1"><a class="header-anchor" href="#binary-tree"><span>Binary Tree</span></a></h2><p>Depth-First Traversal Preorder Traversal (Recursive, Iterative) Left-Right Inorder Traversal (Recursive, Iterative) Left-Middle-Right Postorder Traversal (Recursive, Iterative) Left-Right-Middle Breadth-First Traversal Level Order Traversal (Iterative)</p><h2 id="backtracking" tabindex="-1"><a class="header-anchor" href="#backtracking"><span>Backtracking</span></a></h2><p>The for loop can be understood as horizontal traversal, and backtracking (recursive) is vertical traversal, which fully traverses the tree. Generally, finding a leaf node is finding one of the results.</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>void backtracking(parameters) {</span></span>\n<span class="line"><span>    if (termination condition) {</span></span>\n<span class="line"><span>        store result;</span></span>\n<span class="line"><span>        return;</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    for (selection: elements in the current layer collection (the number of children of the node in the tree is the size of the collection)) {</span></span>\n<span class="line"><span>        process node;</span></span>\n<span class="line"><span>        backtracking(path, selection list); // Recursive</span></span>\n<span class="line"><span>        backtrack, undo processing results</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Combination problems: Find a collection of k numbers from N numbers according to certain rules Cutting problems: How many ways are there to cut a string according to certain rules Subset problems: How many subsets of N numbers meet the conditions Permutation problems: How many permutations are there for N numbers according to certain rules Chessboard problems: N queens, solving Sudoku, etc.</p><h2 id="greedy" tabindex="-1"><a class="header-anchor" href="#greedy"><span>Greedy</span></a></h2><h3 id="as-long-as-you-think-clearly-about-what-the-local-optimum-is-if-you-can-deduce-the-global-optimum-it-s-actually-enough" tabindex="-1"><a class="header-anchor" href="#as-long-as-you-think-clearly-about-what-the-local-optimum-is-if-you-can-deduce-the-global-optimum-it-s-actually-enough"><span>As long as you think clearly about what the local optimum is, if you can deduce the global optimum, it&#39;s actually enough</span></a></h3><h2 id="dynamic-programming" tabindex="-1"><a class="header-anchor" href="#dynamic-programming"><span>Dynamic Programming</span></a></h2><h3 id="determine-the-dp-array-dp-table-and-the-meaning-of-the-index" tabindex="-1"><a class="header-anchor" href="#determine-the-dp-array-dp-table-and-the-meaning-of-the-index"><span>Determine the dp array (dp table) and the meaning of the index</span></a></h3><h3 id="determine-the-recursive-formula" tabindex="-1"><a class="header-anchor" href="#determine-the-recursive-formula"><span>Determine the recursive formula</span></a></h3><h3 id="how-to-initialize-the-dp-array" tabindex="-1"><a class="header-anchor" href="#how-to-initialize-the-dp-array"><span>How to initialize the dp array</span></a></h3><h3 id="determine-the-traversal-order" tabindex="-1"><a class="header-anchor" href="#determine-the-traversal-order"><span>Determine the traversal order</span></a></h3><h3 id="example-to-deduce-the-dp-array" tabindex="-1"><a class="header-anchor" href="#example-to-deduce-the-dp-array"><span>Example to deduce the dp array</span></a></h3>',19)]))}]]),l=JSON.parse('{"path":"/posts/algorithm/summary.html","title":"LeetCode Summary","lang":"en-US","frontmatter":{"icon":"pen-to-square","date":"2025-05-03T00:00:00.000Z","category":["Learning Records"],"tag":["LeetCode"],"description":"LeetCode Summary Array HashMap Stack and Queue Stack and QueueStack and Queue Binary Tree Depth-First Traversal Preorder Traversal (Recursive, Iterative) Left-Right Inorder Trav...","head":[["meta",{"property":"og:url","content":"https://crc011220.github.io/posts/algorithm/summary.html"}],["meta",{"property":"og:site_name","content":"Richard Chen"}],["meta",{"property":"og:title","content":"LeetCode Summary"}],["meta",{"property":"og:description","content":"LeetCode Summary Array HashMap Stack and Queue Stack and QueueStack and Queue Binary Tree Depth-First Traversal Preorder Traversal (Recursive, Iterative) Left-Right Inorder Trav..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2025-05-12T12:41:35.000Z"}],["meta",{"property":"article:tag","content":"LeetCode"}],["meta",{"property":"article:published_time","content":"2025-05-03T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-05-12T12:41:35.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"LeetCode Summary\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-05-03T00:00:00.000Z\\",\\"dateModified\\":\\"2025-05-12T12:41:35.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Richard Chen\\"}]}"]]},"headers":[{"level":2,"title":"Array","slug":"array","link":"#array","children":[]},{"level":2,"title":"HashMap","slug":"hashmap","link":"#hashmap","children":[]},{"level":2,"title":"Stack and Queue","slug":"stack-and-queue","link":"#stack-and-queue","children":[]},{"level":2,"title":"Binary Tree","slug":"binary-tree","link":"#binary-tree","children":[]},{"level":2,"title":"Backtracking","slug":"backtracking","link":"#backtracking","children":[]},{"level":2,"title":"Greedy","slug":"greedy","link":"#greedy","children":[{"level":3,"title":"As long as you think clearly about what the local optimum is, if you can deduce the global optimum, it\'s actually enough","slug":"as-long-as-you-think-clearly-about-what-the-local-optimum-is-if-you-can-deduce-the-global-optimum-it-s-actually-enough","link":"#as-long-as-you-think-clearly-about-what-the-local-optimum-is-if-you-can-deduce-the-global-optimum-it-s-actually-enough","children":[]}]},{"level":2,"title":"Dynamic Programming","slug":"dynamic-programming","link":"#dynamic-programming","children":[{"level":3,"title":"Determine the dp array (dp table) and the meaning of the index","slug":"determine-the-dp-array-dp-table-and-the-meaning-of-the-index","link":"#determine-the-dp-array-dp-table-and-the-meaning-of-the-index","children":[]},{"level":3,"title":"Determine the recursive formula","slug":"determine-the-recursive-formula","link":"#determine-the-recursive-formula","children":[]},{"level":3,"title":"How to initialize the dp array","slug":"how-to-initialize-the-dp-array","link":"#how-to-initialize-the-dp-array","children":[]},{"level":3,"title":"Determine the traversal order","slug":"determine-the-traversal-order","link":"#determine-the-traversal-order","children":[]},{"level":3,"title":"Example to deduce the dp array","slug":"example-to-deduce-the-dp-array","link":"#example-to-deduce-the-dp-array","children":[]}]}],"git":{"createdTime":1746580836000,"updatedTime":1747053695000,"contributors":[{"name":"Ruochen Chen","email":"ruocchen1220@gmail.com","commits":2}]},"readingTime":{"minutes":0.84,"words":253},"filePathRelative":"posts/algorithm/summary.md","localizedDate":"May 3, 2025","excerpt":"\\n<h2>Array</h2>\\n<h2>HashMap</h2>\\n<h2>Stack and Queue</h2>\\n<figure><figcaption>Stack and Queue</figcaption></figure>\\n<h2>Binary Tree</h2>\\n<p>Depth-First Traversal\\nPreorder Traversal (Recursive, Iterative) Left-Right\\nInorder Traversal (Recursive, Iterative) Left-Middle-Right\\nPostorder Traversal (Recursive, Iterative) Left-Right-Middle\\nBreadth-First Traversal\\nLevel Order Traversal (Iterative)</p>","autoDesc":true}')},6262:(e,a)=>{a.A=(e,a)=>{const r=e.__vccOpts||e;for(const[e,t]of a)r[e]=t;return r}}}]);