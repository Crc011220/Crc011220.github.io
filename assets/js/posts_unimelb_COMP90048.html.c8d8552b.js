"use strict";(self.webpackChunkpersonalweb=self.webpackChunkpersonalweb||[]).push([[7849],{6262:(i,s)=>{s.A=(i,s)=>{const a=i.__vccOpts||i;for(const[i,e]of s)a[i]=e;return a}},6660:(i,s,a)=>{a.r(s),a.d(s,{comp:()=>l,data:()=>h});var e=a(641);const t=a.p+"assets/img/Prolog-Arithmetic-Expressions.9b8b250d.png",n={},l=(0,a(6262).A)(n,[["render",function(i,s){return(0,e.uX)(),(0,e.CE)("div",null,s[0]||(s[0]=[(0,e.Fv)('<h1 id="declarative-programming-comp90048" tabindex="-1"><a class="header-anchor" href="#declarative-programming-comp90048"><span>Declarative Programming (COMP90048)</span></a></h1><h2 id="week-1" tabindex="-1"><a class="header-anchor" href="#week-1"><span>Week 1</span></a></h2><h4 id="imperative-languages-are-based-on-commands-in-the-form-of-instructions-and-statements" tabindex="-1"><a class="header-anchor" href="#imperative-languages-are-based-on-commands-in-the-form-of-instructions-and-statements"><span>Imperative languages are based on commands, in the form of instructions and statements.</span></a></h4><ul><li>Commands are executed.</li><li>Commands have an effect, such as to update the computation state,and later code may depend on this update.</li></ul><h4 id="logic-programming-languages-are-based-on-finding-values-that-satisfy-a-set-of-constraints" tabindex="-1"><a class="header-anchor" href="#logic-programming-languages-are-based-on-finding-values-that-satisfy-a-set-of-constraints"><span>Logic programming languages are based on finding values that satisfy a set of constraints.</span></a></h4><ul><li>Constraints may have multiple solutions or none at all.</li><li>Constraints do not have an effect.</li></ul><h4 id="functional-languages-are-based-on-evaluating-expressions" tabindex="-1"><a class="header-anchor" href="#functional-languages-are-based-on-evaluating-expressions"><span>Functional languages are based on evaluating expressions.</span></a></h4><ul><li>Expressions are evaluated.</li><li>Expressions do not have an effect.</li></ul><h2 id="prolog" tabindex="-1"><a class="header-anchor" href="#prolog"><span>Prolog</span></a></h2><p>Prolog is a declarative programming language. It is based on logic programming and uses the predicate calculus.</p><div class="language-prolog line-numbers-mode" data-highlighter="shiki" data-ext="prolog" data-title="prolog" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">% import the test.pl file</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">% (A small part of) the British Royal family</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">% parent(queen_elizabeth, prince_charles).</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">% parent(prince_philip, prince_charles).</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">% parent(prince_charles, prince_william).</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">% parent(prince_charles, prince_harry).</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">% parent(princess_diana, prince_william).</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">% parent(princess_diana, prince_harry).</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">?- [test].</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">%queries</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">?- parent(prince_charles, prince_william).</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">% true</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">% This query asks: of whom Prince Charles is a parent?</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">?- parent(prince_charles, X)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>If there is more than one answer to the query, Prolog prints them one at a time, pausing to see if more solutions are wanted. Typing semicolon asks for more solutions; just hitting enter (return) finishes without more solutions.</li></ul><h3 id="rules" tabindex="-1"><a class="header-anchor" href="#rules"><span>Rules</span></a></h3><p><strong>Rules need to be written in the file .pl</strong></p><div class="language-prolog line-numbers-mode" data-highlighter="shiki" data-ext="prolog" data-title="prolog" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">% “X is grandparent of Z if X is parent of Y and Y is parent of Z .”</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">grandparent</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">X</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">Z</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">:-</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> parent(</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">X</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">Y</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">), parent(</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">Y</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">Z</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">.</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>Rules can be recursive. Prolog has no looping constructs, so recursion is widely used.</li></ul><div class="language-prolog line-numbers-mode" data-highlighter="shiki" data-ext="prolog" data-title="prolog" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">% A person’s ancestors are their parents and the ancestors of their parents.</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">ancestor</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">Anc</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">Desc</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">:-</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">parent(</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">Parent</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">Desc</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">),ancestor(</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">Anc</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">Parent</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">.</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="equality" tabindex="-1"><a class="header-anchor" href="#equality"><span>Equality</span></a></h3><ul><li>Equality in Prolog, written “=” and used as an infix operator, can be used both to bind variables and to check for equality. Prolog is a single-assignment language: once bound, a variable cannot be reassigned.</li></ul><h3 id="disjunction-and-conjunction" tabindex="-1"><a class="header-anchor" href="#disjunction-and-conjunction"><span>Disjunction and Conjunction</span></a></h3><ul><li>Goals can be combined with disjunction (or) as well as conjunction (and). Disjunction is written “;” and used as an infix operator. Conjunction (“,”) has higher precedence (binds tighter) than disjunction, but parentheses can be used to achieve the desired precedence.</li></ul><h3 id="negation" tabindex="-1"><a class="header-anchor" href="#negation"><span>Negation</span></a></h3><ul><li>Negation in Prolog is written “+” and used as a prefix operator. Negation has higher (tighter) precedence than both conjunction and disjunction. Be sure to leave a space between the + and an open parenthesis.</li></ul><div class="language-prolog line-numbers-mode" data-highlighter="shiki" data-ext="prolog" data-title="prolog" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">% Who are the parents of Prince William other than Prince Charles?</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">?- parent(X, prince_william), \\+ X = prince_charles.</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">X</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> = </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">princess_diana</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">.</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>Disequality in Prolog is written as an infix “=”. So X = Y is the same as + X = Y.</li></ul><h3 id="closed-world-assumption" tabindex="-1"><a class="header-anchor" href="#closed-world-assumption"><span>Closed World Assumption</span></a></h3><ul><li>Prolog assumes that all terms are true, unless explicitly stated otherwise. This is called the closed world assumption (CWA). <strong>This means that if a term is not mentioned in the program, it is assumed to be false</strong>. This can be a problem if the program is used to reason about real-world situations, where some terms may be unknown or undecidable.</li></ul><div class="hint-container info"><p class="hint-container-title">Info</p><ol><li>Variables must start with an uppercase letter (A-Z) or _.</li><li>Atoms (constants) must start with a lowercase letter (a-z) or be enclosed in single quotes (&#39;...&#39;).</li><li>Prolog is strictly case-sensitive, so X and x are completely different!</li></ol></div><h2 id="week-2" tabindex="-1"><a class="header-anchor" href="#week-2"><span>Week 2</span></a></h2><h3 id="prolog-concepts" tabindex="-1"><a class="header-anchor" href="#prolog-concepts"><span>Prolog Concepts</span></a></h3><ul><li>In Prolog, all data structures are called term. A term can be atomic orcompound, or it can be a variable.</li><li>An atom begins with a lower case letter and follows with letters, digits and underscores</li><li>each compound term is a functor (sometimes called function symbol) followed by one or more arguments in parentheses, separated by commas.</li><li>List: [] is the empty list, [H | T] is a list with head H and tail T.</li><li>A variable is also a term. It denotes a single unknown term. A variable name begins with an upper case letter or underscore, followed by any number of letters, digits, and underscores.</li><li>Prolog is a single-assignment language: a variable can only be bound (assigned) once.</li><li>A term is a ground term if it contains no variables, and it is a nonground term if it contains at least one variable.</li><li>A substitution is a mapping from variables to terms.Any ground Prolog term has only one instance, while a nonground Prolog terms has an infinite number of instances.</li></ul><h3 id="proper-lists" tabindex="-1"><a class="header-anchor" href="#proper-lists"><span>Proper Lists</span></a></h3><ul><li>A proper list is either empty ([]) or not ([X | Y]), in which case, the tail of the list must be a proper list. We can define a predicate to recognise these.</li></ul><div class="language-prolog line-numbers-mode" data-highlighter="shiki" data-ext="prolog" data-title="prolog" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">proper_list</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">[]</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">.</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">proper_list</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">([</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">_</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">Head|</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">Tail</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">]) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">:-</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">proper_list(</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">Tail</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">.</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="append" tabindex="-1"><a class="header-anchor" href="#append"><span>Append</span></a></h3><ul><li>The append operation is used to concatenate two lists. It is defined as follows:</li></ul><div class="language-prolog line-numbers-mode" data-highlighter="shiki" data-ext="prolog" data-title="prolog" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">append</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">[]</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">C</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">C</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">.</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">append</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">([</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">A</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">|</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">B</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">], </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">C</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, [</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">A</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">|</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">BC</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">]) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">:-</span></span>\n<span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">append</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">B</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">C</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">BC</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">.</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="e-g-find-the-first-n-th-elements-of-a-list" tabindex="-1"><a class="header-anchor" href="#e-g-find-the-first-n-th-elements-of-a-list"><span>e.g. Find the first n th elements of a list</span></a></h3><div class="language-prolog line-numbers-mode" data-highlighter="shiki" data-ext="prolog" data-title="prolog" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">% Find the first n th elements of a list</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">take</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">N</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">List</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">Front</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">:-</span></span>\n<span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">length</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">Front</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">N</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">),</span></span>\n<span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">append</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">Front</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">_</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">List</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">.</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="arithmetic" tabindex="-1"><a class="header-anchor" href="#arithmetic"><span>Arithmetic</span></a></h3><ul><li>Use the built-in predicate is/2 (an infix operator) evaluates expressions. <img src="'+t+'" alt="Prolog Arithmetic Expressions" loading="lazy"></li></ul><h3 id="logic-and-resolution" tabindex="-1"><a class="header-anchor" href="#logic-and-resolution"><span>Logic and Resolution</span></a></h3><h4 id="_1-resolution-method-resolution" tabindex="-1"><a class="header-anchor" href="#_1-resolution-method-resolution"><span>1. <strong>Resolution Method (Resolution)</strong>:</span></a></h4><p>Resolution is an inference method used in automated reasoning systems (like Prolog). It works by applying facts and rules to a goal, simplifying the goal until it becomes either a tautology or a contradiction.</p><h4 id="_2-rules-and-facts" tabindex="-1"><a class="header-anchor" href="#_2-rules-and-facts"><span>2. <strong>Rules and Facts</strong>:</span></a></h4><ul><li><strong>Facts</strong> are known true statements.</li><li><strong>Rules</strong> are conditional inferences and are written in the form of <code>head :- body</code>. This means if <code>body</code> is true, then <code>head</code> is true.</li></ul><h4 id="_3-resolution-algorithm" tabindex="-1"><a class="header-anchor" href="#_3-resolution-algorithm"><span>3. <strong>Resolution Algorithm</strong>:</span></a></h4><ul><li>The core of the resolution method is to use <strong>proof by contradiction</strong> (driving reasoning through negation of the goal).</li><li>It simplifies the goal by matching it with rules and facts in the program until a conclusion is reached, or no solution is found.</li></ul><h4 id="_4-specific-process" tabindex="-1"><a class="header-anchor" href="#_4-specific-process"><span>4. <strong>Specific Process</strong>:</span></a></h4><ul><li>Select a clause and attempt to match it with the goal.</li><li>Use logical reasoning to reduce the goal until it is either true (tautology) or false (contradiction). If the goal is true, a solution has been found. If false, there is no solution.</li></ul><h4 id="summary" tabindex="-1"><a class="header-anchor" href="#summary"><span>Summary:</span></a></h4><p>Resolution in Prolog is used to derive a goal step by step by applying rules, rather than directly &quot;computing&quot; the result. It is a <strong>logic programming</strong> approach based on inference.</p><h2 id="week-3" tabindex="-1"><a class="header-anchor" href="#week-3"><span>Week 3</span></a></h2><h3 id="debugger" tabindex="-1"><a class="header-anchor" href="#debugger"><span>Debugger</span></a></h3><ul><li>The debugger prints the current port, execution depth, and goal (with the current variable bindings) at each step.</li><li>use <code>trace.</code> to start tracing, and <code>notrace.</code> to stop tracing. <code>creep</code> can be used to step through the program one step at a time.</li><li>Bird box model: the debugger shows the current state of the program, and the user can selectively step through the program to examine the intermediate states.</li></ul><h3 id="infinite-backtracking-loop" tabindex="-1"><a class="header-anchor" href="#infinite-backtracking-loop"><span>Infinite backtracking loop</span></a></h3><ul><li>If a goal cannot be proven, Prolog will backtrack and try other possibilities. This can lead to an infinite loop.</li><li>To avoid this, we can use the <code>once</code> predicate, which will try to prove the goal once, and fail if it cannot be proven。</li></ul><h3 id="tail-recursion" tabindex="-1"><a class="header-anchor" href="#tail-recursion"><span>Tail Recursion</span></a></h3><ul><li><p>Tail recursion is a special case of recursion where the recursive call is the last operation performed in the function.</p></li><li><p>Efficiency: Tail recursion helps to avoid adding stack frames with each recursive call, thereby reducing memory consumption. Especially with deep recursion, it can prevent stack overflow errors.</p></li><li><p>Optimization: Some Prolog implementations can optimize tail-recursive predicates by reusing the same stack frame, making the performance of tail recursion as efficient as iterative solutions.</p></li><li><p>We make factorial tail recursive by introducing an accumulating parameter, or just an accumulator. This is an extra parameter to the predicate that holds a partially computed result.</p></li></ul><h2 id="week-4" tabindex="-1"><a class="header-anchor" href="#week-4"><span>Week 4</span></a></h2><h3 id="homoiconicity" tabindex="-1"><a class="header-anchor" href="#homoiconicity"><span>Homoiconicity</span></a></h3><ul><li>Homoiconicity is a property of programming languages that allows the use of data structures as first-class citizens.</li><li>In Prolog, this means that terms can be constructed and manipulated at runtime, and that the language itself can be used as a data structure.</li></ul><h3 id="auto-loading" tabindex="-1"><a class="header-anchor" href="#auto-loading"><span>Auto-loading</span></a></h3><ul><li>Many SWI Prolog “built-ins”, such as append/3, are not actually built-in, but are auto-loaded.</li></ul><div class="hint-container info"><p class="hint-container-title">Info</p><h3 id="call" tabindex="-1"><a class="header-anchor" href="#call"><span>Call</span></a></h3><p>square(X, Y) :- Y is X * X. ?- call(square, 5, Y). Y = 25.</p></div><p>e.g.</p><div class="language-prolog line-numbers-mode" data-highlighter="shiki" data-ext="prolog" data-title="prolog" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">filter</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">_</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">[]</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">[]</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">.</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">filter</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">P</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, [</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">X</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">|</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">Xs</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">], </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">Filtered</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">:-</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    ( call(</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">P</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">X</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">-&gt;</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">        Filtered</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> = [</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">X</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">|</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">Filtered1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">]</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    ;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">        Filtered</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> = </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">Filtered1</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    ),</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    filter(</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">P</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">Xs</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">Filtered1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">.</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 保留偶数</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">filter(even,</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> [1,2,3,4,5,6], Result).</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># Result 将是 [2,4,6]</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 保留大于3的数</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">filter(X</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &gt; </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">3,</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> [1,2,3,4,5,6], Result).</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># Result 将是 [4,5,6]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="setof" tabindex="-1"><a class="header-anchor" href="#setof"><span>Setof</span></a></h3><ul><li>The <code>setof</code> construct is used to generate a set of solutions to a goal. It is similar to <code>findall</code>, but it returns a set of solutions instead of a list. Template：模板项，通常包含Goal中的变量 Goal：要求解的目标 List：收集的解的有序列表 e.g.</li></ul><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">#  找出能被3整除的数</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">setof(X,</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> X</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> in</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> 1..10,</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> Y</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># Y 将是 [3, 6, 9]</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 更复杂的例子</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">setof(X,</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> Y^</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">parent(Y,</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> X</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)), Children)</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 找出每个父亲的孩子列表</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Use existential quantification, written with infix caret (ˆ), to collect solutions for a template regardless of the bindings of some of the variables not in the Template.</p><h3 id="bagof" tabindex="-1"><a class="header-anchor" href="#bagof"><span>Bagof</span></a></h3><ul><li>The bagof/3 predicate is just like setof/3, except that it does not sort the result or remove duplicates.</li></ul><h3 id="comparing" tabindex="-1"><a class="header-anchor" href="#comparing"><span>Comparing</span></a></h3><ul><li>Prolog, somewhat arbitrarily, uses the ordering: <strong>Variables &lt; Numbers &lt; Atoms &lt; CompoundTerms</strong></li><li><code>@&lt;, @=&lt;, @&gt;, and @&gt;=</code></li></ul><h3 id="sorting" tabindex="-1"><a class="header-anchor" href="#sorting"><span>Sorting</span></a></h3><ul><li>sort list according to @&lt; ordering</li><li>sort/2 sorts a list, removing duplicates,</li><li>msort/2 sorts a list, without removing duplicates, and</li><li>keysort/2 stably sorts list of X-Y terms, only comparing X parts</li></ul><h3 id="determining-term-types" tabindex="-1"><a class="header-anchor" href="#determining-term-types"><span>Determining term types</span></a></h3><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">?- integer(</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">3</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>\n<span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">true</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">.</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">?- float(</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">3.14</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>\n<span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">true</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">.</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">?- atom(</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">hello</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>\n<span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">true</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">.</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="others" tabindex="-1"><a class="header-anchor" href="#others"><span>Others</span></a></h3><ul><li>var/1 holds for unbound variables, nonvar/1 holds for any term other than an unbound variable, and ground/1 holds for ground terms (this requires traversing the whole term). Using these or the predicates on the previous slide can make your code behave differently in different modes.</li></ul><div class="language-prolog line-numbers-mode" data-highlighter="shiki" data-ext="prolog" data-title="prolog" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">% Define a custom infix operator</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">:- </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">op</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">Precedence</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">Type</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">OperatorName</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">.</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">:- </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">op</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">500</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">yfx</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">&#39;+&gt;&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">.</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  </span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">% Now it can be used like this</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">test</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">X</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">:-</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 3</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> +&gt; </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">4</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> = </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">X</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">.</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">- write/1 is handy for printing messages</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="propagation-and-labeling" tabindex="-1"><a class="header-anchor" href="#propagation-and-labeling"><span>Propagation and Labeling</span></a></h3><ul><li>Propagation: Reducing the domain of variables through constraints to improve solving efficiency.</li><li>Labeling: Selecting specific values for variables to try to satisfy all constraints.</li></ul><h3 id="clp-fd" tabindex="-1"><a class="header-anchor" href="#clp-fd"><span>CLP(FD)</span></a></h3><ul><li>In the CLP(FD) (Constraint Logic Programming over Finite Domains) library, more advanced arithmetic constraint predicates are provided, which can be used for bidirectional reasoning (i.e., in,out and out,in modes). | <strong>Arithmetic Predicate</strong> | <strong>Limitation</strong> | <strong>CLP(FD) Alternative</strong> | <strong>Advantage</strong> | |--------------------------|----------------|-------------------------|---------------| | <code>is/2</code> | Right side must be ground | <code>#=/2</code> | Supports variable inference | | <code>=:=/2</code> | Can only compare known values | <code>#=/2</code> | Suitable for variables | | <code>=\\=/2</code> | Can only compare known values | <code>#\\=/2</code> | Suitable for variables | | <code>=&lt; /2</code> | Can only compare known values | <code>#=&lt;/2</code> | Suitable for variables |</li></ul><table><thead><tr><th><strong>Operator</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td><code>Expr1 #= Expr2</code></td><td><code>Expr1</code> equals <code>Expr2</code></td></tr><tr><td><code>Expr1 #\\= Expr2</code></td><td><code>Expr1</code> not equal to <code>Expr2</code></td></tr><tr><td><code>Expr1 #&gt; Expr2</code></td><td><code>Expr1</code> greater than <code>Expr2</code></td></tr><tr><td><code>Expr1 #&lt; Expr2</code></td><td><code>Expr1</code> less than <code>Expr2</code></td></tr><tr><td><code>Expr1 #&gt;= Expr2</code></td><td><code>Expr1</code> greater than or equal to <code>Expr2</code></td></tr><tr><td><code>Expr1 #=&lt; Expr2</code></td><td><code>Expr1</code> less than or equal to <code>Expr2</code></td></tr><tr><td><code>Var in Low..High</code></td><td><code>Low ≤ Var ≤ High</code></td></tr><tr><td><code>List ins Low..High</code></td><td>Each <code>Var</code> in <code>List</code> is between <code>Low..High</code></td></tr></tbody></table><ul><li><p>label/1 is an enumeration predicate used to search for specific assignments of variables to satisfy all defined constraints. It traverses possible values of variables and solves them.</p></li><li><p>Generate-and-Test requires generating candidate solutions before validation, which is less efficient.</p></li><li><p>Constrain-and-Generate reduces the range of candidate solutions through constraints, usually more efficient.</p></li><li><p>Through labeling, Prolog can automate the search process and provide the final solution.</p></li></ul><h2 id="week-5" tabindex="-1"><a class="header-anchor" href="#week-5"><span>Week 5</span></a></h2><h3 id="haskell" tabindex="-1"><a class="header-anchor" href="#haskell"><span>Haskell</span></a></h3><ul><li>Haskell is a purely functional programming language. It is statically typed, and supports pattern matching, higher-order functions, and lazy evaluation.</li></ul><h3 id="in-haskell" tabindex="-1"><a class="header-anchor" href="#in-haskell"><span>[] in Haskell</span></a></h3><ul><li>The empty list is denoted by [], and it is a built-in data type in Haskell.</li><li>[&quot;a&quot;,&quot;b&quot;] is syntactic suger for <code>&quot;a&quot; : &quot;b&quot; : []</code>.</li></ul><h3 id="functions-in-haskell" tabindex="-1"><a class="header-anchor" href="#functions-in-haskell"><span>Functions in Haskell</span></a></h3><div class="hint-container info"><p class="hint-container-title">Info</p><p>Haskell 是一种纯函数式编程语言，它强调在编程中使用函数。在 Haskell 中，函数是一等公民，这意味着它们可以像其他数据类型一样被传递和操作。下面是一些关于 Haskell 函数的基本介绍：</p><h3 id="函数定义" tabindex="-1"><a class="header-anchor" href="#函数定义"><span>函数定义</span></a></h3><p>在 Haskell 中，函数通过以下语法定义：</p><div class="language-haskell line-numbers-mode" data-highlighter="shiki" data-ext="haskell" data-title="haskell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">name</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> :: </span><span style="--shiki-light:#A626A4;--shiki-dark:#D19A66;">TypeSignature</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">name parameter1 parameter2 ... = expression</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>name</code> 是函数的名称。</li><li><code>TypeSignature</code> 是函数的类型签名，它声明了函数的输入类型和输出类型。</li><li><code>parameter1</code>, <code>parameter2</code>, ... 是函数的参数。</li><li><code>expression</code> 是函数体，它定义了如何从参数计算结果。</li></ul><h3 id="示例" tabindex="-1"><a class="header-anchor" href="#示例"><span>示例</span></a></h3><p>这是一个简单的 Haskell 函数，它将两个数字相加：</p><div class="language-haskell line-numbers-mode" data-highlighter="shiki" data-ext="haskell" data-title="haskell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">add</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> :: </span><span style="--shiki-light:#A626A4;--shiki-dark:#D19A66;">Num</span><span style="--shiki-light:#E45649;--shiki-dark:#C678DD;"> a</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> =&gt; </span><span style="--shiki-light:#E45649;--shiki-dark:#C678DD;">a</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> -&gt; </span><span style="--shiki-light:#E45649;--shiki-dark:#C678DD;">a</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> -&gt; </span><span style="--shiki-light:#E45649;--shiki-dark:#C678DD;">a</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">add x y = x + y</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，<code>add</code> 是函数名，<code>Num a =&gt;</code> 表示这个函数适用于任何数值类型 <code>a</code>，<code>a -&gt; a -&gt; a</code> 是类型签名，表示函数接受两个类型为 <code>a</code> 的参数并返回一个类型为 <code>a</code> 的结果。</p><h3 id="函数调用" tabindex="-1"><a class="header-anchor" href="#函数调用"><span>函数调用</span></a></h3><p>在 Haskell 中，函数调用不使用括号，而是通过空格分隔参数：</p><div class="language-haskell line-numbers-mode" data-highlighter="shiki" data-ext="haskell" data-title="haskell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">result = add </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">3</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 4</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这将返回 <code>7</code>。</p><h3 id="模式匹配" tabindex="-1"><a class="header-anchor" href="#模式匹配"><span>模式匹配</span></a></h3><p>Haskell 函数通常使用模式匹配来定义不同的行为，这类似于其他语言中的 switch 语句或多个 if-else 语句。例如：</p><div class="language-haskell line-numbers-mode" data-highlighter="shiki" data-ext="haskell" data-title="haskell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">factorial</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> :: (</span><span style="--shiki-light:#A626A4;--shiki-dark:#D19A66;">Integral</span><span style="--shiki-light:#E45649;--shiki-dark:#C678DD;"> a</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) =&gt; </span><span style="--shiki-light:#E45649;--shiki-dark:#C678DD;">a</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> -&gt; </span><span style="--shiki-light:#E45649;--shiki-dark:#C678DD;">a</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">factorial </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> = </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">factorial n = n * factorial (n - </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里，<code>factorial</code> 函数通过模式匹配定义了两种情况：当输入为 <code>0</code> 时返回 <code>1</code>，否则递归地计算 <code>n * (n - 1)!</code>。</p><h3 id="递归" tabindex="-1"><a class="header-anchor" href="#递归"><span>递归</span></a></h3><p>由于 Haskell 没有 while 或 for 循环，递归是执行重复任务的主要方式。上面的 <code>factorial</code> 函数就是一个递归的例子。</p><h3 id="高阶函数" tabindex="-1"><a class="header-anchor" href="#高阶函数"><span>高阶函数</span></a></h3><p>Haskell 支持高阶函数，即可以接受其他函数作为参数或返回函数作为结果的函数。例如：</p><div class="language-haskell line-numbers-mode" data-highlighter="shiki" data-ext="haskell" data-title="haskell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">applyTwice</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> :: (</span><span style="--shiki-light:#E45649;--shiki-dark:#C678DD;">a</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> -&gt; </span><span style="--shiki-light:#E45649;--shiki-dark:#C678DD;">a</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) -&gt; </span><span style="--shiki-light:#E45649;--shiki-dark:#C678DD;">a</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> -&gt; </span><span style="--shiki-light:#E45649;--shiki-dark:#C678DD;">a</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">applyTwice f x = f (f x)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>这个 <code>applyTwice</code> 函数接受一个函数 <code>f</code> 和一个参数 <code>x</code>，然后两次应用 <code>f</code> 到 <code>x</code> 上。</p><h3 id="惰性计算" tabindex="-1"><a class="header-anchor" href="#惰性计算"><span>惰性计算</span></a></h3><p>Haskell 使用惰性计算模型，这意味着表达式只在需要时计算。这允许 Haskell 程序以非常高效的方式处理无限数据结构和其他高级抽象。 这些是 Haskell 函数的一些基本概念。Haskell 的强大之处在于它的类型系统和函数式编程范式，这使得编写简洁、可重用和高效的代码成为可能。</p></div><h3 id="referential-transparency" tabindex="-1"><a class="header-anchor" href="#referential-transparency"><span>Referential transparency</span></a></h3><ul><li>A function is referentially transparent if it always returns the same result when given the same arguments.</li></ul>',98)]))}]]),h=JSON.parse('{"path":"/posts/unimelb/COMP90048.html","title":"Declarative Programming (COMP90048)","lang":"en-US","frontmatter":{"icon":"pen-to-square","date":"2025-03-02T00:00:00.000Z","category":["Learning Records"],"tag":["Unimelb"],"description":"Declarative Programming (COMP90048) Week 1 Imperative languages are based on commands, in the form of instructions and statements. Commands are executed. Commands have an effect...","head":[["meta",{"property":"og:url","content":"https://crc011220.github.io/personalweb/personalweb/posts/unimelb/COMP90048.html"}],["meta",{"property":"og:site_name","content":"Richard Chen"}],["meta",{"property":"og:title","content":"Declarative Programming (COMP90048)"}],["meta",{"property":"og:description","content":"Declarative Programming (COMP90048) Week 1 Imperative languages are based on commands, in the form of instructions and statements. Commands are executed. Commands have an effect..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2025-04-16T08:56:23.000Z"}],["meta",{"property":"article:tag","content":"Unimelb"}],["meta",{"property":"article:published_time","content":"2025-03-02T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-04-16T08:56:23.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Declarative Programming (COMP90048)\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-03-02T00:00:00.000Z\\",\\"dateModified\\":\\"2025-04-16T08:56:23.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Richard Chen\\"}]}"]]},"headers":[{"level":2,"title":"Week 1","slug":"week-1","link":"#week-1","children":[]},{"level":2,"title":"Prolog","slug":"prolog","link":"#prolog","children":[{"level":3,"title":"Rules","slug":"rules","link":"#rules","children":[]},{"level":3,"title":"Equality","slug":"equality","link":"#equality","children":[]},{"level":3,"title":"Disjunction and Conjunction","slug":"disjunction-and-conjunction","link":"#disjunction-and-conjunction","children":[]},{"level":3,"title":"Negation","slug":"negation","link":"#negation","children":[]},{"level":3,"title":"Closed World Assumption","slug":"closed-world-assumption","link":"#closed-world-assumption","children":[]}]},{"level":2,"title":"Week 2","slug":"week-2","link":"#week-2","children":[{"level":3,"title":"Prolog Concepts","slug":"prolog-concepts","link":"#prolog-concepts","children":[]},{"level":3,"title":"Proper Lists","slug":"proper-lists","link":"#proper-lists","children":[]},{"level":3,"title":"Append","slug":"append","link":"#append","children":[]},{"level":3,"title":"e.g. Find the first n th elements of a list","slug":"e-g-find-the-first-n-th-elements-of-a-list","link":"#e-g-find-the-first-n-th-elements-of-a-list","children":[]},{"level":3,"title":"Arithmetic","slug":"arithmetic","link":"#arithmetic","children":[]},{"level":3,"title":"Logic and Resolution","slug":"logic-and-resolution","link":"#logic-and-resolution","children":[]}]},{"level":2,"title":"Week 3","slug":"week-3","link":"#week-3","children":[{"level":3,"title":"Debugger","slug":"debugger","link":"#debugger","children":[]},{"level":3,"title":"Infinite backtracking loop","slug":"infinite-backtracking-loop","link":"#infinite-backtracking-loop","children":[]},{"level":3,"title":"Tail Recursion","slug":"tail-recursion","link":"#tail-recursion","children":[]}]},{"level":2,"title":"Week 4","slug":"week-4","link":"#week-4","children":[{"level":3,"title":"Homoiconicity","slug":"homoiconicity","link":"#homoiconicity","children":[]},{"level":3,"title":"Auto-loading","slug":"auto-loading","link":"#auto-loading","children":[]},{"level":3,"title":"Setof","slug":"setof","link":"#setof","children":[]},{"level":3,"title":"Bagof","slug":"bagof","link":"#bagof","children":[]},{"level":3,"title":"Comparing","slug":"comparing","link":"#comparing","children":[]},{"level":3,"title":"Sorting","slug":"sorting","link":"#sorting","children":[]},{"level":3,"title":"Determining term types","slug":"determining-term-types","link":"#determining-term-types","children":[]},{"level":3,"title":"Others","slug":"others","link":"#others","children":[]},{"level":3,"title":"Propagation and Labeling","slug":"propagation-and-labeling","link":"#propagation-and-labeling","children":[]},{"level":3,"title":"CLP(FD)","slug":"clp-fd","link":"#clp-fd","children":[]}]},{"level":2,"title":"Week 5","slug":"week-5","link":"#week-5","children":[{"level":3,"title":"Haskell","slug":"haskell","link":"#haskell","children":[]},{"level":3,"title":"[] in Haskell","slug":"in-haskell","link":"#in-haskell","children":[]},{"level":3,"title":"Functions in Haskell","slug":"functions-in-haskell","link":"#functions-in-haskell","children":[]},{"level":3,"title":"Referential transparency","slug":"referential-transparency","link":"#referential-transparency","children":[]}]}],"git":{"createdTime":1740916663000,"updatedTime":1744793783000,"contributors":[{"name":"Ruochen Chen","email":"ruocchen1220@gmail.com","commits":6}]},"readingTime":{"minutes":8.79,"words":2636},"filePathRelative":"posts/unimelb/COMP90048.md","localizedDate":"March 2, 2025","excerpt":"\\n<h2>Week 1</h2>\\n<h4>Imperative languages are based on commands, in the form of instructions and statements.</h4>\\n<ul>\\n<li>Commands are executed.</li>\\n<li>Commands have an effect, such as to update the computation state,and later code may depend on this update.</li>\\n</ul>\\n<h4>Logic programming languages are based on finding values that satisfy a set of constraints.</h4>","autoDesc":true}')}}]);