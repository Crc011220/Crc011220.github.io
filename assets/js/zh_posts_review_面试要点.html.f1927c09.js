"use strict";(self.webpackChunkpersonalweb=self.webpackChunkpersonalweb||[]).push([[2071],{2853:(t,d,r)=>{r.r(d),r.d(d,{comp:()=>e,data:()=>s});var a=r(641);const h={},e=(0,r(6262).A)(h,[["render",function(t,d){return(0,a.uX)(),(0,a.CE)("div",null,d[0]||(d[0]=[(0,a.Fv)('<h1 id="面试要点" tabindex="-1"><a class="header-anchor" href="#面试要点"><span>面试要点</span></a></h1><h2 id="java基础" tabindex="-1"><a class="header-anchor" href="#java基础"><span>Java基础</span></a></h2><h3 id="_1-equals-和-的区别-如何正确重写-equals-和-hashcode-方法-为什么需要同时重写" tabindex="-1"><a class="header-anchor" href="#_1-equals-和-的区别-如何正确重写-equals-和-hashcode-方法-为什么需要同时重写"><span>1. equals() 和 == 的区别？如何正确重写 equals() 和 hashCode() 方法？为什么需要同时重写？</span></a></h3><h4 id="和-equals-的区别" tabindex="-1"><a class="header-anchor" href="#和-equals-的区别"><span>== 和 equals() 的区别</span></a></h4><ul><li><strong>== 操作符</strong>：对于基本数据类型比较值，对于引用类型比较内存地址</li><li><strong>equals() 方法</strong>：Object类默认实现是比较引用，String等类重写后比较内容</li></ul><h4 id="正确重写的五个原则" tabindex="-1"><a class="header-anchor" href="#正确重写的五个原则"><span>正确重写的五个原则</span></a></h4><ol><li><strong>自反性</strong>：x.equals(x) 必须返回 true</li><li><strong>对称性</strong>：x.equals(y) 和 y.equals(x) 结果相同</li><li><strong>传递性</strong>：如果 x.equals(y) 且 y.equals(z)，则 x.equals(z)</li><li><strong>一致性</strong>：多次调用结果一致</li><li><strong>非空性</strong>：x.equals(null) 返回 false</li></ol><h4 id="为什么要同时重写" tabindex="-1"><a class="header-anchor" href="#为什么要同时重写"><span>为什么要同时重写？</span></a></h4><p>因为HashMap/HashSet的工作机制：先用hashCode()确定存储位置，再用equals()处理哈希冲突。如果不同时重写会导致相等对象无法在HashMap中正确查找。Java约定：如果两个对象equals()返回true，它们的hashCode()必须相同。</p><table><thead><tr><th>问题</th><th>结论</th></tr></thead><tbody><tr><td><code>equals()</code> 比较什么？</td><td>值是否相等</td></tr><tr><td><code>hashCode()</code> 用来干嘛？</td><td>快速查找桶</td></tr><tr><td>为什么要同时重写？</td><td>保证集合类正常工作，避免逻辑错误</td></tr><tr><td>不重写会怎样？</td><td>数据重复、查找失败、逻辑异常</td></tr></tbody></table><h3 id="_2-接口和抽象类的区别-何时用接口-何时用抽象类" tabindex="-1"><a class="header-anchor" href="#_2-接口和抽象类的区别-何时用接口-何时用抽象类"><span>2. 接口和抽象类的区别？何时用接口？何时用抽象类？</span></a></h3><h4 id="主要区别" tabindex="-1"><a class="header-anchor" href="#主要区别"><span>主要区别</span></a></h4><ul><li><strong>继承关系</strong>：接口支持多实现，抽象类只能单继承</li><li><strong>方法</strong>：接口Java8前只有抽象方法，抽象类可以有具体实现</li><li><strong>成员变量</strong>：接口只能有常量，抽象类可以有各种成员变量</li><li><strong>构造方法</strong>：接口不能有，抽象类可以有</li></ul><h4 id="使用场景" tabindex="-1"><a class="header-anchor" href="#使用场景"><span>使用场景</span></a></h4><ul><li><strong>接口</strong>：定义契约规范、实现多重&quot;继承&quot;、强调&quot;能做什么&quot;（can-do关系）</li><li><strong>抽象类</strong>：代码复用、提供部分实现、强调&quot;是什么&quot;（is-a关系）、需要有状态</li></ul><table><thead><tr><th>特性</th><th>接口</th><th>抽象类</th></tr></thead><tbody><tr><td>继承关系</td><td>可实现多个</td><td>只能继承一个</td></tr><tr><td>方法实现</td><td>抽象方法+默认方法（Java8+）</td><td>抽象方法+具体方法</td></tr><tr><td>成员变量</td><td>只能有常量</td><td>可以有各种类型变量</td></tr><tr><td>构造方法</td><td>不能有</td><td>可以有</td></tr><tr><td>关系类型</td><td>can-do（能做什么）</td><td>is-a（是什么）</td></tr><tr><td>使用场景</td><td>定义规范、多重继承</td><td>代码复用、部分实现、有状态</td></tr></tbody></table><h3 id="_3-string-vs-stringbuffer-vs-stringbuilder" tabindex="-1"><a class="header-anchor" href="#_3-string-vs-stringbuffer-vs-stringbuilder"><span>3. String vs StringBuffer vs StringBuilder</span></a></h3><h4 id="特性对比" tabindex="-1"><a class="header-anchor" href="#特性对比"><span>特性对比</span></a></h4><ul><li><strong>String</strong>：不可变，线程安全，频繁操作性能差，会创建大量临时对象</li><li><strong>StringBuffer</strong>：可变，线程安全（synchronized），适合多线程环境</li><li><strong>StringBuilder</strong>：可变，线程不安全，单线程环境性能最佳</li></ul><h4 id="选择原则" tabindex="-1"><a class="header-anchor" href="#选择原则"><span>选择原则</span></a></h4><ul><li><strong>String</strong>：字符串很少改变的情况</li><li><strong>StringBuffer</strong>：多线程环境下的字符串频繁操作</li><li><strong>StringBuilder</strong>：单线程环境下的字符串频繁操作</li></ul><table><thead><tr><th>特性</th><th>String</th><th>StringBuffer</th><th>StringBuilder</th></tr></thead><tbody><tr><td>可变性</td><td>不可变</td><td>可变</td><td>可变</td></tr><tr><td>线程安全</td><td>安全（不可变）</td><td>安全（同步）</td><td>不安全</td></tr><tr><td>性能</td><td>频繁操作差</td><td>中等</td><td>最佳</td></tr><tr><td>内存使用</td><td>创建新对象</td><td>内部缓冲区</td><td>内部缓冲区</td></tr><tr><td>适用场景</td><td>少量操作</td><td>多线程字符串操作</td><td>单线程字符串操作</td></tr></tbody></table><h3 id="_4-自动装箱与拆箱原理及潜在问题" tabindex="-1"><a class="header-anchor" href="#_4-自动装箱与拆箱原理及潜在问题"><span>4. 自动装箱与拆箱原理及潜在问题</span></a></h3><h4 id="基本概念" tabindex="-1"><a class="header-anchor" href="#基本概念"><span>基本概念</span></a></h4><ul><li><strong>自动装箱</strong>：基本类型自动转换为包装类型（如int→Integer）</li><li><strong>自动拆箱</strong>：包装类型自动转换为基本类型</li><li><strong>实现原理</strong>：编译器自动插入valueOf()和xxxValue()方法调用</li></ul><h4 id="四大潜在问题" tabindex="-1"><a class="header-anchor" href="#四大潜在问题"><span>四大潜在问题</span></a></h4><ol><li><strong>缓存范围问题</strong>：-128到127范围内的Integer对象会被缓存复用，超出范围会创建新对象</li><li><strong>性能问题</strong>：频繁装箱拆箱会影响性能，特别是在循环中</li><li><strong>NullPointerException</strong>：null的包装类型拆箱时会抛NPE</li><li><strong>三目运算符陷阱</strong>：类型不一致时编译器会自动拆箱，可能导致NPE</li></ol><h4 id="最佳实践" tabindex="-1"><a class="header-anchor" href="#最佳实践"><span>最佳实践</span></a></h4><p>尽量使用基本类型、比较包装类型用equals()、避免循环中频繁装箱拆箱、注意缓存范围、小心null值拆箱</p><table><thead><tr><th>问题类型</th><th>具体表现</th><th>解决方案</th></tr></thead><tbody><tr><td>缓存范围问题</td><td>-128~127外用==比较结果为false</td><td>用equals()比较</td></tr><tr><td>性能问题</td><td>循环中频繁装箱拆箱</td><td>使用基本类型</td></tr><tr><td>NPE问题</td><td>null包装类型拆箱时抛异常</td><td>判空或使用基本类型</td></tr><tr><td>三目运算符陷阱</td><td>类型不一致导致自动拆箱NPE</td><td>保证两边类型一致</td></tr><tr><td>最佳实践</td><td>什么时候用包装类型？</td><td>需要null值或泛型时才用</td></tr></tbody></table><h3 id="_5-bio、nio、aio的区别" tabindex="-1"><a class="header-anchor" href="#_5-bio、nio、aio的区别"><span>5. BIO、NIO、AIO的区别？</span></a></h3><h4 id="i-o模型核心概念" tabindex="-1"><a class="header-anchor" href="#i-o模型核心概念"><span>I/O模型核心概念</span></a></h4><p><strong>BIO、NIO、AIO三种I/O模型对比：</strong></p><table><thead><tr><th>特性</th><th>BIO（同步阻塞）</th><th>NIO（同步非阻塞）</th><th>AIO（异步非阻塞）</th></tr></thead><tbody><tr><td>全称</td><td>Blocking I/O</td><td>Non-blocking I/O</td><td>Asynchronous I/O</td></tr><tr><td>阻塞性</td><td>阻塞</td><td>非阻塞</td><td>异步</td></tr><tr><td>同步性</td><td>同步</td><td>同步</td><td>异步</td></tr><tr><td>线程模型</td><td>一线程一连接</td><td>一线程处理多连接</td><td>一线程处理多连接</td></tr><tr><td>API复杂度</td><td>简单</td><td>复杂</td><td>复杂</td></tr><tr><td>适用场景</td><td>连接数少、并发度低</td><td>连接数多、并发度高</td><td>连接数多、并发度高</td></tr></tbody></table><h4 id="工作原理对比" tabindex="-1"><a class="header-anchor" href="#工作原理对比"><span>工作原理对比</span></a></h4><table><thead><tr><th>I/O模型</th><th>工作原理</th><th>线程利用率</th><th>内存消耗</th><th>CPU利用率</th></tr></thead><tbody><tr><td>BIO</td><td>每个连接创建一个线程，线程阻塞等待I/O完成</td><td>低</td><td>高</td><td>低</td></tr><tr><td>NIO</td><td>一个线程通过Selector轮询多个Channel</td><td>高</td><td>中</td><td>高</td></tr><tr><td>AIO</td><td>操作系统完成I/O后通知应用程序</td><td>高</td><td>低</td><td>中</td></tr></tbody></table><h4 id="性能特性对比" tabindex="-1"><a class="header-anchor" href="#性能特性对比"><span>性能特性对比</span></a></h4><table><thead><tr><th>性能指标</th><th>BIO</th><th>NIO</th><th>AIO</th></tr></thead><tbody><tr><td>吞吐量</td><td>低（受线程数限制）</td><td>高</td><td>高</td></tr><tr><td>延迟</td><td>中等</td><td>低</td><td>最低</td></tr><tr><td>内存占用</td><td>高（大量线程栈）</td><td>中等</td><td>低</td></tr><tr><td>CPU消耗</td><td>低（大量阻塞等待）</td><td>中等</td><td>低</td></tr><tr><td>可扩展性</td><td>差</td><td>好</td><td>最好</td></tr></tbody></table><h4 id="编程模型对比" tabindex="-1"><a class="header-anchor" href="#编程模型对比"><span>编程模型对比</span></a></h4><table><thead><tr><th>模型</th><th>编程模型</th><th>事件处理</th><th>错误处理</th><th>学习成本</th></tr></thead><tbody><tr><td>BIO</td><td>顺序编程，符合人类思维</td><td>同步处理</td><td>try-catch</td><td>低</td></tr><tr><td>NIO</td><td>事件驱动，需要状态机管理</td><td>事件循环</td><td>复杂</td><td>高</td></tr><tr><td>AIO</td><td>回调驱动，异步编程</td><td>回调函数</td><td>回调地狱</td><td>高</td></tr></tbody></table><h4 id="实际应用场景选择" tabindex="-1"><a class="header-anchor" href="#实际应用场景选择"><span>实际应用场景选择</span></a></h4><table><thead><tr><th>应用场景</th><th>推荐模型</th><th>选择理由</th><th>注意事项</th></tr></thead><tbody><tr><td>Web服务器</td><td>NIO</td><td>大量连接，请求处理时间短</td><td>需要处理粘包拆包问题</td></tr><tr><td>文件服务器</td><td>BIO</td><td>文件I/O多为顺序操作，编程简单</td><td>控制并发连接数</td></tr><tr><td>即时通讯</td><td>NIO</td><td>长连接，需要高并发</td><td>心跳检测，连接管理</td></tr><tr><td>游戏服务器</td><td>AIO</td><td>实时性要求高，性能敏感</td><td>回调处理复杂</td></tr><tr><td>数据库连接池</td><td>BIO</td><td>连接数可控，操作多为短连接</td><td>连接复用</td></tr><tr><td>大数据传输</td><td>AIO</td><td>大文件传输，异步处理效率高</td><td>需要处理传输中断</td></tr></tbody></table><h4 id="技术选型决策" tabindex="-1"><a class="header-anchor" href="#技术选型决策"><span>技术选型决策</span></a></h4><table><thead><tr><th>考虑因素</th><th>权重</th><th>BIO评分</th><th>NIO评分</th><th>AIO评分</th><th>说明</th></tr></thead><tbody><tr><td>开发难度（20%）</td><td>20%</td><td>9</td><td>6</td><td>5</td><td>BIO最简单</td></tr><tr><td>性能表现（30%）</td><td>30%</td><td>4</td><td>8</td><td>9</td><td>AIO性能最好</td></tr><tr><td>并发能力（25%）</td><td>25%</td><td>3</td><td>8</td><td>9</td><td>NIO/AIO并发能力强</td></tr><tr><td>稳定性（15%）</td><td>15%</td><td>9</td><td>7</td><td>6</td><td>BIO最稳定</td></tr><tr><td>生态成熟度（10%）</td><td>10%</td><td>10</td><td>8</td><td>5</td><td>BIO生态最成熟</td></tr><tr><td><strong>加权总分</strong></td><td></td><td><strong>5.9</strong></td><td><strong>7.3</strong></td><td><strong>7.4</strong></td><td>AIO综合评分略高</td></tr></tbody></table><h2 id="集合" tabindex="-1"><a class="header-anchor" href="#集合"><span>集合</span></a></h2><h3 id="_1-hashmap-的实现原理-jdk-1-7和1-8的区别-hash-方法的作用-如何处理哈希冲突" tabindex="-1"><a class="header-anchor" href="#_1-hashmap-的实现原理-jdk-1-7和1-8的区别-hash-方法的作用-如何处理哈希冲突"><span>1. HashMap 的实现原理？JDK 1.7和1.8的区别？hash()方法的作用？如何处理哈希冲突？</span></a></h3><h4 id="实现原理" tabindex="-1"><a class="header-anchor" href="#实现原理"><span>实现原理</span></a></h4><p>HashMap基于数组+链表/红黑树的数据结构，通过hash算法将key映射到数组索引位置。</p><h4 id="jdk-1-7-vs-1-8-主要区别" tabindex="-1"><a class="header-anchor" href="#jdk-1-7-vs-1-8-主要区别"><span>JDK 1.7 vs 1.8 主要区别</span></a></h4><ul><li><strong>数据结构</strong>：1.7是数组+链表，1.8是数组+链表+红黑树</li><li><strong>插入方式</strong>：1.7头插法（并发环境可能死循环），1.8尾插法</li><li><strong>扩容时机</strong>：1.7先扩容再插入，1.8先插入再扩容</li><li><strong>hash算法</strong>：1.8优化了hash算法，减少碰撞</li></ul><h4 id="hash-方法作用" tabindex="-1"><a class="header-anchor" href="#hash-方法作用"><span>hash()方法作用</span></a></h4><p>将key的hashCode进行二次hash，让hash值更均匀分布，减少哈希冲突。</p><h4 id="哈希冲突处理" tabindex="-1"><a class="header-anchor" href="#哈希冲突处理"><span>哈希冲突处理</span></a></h4><ol><li><strong>链表法</strong>：相同hash值的元素用链表连接</li><li><strong>红黑树优化</strong>：当链表长度≥8且数组长度≥64时，链表转红黑树</li><li><strong>扩容机制</strong>：负载因子超过0.75时，数组容量翻倍</li></ol><table><thead><tr><th>版本对比</th><th>JDK 1.7</th><th>JDK 1.8</th></tr></thead><tbody><tr><td>数据结构</td><td>数组+链表</td><td>数组+链表+红黑树</td></tr><tr><td>插入方式</td><td>头插法</td><td>尾插法</td></tr><tr><td>链表转树</td><td>无</td><td>链表长度≥8且数组长度≥64时</td></tr><tr><td>扩容时机</td><td>先扩容再插入</td><td>先插入再扩容</td></tr><tr><td>并发问题</td><td>可能死循环</td><td>避免了死循环</td></tr></tbody></table><h3 id="_2-concurrenthashmap-如何实现线程安全" tabindex="-1"><a class="header-anchor" href="#_2-concurrenthashmap-如何实现线程安全"><span>2. ConcurrentHashMap 如何实现线程安全？</span></a></h3><h4 id="jdk-1-7-分段锁机制" tabindex="-1"><a class="header-anchor" href="#jdk-1-7-分段锁机制"><span>JDK 1.7：分段锁机制</span></a></h4><ul><li><strong>Segment数组</strong>：将HashMap分成多个段，每个段有独立的锁</li><li><strong>锁粒度</strong>：只锁需要操作的段，其他段可并发访问</li><li><strong>并发度</strong>：默认16个段，最多支持16个线程同时写入</li></ul><h4 id="jdk-1-8-cas-synchronized" tabindex="-1"><a class="header-anchor" href="#jdk-1-8-cas-synchronized"><span>JDK 1.8：CAS + synchronized</span></a></h4><ul><li><strong>取消Segment</strong>：直接在Node节点上加锁</li><li><strong>CAS操作</strong>：数组元素为空时用CAS插入</li><li><strong>synchronized</strong>：发生冲突时锁住链表/红黑树的头节点</li><li><strong>更细粒度</strong>：锁的是具体的hash桶，并发性能更好</li></ul><table><thead><tr><th>版本</th><th>JDK 1.7</th><th>JDK 1.8</th></tr></thead><tbody><tr><td>锁机制</td><td>分段锁（Segment）</td><td>CAS + synchronized</td></tr><tr><td>锁粒度</td><td>段级别</td><td>节点级别</td></tr><tr><td>并发度</td><td>最多16个写线程</td><td>理论上无限制</td></tr><tr><td>内存占用</td><td>Segment额外开销</td><td>更少的内存开销</td></tr><tr><td>性能</td><td>读写分离，性能较好</td><td>读写性能都更优</td></tr></tbody></table><h3 id="_3-arraylist-和-linkedlist-的底层实现、时间复杂度" tabindex="-1"><a class="header-anchor" href="#_3-arraylist-和-linkedlist-的底层实现、时间复杂度"><span>3. ArrayList 和 LinkedList 的底层实现、时间复杂度？</span></a></h3><h4 id="底层实现" tabindex="-1"><a class="header-anchor" href="#底层实现"><span>底层实现</span></a></h4><ul><li><strong>ArrayList</strong>：动态数组，连续内存空间存储</li><li><strong>LinkedList</strong>：双向链表，节点包含data、prev、next指针</li></ul><h4 id="时间复杂度对比" tabindex="-1"><a class="header-anchor" href="#时间复杂度对比"><span>时间复杂度对比</span></a></h4><table><thead><tr><th>操作</th><th>ArrayList</th><th>LinkedList</th></tr></thead><tbody><tr><td>随机访问</td><td>O(1)</td><td>O(n)</td></tr><tr><td>头部插入</td><td>O(n)</td><td>O(1)</td></tr><tr><td>尾部插入</td><td>O(1)</td><td>O(1)</td></tr><tr><td>中间插入</td><td>O(n)</td><td>O(1)*</td></tr><tr><td>头部删除</td><td>O(n)</td><td>O(1)</td></tr><tr><td>尾部删除</td><td>O(1)</td><td>O(1)</td></tr><tr><td>中间删除</td><td>O(n)</td><td>O(1)*</td></tr></tbody></table><p>*注：LinkedList中间插入/删除的O(1)是指已知节点位置的情况，查找节点仍需O(n)</p><h4 id="使用场景-1" tabindex="-1"><a class="header-anchor" href="#使用场景-1"><span>使用场景</span></a></h4><ul><li><strong>ArrayList</strong>：频繁随机访问、少量插入删除</li><li><strong>LinkedList</strong>：频繁插入删除、顺序访问</li></ul><h3 id="_4-iterator-和-listiterator-的区别-fail-fast-和-fail-safe-机制" tabindex="-1"><a class="header-anchor" href="#_4-iterator-和-listiterator-的区别-fail-fast-和-fail-safe-机制"><span>4. Iterator 和 ListIterator 的区别？fail-fast 和 fail-safe 机制？</span></a></h3><h4 id="iterator-vs-listiterator" tabindex="-1"><a class="header-anchor" href="#iterator-vs-listiterator"><span>Iterator vs ListIterator</span></a></h4><table><thead><tr><th>特性</th><th>Iterator</th><th>ListIterator</th></tr></thead><tbody><tr><td>适用范围</td><td>所有Collection</td><td>只适用于List</td></tr><tr><td>遍历方向</td><td>单向（向前）</td><td>双向（前进+后退）</td></tr><tr><td>操作能力</td><td>只能删除</td><td>增删改查都支持</td></tr><tr><td>索引访问</td><td>不支持</td><td>支持获取当前索引</td></tr><tr><td>起始位置</td><td>只能从头开始</td><td>可以从任意位置开始</td></tr></tbody></table><h4 id="fail-fast-vs-fail-safe" tabindex="-1"><a class="header-anchor" href="#fail-fast-vs-fail-safe"><span>fail-fast vs fail-safe</span></a></h4><p><strong>fail-fast（快速失败）：</strong></p><ul><li><strong>机制</strong>：检测到并发修改立即抛ConcurrentModificationException</li><li><strong>实现</strong>：通过modCount计数器检测结构性修改</li><li><strong>代表</strong>：ArrayList、HashMap的迭代器</li></ul><p><strong>fail-safe（安全失败）：</strong></p><ul><li><strong>机制</strong>：在副本上迭代，不会抛异常但可能读到过期数据</li><li><strong>实现</strong>：复制一份数据进行迭代</li><li><strong>代表</strong>：CopyOnWriteArrayList、ConcurrentHashMap</li></ul><table><thead><tr><th>机制</th><th>fail-fast</th><th>fail-safe</th></tr></thead><tbody><tr><td>异常处理</td><td>立即抛异常</td><td>不抛异常</td></tr><tr><td>数据一致性</td><td>强一致性</td><td>可能读到过期数据</td></tr><tr><td>性能开销</td><td>低</td><td>高（需要复制）</td></tr><tr><td>内存使用</td><td>少</td><td>多（额外副本）</td></tr><tr><td>适用场景</td><td>单线程环境</td><td>多线程环境</td></tr></tbody></table><h3 id="_5-如何保证集合的线程安全" tabindex="-1"><a class="header-anchor" href="#_5-如何保证集合的线程安全"><span>5. 如何保证集合的线程安全？</span></a></h3><h4 id="五种解决方案" tabindex="-1"><a class="header-anchor" href="#五种解决方案"><span>五种解决方案</span></a></h4><p><strong>1. Collections.synchronizedXXX()</strong></p><ul><li><strong>原理</strong>：为每个方法加synchronized关键字</li><li><strong>缺点</strong>：性能较差，复合操作仍不安全</li></ul><p><strong>2. Vector、Hashtable</strong></p><ul><li><strong>原理</strong>：方法级别的synchronized</li><li><strong>缺点</strong>：过时的重量级同步，性能差</li></ul><p><strong>3. CopyOnWriteArrayList</strong></p><ul><li><strong>原理</strong>：写时复制，读写分离</li><li><strong>适用</strong>：读多写少的场景</li></ul><p><strong>4. ConcurrentHashMap</strong></p><ul><li><strong>原理</strong>：分段锁/CAS+synchronized</li><li><strong>优点</strong>：高并发性能好</li></ul><p><strong>5. 外部加锁</strong></p><ul><li><strong>原理</strong>：使用外部锁控制访问</li><li><strong>灵活性</strong>：可控制锁的粒度</li></ul><table><thead><tr><th>方案</th><th>性能</th><th>适用场景</th><th>缺点</th></tr></thead><tbody><tr><td>Collections.synchronized</td><td>差</td><td>简单场景</td><td>复合操作不安全</td></tr><tr><td>Vector/Hashtable</td><td>差</td><td>遗留代码</td><td>重量级同步</td></tr><tr><td>CopyOnWriteArrayList</td><td>读快</td><td>读多写少</td><td>写操作开销大</td></tr><tr><td>ConcurrentHashMap</td><td>优</td><td>高并发Map操作</td><td>只适用于Map</td></tr><tr><td>外部加锁</td><td>中</td><td>复杂业务逻辑</td><td>需要小心死锁</td></tr></tbody></table><h3 id="_6-comparable-和-comparator-接口的区别" tabindex="-1"><a class="header-anchor" href="#_6-comparable-和-comparator-接口的区别"><span>6. Comparable 和 Comparator 接口的区别？</span></a></h3><h4 id="核心区别" tabindex="-1"><a class="header-anchor" href="#核心区别"><span>核心区别</span></a></h4><ul><li><strong>Comparable</strong>：内部比较器，对象自己定义排序规则</li><li><strong>Comparator</strong>：外部比较器，第三方定义排序规则</li></ul><h4 id="详细对比" tabindex="-1"><a class="header-anchor" href="#详细对比"><span>详细对比</span></a></h4><p><strong>Comparable接口：</strong></p><ul><li><strong>方法</strong>：compareTo(T o)</li><li><strong>实现位置</strong>：在被比较的类内部实现</li><li><strong>排序规则</strong>：固定的，类的自然排序</li><li><strong>使用方式</strong>：Collections.sort(list)</li></ul><p><strong>Comparator接口：</strong></p><ul><li><strong>方法</strong>：compare(T o1, T o2)</li><li><strong>实现位置</strong>：可以在任何地方实现</li><li><strong>排序规则</strong>：灵活的，可以有多种排序方式</li><li><strong>使用方式</strong>：Collections.sort(list, comparator)</li></ul><table><thead><tr><th>特性</th><th>Comparable</th><th>Comparator</th></tr></thead><tbody><tr><td>位置</td><td>类内部实现</td><td>外部实现</td></tr><tr><td>方法</td><td>compareTo()</td><td>compare()</td></tr><tr><td>排序规则</td><td>单一固定</td><td>多样化灵活</td></tr><tr><td>修改成本</td><td>需要修改原类</td><td>不需要修改原类</td></tr><tr><td>使用场景</td><td>类有明确的自然排序</td><td>需要多种排序方式或无法修改原类</td></tr><tr><td>实现数量</td><td>一个类只能有一种</td><td>可以有多个不同的实现</td></tr></tbody></table><h2 id="多线程" tabindex="-1"><a class="header-anchor" href="#多线程"><span>多线程</span></a></h2><h3 id="线程基础" tabindex="-1"><a class="header-anchor" href="#线程基础"><span>线程基础</span></a></h3><h4 id="_1-进程和线程的区别-创建线程的几种方式-哪种更推荐" tabindex="-1"><a class="header-anchor" href="#_1-进程和线程的区别-创建线程的几种方式-哪种更推荐"><span>1. 进程和线程的区别？创建线程的几种方式？哪种更推荐？</span></a></h4><p><strong>进程 vs 线程：</strong></p><ul><li><strong>进程</strong>：操作系统资源分配的基本单位，拥有独立的内存空间</li><li><strong>线程</strong>：CPU调度的基本单位，同一进程内的线程共享内存空间</li></ul><table><thead><tr><th>特性</th><th>进程</th><th>线程</th></tr></thead><tbody><tr><td>资源占用</td><td>独立内存空间</td><td>共享进程内存空间</td></tr><tr><td>创建开销</td><td>大</td><td>小</td></tr><tr><td>通信方式</td><td>IPC（管道、消息队列）</td><td>共享内存、同步机制</td></tr><tr><td>崩溃影响</td><td>不影响其他进程</td><td>可能影响整个进程</td></tr><tr><td>切换开销</td><td>大</td><td>小</td></tr></tbody></table><p><strong>创建线程的方式：</strong></p><table><thead><tr><th>方式</th><th>特点</th><th>推荐度</th><th>使用场景</th></tr></thead><tbody><tr><td>继承Thread类</td><td>简单，但Java单继承限制</td><td>⭐⭐</td><td>简单场景，不推荐</td></tr><tr><td>实现Runnable接口</td><td>可多继承，推荐</td><td>⭐⭐⭐</td><td>一般异步任务</td></tr><tr><td>实现Callable+FutureTask</td><td>有返回值，可抛异常</td><td>⭐⭐⭐</td><td>需要返回结果的任务</td></tr><tr><td>线程池</td><td>复用线程，性能好，资源可控</td><td>⭐⭐⭐⭐⭐</td><td>生产环境，高并发场景</td></tr></tbody></table><p><strong>最推荐</strong>：线程池方式，因为可以避免频繁创建销毁线程的开销，更好地控制并发数量。</p><h4 id="_2-sleep-wait-yield-join-方法的区别" tabindex="-1"><a class="header-anchor" href="#_2-sleep-wait-yield-join-方法的区别"><span>2. sleep(), wait(), yield(), join() 方法的区别？</span></a></h4><table><thead><tr><th>方法</th><th>所属类</th><th>锁状态</th><th>使用场景</th><th>唤醒方式</th></tr></thead><tbody><tr><td>sleep()</td><td>Thread</td><td>不释放锁</td><td>暂停指定时间</td><td>时间到自动唤醒</td></tr><tr><td>wait()</td><td>Object</td><td>释放锁</td><td>等待条件满足</td><td>notify/notifyAll</td></tr><tr><td>yield()</td><td>Thread</td><td>不释放锁</td><td>让出CPU给同优先级线程</td><td>立即重新参与调度</td></tr><tr><td>join()</td><td>Thread</td><td>不释放锁</td><td>等待线程执行完毕</td><td>目标线程执行完毕</td></tr></tbody></table><p><strong>核心区别：</strong></p><ul><li><strong>sleep()和wait()的最大区别</strong>：sleep不释放锁，wait释放锁</li><li><strong>yield()作用</strong>：暂停当前线程，让同优先级线程有机会执行</li><li><strong>join()用途</strong>：主线程等待子线程执行完毕后再继续</li></ul><h4 id="_3-上下文切换是什么-开销在哪里" tabindex="-1"><a class="header-anchor" href="#_3-上下文切换是什么-开销在哪里"><span>3. 上下文切换是什么？开销在哪里？</span></a></h4><p><strong>上下文切换</strong>：CPU从一个线程切换到另一个线程时，需要保存当前线程状态并加载新线程状态的过程。</p><p><strong>开销构成：</strong></p><ol><li><strong>保存现场</strong>：寄存器、程序计数器、栈指针等</li><li><strong>加载新现场</strong>：新线程的执行环境</li><li><strong>内存缓存失效</strong>：CPU缓存可能失效，需要重新加载</li><li><strong>内核态切换</strong>：用户态到内核态的切换开销</li></ol><table><thead><tr><th>开销类型</th><th>具体内容</th><th>影响程度</th></tr></thead><tbody><tr><td>寄存器保存</td><td>CPU寄存器状态保存/恢复</td><td>中等</td></tr><tr><td>内存访问</td><td>栈、堆内存访问模式变化</td><td>高</td></tr><tr><td>缓存失效</td><td>CPU缓存、TLB失效</td><td>高</td></tr><tr><td>系统调用</td><td>用户态/内核态切换</td><td>中等</td></tr></tbody></table><h3 id="线程安全" tabindex="-1"><a class="header-anchor" href="#线程安全"><span>线程安全</span></a></h3><h4 id="_1-什么是线程安全-如何理解原子性、可见性、有序性" tabindex="-1"><a class="header-anchor" href="#_1-什么是线程安全-如何理解原子性、可见性、有序性"><span>1. 什么是线程安全？如何理解原子性、可见性、有序性？</span></a></h4><p><strong>线程安全</strong>：多个线程同时访问共享资源时，不会产生数据不一致或其他非预期的结果。</p><p><strong>并发编程三大特性：</strong></p><table><thead><tr><th>特性</th><th>定义</th><th>问题表现</th><th>解决方案</th></tr></thead><tbody><tr><td>原子性</td><td>操作不可被中断，要么全部成功要么全部失败</td><td>数据不一致</td><td>synchronized、CAS</td></tr><tr><td>可见性</td><td>一个线程修改共享变量，其他线程能立即看到</td><td>读取到过期数据</td><td>volatile、synchronized</td></tr><tr><td>有序性</td><td>程序执行顺序与代码顺序一致</td><td>指令重排序导致逻辑错误</td><td>volatile、synchronized</td></tr></tbody></table><h4 id="_2-synchronized-关键字的原理-使用方式-锁升级过程" tabindex="-1"><a class="header-anchor" href="#_2-synchronized-关键字的原理-使用方式-锁升级过程"><span>2. synchronized 关键字的原理？使用方式？锁升级过程？</span></a></h4><p><strong>使用方式：</strong></p><ul><li><strong>修饰实例方法</strong>：锁的是当前实例对象</li><li><strong>修饰静态方法</strong>：锁的是Class对象</li><li><strong>修饰代码块</strong>：锁的是指定对象</li></ul><p><strong>锁升级过程（JDK1.6+）：</strong></p><table><thead><tr><th>锁状态</th><th>特点</th><th>适用场景</th><th>性能</th></tr></thead><tbody><tr><td>无锁</td><td>没有锁竞争</td><td>单线程访问</td><td>最高</td></tr><tr><td>偏向锁</td><td>偏向第一个获得锁的线程</td><td>基本没有竞争</td><td>高</td></tr><tr><td>轻量级锁</td><td>CAS自旋获取锁</td><td>竞争不激烈，持锁时间短</td><td>中等</td></tr><tr><td>重量级锁</td><td>操作系统互斥锁</td><td>竞争激烈，持锁时间长</td><td>低</td></tr></tbody></table><p><strong>升级路径</strong>：无锁 → 偏向锁 → 轻量级锁 → 重量级锁（不可逆）</p><h4 id="_3-volatile-关键字的语义-原理-能保证原子性吗-适用场景" tabindex="-1"><a class="header-anchor" href="#_3-volatile-关键字的语义-原理-能保证原子性吗-适用场景"><span>3. volatile 关键字的语义？原理？能保证原子性吗？适用场景？</span></a></h4><p><strong>volatile的两大语义：</strong></p><ol><li><strong>保证可见性</strong>：修改立即刷新到主内存，读取直接从主内存读</li><li><strong>保证有序性</strong>：禁止指令重排序</li></ol><p><strong>实现原理：</strong></p><ul><li><strong>内存屏障</strong>：编译器在volatile变量前后插入内存屏障指令</li><li><strong>缓存一致性协议</strong>：MESI协议确保缓存一致性</li></ul><p><strong>不能保证原子性</strong>：volatile不能保证复合操作的原子性，如 i++ 操作。</p><table><thead><tr><th>特性</th><th>volatile</th><th>synchronized</th></tr></thead><tbody><tr><td>原子性</td><td>❌</td><td>✅</td></tr><tr><td>可见性</td><td>✅</td><td>✅</td></tr><tr><td>有序性</td><td>✅</td><td>✅</td></tr><tr><td>阻塞性</td><td>不阻塞</td><td>可能阻塞</td></tr><tr><td>性能</td><td>高</td><td>相对较低</td></tr></tbody></table><p><strong>适用场景：</strong></p><ul><li>状态标记（如停止标志）</li><li>双重检查锁定模式</li><li>单例模式中的实例变量</li></ul><h4 id="_4-synchronized-和-volatile-的区别" tabindex="-1"><a class="header-anchor" href="#_4-synchronized-和-volatile-的区别"><span>4. synchronized 和 volatile 的区别？</span></a></h4><table><thead><tr><th>对比维度</th><th>synchronized</th><th>volatile</th></tr></thead><tbody><tr><td>作用对象</td><td>方法、代码块</td><td>变量</td></tr><tr><td>原子性</td><td>保证</td><td>不保证</td></tr><tr><td>可见性</td><td>保证</td><td>保证</td></tr><tr><td>有序性</td><td>保证</td><td>保证</td></tr><tr><td>阻塞特性</td><td>可能阻塞</td><td>不阻塞</td></tr><tr><td>锁机制</td><td>互斥锁</td><td>无锁</td></tr><tr><td>性能开销</td><td>较高</td><td>较低</td></tr><tr><td>适用场景</td><td>复合操作、临界区</td><td>状态标记、简单赋值</td></tr></tbody></table><h4 id="_5-cas-操作的原理-atomic类实现-aba问题及解决方案" tabindex="-1"><a class="header-anchor" href="#_5-cas-操作的原理-atomic类实现-aba问题及解决方案"><span>5. CAS 操作的原理？Atomic类实现？ABA问题及解决方案？</span></a></h4><p><strong>CAS（Compare-And-Swap）原理：</strong> 比较内存位置的值与期望值，如果相同则更新为新值，整个操作是原子的。</p><p><strong>三个操作数：</strong></p><ul><li><strong>内存位置V</strong>：要更新的变量</li><li><strong>预期值A</strong>：期望的当前值</li><li><strong>新值B</strong>：要设置的新值</li></ul><p><strong>Atomic类实现：</strong> 基于CAS + volatile，通过无锁算法实现线程安全。</p><p><strong>ABA问题：</strong> 值从A变成B再变回A，CAS检测不到中间的变化过程。</p><table><thead><tr><th>问题</th><th>表现</th><th>解决方案</th></tr></thead><tbody><tr><td>ABA问题</td><td>值变化后又变回原值，CAS误判为未变化</td><td>AtomicStampedReference</td></tr><tr><td>性能问题</td><td>高竞争时自旋消耗CPU</td><td>结合synchronized</td></tr><tr><td>只能保证单变量</td><td>多个变量的原子性无法保证</td><td>AtomicReference包装对象</td></tr></tbody></table><h4 id="_6-threadlocal-的原理-使用场景-内存泄漏问题及如何避免" tabindex="-1"><a class="header-anchor" href="#_6-threadlocal-的原理-使用场景-内存泄漏问题及如何避免"><span>6. ThreadLocal 的原理？使用场景？内存泄漏问题及如何避免？</span></a></h4><p><strong>原理：</strong> 每个线程都有一个ThreadLocalMap，以ThreadLocal为key存储线程私有数据。</p><p><strong>数据结构：</strong> Thread → ThreadLocalMap → Entry(ThreadLocal, Value)</p><p><strong>使用场景：</strong></p><ul><li><strong>数据库连接管理</strong>：每个线程独立的连接</li><li><strong>用户会话信息</strong>：Web请求中的用户信息</li><li><strong>数据格式化</strong>：SimpleDateFormat等非线程安全类</li></ul><p><strong>内存泄漏问题：</strong></p><table><thead><tr><th>问题原因</th><th>后果</th><th>解决方案</th></tr></thead><tbody><tr><td>ThreadLocal被回收</td><td>key为null</td><td>手动调用remove()</td></tr><tr><td>线程长期存活</td><td>value无法回收</td><td>使用完毕立即remove()</td></tr><tr><td>强引用链</td><td>整个对象无法回收</td><td>避免在线程池中使用静态ThreadLocal</td></tr></tbody></table><p><strong>最佳实践：</strong></p><ol><li>使用完毕后立即调用 <code>remove()</code></li><li>使用 <code>try-finally</code> 确保清理</li><li>避免在线程池中使用静态ThreadLocal</li></ol><h2 id="数据库" tabindex="-1"><a class="header-anchor" href="#数据库"><span>数据库</span></a></h2><h3 id="sql基础" tabindex="-1"><a class="header-anchor" href="#sql基础"><span>SQL基础</span></a></h3><h4 id="_1-sql基础语法-ddl-dml-dql-dcl-常用函数" tabindex="-1"><a class="header-anchor" href="#_1-sql基础语法-ddl-dml-dql-dcl-常用函数"><span>1. SQL基础语法（DDL, DML, DQL, DCL）？常用函数？</span></a></h4><p><strong>SQL语言分类：</strong></p><table><thead><tr><th>类型</th><th>全称</th><th>作用</th><th>常用语句</th></tr></thead><tbody><tr><td>DDL</td><td>Data Definition Language</td><td>数据定义语言</td><td>CREATE、ALTER、DROP</td></tr><tr><td>DML</td><td>Data Manipulation Language</td><td>数据操作语言</td><td>INSERT、UPDATE、DELETE</td></tr><tr><td>DQL</td><td>Data Query Language</td><td>数据查询语言</td><td>SELECT</td></tr><tr><td>DCL</td><td>Data Control Language</td><td>数据控制语言</td><td>GRANT、REVOKE、COMMIT、ROLLBACK</td></tr></tbody></table><p><strong>常用函数分类：</strong></p><table><thead><tr><th>函数类型</th><th>常用函数</th><th>作用</th></tr></thead><tbody><tr><td>聚合函数</td><td>COUNT、SUM、AVG、MAX、MIN</td><td>统计计算</td></tr><tr><td>字符串函数</td><td>CONCAT、SUBSTRING、LENGTH、UPPER、LOWER</td><td>字符串处理</td></tr><tr><td>日期函数</td><td>NOW、CURDATE、DATE_FORMAT、DATEDIFF</td><td>日期时间处理</td></tr><tr><td>数学函数</td><td>ROUND、CEIL、FLOOR、ABS、MOD</td><td>数值计算</td></tr><tr><td>条件函数</td><td>IF、CASE WHEN、IFNULL、NULLIF</td><td>条件判断</td></tr></tbody></table><h3 id="mysql特性" tabindex="-1"><a class="header-anchor" href="#mysql特性"><span>MySQL特性</span></a></h3><h4 id="_2-mysql核心区别-事务、锁、外键、索引结构" tabindex="-1"><a class="header-anchor" href="#_2-mysql核心区别-事务、锁、外键、索引结构"><span>2. MySQL核心区别（事务、锁、外键、索引结构）？</span></a></h4><p><strong>存储引擎对比：</strong></p><table><thead><tr><th>特性</th><th>InnoDB</th><th>MyISAM</th><th>Memory</th></tr></thead><tbody><tr><td>事务支持</td><td>✅支持ACID</td><td>❌不支持</td><td>❌不支持</td></tr><tr><td>锁级别</td><td>行级锁</td><td>表级锁</td><td>表级锁</td></tr><tr><td>外键支持</td><td>✅支持</td><td>❌不支持</td><td>❌不支持</td></tr><tr><td>索引结构</td><td>B+树聚集索引</td><td>B+树非聚集索引</td><td>Hash索引</td></tr><tr><td>崩溃恢复</td><td>✅支持</td><td>❌不支持</td><td>❌不支持</td></tr><tr><td>适用场景</td><td>事务处理、高并发写入</td><td>只读、数据仓库</td><td>临时表、缓存</td></tr></tbody></table><h3 id="索引优化" tabindex="-1"><a class="header-anchor" href="#索引优化"><span>索引优化</span></a></h3><h4 id="_3-索引-什么是索引-为什么能提高查询效率-索引的优缺点" tabindex="-1"><a class="header-anchor" href="#_3-索引-什么是索引-为什么能提高查询效率-索引的优缺点"><span>3. 索引：什么是索引？为什么能提高查询效率？索引的优缺点？</span></a></h4><p><strong>索引定义：</strong> 索引是数据库表中一个或多个列的值排序的数据结构，类似书的目录，用于快速定位数据。</p><p><strong>提高效率原理：</strong></p><ul><li><strong>减少扫描行数</strong>：从全表扫描变为索引查找</li><li><strong>有序存储</strong>：B+树结构保证数据有序，支持范围查询</li><li><strong>减少I/O操作</strong>：索引通常比数据小，能缓存在内存中</li></ul><p><strong>索引优缺点：</strong></p><table><thead><tr><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>大幅提高查询速度</td><td>占用额外存储空间</td></tr><tr><td>加速表连接</td><td>降低写操作性能（增删改）</td></tr><tr><td>减少分组和排序时间</td><td>维护索引需要额外开销</td></tr><tr><td>唯一索引保证数据唯一性</td><td>过多索引影响优化器选择</td></tr></tbody></table><h4 id="_4-b-树索引结构-为什么mysql使用b-树而不是b树或哈希表" tabindex="-1"><a class="header-anchor" href="#_4-b-树索引结构-为什么mysql使用b-树而不是b树或哈希表"><span>4. B+树索引结构？为什么MySQL使用B+树而不是B树或哈希表？</span></a></h4><p><strong>B+树特点：</strong></p><ul><li><strong>所有数据在叶子节点</strong>：非叶子节点只存储键值</li><li><strong>叶子节点连接</strong>：叶子节点通过指针连接，支持范围查询</li><li><strong>更高的扇出比</strong>：非叶子节点可存储更多键值</li></ul><p><strong>选择B+树的原因：</strong></p><table><thead><tr><th>对比项</th><th>B+树</th><th>B树</th><th>哈希表</th></tr></thead><tbody><tr><td>范围查询</td><td>✅优秀</td><td>❌较差</td><td>❌不支持</td></tr><tr><td>顺序访问</td><td>✅优秀</td><td>❌一般</td><td>❌不支持</td></tr><tr><td>磁盘I/O</td><td>✅少</td><td>❌多</td><td>✅少</td></tr><tr><td>内存利用率</td><td>✅高</td><td>❌低</td><td>✅高</td></tr><tr><td>等值查询</td><td>✅快</td><td>✅快</td><td>✅最快</td></tr><tr><td>数据有序性</td><td>✅有序</td><td>✅有序</td><td>❌无序</td></tr></tbody></table><h4 id="_5-聚集索引和非聚集索引的区别-innodb的主键索引结构" tabindex="-1"><a class="header-anchor" href="#_5-聚集索引和非聚集索引的区别-innodb的主键索引结构"><span>5. 聚集索引和非聚集索引的区别？InnoDB的主键索引结构？</span></a></h4><p><strong>聚集索引 vs 非聚集索引：</strong></p><table><thead><tr><th>特性</th><th>聚集索引（主键索引）</th><th>非聚集索引（辅助索引）</th></tr></thead><tbody><tr><td>数据存储</td><td>叶子节点存储完整行数据</td><td>叶子节点存储主键值</td></tr><tr><td>数据排序</td><td>数据按索引键物理排序</td><td>数据排序与索引无关</td></tr><tr><td>查询性能</td><td>一次查询获取所有数据</td><td>可能需要回表查询</td></tr><tr><td>每表数量</td><td>最多一个</td><td>可以有多个</td></tr><tr><td>存储开销</td><td>无额外开销</td><td>需要额外存储空间</td></tr></tbody></table><p><strong>InnoDB主键索引结构：</strong></p><ul><li><strong>主键索引</strong>：聚集索引，叶子节点存储完整行数据</li><li><strong>辅助索引</strong>：非聚集索引，叶子节点存储主键值</li><li><strong>回表查询</strong>：通过辅助索引查询时，需要根据主键值再查主键索引</li></ul><h4 id="_6-索引类型分类" tabindex="-1"><a class="header-anchor" href="#_6-索引类型分类"><span>6. 索引类型分类？</span></a></h4><p><strong>按功能分类：</strong></p><table><thead><tr><th>索引类型</th><th>特点</th><th>使用场景</th><th>示例</th></tr></thead><tbody><tr><td>主键索引</td><td>唯一+非空，自动创建聚集索引</td><td>主键字段</td><td>PRIMARY KEY</td></tr><tr><td>唯一索引</td><td>值唯一，允许一个NULL</td><td>身份证号、邮箱</td><td>UNIQUE</td></tr><tr><td>普通索引</td><td>无唯一性限制，提高查询速度</td><td>查询频繁的字段</td><td>INDEX</td></tr><tr><td>组合索引</td><td>多列联合索引，遵循最左前缀原则</td><td>多条件查询</td><td>(name, age, city)</td></tr><tr><td>全文索引</td><td>文本关键词搜索</td><td>文章内容搜索</td><td>FULLTEXT</td></tr></tbody></table><h4 id="_7-索引失效的常见场景" tabindex="-1"><a class="header-anchor" href="#_7-索引失效的常见场景"><span>7. 索引失效的常见场景？</span></a></h4><p><strong>索引失效情况：</strong></p><table><thead><tr><th>失效场景</th><th>示例</th><th>原因</th></tr></thead><tbody><tr><td>函数操作</td><td>WHERE YEAR(date) = 2023</td><td>对索引列使用函数</td></tr><tr><td>隐式类型转换</td><td>WHERE age = &#39;18&#39;</td><td>数据类型不匹配</td></tr><tr><td>LIKE以%开头</td><td>WHERE name LIKE &#39;%张&#39;</td><td>无法利用索引的有序性</td></tr><tr><td>OR条件</td><td>WHERE a = 1 OR b = 2</td><td>其中一个条件没有索引</td></tr><tr><td>组合索引不满足最左前缀</td><td>INDEX(a,b,c) WHERE b = 1</td><td>违反最左前缀原则</td></tr><tr><td>不等于操作</td><td>WHERE age != 18</td><td>范围太大，优化器选择全表扫描</td></tr><tr><td>IS NULL判断</td><td>WHERE name IS NULL</td><td>NULL值不存储在索引中</td></tr></tbody></table><h3 id="锁机制" tabindex="-1"><a class="header-anchor" href="#锁机制"><span>锁机制</span></a></h3><h4 id="_8-explain命令的作用-关键字段的含义" tabindex="-1"><a class="header-anchor" href="#_8-explain命令的作用-关键字段的含义"><span>8. EXPLAIN命令的作用？关键字段的含义？</span></a></h4><p><strong>EXPLAIN作用：</strong> 分析SQL语句执行计划，帮助优化查询性能。</p><p><strong>关键字段含义：</strong></p><table><thead><tr><th>字段</th><th>含义</th><th>重要值</th></tr></thead><tbody><tr><td>type</td><td>访问类型</td><td>system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL</td></tr><tr><td>key</td><td>实际使用的索引</td><td>NULL表示未使用索引</td></tr><tr><td>rows</td><td>预估扫描行数</td><td>数值越小越好</td></tr><tr><td>Extra</td><td>额外信息</td><td>Using index &gt; Using where &gt; Using filesort</td></tr></tbody></table><p><strong>type字段详解：</strong></p><table><thead><tr><th>type值</th><th>性能</th><th>说明</th></tr></thead><tbody><tr><td>system</td><td>最优</td><td>表只有一行</td></tr><tr><td>const</td><td>优</td><td>主键或唯一索引等值查询</td></tr><tr><td>eq_ref</td><td>优</td><td>主键或唯一索引关联</td></tr><tr><td>ref</td><td>良</td><td>非唯一索引等值查询</td></tr><tr><td>range</td><td>中</td><td>范围查询</td></tr><tr><td>index</td><td>差</td><td>索引全扫描</td></tr><tr><td>ALL</td><td>最差</td><td>全表扫描</td></tr></tbody></table><h4 id="_9-锁-innodb的行锁、间隙锁、临键锁-mvcc的原理-如何解决幻读" tabindex="-1"><a class="header-anchor" href="#_9-锁-innodb的行锁、间隙锁、临键锁-mvcc的原理-如何解决幻读"><span>9. 锁：InnoDB的行锁、间隙锁、临键锁？MVCC的原理？如何解决幻读？</span></a></h4><p><strong>InnoDB锁类型：</strong></p><table><thead><tr><th>锁类型</th><th>锁范围</th><th>作用</th><th>示例场景</th></tr></thead><tbody><tr><td>行锁</td><td>锁定具体的行</td><td>防止并发修改同一行数据</td><td>UPDATE具体记录</td></tr><tr><td>间隙锁</td><td>锁定索引记录之间的间隙</td><td>防止在间隙中插入新记录</td><td>防止幻读</td></tr><tr><td>临键锁</td><td>行锁+间隙锁的组合</td><td>既锁记录又锁间隙</td><td>范围查询时使用</td></tr><tr><td>意向锁</td><td>表级锁，表示事务的加锁意图</td><td>提高表锁检测效率</td><td>加行锁时自动加意向锁</td></tr></tbody></table><p><strong>MVCC（多版本并发控制）原理：</strong></p><ul><li><strong>版本链</strong>：每行记录维护多个版本</li><li><strong>ReadView</strong>：事务开始时创建的一致性视图</li><li><strong>undo log</strong>：存储历史版本数据</li><li><strong>实现隔离</strong>：不同事务看到不同版本的数据</li></ul><p><strong>解决幻读：</strong></p><ul><li><strong>快照读</strong>：通过MVCC，读取事务开始时的数据快照</li><li><strong>当前读</strong>：通过临键锁，锁定查询范围防止插入新数据</li></ul><h3 id="事务管理" tabindex="-1"><a class="header-anchor" href="#事务管理"><span>事务管理</span></a></h3><h4 id="_10-事务隔离级别-mysql默认级别-不同级别解决的问题" tabindex="-1"><a class="header-anchor" href="#_10-事务隔离级别-mysql默认级别-不同级别解决的问题"><span>10. 事务隔离级别？MySQL默认级别？不同级别解决的问题？</span></a></h4><p><strong>四大隔离级别：</strong></p><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th><th>实现方式</th><th>性能</th></tr></thead><tbody><tr><td>读未提交（READ UNCOMMITTED）</td><td>❌</td><td>❌</td><td>❌</td><td>无锁</td><td>最高</td></tr><tr><td>读已提交（READ COMMITTED）</td><td>✅</td><td>❌</td><td>❌</td><td>行锁+MVCC</td><td>高</td></tr><tr><td>可重复读（REPEATABLE READ）</td><td>✅</td><td>✅</td><td>部分解决</td><td>临键锁+MVCC</td><td>中</td></tr><tr><td>串行化（SERIALIZABLE）</td><td>✅</td><td>✅</td><td>✅</td><td>表锁</td><td>低</td></tr></tbody></table><p>**MySQL默认隔离级别：**可重复读（REPEATABLE READ）</p><p><strong>问题说明：</strong></p><ul><li><strong>脏读</strong>：读到其他事务未提交的数据</li><li><strong>不可重复读</strong>：同一事务中多次读取同一数据结果不同</li><li><strong>幻读</strong>：同一事务中多次查询记录数量不同</li></ul><h3 id="性能优化" tabindex="-1"><a class="header-anchor" href="#性能优化"><span>性能优化</span></a></h3><h4 id="_11-如何优化慢查询" tabindex="-1"><a class="header-anchor" href="#_11-如何优化慢查询"><span>11. 如何优化慢查询？</span></a></h4><p><strong>优化策略：</strong></p><table><thead><tr><th>优化方向</th><th>具体方法</th><th>效果评估</th></tr></thead><tbody><tr><td>索引优化</td><td>添加合适索引、优化索引使用</td><td>⭐⭐⭐⭐⭐</td></tr><tr><td>SQL语句优化</td><td>避免SELECT *、减少子查询</td><td>⭐⭐⭐⭐</td></tr><tr><td>分库分表</td><td>水平/垂直分割减少单表数据量</td><td>⭐⭐⭐⭐⭐</td></tr><tr><td>读写分离</td><td>主库写、从库读，减少主库压力</td><td>⭐⭐⭐⭐</td></tr></tbody></table><p><strong>具体优化手段：</strong></p><table><thead><tr><th>方法</th><th>说明</th><th>适用场景</th></tr></thead><tbody><tr><td>添加索引</td><td>为WHERE、ORDER BY字段添加索引</td><td>查询频繁的字段</td></tr><tr><td>优化JOIN</td><td>使用小表驱动大表</td><td>多表关联查询</td></tr><tr><td>避免函数计算</td><td>不在WHERE条件中使用函数</td><td>所有查询</td></tr><tr><td>分页优化</td><td>使用索引+偏移量代替LIMIT大偏移</td><td>深度分页查询</td></tr><tr><td>垂直分表</td><td>将大字段拆分到独立表</td><td>表字段过多</td></tr><tr><td>水平分表</td><td>按规则将数据分散到多个表</td><td>单表数据量过大</td></tr><tr><td>使用缓存</td><td>Redis缓存热点数据</td><td>读多写少场景</td></tr><tr><td>连接池优化</td><td>合理设置连接池参数</td><td>高并发场景</td></tr></tbody></table><h2 id="redis" tabindex="-1"><a class="header-anchor" href="#redis"><span>Redis</span></a></h2><h3 id="基础特性" tabindex="-1"><a class="header-anchor" href="#基础特性"><span>基础特性</span></a></h3><h4 id="_1-redis是什么-常用数据类型及其底层实现和典型应用场景" tabindex="-1"><a class="header-anchor" href="#_1-redis是什么-常用数据类型及其底层实现和典型应用场景"><span>1. Redis是什么？常用数据类型及其底层实现和典型应用场景？</span></a></h4><p><strong>Redis定义：</strong> Redis是一个开源的内存数据结构存储系统，可用作数据库、缓存和消息代理。</p><p><strong>常用数据类型：</strong></p><table><thead><tr><th>数据类型</th><th>底层实现</th><th>典型应用场景</th><th>常用命令</th></tr></thead><tbody><tr><td>String</td><td>SDS（简单动态字符串）</td><td>缓存、计数器、分布式锁</td><td>SET、GET、INCR</td></tr><tr><td>Hash</td><td>压缩列表/哈希表</td><td>用户信息、商品信息</td><td>HSET、HGET、HMGET</td></tr><tr><td>List</td><td>压缩列表/双向链表</td><td>消息队列、最新消息列表</td><td>LPUSH、RPOP、LRANGE</td></tr><tr><td>Set</td><td>整数集合/哈希表</td><td>标签、好友关系、唯一性统计</td><td>SADD、SMEMBERS、SINTER</td></tr><tr><td>Sorted Set</td><td>压缩列表/跳跃表</td><td>排行榜、延时队列</td><td>ZADD、ZRANGE、ZRANK</td></tr><tr><td>HyperLogLog</td><td>基数估算算法</td><td>UV统计、独立访客统计</td><td>PFADD、PFCOUNT</td></tr><tr><td>Bitmap</td><td>位数组</td><td>用户签到、在线状态</td><td>SETBIT、GETBIT、BITCOUNT</td></tr><tr><td>Geospatial</td><td>Sorted Set + GeoHash</td><td>地理位置、附近的人</td><td>GEOADD、GEORADIUS</td></tr><tr><td>Stream</td><td>Radix Tree + Listpack</td><td>消息流、日志收集</td><td>XADD、XREAD、XGROUP</td></tr></tbody></table><h4 id="_2-redis为什么快" tabindex="-1"><a class="header-anchor" href="#_2-redis为什么快"><span>2. Redis为什么快？</span></a></h4><p><strong>性能优势分析：</strong></p><table><thead><tr><th>优势</th><th>具体表现</th><th>性能影响</th></tr></thead><tbody><tr><td>内存存储</td><td>数据存储在内存中，避免磁盘I/O</td><td>⭐⭐⭐⭐⭐</td></tr><tr><td>单线程模型</td><td>避免线程切换和锁竞争开销</td><td>⭐⭐⭐⭐</td></tr><tr><td>I/O多路复用</td><td>epoll机制处理并发连接</td><td>⭐⭐⭐⭐</td></tr><tr><td>高效数据结构</td><td>针对不同场景优化的数据结构</td><td>⭐⭐⭐</td></tr><tr><td>简单协议</td><td>RESP协议简单，解析开销小</td><td>⭐⭐⭐</td></tr></tbody></table><p><strong>核心原因：</strong></p><ul><li><strong>纯内存操作</strong>：避免磁盘I/O，速度快10000倍</li><li><strong>单线程避免竞争</strong>：无锁设计，减少上下文切换</li><li><strong>非阻塞I/O</strong>：高效处理大量并发连接</li></ul><h3 id="持久化机制" tabindex="-1"><a class="header-anchor" href="#持久化机制"><span>持久化机制</span></a></h3><h4 id="_3-redis的持久化机制-优缺点-如何选择" tabindex="-1"><a class="header-anchor" href="#_3-redis的持久化机制-优缺点-如何选择"><span>3. Redis的持久化机制？优缺点？如何选择？</span></a></h4><p><strong>两种持久化方式：</strong></p><table><thead><tr><th>特性</th><th>RDB快照</th><th>AOF日志</th></tr></thead><tbody><tr><td>持久化方式</td><td>定期生成数据快照</td><td>记录每个写操作命令</td></tr><tr><td>文件大小</td><td>紧凑，文件小</td><td>较大，包含所有操作</td></tr><tr><td>恢复速度</td><td>快</td><td>慢</td></tr><tr><td>数据完整性</td><td>可能丢失最后一次快照后的数据</td><td>根据同步策略，丢失较少</td></tr><tr><td>性能影响</td><td>fork子进程时有短暂阻塞</td><td>持续写入，影响相对较小</td></tr><tr><td>适用场景</td><td>对数据丢失不敏感的场景</td><td>对数据完整性要求高的场景</td></tr></tbody></table><p><strong>选择策略：</strong></p><table><thead><tr><th>场景</th><th>推荐方案</th><th>原因</th></tr></thead><tbody><tr><td>缓存场景</td><td>仅RDB</td><td>数据可重新计算，性能优先</td></tr><tr><td>重要数据存储</td><td>RDB + AOF</td><td>双重保障，确保数据安全</td></tr><tr><td>高写入量场景</td><td>仅RDB</td><td>避免AOF写入影响性能</td></tr><tr><td>数据完整性要求极高的场景</td><td>AOF</td><td>最大程度保证数据不丢失</td></tr></tbody></table><h3 id="内存管理" tabindex="-1"><a class="header-anchor" href="#内存管理"><span>内存管理</span></a></h3><h4 id="_4-redis的过期键删除策略" tabindex="-1"><a class="header-anchor" href="#_4-redis的过期键删除策略"><span>4. Redis的过期键删除策略？</span></a></h4><p><strong>三种删除策略：</strong></p><table><thead><tr><th>策略</th><th>触发时机</th><th>优点</th><th>缺点</th><th>CPU消耗</th><th>内存消耗</th></tr></thead><tbody><tr><td>定时删除</td><td>设置定时器</td><td>内存友好</td><td>CPU消耗大</td><td>高</td><td>低</td></tr><tr><td>惰性删除</td><td>访问时检查</td><td>CPU友好</td><td>内存不友好</td><td>低</td><td>高</td></tr><tr><td>定期删除</td><td>定期随机抽查</td><td>平衡CPU和内存</td><td>可能有漏网之鱼</td><td>中</td><td>中</td></tr></tbody></table><p><strong>Redis实际策略：</strong> 惰性删除 + 定期删除的组合方式</p><h4 id="_5-内存淘汰策略" tabindex="-1"><a class="header-anchor" href="#_5-内存淘汰策略"><span>5. 内存淘汰策略？</span></a></h4><p><strong>8种淘汰策略：</strong></p><table><thead><tr><th>策略</th><th>作用范围</th><th>淘汰算法</th><th>适用场景</th></tr></thead><tbody><tr><td>noeviction</td><td>无</td><td>不淘汰</td><td>内存足够，不希望数据丢失</td></tr><tr><td>allkeys-lru</td><td>所有key</td><td>LRU最近最少使用</td><td>通用缓存，访问有热点</td></tr><tr><td>volatile-lru</td><td>有过期时间的key</td><td>LRU</td><td>只淘汰临时数据</td></tr><tr><td>allkeys-random</td><td>所有key</td><td>随机</td><td>访问模式均匀</td></tr><tr><td>volatile-random</td><td>有过期时间的key</td><td>随机</td><td>临时数据访问均匀</td></tr><tr><td>volatile-ttl</td><td>有过期时间的key</td><td>TTL最短优先</td><td>希望快到期的数据先删除</td></tr><tr><td>allkeys-lfu</td><td>所有key</td><td>LFU最少使用频率</td><td>访问频率差异明显</td></tr><tr><td>volatile-lfu</td><td>有过期时间的key</td><td>LFU</td><td>临时数据访问频率差异明显</td></tr></tbody></table><p><strong>推荐选择：</strong></p><ul><li><strong>通用场景</strong>：allkeys-lru（最常用）</li><li><strong>只缓存场景</strong>：volatile-lru</li><li><strong>混合数据</strong>：volatile-ttl</li></ul><h3 id="高可用架构" tabindex="-1"><a class="header-anchor" href="#高可用架构"><span>高可用架构</span></a></h3><h4 id="_6-如何保证redis的高可用-redis-cluster的槽分配原理" tabindex="-1"><a class="header-anchor" href="#_6-如何保证redis的高可用-redis-cluster的槽分配原理"><span>6. 如何保证Redis的高可用？Redis Cluster的槽分配原理？</span></a></h4><p><strong>高可用方案：</strong></p><table><thead><tr><th>方案</th><th>特点</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>主从复制</td><td>一主多从，读写分离</td><td>简单，读性能好</td><td>主节点单点故障</td><td>读多写少</td></tr><tr><td>哨兵模式</td><td>自动故障转移</td><td>高可用，自动切换</td><td>配置复杂</td><td>中小型应用</td></tr><tr><td>Redis Cluster</td><td>分布式，无中心节点</td><td>高可用+高性能</td><td>运维复杂</td><td>大型分布式应用</td></tr></tbody></table><p><strong>Redis Cluster槽分配：</strong></p><ul><li><strong>总槽数</strong>：16384个槽（0-16383）</li><li><strong>分配原理</strong>：CRC16(key) % 16384</li><li><strong>槽分布</strong>：平均分配到各个主节点</li><li><strong>数据分片</strong>：根据key计算槽位，找到对应节点</li></ul><table><thead><tr><th>集群规模</th><th>节点配置</th><th>槽分配示例</th></tr></thead><tbody><tr><td>3主3从</td><td>每主1从</td><td>0-5460, 5461-10922, 10923-16383</td></tr><tr><td>6主6从</td><td>每主1从</td><td>每个主节点约2730个槽</td></tr><tr><td>9主9从</td><td>每主1从</td><td>每个主节点约1820个槽</td></tr></tbody></table><h3 id="缓存问题" tabindex="-1"><a class="header-anchor" href="#缓存问题"><span>缓存问题</span></a></h3><h4 id="_7-缓存穿透、缓存击穿、缓存雪崩的概念、原因及解决方案" tabindex="-1"><a class="header-anchor" href="#_7-缓存穿透、缓存击穿、缓存雪崩的概念、原因及解决方案"><span>7. 缓存穿透、缓存击穿、缓存雪崩的概念、原因及解决方案？</span></a></h4><p><strong>三大缓存问题对比：</strong></p><table><thead><tr><th>问题类型</th><th>定义</th><th>原因分析</th><th>解决方案</th></tr></thead><tbody><tr><td>缓存穿透</td><td>查询不存在的数据，缓存和数据库都没有</td><td>恶意攻击、业务逻辑错误</td><td>布隆过滤器、空值缓存、参数校验</td></tr><tr><td>缓存击穿</td><td>热点数据过期，大量请求同时访问数据库</td><td>热点key过期</td><td>互斥锁、热点数据永不过期、提前更新</td></tr><tr><td>缓存雪崩</td><td>大量缓存同时过期，数据库压力剧增</td><td>缓存集中过期、Redis宕机</td><td>过期时间随机化、熔断降级、多级缓存、集群部署</td></tr></tbody></table><p><strong>详细解决方案：</strong></p><table><thead><tr><th>解决方案</th><th>实现方式</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>布隆过滤器</td><td>位数组+多个hash函数</td><td>内存占用小，查询快</td><td>存在误判，不支持删除</td></tr><tr><td>空值缓存</td><td>对空结果设置较短过期时间</td><td>简单有效</td><td>占用内存</td></tr><tr><td>互斥锁</td><td>只允许一个线程查询数据库</td><td>避免重复查询</td><td>可能造成阻塞</td></tr><tr><td>熔断降级</td><td>失败率超过阈值时停止访问</td><td>保护系统</td><td>可能影响用户体验</td></tr></tbody></table><h3 id="分布式锁" tabindex="-1"><a class="header-anchor" href="#分布式锁"><span>分布式锁</span></a></h3><h4 id="_8-如何设计一个分布式锁-watch-dog机制" tabindex="-1"><a class="header-anchor" href="#_8-如何设计一个分布式锁-watch-dog机制"><span>8. 如何设计一个分布式锁？Watch Dog机制？</span></a></h4><p><strong>分布式锁实现要点：</strong></p><table><thead><tr><th>要求</th><th>Redis实现方式</th><th>说明</th></tr></thead><tbody><tr><td>互斥性</td><td>SET key value NX EX</td><td>NX确保原子性设置</td></tr><tr><td>防死锁</td><td>设置过期时间</td><td>避免持锁进程崩溃导致死锁</td></tr><tr><td>防误删</td><td>删除时校验value</td><td>确保只能删除自己的锁</td></tr><tr><td>可重入</td><td>记录线程ID和重入次数</td><td>支持同一线程多次获取锁</td></tr><tr><td>阻塞等待</td><td>循环尝试获取锁</td><td>获取失败时等待重试</td></tr></tbody></table><p><strong>Watch Dog机制：</strong></p><table><thead><tr><th>特性</th><th>实现原理</th><th>作用</th></tr></thead><tbody><tr><td>自动续期</td><td>定时任务延长锁过期时间</td><td>防止业务执行时间超过锁过期时间</td></tr><tr><td>续期条件</td><td>锁仍被当前线程持有</td><td>避免给其他线程的锁续期</td></tr><tr><td>续期时间</td><td>通常为锁过期时间的1/3</td><td>保证在锁过期前完成续期</td></tr><tr><td>停止条件</td><td>锁被释放或线程结束</td><td>避免无限续期</td></tr></tbody></table><p><strong>完整分布式锁方案：</strong></p><div class="language-lua line-numbers-mode" data-highlighter="shiki" data-ext="lua" data-title="lua" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 加锁Lua脚本</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">if</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> redis</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">call</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;set&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">KEYS</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">], </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">ARGV</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">], </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;nx&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;ex&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">ARGV</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">]) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">then</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">else</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">end</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 解锁Lua脚本  </span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">if</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> redis</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">call</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;get&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">KEYS</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">]) == </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">ARGV</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">] </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">then</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> redis</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">call</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;del&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">KEYS</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">])</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">else</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">end</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>方案对比：</strong></p><table><thead><tr><th>实现方案</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>单Redis节点</td><td>简单，性能好</td><td>单点故障</td><td>对可用性要求不高</td></tr><tr><td>Redis集群</td><td>高可用</td><td>脑裂时可能出现多个锁</td><td>一般业务场景</td></tr><tr><td>Redlock算法</td><td>更高的安全性</td><td>复杂，性能较差</td><td>对数据一致性要求极高</td></tr><tr><td>ZooKeeper</td><td>强一致性，自动续期</td><td>性能较差，依赖ZK集群</td><td>强一致性要求</td></tr></tbody></table><h2 id="分布式" tabindex="-1"><a class="header-anchor" href="#分布式"><span>分布式</span></a></h2><h3 id="理论基础" tabindex="-1"><a class="header-anchor" href="#理论基础"><span>理论基础</span></a></h3><h4 id="_1-cap理论-base理论" tabindex="-1"><a class="header-anchor" href="#_1-cap理论-base理论"><span>1. CAP理论？BASE理论？</span></a></h4><p><strong>CAP理论（布鲁尔定理）：</strong> 分布式系统不可能同时满足一致性（Consistency）、可用性（Availability）、分区容错性（Partition tolerance）三个特性。</p><table><thead><tr><th>特性</th><th>定义</th><th>说明</th></tr></thead><tbody><tr><td>一致性（C）</td><td>所有节点同时看到相同的数据</td><td>数据在所有节点保持同步</td></tr><tr><td>可用性（A）</td><td>系统持续可用，快速响应</td><td>系统不会因为部分节点故障而停止服务</td></tr><tr><td>分区容错性（P）</td><td>系统在网络分区故障时仍能继续运行</td><td>网络故障不会导致整个系统不可用</td></tr></tbody></table><p><strong>CAP组合选择：</strong></p><table><thead><tr><th>组合</th><th>特点</th><th>典型应用</th><th>使用场景</th></tr></thead><tbody><tr><td>CA</td><td>一致性+可用性</td><td>传统关系型数据库</td><td>单机或局域网环境</td></tr><tr><td>CP</td><td>一致性+分区容错性</td><td>MongoDB、Redis</td><td>数据一致性要求高</td></tr><tr><td>AP</td><td>可用性+分区容错性</td><td>DNS、CDN</td><td>高可用性要求，允许数据延迟</td></tr></tbody></table><p><strong>BASE理论：</strong> 作为CAP理论的延伸，提供了一种在分布式系统中实现高可用的方式。</p><table><thead><tr><th>特性</th><th>全称</th><th>含义</th></tr></thead><tbody><tr><td>基本可用（BA）</td><td>Basically Available</td><td>系统基本可用，允许损失部分功能</td></tr><tr><td>软状态（S）</td><td>Soft State</td><td>允许系统中数据存在中间状态</td></tr><tr><td>最终一致性（E）</td><td>Eventually Consistent</td><td>系统中数据最终达到一致状态</td></tr></tbody></table><h3 id="分布式事务" tabindex="-1"><a class="header-anchor" href="#分布式事务"><span>分布式事务</span></a></h3><h4 id="_2-分布式事务的解决方案" tabindex="-1"><a class="header-anchor" href="#_2-分布式事务的解决方案"><span>2. 分布式事务的解决方案？</span></a></h4><p><strong>分布式事务挑战：</strong> 跨多个服务或数据库的事务操作，需要保证ACID特性。</p><p><strong>解决方案对比：</strong></p><table><thead><tr><th>方案</th><th>实现原理</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>2PC</td><td>两阶段提交</td><td>强一致性</td><td>阻塞、单点故障</td><td>强一致性要求</td></tr><tr><td>3PC</td><td>三阶段提交</td><td>减少阻塞时间</td><td>复杂度高、网络分区问题</td><td>对2PC的改进</td></tr><tr><td>TCC</td><td>Try-Confirm-Cancel</td><td>业务无侵入</td><td>实现复杂、补偿逻辑</td><td>业务逻辑相对简单</td></tr><tr><td>Saga</td><td>长事务拆分+补偿</td><td>高性能、最终一致性</td><td>补偿逻辑复杂</td><td>长流程业务</td></tr><tr><td>消息事务</td><td>消息队列保证最终一致性</td><td>异步高性能</td><td>最终一致性、消息重复</td><td>异步处理场景</td></tr><tr><td>最大努力通知</td><td>定期重试+人工介入</td><td>简单易实现</td><td>可能不一致</td><td>对一致性要求不严格</td></tr></tbody></table><p><strong>详细方案分析：</strong></p><table><thead><tr><th>方案特点</th><th>2PC</th><th>TCC</th><th>Saga</th></tr></thead><tbody><tr><td>一致性</td><td>强一致性</td><td>最终一致性</td><td>最终一致性</td></tr><tr><td>性能</td><td>较差</td><td>好</td><td>好</td></tr><tr><td>复杂度</td><td>简单</td><td>中等</td><td>复杂</td></tr><tr><td>业务侵入性</td><td>无</td><td>中等</td><td>高</td></tr><tr><td>故障恢复</td><td>困难</td><td>相对容易</td><td>容易</td></tr></tbody></table><h3 id="分布式锁-1" tabindex="-1"><a class="header-anchor" href="#分布式锁-1"><span>分布式锁</span></a></h3><h4 id="_3-分布式锁的实现" tabindex="-1"><a class="header-anchor" href="#_3-分布式锁的实现"><span>3. 分布式锁的实现？</span></a></h4><p><strong>实现方案对比：</strong></p><table><thead><tr><th>实现方案</th><th>原理</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>数据库锁</td><td>基于数据库唯一索引</td><td>简单易理解</td><td>性能差、单点故障</td><td>简单场景</td></tr><tr><td>Redis分布式锁</td><td>SET NX EX命令</td><td>性能好、支持过期</td><td>可能出现锁丢失</td><td>一般业务场景</td></tr><tr><td>ZooKeeper临时节点</td><td>临时有序节点</td><td>强一致性、自动释放</td><td>性能相对较差</td><td>强一致性要求</td></tr><tr><td>Etcd</td><td>基于Raft算法的分布式锁</td><td>强一致性、高可用</td><td>依赖额外组件</td><td>微服务架构</td></tr></tbody></table><p><strong>各方案详细对比：</strong></p><table><thead><tr><th>对比维度</th><th>Redis</th><th>ZooKeeper</th><th>数据库</th><th>Etcd</th></tr></thead><tbody><tr><td>性能</td><td>高</td><td>中</td><td>低</td><td>中</td></tr><tr><td>可靠性</td><td>中</td><td>高</td><td>中</td><td>高</td></tr><tr><td>复杂度</td><td>低</td><td>中</td><td>低</td><td>中</td></tr><tr><td>运维成本</td><td>低</td><td>中</td><td>低</td><td>中</td></tr><tr><td>社区支持</td><td>好</td><td>好</td><td>好</td><td>好</td></tr></tbody></table><h3 id="分布式id生成" tabindex="-1"><a class="header-anchor" href="#分布式id生成"><span>分布式ID生成</span></a></h3><h4 id="_4-分布式id生成方案" tabindex="-1"><a class="header-anchor" href="#_4-分布式id生成方案"><span>4. 分布式ID生成方案？</span></a></h4><p><strong>ID生成方案对比：</strong></p><table><thead><tr><th>方案</th><th>实现原理</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>UUID</td><td>随机生成128位标识符</td><td>简单、本地生成</td><td>无序、占用空间大</td><td>对顺序无要求的场景</td></tr><tr><td>数据库自增ID</td><td>数据库AUTO_INCREMENT</td><td>简单、有序</td><td>性能瓶颈、单点故障</td><td>单机应用</td></tr><tr><td>号段模式</td><td>批量获取ID段</td><td>高性能、减少数据库访问</td><td>浪费ID、重启丢失</td><td>高并发场景</td></tr><tr><td>雪花算法</td><td>时间戳+机器ID+序列号</td><td>有序、高性能、分布式</td><td>时钟回拨问题</td><td>分布式高并发</td></tr><tr><td>美团Leaf</td><td>号段模式+雪花算法优化</td><td>高可用、性能好</td><td>复杂度较高</td><td>大规模分布式系统</td></tr><tr><td>百度UidGenerator</td><td>雪花算法优化</td><td>解决时钟回拨、高性能</td><td>依赖机器时间</td><td>对顺序性要求高的场景</td></tr></tbody></table><p><strong>雪花算法详解：</strong></p><table><thead><tr><th>组成部分</th><th>位数</th><th>说明</th><th>取值范围</th></tr></thead><tbody><tr><td>符号位</td><td>1位</td><td>固定为0</td><td>0</td></tr><tr><td>时间戳</td><td>41位</td><td>相对于某个起始时间的毫秒数</td><td>69年</td></tr><tr><td>机器ID</td><td>10位</td><td>数据中心ID(5位)+机器ID(5位)</td><td>1024台机器</td></tr><tr><td>序列号</td><td>12位</td><td>毫秒内的序列号</td><td>4096个序列号</td></tr></tbody></table><p><strong>方案选择建议：</strong></p><table><thead><tr><th>场景需求</th><th>推荐方案</th><th>原因</th></tr></thead><tbody><tr><td>对性能要求不高</td><td>UUID</td><td>实现简单</td></tr><tr><td>需要有序ID</td><td>雪花算法</td><td>趋势递增、性能好</td></tr><tr><td>超高并发</td><td>号段模式</td><td>批量获取、减少竞争</td></tr><tr><td>对可用性要求极高</td><td>美团Leaf/百度UidGenerator</td><td>双buffer、解决时钟回拨问题</td></tr></tbody></table><h3 id="负载均衡" tabindex="-1"><a class="header-anchor" href="#负载均衡"><span>负载均衡</span></a></h3><h4 id="_5-负载均衡算法" tabindex="-1"><a class="header-anchor" href="#_5-负载均衡算法"><span>5. 负载均衡算法？</span></a></h4><p><strong>负载均衡算法对比：</strong></p><table><thead><tr><th>算法</th><th>实现原理</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>轮询</td><td>依次分配请求到每个服务器</td><td>简单、分布均匀</td><td>不考虑服务器性能差异</td><td>服务器性能相近</td></tr><tr><td>加权轮询</td><td>根据权重分配请求</td><td>考虑服务器性能差异</td><td>静态权重、不能动态调整</td><td>服务器性能差异已知</td></tr><tr><td>最少连接</td><td>分配到连接数最少的服务器</td><td>考虑服务器当前负载</td><td>需要维护连接数统计</td><td>长连接场景</td></tr><tr><td>加权最少连接</td><td>结合权重和连接数</td><td>综合考虑性能和负载</td><td>计算复杂度高</td><td>复杂负载场景</td></tr><tr><td>随机</td><td>随机选择服务器</td><td>实现简单</td><td>可能分布不均匀</td><td>服务器数量多</td></tr><tr><td>加权随机</td><td>根据权重随机选择</td><td>简单、考虑性能差异</td><td>短期可能不均匀</td><td>一般业务场景</td></tr><tr><td>IP Hash</td><td>根据客户端IP哈希选择</td><td>相同IP访问同一服务器</td><td>可能负载不均</td><td>需要会话保持</td></tr><tr><td>最短响应时间</td><td>选择响应时间最短的服务器</td><td>考虑服务器实际性能</td><td>需要监控响应时间</td><td>对延迟敏感的应用</td></tr></tbody></table><p><strong>算法适用场景详解：</strong></p><table><thead><tr><th>业务特点</th><th>推荐算法</th><th>原因</th></tr></thead><tbody><tr><td>无状态服务</td><td>轮询/随机</td><td>简单高效，分布均匀</td></tr><tr><td>有状态服务</td><td>IP Hash</td><td>保证同一用户访问同一服务器</td></tr><tr><td>服务器性能差异大</td><td>加权轮询/加权随机</td><td>根据性能分配不同权重</td></tr><tr><td>长连接场景</td><td>最少连接</td><td>避免连接过度集中</td></tr><tr><td>对延迟敏感</td><td>最短响应时间</td><td>选择响应最快的服务器</td></tr><tr><td>高并发场景</td><td>一致性哈希</td><td>避免服务器变化时大量请求重新分配</td></tr></tbody></table><p><strong>实现层级对比：</strong></p><table><thead><tr><th>实现层级</th><th>特点</th><th>代表产品</th><th>优势</th><th>劣势</th></tr></thead><tbody><tr><td>4层负载均衡</td><td>基于IP和端口进行负载均衡</td><td>LVS、F5</td><td>性能高、透明</td><td>功能相对简单</td></tr><tr><td>7层负载均衡</td><td>基于应用层内容进行负载均衡</td><td>Nginx、HAProxy</td><td>功能丰富、灵活</td><td>性能相对较低</td></tr><tr><td>DNS负载均衡</td><td>通过DNS解析实现负载均衡</td><td>云解析</td><td>简单、分布式</td><td>精度不高、缓存问题</td></tr></tbody></table><h2 id="微服务" tabindex="-1"><a class="header-anchor" href="#微服务"><span>微服务</span></a></h2><h3 id="架构特性" tabindex="-1"><a class="header-anchor" href="#架构特性"><span>架构特性</span></a></h3><h4 id="_1-微服务的优势和挑战" tabindex="-1"><a class="header-anchor" href="#_1-微服务的优势和挑战"><span>1. 微服务的优势和挑战？</span></a></h4><p><strong>微服务定义：</strong> 将单一应用程序拆分为一组小型服务，每个服务运行在独立进程中，通过轻量级通信机制协作。</p><p><strong>优势 vs 挑战对比：</strong></p><table><thead><tr><th>维度</th><th>优势</th><th>挑战</th></tr></thead><tbody><tr><td>开发维护</td><td>代码库小、团队独立开发、技术栈灵活</td><td>服务间协调复杂、版本管理困难</td></tr><tr><td>部署运维</td><td>独立部署、故障隔离、弹性伸缩</td><td>运维复杂度高、监控困难</td></tr><tr><td>性能扩展</td><td>按需扩展、资源利用率高</td><td>网络延迟、分布式事务复杂</td></tr><tr><td>团队协作</td><td>团队自治、并行开发</td><td>服务边界划分难、团队沟通成本高</td></tr><tr><td>系统稳定性</td><td>单点故障影响范围小</td><td>服务间依赖复杂、调试困难</td></tr></tbody></table><p><strong>适用场景判断：</strong></p><table><thead><tr><th>项目特征</th><th>单体架构</th><th>微服务架构</th><th>推荐理由</th></tr></thead><tbody><tr><td>团队规模</td><td>&lt; 10人</td><td>&gt; 10人</td><td>微服务需要足够的团队支撑</td></tr><tr><td>业务复杂度</td><td>简单</td><td>复杂</td><td>复杂业务适合拆分独立维护</td></tr><tr><td>技术栈要求</td><td>统一</td><td>多样化</td><td>微服务支持不同技术栈</td></tr><tr><td>部署频率</td><td>低</td><td>高</td><td>微服务支持独立快速部署</td></tr><tr><td>扩展性要求</td><td>一般</td><td>高</td><td>微服务支持按需精确扩展</td></tr></tbody></table><h3 id="服务发现" tabindex="-1"><a class="header-anchor" href="#服务发现"><span>服务发现</span></a></h3><h4 id="_2-服务注册与发现-原理-常用组件-比较" tabindex="-1"><a class="header-anchor" href="#_2-服务注册与发现-原理-常用组件-比较"><span>2. 服务注册与发现：原理？常用组件？比较？</span></a></h4><p><strong>服务发现原理：</strong> 解决微服务环境下服务实例动态变化时的相互发现和调用问题。</p><p><strong>实现模式对比：</strong></p><table><thead><tr><th>模式</th><th>原理</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>客户端发现</td><td>客户端查询注册中心获取服务实例列表</td><td>性能好、负载均衡灵活</td><td>客户端逻辑复杂、语言绑定</td><td>性能要求高</td></tr><tr><td>服务端发现</td><td>通过负载均衡器代理访问服务</td><td>客户端简单、语言无关</td><td>负载均衡器成为瓶颈</td><td>多语言环境</td></tr><tr><td>服务网格</td><td>基础设施层处理服务通信</td><td>业务无感知、功能丰富</td><td>架构复杂、性能开销</td><td>大规模微服务</td></tr></tbody></table><p><strong>主流组件对比：</strong></p><table><thead><tr><th>组件</th><th>类型</th><th>一致性算法</th><th>多数据中心</th><th>健康检查</th><th>负载均衡</th><th>适用场景</th></tr></thead><tbody><tr><td>Eureka</td><td>AP</td><td>无</td><td>支持</td><td>支持</td><td>客户端</td><td>Spring Cloud</td></tr><tr><td>Consul</td><td>CP</td><td>Raft</td><td>支持</td><td>支持</td><td>支持</td><td>多语言环境</td></tr><tr><td>Zookeeper</td><td>CP</td><td>ZAB</td><td>支持</td><td>支持</td><td>不支持</td><td>Dubbo生态</td></tr><tr><td>Nacos</td><td>AP/CP</td><td>Raft</td><td>支持</td><td>支持</td><td>支持</td><td>阿里云生态</td></tr><tr><td>Etcd</td><td>CP</td><td>Raft</td><td>支持</td><td>支持</td><td>不支持</td><td>Kubernetes</td></tr></tbody></table><h3 id="服务调用" tabindex="-1"><a class="header-anchor" href="#服务调用"><span>服务调用</span></a></h3><h4 id="_3-服务调用-restful-api-和-rpc-dubbo-grpc-比较" tabindex="-1"><a class="header-anchor" href="#_3-服务调用-restful-api-和-rpc-dubbo-grpc-比较"><span>3. 服务调用：RESTful API 和 RPC (Dubbo, gRPC)？比较？</span></a></h4><p><strong>调用方式对比：</strong></p><table><thead><tr><th>特性</th><th>RESTful API</th><th>RPC (Dubbo)</th><th>RPC (gRPC)</th></tr></thead><tbody><tr><td>协议</td><td>HTTP/HTTPS</td><td>TCP/HTTP</td><td>HTTP/2</td></tr><tr><td>序列化</td><td>JSON/XML</td><td>Hessian/Kryo</td><td>Protocol Buffers</td></tr><tr><td>性能</td><td>中等</td><td>高</td><td>高</td></tr><tr><td>跨语言支持</td><td>优秀</td><td>Java生态</td><td>优秀</td></tr><tr><td>学习成本</td><td>低</td><td>中等</td><td>中等</td></tr><tr><td>生态完整性</td><td>丰富</td><td>Java生态丰富</td><td>快速发展中</td></tr><tr><td>适用场景</td><td>Web服务、对外API</td><td>Java微服务</td><td>多语言微服务</td></tr></tbody></table><p><strong>技术选型建议：</strong></p><table><thead><tr><th>场景需求</th><th>推荐方案</th><th>原因</th></tr></thead><tbody><tr><td>对外开放API</td><td>RESTful API</td><td>标准化、易于集成</td></tr><tr><td>内部服务高性能调用</td><td>Dubbo/gRPC</td><td>性能好、功能丰富</td></tr><tr><td>多语言团队</td><td>gRPC</td><td>跨语言支持好</td></tr><tr><td>Spring Boot项目</td><td>RESTful API</td><td>生态集成度高</td></tr><tr><td>大数据量传输</td><td>gRPC</td><td>二进制序列化、HTTP/2协议</td></tr><tr><td>快速原型开发</td><td>RESTful API</td><td>开发简单、调试方便</td></tr></tbody></table><h3 id="api网关" tabindex="-1"><a class="header-anchor" href="#api网关"><span>API网关</span></a></h3><h4 id="_4-服务网关-api-gateway-作用-常用组件" tabindex="-1"><a class="header-anchor" href="#_4-服务网关-api-gateway-作用-常用组件"><span>4. 服务网关 (API Gateway)：作用？常用组件？</span></a></h4><p><strong>API网关作用：</strong> 作为所有客户端请求的统一入口，提供路由、认证、限流、监控等功能。</p><p><strong>核心功能对比：</strong></p><table><thead><tr><th>功能类别</th><th>具体功能</th><th>价值</th><th>实现方式</th></tr></thead><tbody><tr><td>请求路由</td><td>动态路由、负载均衡</td><td>请求分发到正确服务</td><td>规则配置、服务发现</td></tr><tr><td>安全认证</td><td>身份验证、权限控制</td><td>统一安全策略</td><td>JWT、OAuth2</td></tr><tr><td>流量控制</td><td>限流、熔断、降级</td><td>保护后端服务</td><td>令牌桶、熔断器</td></tr><tr><td>协议转换</td><td>HTTP/WebSocket等</td><td>协议统一</td><td>协议适配器</td></tr><tr><td>监控运维</td><td>日志、监控、链路追踪</td><td>可观测性</td><td>APM集成</td></tr></tbody></table><p><strong>主流网关对比：</strong></p><table><thead><tr><th>网关</th><th>类型</th><th>性能</th><th>功能丰富度</th><th>生态集成</th><th>学习成本</th><th>适用场景</th></tr></thead><tbody><tr><td>Spring Cloud Gateway</td><td>响应式</td><td>高</td><td>丰富</td><td>Spring</td><td>中等</td><td>Spring Cloud项目</td></tr><tr><td>Zuul</td><td>阻塞式</td><td>中</td><td>基础</td><td>Spring</td><td>低</td><td>简单场景</td></tr><tr><td>Kong</td><td>高性能</td><td>很高</td><td>极丰富</td><td>开放</td><td>高</td><td>企业级应用</td></tr><tr><td>Nginx Plus</td><td>反向代理</td><td>极高</td><td>丰富</td><td>广泛</td><td>中等</td><td>高并发场景</td></tr><tr><td>Envoy</td><td>代理</td><td>高</td><td>丰富</td><td>云原生</td><td>高</td><td>服务网格</td></tr></tbody></table><h3 id="配置中心" tabindex="-1"><a class="header-anchor" href="#配置中心"><span>配置中心</span></a></h3><h4 id="_5-配置中心-作用-常用组件" tabindex="-1"><a class="header-anchor" href="#_5-配置中心-作用-常用组件"><span>5. 配置中心：作用？常用组件？</span></a></h4><p><strong>配置中心价值：</strong> 集中管理微服务配置，支持动态更新，避免重启服务。</p><p><strong>核心能力对比：</strong></p><table><thead><tr><th>能力</th><th>传统配置文件</th><th>配置中心</th><th>提升效果</th></tr></thead><tbody><tr><td>配置管理</td><td>散落在各个服务</td><td>集中统一管理</td><td>管理效率提升90%</td></tr><tr><td>动态更新</td><td>需要重启服务</td><td>实时推送更新</td><td>变更速度提升10倍</td></tr><tr><td>环境隔离</td><td>手动维护多套配置</td><td>自动环境区分</td><td>错误率降低80%</td></tr><tr><td>权限控制</td><td>无权限控制</td><td>细粒度权限管理</td><td>安全性大幅提升</td></tr><tr><td>版本管理</td><td>手动备份</td><td>自动版本控制和回滚</td><td>可靠性提升</td></tr></tbody></table><p><strong>主流配置中心对比：</strong></p><table><thead><tr><th>组件</th><th>数据存储</th><th>动态推送</th><th>多环境</th><th>权限控制</th><th>可视化界面</th><th>生态集成</th></tr></thead><tbody><tr><td>Spring Cloud Config</td><td>Git/SVN</td><td>需结合Bus</td><td>支持</td><td>基础</td><td>基础</td><td>Spring生态</td></tr><tr><td>Apollo</td><td>MySQL</td><td>支持</td><td>支持</td><td>完善</td><td>优秀</td><td>多语言</td></tr><tr><td>Nacos</td><td>内置数据库</td><td>支持</td><td>支持</td><td>支持</td><td>优秀</td><td>阿里云生态</td></tr><tr><td>Consul</td><td>KV存储</td><td>支持</td><td>支持</td><td>支持</td><td>基础</td><td>HashiCorp生态</td></tr></tbody></table><h3 id="服务容错" tabindex="-1"><a class="header-anchor" href="#服务容错"><span>服务容错</span></a></h3><h4 id="_6-服务容错-熔断、降级、限流-令牌桶、漏桶-sentinel和hystrix" tabindex="-1"><a class="header-anchor" href="#_6-服务容错-熔断、降级、限流-令牌桶、漏桶-sentinel和hystrix"><span>6. 服务容错：熔断、降级、限流 (令牌桶、漏桶)，Sentinel和Hystrix？</span></a></h4><p><strong>容错机制对比：</strong></p><table><thead><tr><th>机制</th><th>目的</th><th>触发条件</th><th>恢复机制</th><th>适用场景</th></tr></thead><tbody><tr><td>熔断</td><td>避免连锁故障</td><td>错误率/响应时间超阈值</td><td>半开状态探测</td><td>依赖服务不稳定</td></tr><tr><td>降级</td><td>保证核心功能可用</td><td>系统负载过高</td><td>手动或自动恢复</td><td>非核心功能可牺牲</td></tr><tr><td>限流</td><td>保护系统不被压垮</td><td>请求量超过系统处理能力</td><td>拒绝或排队等待</td><td>高并发场景</td></tr></tbody></table><p><strong>限流算法对比：</strong></p><table><thead><tr><th>算法</th><th>原理</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>令牌桶</td><td>固定速率产生令牌，请求消耗令牌</td><td>允许突发流量</td><td>实现相对复杂</td><td>允许突发的业务场景</td></tr><tr><td>漏桶</td><td>请求以固定速率处理</td><td>流量平滑</td><td>不能处理突发流量</td><td>需要平滑处理的场景</td></tr><tr><td>固定窗口</td><td>固定时间窗口内限制请求数量</td><td>实现简单</td><td>临界问题</td><td>简单限流场景</td></tr><tr><td>滑动窗口</td><td>动态时间窗口统计</td><td>更精确的限流</td><td>内存占用大</td><td>精确限流需求</td></tr></tbody></table><p><strong>Sentinel vs Hystrix：</strong></p><table><thead><tr><th>对比维度</th><th>Sentinel</th><th>Hystrix</th></tr></thead><tbody><tr><td>开发状态</td><td>活跃开发</td><td>停止维护</td></tr><tr><td>性能</td><td>更优</td><td>较好</td></tr><tr><td>功能丰富度</td><td>全面（熔断+限流+降级+系统保护）</td><td>主要专注熔断降级</td></tr><tr><td>控制台</td><td>功能强大的实时监控</td><td>基础监控</td></tr><tr><td>规则配置</td><td>支持多种数据源动态配置</td><td>主要基于注解和配置文件</td></tr><tr><td>生态集成</td><td>Spring Cloud Alibaba</td><td>Spring Cloud Netflix</td></tr><tr><td>学习成本</td><td>中等</td><td>较低</td></tr></tbody></table><h3 id="链路追踪" tabindex="-1"><a class="header-anchor" href="#链路追踪"><span>链路追踪</span></a></h3><h4 id="_7-链路追踪-目的-原理-常用组件-zipkin-skywalking" tabindex="-1"><a class="header-anchor" href="#_7-链路追踪-目的-原理-常用组件-zipkin-skywalking"><span>7. 链路追踪：目的？原理？常用组件 (Zipkin, SkyWalking)？</span></a></h4><p><strong>链路追踪目的：</strong> 在分布式系统中追踪请求的完整调用链路，快速定位性能瓶颈和故障根因。</p><p><strong>核心概念：</strong></p><table><thead><tr><th>概念</th><th>定义</th><th>作用</th></tr></thead><tbody><tr><td>Trace</td><td>一次完整的请求调用链路</td><td>代表一次业务请求的全链路</td></tr><tr><td>Span</td><td>链路中的一个操作单元</td><td>代表一次服务调用或操作</td></tr><tr><td>SpanId</td><td>Span的唯一标识</td><td>标识具体的操作单元</td></tr><tr><td>TraceId</td><td>Trace的唯一标识</td><td>串联整个调用链路</td></tr><tr><td>采样率</td><td>采集链路数据的比例</td><td>平衡性能和可观测性</td></tr></tbody></table><p><strong>实现原理：</strong></p><ol><li><strong>埋点收集</strong>：在应用中插入追踪代码收集调用信息</li><li><strong>传递TraceId</strong>：通过HTTP头或RPC上下文传递追踪标识</li><li><strong>数据上报</strong>：异步上报链路数据到追踪系统</li><li><strong>存储分析</strong>：存储并分析链路数据，提供查询界面</li></ol><p><strong>主流组件对比：</strong></p><table><thead><tr><th>组件</th><th>开发者</th><th>语言支持</th><th>存储支持</th><th>性能开销</th><th>界面友好度</th><th>生态集成</th></tr></thead><tbody><tr><td>Zipkin</td><td>Twitter</td><td>多语言</td><td>多种存储后端</td><td>低</td><td>一般</td><td>广泛</td></tr><tr><td>SkyWalking</td><td>Apache</td><td>Java为主</td><td>ES/H2/MySQL</td><td>低</td><td>优秀</td><td>Java生态</td></tr><tr><td>Jaeger</td><td>Uber</td><td>多语言</td><td>多种存储后端</td><td>低</td><td>良好</td><td>云原生</td></tr><tr><td>Pinpoint</td><td>Naver</td><td>Java</td><td>HBase</td><td>中等</td><td>优秀</td><td>Java专用</td></tr></tbody></table><p><strong>技术选型建议：</strong></p><table><thead><tr><th>场景需求</th><th>推荐方案</th><th>选择理由</th></tr></thead><tbody><tr><td>Java微服务</td><td>SkyWalking</td><td>无侵入、功能全面、界面友好</td></tr><tr><td>多语言环境</td><td>Zipkin/Jaeger</td><td>语言支持广泛</td></tr><tr><td>云原生架构</td><td>Jaeger</td><td>CNCF项目，K8s集成好</td></tr><tr><td>性能敏感应用</td><td>自研或轻量级方案</td><td>减少性能开销</td></tr><tr><td>大数据量场景</td><td>SkyWalking</td><td>支持采样和聚合分析</td></tr><tr><td>快速上手</td><td>Zipkin</td><td>简单易用，社区资源丰富</td></tr></tbody></table><h2 id="消息队列" tabindex="-1"><a class="header-anchor" href="#消息队列"><span>消息队列</span></a></h2><h3 id="基础概念" tabindex="-1"><a class="header-anchor" href="#基础概念"><span>基础概念</span></a></h3><h4 id="_1-消息队列的作用-解耦、异步、削峰填谷" tabindex="-1"><a class="header-anchor" href="#_1-消息队列的作用-解耦、异步、削峰填谷"><span>1. 消息队列的作用？（解耦、异步、削峰填谷）</span></a></h4><p><strong>消息队列定义：</strong> 在分布式系统中用于服务间通信的中间件，实现消息的异步传递和处理。</p><p><strong>三大核心作用：</strong></p><table><thead><tr><th>作用</th><th>定义</th><th>解决问题</th><th>应用场景</th><th>效果评估</th></tr></thead><tbody><tr><td>解耦</td><td>消息发送者和接收者不直接依赖</td><td>系统间强耦合</td><td>订单系统通知库存、支付、物流系统</td><td>耦合度降低80%</td></tr><tr><td>异步</td><td>发送消息后立即返回，不等待处理结果</td><td>同步调用响应时间长</td><td>用户注册后发送邮件、短信</td><td>响应时间减少70%</td></tr><tr><td>削峰填谷</td><td>缓冲高并发请求，平滑处理</td><td>瞬时高并发冲击</td><td>秒杀活动、双11促销</td><td>系统稳定性提升</td></tr></tbody></table><p><strong>使用前后对比：</strong></p><table><thead><tr><th>场景</th><th>不使用消息队列</th><th>使用消息队列</th><th>改善效果</th></tr></thead><tbody><tr><td>订单处理</td><td>同步调用库存、支付、物流，响应时间3秒</td><td>异步通知，响应时间500ms</td><td>响应速度提升6倍</td></tr><tr><td>系统故障</td><td>一个服务故障导致整个链路失败</td><td>服务故障不影响消息发送，具备容错能力</td><td>可用性从95%提升到99.9%</td></tr><tr><td>促销活动</td><td>瞬时流量冲垮系统</td><td>消息队列缓冲，平稳处理</td><td>系统零宕机</td></tr></tbody></table><h4 id="_2-消息模型-点对点queue和发布-订阅topic" tabindex="-1"><a class="header-anchor" href="#_2-消息模型-点对点queue和发布-订阅topic"><span>2. 消息模型？（点对点Queue和发布/订阅Topic）</span></a></h4><p><strong>两种消息模型对比：</strong></p><table><thead><tr><th>特性</th><th>点对点模型（Queue）</th><th>发布/订阅模型（Topic）</th></tr></thead><tbody><tr><td>消息消费</td><td>一条消息只能被一个消费者消费</td><td>一条消息可以被多个消费者消费</td></tr><tr><td>消费者关系</td><td>竞争关系</td><td>独立关系</td></tr><tr><td>消息持久化</td><td>消费后从队列删除</td><td>根据配置决定是否删除</td></tr><tr><td>扩展性</td><td>通过增加消费者实现负载均衡</td><td>通过增加订阅者实现广播</td></tr><tr><td>应用场景</td><td>任务分发、负载均衡</td><td>事件通知、数据同步</td></tr><tr><td>典型例子</td><td>订单处理队列</td><td>用户注册事件广播</td></tr></tbody></table><p><strong>使用场景选择：</strong></p><table><thead><tr><th>业务需求</th><th>推荐模型</th><th>原因</th><th>典型应用</th></tr></thead><tbody><tr><td>任务处理</td><td>Queue</td><td>确保每个任务只被处理一次</td><td>邮件发送、文件处理</td></tr><tr><td>事件广播</td><td>Topic</td><td>多个系统需要响应同一事件</td><td>用户注册、订单状态变更</td></tr><tr><td>负载均衡</td><td>Queue</td><td>多个消费者竞争处理消息</td><td>并发订单处理</td></tr><tr><td>数据同步</td><td>Topic</td><td>多个下游系统需要同步数据</td><td>数据仓库同步、缓存更新</td></tr><tr><td>日志收集</td><td>Topic</td><td>多个监控系统需要收集日志</td><td>ELK日志分析</td></tr></tbody></table><h3 id="消息可靠性" tabindex="-1"><a class="header-anchor" href="#消息可靠性"><span>消息可靠性</span></a></h3><h4 id="_3-如何保证消息不丢失" tabindex="-1"><a class="header-anchor" href="#_3-如何保证消息不丢失"><span>3. 如何保证消息不丢失？</span></a></h4><p><strong>消息丢失的三个阶段：</strong></p><table><thead><tr><th>阶段</th><th>丢失场景</th><th>解决方案</th><th>实现方式</th></tr></thead><tbody><tr><td>生产者阶段</td><td>网络故障、Broker宕机</td><td>生产者确认机制</td><td>同步发送、异步回调确认</td></tr><tr><td>Broker阶段</td><td>消息未持久化到磁盘</td><td>消息持久化</td><td>同步刷盘、主从复制</td></tr><tr><td>消费者阶段</td><td>消费者宕机、处理失败</td><td>手动ACK</td><td>消费成功后再确认</td></tr></tbody></table><p><strong>详细保障机制：</strong></p><table><thead><tr><th>保障机制</th><th>实现原理</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>生产者确认</td><td>Producer等待Broker确认</td><td>确保消息到达Broker</td><td>性能略有下降</td><td>重要业务消息</td></tr><tr><td>同步刷盘</td><td>消息写入磁盘后返回确认</td><td>数据安全性高</td><td>性能影响大</td><td>金融级别可靠性</td></tr><tr><td>异步刷盘</td><td>消息先写入内存，异步写入磁盘</td><td>性能好</td><td>极端情况可能丢失消息</td><td>一般业务场景</td></tr><tr><td>主从复制</td><td>主节点同步消息到从节点</td><td>高可用</td><td>网络开销</td><td>高可用要求</td></tr><tr><td>手动ACK</td><td>消费者处理完业务逻辑后手动确认</td><td>确保消息被正确处理</td><td>需要处理重复消息</td><td>所有重要业务</td></tr></tbody></table><h4 id="_4-如何保证消息不被重复消费-幂等性" tabindex="-1"><a class="header-anchor" href="#_4-如何保证消息不被重复消费-幂等性"><span>4. 如何保证消息不被重复消费（幂等性）？</span></a></h4><p><strong>重复消费产生原因：</strong></p><ul><li>网络抖动导致ACK丢失</li><li>消费者重启导致消息重新投递</li><li>Broker故障恢复后重新发送消息</li></ul><p><strong>幂等性保障方案：</strong></p><table><thead><tr><th>方案</th><th>实现原理</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>唯一ID去重</td><td>每条消息携带唯一标识</td><td>简单有效</td><td>需要存储已处理ID</td><td>通用场景</td></tr><tr><td>数据库唯一约束</td><td>利用数据库唯一索引</td><td>实现简单</td><td>依赖数据库</td><td>数据库操作为主的业务</td></tr><tr><td>Redis去重</td><td>使用Redis存储消息ID</td><td>性能好</td><td>需要额外的Redis实例</td><td>高性能要求</td></tr><tr><td>状态机控制</td><td>通过业务状态判断是否已处理</td><td>业务语义明确</td><td>业务逻辑复杂</td><td>有明确状态的业务流程</td></tr><tr><td>业务逻辑幂等</td><td>设计天然幂等的业务逻辑</td><td>无额外开销</td><td>并非所有业务都能实现</td><td>查询类操作</td></tr></tbody></table><p><strong>实现示例对比：</strong></p><table><thead><tr><th>业务场景</th><th>推荐方案</th><th>实现方式</th><th>注意事项</th></tr></thead><tbody><tr><td>账户扣款</td><td>数据库唯一约束</td><td>订单号作为唯一约束</td><td>避免重复扣款</td></tr><tr><td>发送邮件</td><td>Redis去重</td><td>消息ID作为Redis key</td><td>设置合理的过期时间</td></tr><tr><td>数据同步</td><td>状态机控制</td><td>检查目标数据是否已存在</td><td>处理并发更新问题</td></tr><tr><td>积分增加</td><td>业务逻辑幂等</td><td>使用CAS操作更新积分</td><td>处理ABA问题</td></tr></tbody></table><h4 id="_5-如何保证消息的顺序性" tabindex="-1"><a class="header-anchor" href="#_5-如何保证消息的顺序性"><span>5. 如何保证消息的顺序性？</span></a></h4><p><strong>顺序性需求分析：</strong></p><table><thead><tr><th>顺序性类型</th><th>定义</th><th>实现难度</th><th>性能影响</th><th>适用场景</th></tr></thead><tbody><tr><td>全局有序</td><td>所有消息严格按时间顺序处理</td><td>高</td><td>大</td><td>金融交易、账务流水</td></tr><tr><td>分区有序</td><td>同一分区内消息有序</td><td>中</td><td>小</td><td>同一用户的操作序列</td></tr><tr><td>局部有序</td><td>特定业务场景下的消息有序</td><td>低</td><td>无</td><td>单个订单的状态变更流程</td></tr></tbody></table><p><strong>实现方案对比：</strong></p><table><thead><tr><th>方案</th><th>实现方式</th><th>优点</th><th>缺点</th><th>性能影响</th></tr></thead><tbody><tr><td>单队列单消费者</td><td>只使用一个队列和一个消费者</td><td>严格有序</td><td>性能瓶颈、无法扩展</td><td>性能最差</td></tr><tr><td>分区有序</td><td>相同Key的消息发送到同一分区</td><td>平衡性能与顺序</td><td>分区内有序、全局无序</td><td>性能较好</td></tr><tr><td>消息队列顺序</td><td>业务层面保证同类消息的顺序处理</td><td>业务灵活性高</td><td>实现复杂</td><td>性能影响小</td></tr><tr><td>时间戳排序</td><td>消费者根据时间戳重新排序</td><td>全局有序</td><td>延迟高、内存占用大</td><td>延迟增加</td></tr></tbody></table><p><strong>技术选型建议：</strong></p><table><thead><tr><th>业务场景</th><th>推荐方案</th><th>理由</th><th>实现要点</th></tr></thead><tbody><tr><td>股票交易</td><td>单队列单消费者</td><td>严格时序要求</td><td>可以牺牲性能保证正确性</td></tr><tr><td>用户操作日志</td><td>分区有序</td><td>同一用户操作需要有序</td><td>以用户ID作为分区Key</td></tr><tr><td>订单状态流转</td><td>消息队列顺序</td><td>只需要同一订单内有序</td><td>以订单ID作为分组</td></tr><tr><td>系统日志收集</td><td>无需严格顺序</td><td>日志分析不严格依赖顺序</td><td>优先考虑性能和吞吐量</td></tr></tbody></table><h3 id="技术选型" tabindex="-1"><a class="header-anchor" href="#技术选型"><span>技术选型</span></a></h3><h4 id="_6-常用消息队列比较-kafka、rabbitmq、rocketmq" tabindex="-1"><a class="header-anchor" href="#_6-常用消息队列比较-kafka、rabbitmq、rocketmq"><span>6. 常用消息队列比较？（Kafka、RabbitMQ、RocketMQ）</span></a></h4><p><strong>核心特性对比：</strong></p><table><thead><tr><th>特性</th><th>Kafka</th><th>RabbitMQ</th><th>RocketMQ</th></tr></thead><tbody><tr><td>开发语言</td><td>Scala/Java</td><td>Erlang</td><td>Java</td></tr><tr><td>性能</td><td>极高（百万级/秒）</td><td>高（万级/秒）</td><td>高（十万级/秒）</td></tr><tr><td>可靠性</td><td>高</td><td>极高</td><td>高</td></tr><tr><td>功能丰富度</td><td>基础</td><td>丰富</td><td>丰富</td></tr><tr><td>运维复杂度</td><td>中等</td><td>简单</td><td>中等</td></tr><tr><td>社区活跃度</td><td>极高</td><td>高</td><td>中等</td></tr><tr><td>企业支持</td><td>Apache基金会</td><td>VMware</td><td>阿里巴巴</td></tr></tbody></table><p><strong>详细功能对比：</strong></p><table><thead><tr><th>功能</th><th>Kafka</th><th>RabbitMQ</th><th>RocketMQ</th></tr></thead><tbody><tr><td>消息顺序性</td><td>分区有序</td><td>队列有序</td><td>分区有序</td></tr><tr><td>消息路由</td><td>简单</td><td>灵活强大</td><td>丰富</td></tr><tr><td>消息过滤</td><td>不支持</td><td>支持</td><td>支持</td></tr><tr><td>死信队列</td><td>不支持</td><td>支持</td><td>支持</td></tr><tr><td>延时消息</td><td>不支持</td><td>插件支持</td><td>原生支持</td></tr><tr><td>事务消息</td><td>0.11版本后支持</td><td>支持</td><td>支持</td></tr><tr><td>消息重试</td><td>不支持</td><td>支持</td><td>支持</td></tr><tr><td>集群部署</td><td>原生支持</td><td>支持</td><td>支持</td></tr></tbody></table><p><strong>适用场景推荐：</strong></p><table><thead><tr><th>使用场景</th><th>推荐MQ</th><th>选择理由</th><th>注意事项</th></tr></thead><tbody><tr><td>日志收集、大数据处理</td><td>Kafka</td><td>超高吞吐量、水平扩展能力强</td><td>功能相对简单，需要自己实现一些特性</td></tr><tr><td>企业级应用、复杂路由</td><td>RabbitMQ</td><td>功能丰富、可靠性高、运维简单</td><td>性能相对较低</td></tr><tr><td>电商、金融等业务系统</td><td>RocketMQ</td><td>功能全面、性能好、专门为业务场景设计</td><td>社区相对较小</td></tr><tr><td>微服务间通信</td><td>RabbitMQ</td><td>消息路由灵活、支持多种协议</td><td>需要考虑消息积压问题</td></tr><tr><td>实时数据流处理</td><td>Kafka</td><td>低延迟、高吞吐、与大数据生态集成好</td><td>不适合复杂的业务逻辑处理</td></tr><tr><td>订单处理、支付系统</td><td>RocketMQ</td><td>事务消息、顺序消息、高可靠性</td><td>运维复杂度相对较高</td></tr></tbody></table><p><strong>技术选型决策矩阵：</strong></p><table><thead><tr><th>权重因子</th><th>Kafka</th><th>RabbitMQ</th><th>RocketMQ</th><th>说明</th></tr></thead><tbody><tr><td>性能要求（30%）</td><td>10</td><td>7</td><td>8</td><td>Kafka性能最强</td></tr><tr><td>功能丰富度（25%）</td><td>6</td><td>9</td><td>9</td><td>RabbitMQ功能最全</td></tr><tr><td>可靠性（20%）</td><td>8</td><td>10</td><td>9</td><td>RabbitMQ可靠性最佳</td></tr><tr><td>运维难度（15%）</td><td>7</td><td>9</td><td>7</td><td>RabbitMQ最易运维</td></tr><tr><td>社区支持（10%）</td><td>10</td><td>8</td><td>6</td><td>Kafka社区最活跃</td></tr><tr><td><strong>总分</strong></td><td><strong>8.1</strong></td><td><strong>8.6</strong></td><td><strong>8.0</strong></td><td>RabbitMQ综合评分最高</td></tr></tbody></table><h2 id="主流框架、系统设计、编码能力" tabindex="-1"><a class="header-anchor" href="#主流框架、系统设计、编码能力"><span>主流框架、系统设计、编码能力</span></a></h2><h3 id="spring框架" tabindex="-1"><a class="header-anchor" href="#spring框架"><span>Spring框架</span></a></h3><h4 id="_1-spring方向-ioc-控制反转-di-依赖注入-aop-面向切面编程" tabindex="-1"><a class="header-anchor" href="#_1-spring方向-ioc-控制反转-di-依赖注入-aop-面向切面编程"><span>1. Spring方向 - (IoC - 控制反转 / DI - 依赖注入, AOP - 面向切面编程)</span></a></h4><p><strong>IoC（控制反转）核心概念：</strong></p><table><thead><tr><th>概念</th><th>定义</th><th>传统方式</th><th>IoC方式</th><th>优势</th></tr></thead><tbody><tr><td>控制反转</td><td>对象创建控制权从程序代码转移到外部容器</td><td>程序主动创建依赖对象</td><td>容器创建并注入对象</td><td>降低耦合度、提高可测试性</td></tr><tr><td>依赖注入</td><td>容器负责将依赖的对象注入到需要的地方</td><td>new 关键字创建对象</td><td>@Autowired等注解注入</td><td>自动装配、配置灵活</td></tr><tr><td>容器管理</td><td>Spring容器负责对象的生命周期管理</td><td>手动管理对象生命周期</td><td>容器自动管理</td><td>减少内存泄漏、提高性能</td></tr></tbody></table><p><strong>DI依赖注入方式对比：</strong></p><table><thead><tr><th>注入方式</th><th>实现方式</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>构造器注入</td><td>通过构造函数参数注入</td><td>强制依赖、不可变对象</td><td>构造函数参数可能过多</td><td>必需依赖</td></tr><tr><td>Setter注入</td><td>通过setter方法注入</td><td>可选依赖、灵活配置</td><td>可能忘记注入某些依赖</td><td>可选依赖</td></tr><tr><td>字段注入</td><td>直接在字段上使用@Autowired</td><td>代码简洁</td><td>难以测试、违反封装性</td><td>快速开发</td></tr></tbody></table><h4 id="_2-aop-面向切面编程" tabindex="-1"><a class="header-anchor" href="#_2-aop-面向切面编程"><span>2. AOP (面向切面编程)</span></a></h4><p><strong>AOP核心概念：</strong></p><table><thead><tr><th>概念</th><th>定义</th><th>作用</th><th>示例</th></tr></thead><tbody><tr><td>切面(Aspect)</td><td>横切关注点的模块化</td><td>封装横切逻辑</td><td>日志切面、事务切面</td></tr><tr><td>连接点(JoinPoint)</td><td>程序执行过程中能够插入切面的点</td><td>定义切入位置</td><td>方法调用、异常抛出</td></tr><tr><td>切入点(Pointcut)</td><td>匹配连接点的表达式</td><td>定义在哪些地方切入</td><td>execution(* com.<em>.</em>(..))</td></tr><tr><td>通知(Advice)</td><td>在切入点执行的代码</td><td>定义切入后做什么</td><td>@Before、@After</td></tr><tr><td>织入(Weaving)</td><td>将切面应用到目标对象的过程</td><td>实现AOP功能</td><td>编译时、类加载时、运行时</td></tr></tbody></table><p><strong>Spring AOP实现方式：</strong></p><table><thead><tr><th>实现方式</th><th>原理</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>JDK动态代理</td><td>基于接口的代理</td><td>标准JDK实现</td><td>只能代理接口</td><td>有接口的类</td></tr><tr><td>CGLIB代理</td><td>基于继承的代理</td><td>可以代理普通类</td><td>不能代理final类和方法</td><td>没有接口的类</td></tr><tr><td>AspectJ</td><td>编译时织入</td><td>性能好、功能强</td><td>需要特殊编译器</td><td>高性能要求</td></tr></tbody></table><p><strong>常用通知类型：</strong></p><table><thead><tr><th>通知类型</th><th>执行时机</th><th>使用场景</th><th>示例代码</th></tr></thead><tbody><tr><td>@Before</td><td>方法执行前</td><td>参数校验、权限检查</td><td>记录方法调用参数</td></tr><tr><td>@After</td><td>方法执行后</td><td>资源清理、日志记录</td><td>记录方法执行时间</td></tr><tr><td>@AfterReturning</td><td>方法正常返回后</td><td>结果处理、成功日志</td><td>记录方法返回值</td></tr><tr><td>@AfterThrowing</td><td>方法抛异常后</td><td>异常处理、错误日志</td><td>记录异常信息</td></tr><tr><td>@Around</td><td>方法执行前后</td><td>性能监控、事务控制</td><td>计算方法执行时间</td></tr></tbody></table><h4 id="_3-spring事务管理" tabindex="-1"><a class="header-anchor" href="#_3-spring事务管理"><span>3. Spring事务管理</span></a></h4><p><strong>事务传播行为：</strong></p><table><thead><tr><th>传播行为</th><th>行为描述</th><th>使用场景</th><th>风险提示</th></tr></thead><tbody><tr><td>REQUIRED</td><td>有事务就加入，没有就新建</td><td>最常用的传播行为</td><td>无</td></tr><tr><td>REQUIRES_NEW</td><td>总是新建事务</td><td>需要独立事务的操作</td><td>可能导致死锁</td></tr><tr><td>SUPPORTS</td><td>有事务就加入，没有就非事务执行</td><td>查询操作</td><td>数据一致性问题</td></tr><tr><td>NOT_SUPPORTED</td><td>总是非事务执行</td><td>纯查询操作</td><td>不支持事务回滚</td></tr><tr><td>MANDATORY</td><td>必须在事务中执行</td><td>强制事务的业务逻辑</td><td>没有事务会抛异常</td></tr><tr><td>NEVER</td><td>不能在事务中执行</td><td>不能有事务的操作</td><td>有事务会抛异常</td></tr><tr><td>NESTED</td><td>嵌套事务</td><td>部分回滚场景</td><td>依赖数据库支持</td></tr></tbody></table><p><strong>事务隔离级别：</strong></p><table><thead><tr><th>隔离级别</th><th>Spring常量</th><th>解决问题</th><th>性能影响</th><th>适用场景</th></tr></thead><tbody><tr><td>READ_UNCOMMITTED</td><td>ISOLATION_READ_UNCOMMITTED</td><td>无</td><td>最高</td><td>对一致性要求极低</td></tr><tr><td>READ_COMMITTED</td><td>ISOLATION_READ_COMMITTED</td><td>脏读</td><td>高</td><td>一般业务场景</td></tr><tr><td>REPEATABLE_READ</td><td>ISOLATION_REPEATABLE_READ</td><td>脏读、不可重复读</td><td>中</td><td>默认级别，推荐使用</td></tr><tr><td>SERIALIZABLE</td><td>ISOLATION_SERIALIZABLE</td><td>脏读、不可重复读、幻读</td><td>最低</td><td>对一致性要求极高</td></tr></tbody></table><h4 id="_4-spring-mvc的工作原理-核心组件-处理请求的流程" tabindex="-1"><a class="header-anchor" href="#_4-spring-mvc的工作原理-核心组件-处理请求的流程"><span>4. Spring MVC的工作原理？核心组件？处理请求的流程？</span></a></h4><p><strong>Spring MVC核心组件：</strong></p><table><thead><tr><th>组件</th><th>作用</th><th>核心功能</th><th>配置方式</th></tr></thead><tbody><tr><td>DispatcherServlet</td><td>前端控制器，统一调度请求</td><td>请求分发、异常处理、视图渲染</td><td>web.xml或Java配置</td></tr><tr><td>HandlerMapping</td><td>处理器映射器，找到处理请求的Controller</td><td>URL映射、RESTful路由</td><td>@RequestMapping</td></tr><tr><td>HandlerAdapter</td><td>处理器适配器，调用具体的处理方法</td><td>参数解析、返回值处理</td><td>自动配置</td></tr><tr><td>ViewResolver</td><td>视图解析器，解析逻辑视图名</td><td>视图路径解析、模板引擎集成</td><td>配置文件</td></tr></tbody></table><p><strong>请求处理流程：</strong></p><table><thead><tr><th>步骤</th><th>组件</th><th>具体操作</th><th>数据流转</th></tr></thead><tbody><tr><td>1</td><td>DispatcherServlet</td><td>接收HTTP请求</td><td>HttpServletRequest</td></tr><tr><td>2</td><td>HandlerMapping</td><td>根据URL找到对应的Controller和方法</td><td>HandlerExecutionChain</td></tr><tr><td>3</td><td>HandlerAdapter</td><td>调用Controller方法，处理业务逻辑</td><td>ModelAndView</td></tr><tr><td>4</td><td>ViewResolver</td><td>解析逻辑视图名，找到具体视图模板</td><td>View对象</td></tr><tr><td>5</td><td>View</td><td>渲染视图，生成HTML响应</td><td>HttpServletResponse</td></tr></tbody></table><h3 id="mybatis" tabindex="-1"><a class="header-anchor" href="#mybatis"><span>MyBatis</span></a></h3><h4 id="_5-1-一级缓存和二级缓存的区别" tabindex="-1"><a class="header-anchor" href="#_5-1-一级缓存和二级缓存的区别"><span>5.1 一级缓存和二级缓存的区别？</span></a></h4><p><strong>缓存级别对比：</strong></p><table><thead><tr><th>特性</th><th>一级缓存（SqlSession级别）</th><th>二级缓存（Mapper级别）</th></tr></thead><tbody><tr><td>作用域</td><td>单个SqlSession</td><td>同一个Mapper的所有SqlSession</td></tr><tr><td>生命周期</td><td>SqlSession关闭时失效</td><td>应用程序关闭时失效</td></tr><tr><td>默认开启</td><td>默认开启</td><td>需要手动开启</td></tr><tr><td>共享性</td><td>不共享</td><td>多个SqlSession共享</td></tr><tr><td>清空时机</td><td>commit/rollback/close</td><td>手动清空或配置自动清空</td></tr><tr><td>存储位置</td><td>SqlSession内存</td><td>可配置多种存储方式</td></tr></tbody></table><p><strong>缓存配置和使用：</strong></p><table><thead><tr><th>配置项目</th><th>一级缓存</th><th>二级缓存</th></tr></thead><tbody><tr><td>开启方式</td><td>无需配置，默认开启</td><td><code>@CacheNamespace</code>或<code>&lt;cache&gt;</code></td></tr><tr><td>失效策略</td><td>自动失效</td><td>LRU、FIFO、SOFT、WEAK</td></tr><tr><td>刷新策略</td><td>增删改操作自动清空</td><td>可配置flushInterval</td></tr><tr><td>序列化要求</td><td>无</td><td>实体类需实现Serializable接口</td></tr></tbody></table><h4 id="_5-2-resultmap-和-resulttype-的区别" tabindex="-1"><a class="header-anchor" href="#_5-2-resultmap-和-resulttype-的区别"><span>5.2 ResultMap 和 ResultType 的区别？</span></a></h4><p><strong>使用场景对比：</strong></p><table><thead><tr><th>特性</th><th>ResultType</th><th>ResultMap</th></tr></thead><tbody><tr><td>适用场景</td><td>简单映射、字段名一致</td><td>复杂映射、字段名不一致、关联查询</td></tr><tr><td>配置复杂度</td><td>简单</td><td>复杂</td></tr><tr><td>映射方式</td><td>自动映射</td><td>手动配置映射关系</td></tr><tr><td>性能</td><td>较好</td><td>略差（需要解析配置）</td></tr><tr><td>功能</td><td>基础功能</td><td>支持嵌套、关联、继承等高级功能</td></tr><tr><td>维护成本</td><td>低</td><td>高</td></tr></tbody></table><p><strong>选择建议：</strong></p><table><thead><tr><th>场景</th><th>推荐方案</th><th>原因</th></tr></thead><tbody><tr><td>简单POJO映射</td><td>ResultType</td><td>配置简单，性能好</td></tr><tr><td>字段名与属性名不一致</td><td>ResultMap</td><td>需要手动映射</td></tr><tr><td>一对一、一对多关联查询</td><td>ResultMap</td><td>支持嵌套映射</td></tr><tr><td>需要类型转换</td><td>ResultMap</td><td>支持TypeHandler</td></tr><tr><td>继承关系映射</td><td>ResultMap</td><td>支持继承和多态</td></tr></tbody></table><h4 id="_5-3-延迟加载-懒加载-的原理和配置" tabindex="-1"><a class="header-anchor" href="#_5-3-延迟加载-懒加载-的原理和配置"><span>5.3 延迟加载（懒加载）的原理和配置？</span></a></h4><p><strong>延迟加载机制：</strong></p><table><thead><tr><th>概念</th><th>定义</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>延迟加载</td><td>关联对象在真正使用时才加载</td><td>提高性能、减少内存占用</td><td>可能产生N+1问题</td><td>大对象关联</td></tr><tr><td>立即加载</td><td>查询时一次性加载所有关联对象</td><td>减少数据库访问次数</td><td>可能加载不需要的数据</td><td>小对象关联</td></tr></tbody></table><p><strong>配置方式：</strong></p><table><thead><tr><th>配置级别</th><th>配置位置</th><th>配置项</th><th>说明</th></tr></thead><tbody><tr><td>全局配置</td><td>mybatis-config.xml</td><td>lazyLoadingEnabled=true</td><td>全局开启延迟加载</td></tr><tr><td>局部配置</td><td>ResultMap</td><td>fetchType=&quot;lazy/eager&quot;</td><td>针对特定关联配置</td></tr><tr><td>方法级配置</td><td>@Select等注解</td><td>fetchType属性</td><td>注解方式配置</td></tr></tbody></table><h4 id="_5-4-如何实现分页" tabindex="-1"><a class="header-anchor" href="#_5-4-如何实现分页"><span>5.4 如何实现分页？</span></a></h4><p><strong>分页实现方案对比：</strong></p><table><thead><tr><th>方案</th><th>实现原理</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>RowBounds内存分页</td><td>查询所有数据后在内存中分页</td><td>实现简单</td><td>性能差、内存占用大</td><td>小数据量</td></tr><tr><td>PageHelper物理分页</td><td>自动改写SQL添加LIMIT</td><td>性能好、使用简单</td><td>依赖插件</td><td>大数据量、生产环境</td></tr><tr><td>手写SQL分页</td><td>手动编写带LIMIT的SQL</td><td>性能最好、可控性强</td><td>开发复杂、维护成本高</td><td>复杂查询场景</td></tr></tbody></table><p><strong>PageHelper使用示例：</strong></p><table><thead><tr><th>使用方式</th><th>代码示例</th><th>说明</th></tr></thead><tbody><tr><td>方法调用</td><td><code>PageHelper.startPage(1, 10)</code></td><td>在查询前调用</td></tr><tr><td>注解方式</td><td><code>@Select + @Options</code></td><td>注解配置分页参数</td></tr><tr><td>参数传递</td><td><code>PageInfo&lt;User&gt; pageInfo</code></td><td>封装分页结果</td></tr></tbody></table><h3 id="系统设计" tabindex="-1"><a class="header-anchor" href="#系统设计"><span>系统设计</span></a></h3><h4 id="_6-设计一个秒杀系统" tabindex="-1"><a class="header-anchor" href="#_6-设计一个秒杀系统"><span>6. 设计一个秒杀系统</span></a></h4><p><strong>系统架构设计：</strong></p><table><thead><tr><th>层次</th><th>组件</th><th>作用</th><th>技术选型</th><th>关键指标</th></tr></thead><tbody><tr><td>接入层</td><td>CDN + 负载均衡</td><td>静态资源加速、流量分发</td><td>Nginx、LVS</td><td>QPS: 10万+</td></tr><tr><td>应用层</td><td>微服务集群</td><td>业务逻辑处理</td><td>Spring Boot集群</td><td>响应时间: &lt;100ms</td></tr><tr><td>缓存层</td><td>Redis集群</td><td>热点数据缓存</td><td>Redis Cluster</td><td>命中率: &gt;95%</td></tr><tr><td>数据层</td><td>MySQL主从</td><td>数据持久化</td><td>MySQL 8.0</td><td>TPS: 1万+</td></tr><tr><td>消息层</td><td>消息队列</td><td>异步处理、削峰填谷</td><td>RocketMQ</td><td>吞吐量: 10万条/秒</td></tr></tbody></table><p><strong>核心技术方案：</strong></p><table><thead><tr><th>技术挑战</th><th>解决方案</th><th>实现方式</th><th>效果评估</th></tr></thead><tbody><tr><td>高并发读</td><td>多级缓存 + CDN</td><td>Redis + 本地缓存 + CDN静态化</td><td>减少99%数据库访问</td></tr><tr><td>库存扣减</td><td>Redis Lua脚本</td><td>原子性操作，避免超卖</td><td>100%准确性</td></tr><tr><td>流量削峰</td><td>消息队列异步处理</td><td>秒杀请求先入队，异步处理订单</td><td>削峰90%</td></tr><tr><td>限流保护</td><td>令牌桶 + 熔断降级</td><td>Sentinel限流，超限返回友好提示</td><td>系统稳定性99.9%</td></tr><tr><td>数据一致性</td><td>分布式事务</td><td>Seata分布式事务，保证最终一致性</td><td>数据准确性100%</td></tr></tbody></table><p><strong>Redis Lua脚本示例：</strong></p><table><thead><tr><th>功能</th><th>脚本逻辑</th><th>优势</th></tr></thead><tbody><tr><td>库存扣减</td><td>检查库存 → 扣减库存 → 记录用户购买</td><td>原子性操作，避免超卖</td></tr><tr><td>防重复购买</td><td>检查用户购买记录 → 执行购买逻辑</td><td>避免重复下单</td></tr><tr><td>限流控制</td><td>检查请求频率 → 更新计数器</td><td>精确限流</td></tr></tbody></table><h3 id="编码能力" tabindex="-1"><a class="header-anchor" href="#编码能力"><span>编码能力</span></a></h3><h4 id="_7-各类主流算法" tabindex="-1"><a class="header-anchor" href="#_7-各类主流算法"><span>7. 各类主流算法</span></a></h4><p><strong>算法分类和重要性：</strong></p><table><thead><tr><th>算法类型</th><th>重要算法</th><th>面试频率</th><th>难度等级</th><th>应用场景</th></tr></thead><tbody><tr><td>排序算法</td><td>快排、归并、堆排序</td><td>⭐⭐⭐⭐⭐</td><td>中等</td><td>数据排序、TopK问题</td></tr><tr><td>查找算法</td><td>二分查找、哈希查找</td><td>⭐⭐⭐⭐⭐</td><td>简单</td><td>数据检索、去重</td></tr><tr><td>动态规划</td><td>背包、最长子序列、路径问题</td><td>⭐⭐⭐⭐</td><td>困难</td><td>优化问题、计数问题</td></tr><tr><td>图算法</td><td>DFS、BFS、最短路径</td><td>⭐⭐⭐</td><td>中等</td><td>社交网络、路径规划</td></tr><tr><td>树算法</td><td>二叉树遍历、平衡树、字典树</td><td>⭐⭐⭐⭐</td><td>中等</td><td>数据结构、搜索引擎</td></tr><tr><td>贪心算法</td><td>区间调度、最小生成树</td><td>⭐⭐⭐</td><td>中等</td><td>资源分配、网络优化</td></tr></tbody></table><p><strong>面试常考算法题型：</strong></p><table><thead><tr><th>题型</th><th>典型例题</th><th>解题思路</th><th>时间复杂度</th></tr></thead><tbody><tr><td>数组双指针</td><td>两数之和、三数之和</td><td>排序+双指针移动</td><td>O(n) - O(n²)</td></tr><tr><td>链表操作</td><td>反转链表、环形链表检测</td><td>快慢指针、递归</td><td>O(n)</td></tr><tr><td>二叉树递归</td><td>最大深度、路径和</td><td>递归分治</td><td>O(n)</td></tr><tr><td>动态规划</td><td>爬楼梯、最大子数组和</td><td>状态转移方程</td><td>O(n) - O(n²)</td></tr><tr><td>回溯算法</td><td>全排列、N皇后问题</td><td>递归+回溯</td><td>O(n!)</td></tr><tr><td>滑动窗口</td><td>最长无重复子串</td><td>窗口扩展和收缩</td><td>O(n)</td></tr></tbody></table>',461)]))}]]),s=JSON.parse('{"path":"/zh/posts/review/%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9.html","title":"面试要点","lang":"zh-CN","frontmatter":{"icon":"pen-to-square","date":"2025-07-27T00:00:00.000Z","category":["Learning Records"],"tag":["Review"],"description":"面试要点 Java基础 1. equals() 和 == 的区别？如何正确重写 equals() 和 hashCode() 方法？为什么需要同时重写？ == 和 equals() 的区别 == 操作符：对于基本数据类型比较值，对于引用类型比较内存地址 equals() 方法：Object类默认实现是比较引用，String等类重写后比较内容 正确重写的五...","head":[["meta",{"property":"og:url","content":"https://crc011220.github.io/zh/posts/review/%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9.html"}],["meta",{"property":"og:site_name","content":"Ruochen Chen"}],["meta",{"property":"og:title","content":"面试要点"}],["meta",{"property":"og:description","content":"面试要点 Java基础 1. equals() 和 == 的区别？如何正确重写 equals() 和 hashCode() 方法？为什么需要同时重写？ == 和 equals() 的区别 == 操作符：对于基本数据类型比较值，对于引用类型比较内存地址 equals() 方法：Object类默认实现是比较引用，String等类重写后比较内容 正确重写的五..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-07-27T11:10:04.000Z"}],["meta",{"property":"article:tag","content":"Review"}],["meta",{"property":"article:published_time","content":"2025-07-27T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-07-27T11:10:04.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"面试要点\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-07-27T00:00:00.000Z\\",\\"dateModified\\":\\"2025-07-27T11:10:04.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Ruochen Chen\\"}]}"]]},"headers":[{"level":2,"title":"Java基础","slug":"java基础","link":"#java基础","children":[{"level":3,"title":"1. equals() 和 == 的区别？如何正确重写 equals() 和 hashCode() 方法？为什么需要同时重写？","slug":"_1-equals-和-的区别-如何正确重写-equals-和-hashcode-方法-为什么需要同时重写","link":"#_1-equals-和-的区别-如何正确重写-equals-和-hashcode-方法-为什么需要同时重写","children":[]},{"level":3,"title":"2. 接口和抽象类的区别？何时用接口？何时用抽象类？","slug":"_2-接口和抽象类的区别-何时用接口-何时用抽象类","link":"#_2-接口和抽象类的区别-何时用接口-何时用抽象类","children":[]},{"level":3,"title":"3. String vs StringBuffer vs StringBuilder","slug":"_3-string-vs-stringbuffer-vs-stringbuilder","link":"#_3-string-vs-stringbuffer-vs-stringbuilder","children":[]},{"level":3,"title":"4. 自动装箱与拆箱原理及潜在问题","slug":"_4-自动装箱与拆箱原理及潜在问题","link":"#_4-自动装箱与拆箱原理及潜在问题","children":[]},{"level":3,"title":"5. BIO、NIO、AIO的区别？","slug":"_5-bio、nio、aio的区别","link":"#_5-bio、nio、aio的区别","children":[]}]},{"level":2,"title":"集合","slug":"集合","link":"#集合","children":[{"level":3,"title":"1. HashMap 的实现原理？JDK 1.7和1.8的区别？hash()方法的作用？如何处理哈希冲突？","slug":"_1-hashmap-的实现原理-jdk-1-7和1-8的区别-hash-方法的作用-如何处理哈希冲突","link":"#_1-hashmap-的实现原理-jdk-1-7和1-8的区别-hash-方法的作用-如何处理哈希冲突","children":[]},{"level":3,"title":"2. ConcurrentHashMap 如何实现线程安全？","slug":"_2-concurrenthashmap-如何实现线程安全","link":"#_2-concurrenthashmap-如何实现线程安全","children":[]},{"level":3,"title":"3. ArrayList 和 LinkedList 的底层实现、时间复杂度？","slug":"_3-arraylist-和-linkedlist-的底层实现、时间复杂度","link":"#_3-arraylist-和-linkedlist-的底层实现、时间复杂度","children":[]},{"level":3,"title":"4. Iterator 和 ListIterator 的区别？fail-fast 和 fail-safe 机制？","slug":"_4-iterator-和-listiterator-的区别-fail-fast-和-fail-safe-机制","link":"#_4-iterator-和-listiterator-的区别-fail-fast-和-fail-safe-机制","children":[]},{"level":3,"title":"5. 如何保证集合的线程安全？","slug":"_5-如何保证集合的线程安全","link":"#_5-如何保证集合的线程安全","children":[]},{"level":3,"title":"6. Comparable 和 Comparator 接口的区别？","slug":"_6-comparable-和-comparator-接口的区别","link":"#_6-comparable-和-comparator-接口的区别","children":[]}]},{"level":2,"title":"多线程","slug":"多线程","link":"#多线程","children":[{"level":3,"title":"线程基础","slug":"线程基础","link":"#线程基础","children":[]},{"level":3,"title":"线程安全","slug":"线程安全","link":"#线程安全","children":[]}]},{"level":2,"title":"数据库","slug":"数据库","link":"#数据库","children":[{"level":3,"title":"SQL基础","slug":"sql基础","link":"#sql基础","children":[]},{"level":3,"title":"MySQL特性","slug":"mysql特性","link":"#mysql特性","children":[]},{"level":3,"title":"索引优化","slug":"索引优化","link":"#索引优化","children":[]},{"level":3,"title":"锁机制","slug":"锁机制","link":"#锁机制","children":[]},{"level":3,"title":"事务管理","slug":"事务管理","link":"#事务管理","children":[]},{"level":3,"title":"性能优化","slug":"性能优化","link":"#性能优化","children":[]}]},{"level":2,"title":"Redis","slug":"redis","link":"#redis","children":[{"level":3,"title":"基础特性","slug":"基础特性","link":"#基础特性","children":[]},{"level":3,"title":"持久化机制","slug":"持久化机制","link":"#持久化机制","children":[]},{"level":3,"title":"内存管理","slug":"内存管理","link":"#内存管理","children":[]},{"level":3,"title":"高可用架构","slug":"高可用架构","link":"#高可用架构","children":[]},{"level":3,"title":"缓存问题","slug":"缓存问题","link":"#缓存问题","children":[]},{"level":3,"title":"分布式锁","slug":"分布式锁","link":"#分布式锁","children":[]}]},{"level":2,"title":"分布式","slug":"分布式","link":"#分布式","children":[{"level":3,"title":"理论基础","slug":"理论基础","link":"#理论基础","children":[]},{"level":3,"title":"分布式事务","slug":"分布式事务","link":"#分布式事务","children":[]},{"level":3,"title":"分布式锁","slug":"分布式锁-1","link":"#分布式锁-1","children":[]},{"level":3,"title":"分布式ID生成","slug":"分布式id生成","link":"#分布式id生成","children":[]},{"level":3,"title":"负载均衡","slug":"负载均衡","link":"#负载均衡","children":[]}]},{"level":2,"title":"微服务","slug":"微服务","link":"#微服务","children":[{"level":3,"title":"架构特性","slug":"架构特性","link":"#架构特性","children":[]},{"level":3,"title":"服务发现","slug":"服务发现","link":"#服务发现","children":[]},{"level":3,"title":"服务调用","slug":"服务调用","link":"#服务调用","children":[]},{"level":3,"title":"API网关","slug":"api网关","link":"#api网关","children":[]},{"level":3,"title":"配置中心","slug":"配置中心","link":"#配置中心","children":[]},{"level":3,"title":"服务容错","slug":"服务容错","link":"#服务容错","children":[]},{"level":3,"title":"链路追踪","slug":"链路追踪","link":"#链路追踪","children":[]}]},{"level":2,"title":"消息队列","slug":"消息队列","link":"#消息队列","children":[{"level":3,"title":"基础概念","slug":"基础概念","link":"#基础概念","children":[]},{"level":3,"title":"消息可靠性","slug":"消息可靠性","link":"#消息可靠性","children":[]},{"level":3,"title":"技术选型","slug":"技术选型","link":"#技术选型","children":[]}]},{"level":2,"title":"主流框架、系统设计、编码能力","slug":"主流框架、系统设计、编码能力","link":"#主流框架、系统设计、编码能力","children":[{"level":3,"title":"Spring框架","slug":"spring框架","link":"#spring框架","children":[]},{"level":3,"title":"MyBatis","slug":"mybatis","link":"#mybatis","children":[]},{"level":3,"title":"系统设计","slug":"系统设计","link":"#系统设计","children":[]},{"level":3,"title":"编码能力","slug":"编码能力","link":"#编码能力","children":[]}]}],"git":{"createdTime":1753614346000,"updatedTime":1753614604000,"contributors":[{"name":"Ruochen Chen","email":"ruocchen1220@gmail.com","commits":2}]},"readingTime":{"minutes":59.44,"words":17832},"filePathRelative":"zh/posts/review/面试要点.md","localizedDate":"2025年7月27日","excerpt":"\\n<h2>Java基础</h2>\\n<h3>1. equals() 和 == 的区别？如何正确重写 equals() 和 hashCode() 方法？为什么需要同时重写？</h3>\\n<h4>== 和 equals() 的区别</h4>\\n<ul>\\n<li><strong>== 操作符</strong>：对于基本数据类型比较值，对于引用类型比较内存地址</li>\\n<li><strong>equals() 方法</strong>：Object类默认实现是比较引用，String等类重写后比较内容</li>\\n</ul>\\n<h4>正确重写的五个原则</h4>\\n<ol>\\n<li><strong>自反性</strong>：x.equals(x) 必须返回 true</li>\\n<li><strong>对称性</strong>：x.equals(y) 和 y.equals(x) 结果相同</li>\\n<li><strong>传递性</strong>：如果 x.equals(y) 且 y.equals(z)，则 x.equals(z)</li>\\n<li><strong>一致性</strong>：多次调用结果一致</li>\\n<li><strong>非空性</strong>：x.equals(null) 返回 false</li>\\n</ol>","autoDesc":true}')},6262:(t,d)=>{d.A=(t,d)=>{const r=t.__vccOpts||t;for(const[t,a]of d)r[t]=a;return r}}}]);