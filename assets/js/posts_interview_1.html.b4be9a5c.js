"use strict";(self.webpackChunkpersonalweb=self.webpackChunkpersonalweb||[]).push([[8313],{6262:(e,n)=>{n.A=(e,n)=>{const i=e.__vccOpts||e;for(const[e,r]of n)i[e]=r;return i}},9247:(e,n,i)=>{i.r(n),i.d(n,{comp:()=>t,data:()=>a});var r=i(641);const s={},t=(0,i(6262).A)(s,[["render",function(e,n){return(0,r.uX)(),(0,r.CE)("div",null,n[0]||(n[0]=[(0,r.Fv)('<h1 id="mysql" tabindex="-1"><a class="header-anchor" href="#mysql"><span>MySQL</span></a></h1><h2 id="_1-how-to-identify-slow-queries-in-mysql" tabindex="-1"><a class="header-anchor" href="#_1-how-to-identify-slow-queries-in-mysql"><span>1. How to Identify Slow Queries in MySQL</span></a></h2><p>Answer:<br> During our stress testing, we noticed that some API responses were very slow, exceeding 2 seconds. Since our system integrates with SkyWalking/Prometheus for monitoring, its reports helped identify slow APIs and pinpoint which part of the API (including SQL execution) was slow.</p><p>If such monitoring systems are unavailable, MySQL itself provides a <strong>slow query log</strong> feature. You can enable it in the MySQL configuration file and set a threshold (e.g., 2 seconds). Queries exceeding this time will be logged, making it easier to identify slow queries.</p><hr><h2 id="_2-how-to-analyze-slow-queries" tabindex="-1"><a class="header-anchor" href="#_2-how-to-analyze-slow-queries"><span>2. How to Analyze Slow Queries</span></a></h2><p>Answer:<br> If a query is slow, we use the <strong>EXPLAIN</strong> command to analyze its execution plan. Key metrics include:</p><ul><li><strong>Key and key_len</strong>: Check if the query uses indexes and whether they are effective.</li><li><strong>Type</strong>: Review the scan type (e.g., full table scan or range scan).</li><li><strong>Extra</strong>: Look for optimizations (e.g., avoid table backtracking or unnecessary sorting).</li></ul><p>For example, if backtracking occurs, we might add indexes or optimize the returned fields to improve performance.</p><hr><h2 id="_3-what-is-an-index" tabindex="-1"><a class="header-anchor" href="#_3-what-is-an-index"><span>3. What Is an Index?</span></a></h2><p>Answer:<br> Indexes are data structures that help MySQL retrieve data efficiently. They reduce I/O costs, enable faster lookups, and can also help sort data, reducing CPU usage.</p><hr><h2 id="_4-underlying-data-structure-of-indexes" tabindex="-1"><a class="header-anchor" href="#_4-underlying-data-structure-of-indexes"><span>4. Underlying Data Structure of Indexes</span></a></h2><p>Answer:<br> The InnoDB engine uses <strong>B+ trees</strong> for index storage.<br> Advantages of B+ trees:</p><ul><li>More child nodes per node, reducing tree depth.</li><li>Lower disk I/O since non-leaf nodes store only keys and pointers.</li><li>Suited for range queries because leaf nodes form a doubly linked list.</li></ul><hr><h2 id="_5-differences-between-b-trees-and-b-trees" tabindex="-1"><a class="header-anchor" href="#_5-differences-between-b-trees-and-b-trees"><span>5. Differences Between B-Trees and B+ Trees</span></a></h2><p>Answer:</p><ol><li><strong>Data storage</strong>: <ul><li>B-Trees store data in both internal and leaf nodes.</li><li>B+ Trees store all data in leaf nodes, ensuring more consistent query performance.</li></ul></li><li><strong>Range queries</strong>: <ul><li>B+ Trees excel in range queries as leaf nodes form a linked list.</li></ul></li></ol><hr><h2 id="_6-clustered-vs-non-clustered-indexes" tabindex="-1"><a class="header-anchor" href="#_6-clustered-vs-non-clustered-indexes"><span>6. Clustered vs. Non-Clustered Indexes</span></a></h2><p>Answer:</p><ul><li><strong>Clustered Index</strong>:<br> Data and index are stored together. In B+ trees, leaf nodes store entire rows. Each table usually has one clustered index, typically the primary key.</li><li><strong>Non-Clustered Index</strong>:<br> Data and index are stored separately. Leaf nodes store primary key values instead of full rows. Tables can have multiple non-clustered indexes.</li></ul><hr><h2 id="_7-what-is-backtracking-in-queries" tabindex="-1"><a class="header-anchor" href="#_7-what-is-backtracking-in-queries"><span>7. What Is Backtracking in Queries?</span></a></h2><p>Answer:<br> Backtracking occurs when a secondary index points to the primary key, requiring an additional lookup in the clustered index to retrieve full row data.</p><hr><h2 id="_8-what-is-a-covering-index" tabindex="-1"><a class="header-anchor" href="#_8-what-is-a-covering-index"><span>8. What Is a Covering Index?</span></a></h2><p>Answer:<br> A <strong>covering index</strong> is one where all the fields required for a query are included in the index. This avoids backtracking and improves query performance.</p><hr><h2 id="_9-how-to-handle-large-pagination" tabindex="-1"><a class="header-anchor" href="#_9-how-to-handle-large-pagination"><span>9. How to Handle Large Pagination?</span></a></h2><p>Answer:<br> For large datasets, using <code>LIMIT</code> with sorting can be slow. Optimize with:</p><ol><li><strong>Covering indexes</strong>: Use indexed columns for pagination queries.</li><li><strong>Subqueries</strong>: First fetch primary key IDs for the required page, then query using these IDs.</li></ol><hr><h2 id="_10-principles-for-index-creation" tabindex="-1"><a class="header-anchor" href="#_10-principles-for-index-creation"><span>10. Principles for Index Creation</span></a></h2><p>Answer:</p><ul><li>Create indexes for tables with over 100,000 rows.</li><li>Index frequently queried columns (e.g., filters, sorting, grouping).</li><li>Prefer composite indexes that cover query results.</li><li>For fields with low cardinality, place them later in composite indexes.</li><li>Use prefix indexes for long fields.</li><li>Limit the number of indexes to balance read/write performance.</li></ul><hr><h2 id="_11-when-do-indexes-fail" tabindex="-1"><a class="header-anchor" href="#_11-when-do-indexes-fail"><span>11. When Do Indexes Fail?</span></a></h2><p>Answer:<br> Indexes fail in cases such as:</p><ul><li>Ignoring the <strong>leftmost prefix</strong> principle in composite indexes.</li><li>Using wildcard queries starting with <code>%</code>.</li><li>Performing operations or type conversions on indexed fields.</li><li>Using a range query in a composite index, making subsequent conditions ineffective.</li></ul><hr><h2 id="_12-sql-optimization-techniques" tabindex="-1"><a class="header-anchor" href="#_12-sql-optimization-techniques"><span>12. SQL Optimization Techniques</span></a></h2><p>Answer:<br> Optimize SQL by:</p><ul><li>Selecting specific fields instead of <code>SELECT *</code>.</li><li>Using <code>UNION ALL</code> instead of <code>UNION</code>.</li><li>Using <code>INNER JOIN</code> for table joins and ensuring smaller tables are driving tables when using <code>LEFT JOIN</code> or <code>RIGHT JOIN</code>.</li><li>Leveraging read-write separation and replication for large datasets.</li><li>Sharding large tables across databases.</li></ul><hr><h2 id="_13-table-creation-optimization" tabindex="-1"><a class="header-anchor" href="#_13-table-creation-optimization"><span>13. Table Creation Optimization</span></a></h2><p>Answer:<br> We followed the <strong>Alibaba Development Handbook</strong> to choose appropriate field types. For instance:</p><ul><li>Use <code>TINYINT</code>, <code>INT</code>, or <code>BIGINT</code> for numeric fields.</li><li>Use <code>CHAR</code>, <code>VARCHAR</code>, or <code>TEXT</code> for strings based on size and variability.</li></ul><hr><h2 id="_14-index-usage-optimization" tabindex="-1"><a class="header-anchor" href="#_14-index-usage-optimization"><span>14. Index Usage Optimization</span></a></h2><p>Answer:<br> We follow best practices for index creation, ensuring frequent query columns are indexed, avoiding operations on indexed fields, and controlling the total number of indexes.</p><hr><h2 id="_15-personal-sql-optimization-practices" tabindex="-1"><a class="header-anchor" href="#_15-personal-sql-optimization-practices"><span>15. Personal SQL Optimization Practices</span></a></h2><p>Answer:</p><ul><li>Avoid <code>SELECT *</code>; specify required columns.</li><li>Prevent index failure by writing query-friendly syntax.</li><li>Prefer <code>UNION ALL</code> over <code>UNION</code>.</li><li>Use <code>INNER JOIN</code> for better performance in joins.</li></ul><hr><h2 id="_16-what-are-transaction-properties" tabindex="-1"><a class="header-anchor" href="#_16-what-are-transaction-properties"><span>16. What Are Transaction Properties?</span></a></h2><p>Answer:<br> Transactions follow <strong>ACID</strong> principles:</p><ul><li><strong>Atomicity</strong>: All operations succeed or fail as a whole.</li><li><strong>Consistency</strong>: Data remains consistent across transactions.</li><li><strong>Isolation</strong>: Concurrent transactions don&#39;t interfere.</li><li><strong>Durability</strong>: Changes persist after commit.</li></ul><hr><h2 id="_17-issues-with-concurrent-transactions" tabindex="-1"><a class="header-anchor" href="#_17-issues-with-concurrent-transactions"><span>17. Issues with Concurrent Transactions</span></a></h2><p>Answer:<br> Concurrency can lead to:</p><ul><li><strong>Dirty reads</strong>: Reading uncommitted changes.</li><li><strong>Non-repeatable reads</strong>: Different values for the same query in one transaction.</li><li><strong>Phantom reads</strong>: Rows appearing or disappearing during a transaction.</li></ul><hr><h2 id="_18-solving-concurrency-issues" tabindex="-1"><a class="header-anchor" href="#_18-solving-concurrency-issues"><span>18. Solving Concurrency Issues</span></a></h2><p>Answer:<br> MySQL uses isolation levels:</p><ol><li><strong>READ UNCOMMITTED</strong>: Allows all issues.</li><li><strong>READ COMMITTED</strong>: Solves dirty reads.</li><li><strong>REPEATABLE READ</strong>: Solves dirty and non-repeatable reads (default in MySQL).</li><li><strong>SERIALIZABLE</strong>: Prevents all issues but reduces performance.</li></ol><hr><h2 id="_19-difference-between-undo-log-and-redo-log" tabindex="-1"><a class="header-anchor" href="#_19-difference-between-undo-log-and-redo-log"><span>19. Difference Between Undo Log and Redo Log</span></a></h2><p>Answer:</p><ul><li><strong>Redo Log</strong>: Tracks physical changes for recovery after a crash, ensuring durability.</li><li><strong>Undo Log</strong>: Tracks logical changes for rollbacks, ensuring atomicity.</li></ul><hr><h2 id="_20-ensuring-isolation-with-mvcc" tabindex="-1"><a class="header-anchor" href="#_20-ensuring-isolation-with-mvcc"><span>20. Ensuring Isolation with MVCC</span></a></h2><p>Answer:<br><strong>MVCC</strong> uses hidden fields (<code>trx_id</code>, <code>roll_pointer</code>), <strong>undo logs</strong>, and a <strong>read view</strong> for consistent snapshots.</p><hr><h2 id="_21-mysql-master-slave-synchronization" tabindex="-1"><a class="header-anchor" href="#_21-mysql-master-slave-synchronization"><span>21. MySQL Master-Slave Synchronization</span></a></h2><p>Answer:<br> Master-slave replication works as follows:</p><ol><li>Master records changes in a binary log (Binlog).</li><li>Slave reads the Binlog and writes changes to its relay log.</li><li>Slave replays the relay log to sync data.</li></ol><hr><h2 id="_22-vertical-vs-horizontal-partitioning" tabindex="-1"><a class="header-anchor" href="#_22-vertical-vs-horizontal-partitioning"><span>22. Vertical vs. Horizontal Partitioning</span></a></h2><p>Answer:</p><ul><li><strong>Vertical Partitioning</strong>: Splitting databases by functionality (microservices architecture).</li><li><strong>Horizontal Partitioning</strong>: Splitting large tables across databases (e.g., sharding by ID).</li></ul><hr>',85)]))}]]),a=JSON.parse('{"path":"/posts/interview/1.html","title":"MySQL","lang":"en-US","frontmatter":{"icon":"pen-to-square","date":"2024-11-18T00:00:00.000Z","category":["Learning Records"],"tag":["Technical Interview"],"description":"MySQL 1. How to Identify Slow Queries in MySQL Answer: During our stress testing, we noticed that some API responses were very slow, exceeding 2 seconds. Since our system integr...","head":[["meta",{"property":"og:url","content":"https://crc011220.github.io/posts/interview/1.html"}],["meta",{"property":"og:site_name","content":"Ruochen Chen"}],["meta",{"property":"og:title","content":"MySQL"}],["meta",{"property":"og:description","content":"MySQL 1. How to Identify Slow Queries in MySQL Answer: During our stress testing, we noticed that some API responses were very slow, exceeding 2 seconds. Since our system integr..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2024-11-21T12:08:12.000Z"}],["meta",{"property":"article:tag","content":"Technical Interview"}],["meta",{"property":"article:published_time","content":"2024-11-18T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-11-21T12:08:12.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"MySQL\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-11-18T00:00:00.000Z\\",\\"dateModified\\":\\"2024-11-21T12:08:12.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Ruochen Chen\\"}]}"]]},"headers":[{"level":2,"title":"1. How to Identify Slow Queries in MySQL","slug":"_1-how-to-identify-slow-queries-in-mysql","link":"#_1-how-to-identify-slow-queries-in-mysql","children":[]},{"level":2,"title":"2. How to Analyze Slow Queries","slug":"_2-how-to-analyze-slow-queries","link":"#_2-how-to-analyze-slow-queries","children":[]},{"level":2,"title":"3. What Is an Index?","slug":"_3-what-is-an-index","link":"#_3-what-is-an-index","children":[]},{"level":2,"title":"4. Underlying Data Structure of Indexes","slug":"_4-underlying-data-structure-of-indexes","link":"#_4-underlying-data-structure-of-indexes","children":[]},{"level":2,"title":"5. Differences Between B-Trees and B+ Trees","slug":"_5-differences-between-b-trees-and-b-trees","link":"#_5-differences-between-b-trees-and-b-trees","children":[]},{"level":2,"title":"6. Clustered vs. Non-Clustered Indexes","slug":"_6-clustered-vs-non-clustered-indexes","link":"#_6-clustered-vs-non-clustered-indexes","children":[]},{"level":2,"title":"7. What Is Backtracking in Queries?","slug":"_7-what-is-backtracking-in-queries","link":"#_7-what-is-backtracking-in-queries","children":[]},{"level":2,"title":"8. What Is a Covering Index?","slug":"_8-what-is-a-covering-index","link":"#_8-what-is-a-covering-index","children":[]},{"level":2,"title":"9. How to Handle Large Pagination?","slug":"_9-how-to-handle-large-pagination","link":"#_9-how-to-handle-large-pagination","children":[]},{"level":2,"title":"10. Principles for Index Creation","slug":"_10-principles-for-index-creation","link":"#_10-principles-for-index-creation","children":[]},{"level":2,"title":"11. When Do Indexes Fail?","slug":"_11-when-do-indexes-fail","link":"#_11-when-do-indexes-fail","children":[]},{"level":2,"title":"12. SQL Optimization Techniques","slug":"_12-sql-optimization-techniques","link":"#_12-sql-optimization-techniques","children":[]},{"level":2,"title":"13. Table Creation Optimization","slug":"_13-table-creation-optimization","link":"#_13-table-creation-optimization","children":[]},{"level":2,"title":"14. Index Usage Optimization","slug":"_14-index-usage-optimization","link":"#_14-index-usage-optimization","children":[]},{"level":2,"title":"15. Personal SQL Optimization Practices","slug":"_15-personal-sql-optimization-practices","link":"#_15-personal-sql-optimization-practices","children":[]},{"level":2,"title":"16. What Are Transaction Properties?","slug":"_16-what-are-transaction-properties","link":"#_16-what-are-transaction-properties","children":[]},{"level":2,"title":"17. Issues with Concurrent Transactions","slug":"_17-issues-with-concurrent-transactions","link":"#_17-issues-with-concurrent-transactions","children":[]},{"level":2,"title":"18. Solving Concurrency Issues","slug":"_18-solving-concurrency-issues","link":"#_18-solving-concurrency-issues","children":[]},{"level":2,"title":"19. Difference Between Undo Log and Redo Log","slug":"_19-difference-between-undo-log-and-redo-log","link":"#_19-difference-between-undo-log-and-redo-log","children":[]},{"level":2,"title":"20. Ensuring Isolation with MVCC","slug":"_20-ensuring-isolation-with-mvcc","link":"#_20-ensuring-isolation-with-mvcc","children":[]},{"level":2,"title":"21. MySQL Master-Slave Synchronization","slug":"_21-mysql-master-slave-synchronization","link":"#_21-mysql-master-slave-synchronization","children":[]},{"level":2,"title":"22. Vertical vs. Horizontal Partitioning","slug":"_22-vertical-vs-horizontal-partitioning","link":"#_22-vertical-vs-horizontal-partitioning","children":[]}],"git":{"createdTime":1731933228000,"updatedTime":1732190892000,"contributors":[{"name":"Ruochen Chen","email":"ruocchen1220@gmail.com","commits":3}]},"readingTime":{"minutes":3.3,"words":990},"filePathRelative":"posts/interview/1.md","localizedDate":"November 18, 2024","excerpt":"\\n<h2>1. How to Identify Slow Queries in MySQL</h2>\\n<p>Answer:<br>\\nDuring our stress testing, we noticed that some API responses were very slow, exceeding 2 seconds. Since our system integrates with SkyWalking/Prometheus for monitoring, its reports helped identify slow APIs and pinpoint which part of the API (including SQL execution) was slow.</p>","autoDesc":true}')}}]);