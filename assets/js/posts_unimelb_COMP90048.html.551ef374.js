"use strict";(self.webpackChunkpersonalweb=self.webpackChunkpersonalweb||[]).push([[7849],{4967:(i,s,e)=>{e.r(s),e.d(s,{comp:()=>l,data:()=>r});var a=e(641);const t=e.p+"assets/img/Prolog-Arithmetic-Expressions.9b8b250d.png",n={},l=(0,e(6262).A)(n,[["render",function(i,s){return(0,a.uX)(),(0,a.CE)("div",null,s[0]||(s[0]=[(0,a.Fv)('<h1 id="declarative-programming-comp90048" tabindex="-1"><a class="header-anchor" href="#declarative-programming-comp90048"><span>Declarative Programming (COMP90048)</span></a></h1><h2 id="week-1" tabindex="-1"><a class="header-anchor" href="#week-1"><span>Week 1</span></a></h2><h4 id="imperative-languages-are-based-on-commands-in-the-form-of-instructions-and-statements" tabindex="-1"><a class="header-anchor" href="#imperative-languages-are-based-on-commands-in-the-form-of-instructions-and-statements"><span>Imperative languages are based on commands, in the form of instructions and statements.</span></a></h4><ul><li>Commands are executed.</li><li>Commands have an effect, such as to update the computation state,and later code may depend on this update.</li></ul><h4 id="logic-programming-languages-are-based-on-finding-values-that-satisfy-a-set-of-constraints" tabindex="-1"><a class="header-anchor" href="#logic-programming-languages-are-based-on-finding-values-that-satisfy-a-set-of-constraints"><span>Logic programming languages are based on finding values that satisfy a set of constraints.</span></a></h4><ul><li>Constraints may have multiple solutions or none at all.</li><li>Constraints do not have an effect.</li></ul><h4 id="functional-languages-are-based-on-evaluating-expressions" tabindex="-1"><a class="header-anchor" href="#functional-languages-are-based-on-evaluating-expressions"><span>Functional languages are based on evaluating expressions.</span></a></h4><ul><li>Expressions are evaluated.</li><li>Expressions do not have an effect.</li></ul><h2 id="prolog" tabindex="-1"><a class="header-anchor" href="#prolog"><span>Prolog</span></a></h2><p>Prolog is a declarative programming language. It is based on logic programming and uses the predicate calculus.</p><div class="language-prolog line-numbers-mode" data-highlighter="shiki" data-ext="prolog" data-title="prolog" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">% import the test.pl file</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">% (A small part of) the British Royal family</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">% parent(queen_elizabeth, prince_charles).</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">% parent(prince_philip, prince_charles).</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">% parent(prince_charles, prince_william).</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">% parent(prince_charles, prince_harry).</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">% parent(princess_diana, prince_william).</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">% parent(princess_diana, prince_harry).</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">?- [test].</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">%queries</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">?- parent(prince_charles, prince_william).</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">% true</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">% This query asks: of whom Prince Charles is a parent?</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">?- parent(prince_charles, X)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>If there is more than one answer to the query, Prolog prints them one at a time, pausing to see if more solutions are wanted. Typing semicolon asks for more solutions; just hitting enter (return) finishes without more solutions.</li></ul><h3 id="rules" tabindex="-1"><a class="header-anchor" href="#rules"><span>Rules</span></a></h3><p><strong>Rules need to be written in the file .pl</strong></p><div class="language-prolog line-numbers-mode" data-highlighter="shiki" data-ext="prolog" data-title="prolog" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">% “X is grandparent of Z if X is parent of Y and Y is parent of Z .”</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">grandparent</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">X</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">Z</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">:-</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> parent(</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">X</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">Y</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">), parent(</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">Y</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">Z</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">.</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>Rules can be recursive. Prolog has no looping constructs, so recursion is widely used.</li></ul><div class="language-prolog line-numbers-mode" data-highlighter="shiki" data-ext="prolog" data-title="prolog" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">% A person’s ancestors are their parents and the ancestors of their parents.</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">ancestor</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">Anc</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">Desc</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">:-</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">parent(</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">Parent</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">Desc</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">),ancestor(</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">Anc</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">Parent</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">.</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="equality" tabindex="-1"><a class="header-anchor" href="#equality"><span>Equality</span></a></h3><ul><li>Equality in Prolog, written “=” and used as an infix operator, can be used both to bind variables and to check for equality. Prolog is a single-assignment language: once bound, a variable cannot be reassigned.</li></ul><h3 id="disjunction-and-conjunction" tabindex="-1"><a class="header-anchor" href="#disjunction-and-conjunction"><span>Disjunction and Conjunction</span></a></h3><ul><li>Goals can be combined with disjunction (or) as well as conjunction (and). Disjunction is written “;” and used as an infix operator. Conjunction (“,”) has higher precedence (binds tighter) than disjunction, but parentheses can be used to achieve the desired precedence.</li></ul><h3 id="negation" tabindex="-1"><a class="header-anchor" href="#negation"><span>Negation</span></a></h3><ul><li>Negation in Prolog is written “+” and used as a prefix operator. Negation has higher (tighter) precedence than both conjunction and disjunction. Be sure to leave a space between the + and an open parenthesis.</li></ul><div class="language-prolog line-numbers-mode" data-highlighter="shiki" data-ext="prolog" data-title="prolog" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">% Who are the parents of Prince William other than Prince Charles?</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">?- parent(X, prince_william), \\+ X = prince_charles.</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">X</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> = </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">princess_diana</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">.</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>Disequality in Prolog is written as an infix “=”. So X = Y is the same as + X = Y.</li></ul><h3 id="closed-world-assumption" tabindex="-1"><a class="header-anchor" href="#closed-world-assumption"><span>Closed World Assumption</span></a></h3><ul><li>Prolog assumes that all terms are true, unless explicitly stated otherwise. This is called the closed world assumption (CWA). <strong>This means that if a term is not mentioned in the program, it is assumed to be false</strong>. This can be a problem if the program is used to reason about real-world situations, where some terms may be unknown or undecidable.</li></ul><div class="hint-container info"><p class="hint-container-title">Info</p><ol><li>Variables must start with an uppercase letter (A-Z) or _.</li><li>Atoms (constants) must start with a lowercase letter (a-z) or be enclosed in single quotes (&#39;...&#39;).</li><li>Prolog is strictly case-sensitive, so X and x are completely different!</li></ol></div><h2 id="week-2" tabindex="-1"><a class="header-anchor" href="#week-2"><span>Week 2</span></a></h2><h3 id="prolog-concepts" tabindex="-1"><a class="header-anchor" href="#prolog-concepts"><span>Prolog Concepts</span></a></h3><ul><li>In Prolog, all data structures are called term. A term can be atomic orcompound, or it can be a variable.</li><li>An atom begins with a lower case letter and follows with letters, digits and underscores</li><li>each compound term is a functor (sometimes called function symbol) followed by one or more arguments in parentheses, separated by commas.</li><li>List: [] is the empty list, [H | T] is a list with head H and tail T.</li><li>A variable is also a term. It denotes a single unknown term. A variable name begins with an upper case letter or underscore, followed by any number of letters, digits, and underscores.</li><li>Prolog is a single-assignment language: a variable can only be bound (assigned) once.</li><li>A term is a ground term if it contains no variables, and it is a nonground term if it contains at least one variable.</li><li>A substitution is a mapping from variables to terms.Any ground Prolog term has only one instance, while a nonground Prolog terms has an infinite number of instances.</li></ul><h3 id="proper-lists" tabindex="-1"><a class="header-anchor" href="#proper-lists"><span>Proper Lists</span></a></h3><ul><li>A proper list is either empty ([]) or not ([X | Y]), in which case, the tail of the list must be a proper list. We can define a predicate to recognise these.</li></ul><div class="language-prolog line-numbers-mode" data-highlighter="shiki" data-ext="prolog" data-title="prolog" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">proper_list</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">[]</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">.</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">proper_list</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">([</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">_</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">Head|</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">Tail</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">]) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">:-</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">proper_list(</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">Tail</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">.</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="append" tabindex="-1"><a class="header-anchor" href="#append"><span>Append</span></a></h3><ul><li>The append operation is used to concatenate two lists. It is defined as follows:</li></ul><div class="language-prolog line-numbers-mode" data-highlighter="shiki" data-ext="prolog" data-title="prolog" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">append</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">[]</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">C</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">C</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">.</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">append</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">([</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">A</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">|</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">B</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">], </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">C</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, [</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">A</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">|</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">BC</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">]) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">:-</span></span>\n<span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">append</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">B</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">C</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">BC</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">.</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="e-g-find-the-first-n-th-elements-of-a-list" tabindex="-1"><a class="header-anchor" href="#e-g-find-the-first-n-th-elements-of-a-list"><span>e.g. Find the first n th elements of a list</span></a></h3><div class="language-prolog line-numbers-mode" data-highlighter="shiki" data-ext="prolog" data-title="prolog" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">% Find the first n th elements of a list</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">take</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">N</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">List</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">Front</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">:-</span></span>\n<span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">length</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">Front</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">N</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">),</span></span>\n<span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">append</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">Front</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">_</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">List</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">.</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="arithmetic" tabindex="-1"><a class="header-anchor" href="#arithmetic"><span>Arithmetic</span></a></h3><ul><li>Use the built-in predicate is/2 (an infix operator) evaluates expressions. <img src="'+t+'" alt="Prolog Arithmetic Expressions" loading="lazy"></li></ul><h3 id="logic-and-resolution" tabindex="-1"><a class="header-anchor" href="#logic-and-resolution"><span>Logic and Resolution</span></a></h3><h4 id="_1-resolution-method-resolution" tabindex="-1"><a class="header-anchor" href="#_1-resolution-method-resolution"><span>1. <strong>Resolution Method (Resolution)</strong>:</span></a></h4><p>Resolution is an inference method used in automated reasoning systems (like Prolog). It works by applying facts and rules to a goal, simplifying the goal until it becomes either a tautology or a contradiction.</p><h4 id="_2-rules-and-facts" tabindex="-1"><a class="header-anchor" href="#_2-rules-and-facts"><span>2. <strong>Rules and Facts</strong>:</span></a></h4><ul><li><strong>Facts</strong> are known true statements.</li><li><strong>Rules</strong> are conditional inferences and are written in the form of <code>head :- body</code>. This means if <code>body</code> is true, then <code>head</code> is true.</li></ul><h4 id="_3-resolution-algorithm" tabindex="-1"><a class="header-anchor" href="#_3-resolution-algorithm"><span>3. <strong>Resolution Algorithm</strong>:</span></a></h4><ul><li>The core of the resolution method is to use <strong>proof by contradiction</strong> (driving reasoning through negation of the goal).</li><li>It simplifies the goal by matching it with rules and facts in the program until a conclusion is reached, or no solution is found.</li></ul><h4 id="_4-specific-process" tabindex="-1"><a class="header-anchor" href="#_4-specific-process"><span>4. <strong>Specific Process</strong>:</span></a></h4><ul><li>Select a clause and attempt to match it with the goal.</li><li>Use logical reasoning to reduce the goal until it is either true (tautology) or false (contradiction). If the goal is true, a solution has been found. If false, there is no solution.</li></ul><h4 id="summary" tabindex="-1"><a class="header-anchor" href="#summary"><span>Summary:</span></a></h4><p>Resolution in Prolog is used to derive a goal step by step by applying rules, rather than directly &quot;computing&quot; the result. It is a <strong>logic programming</strong> approach based on inference.</p><h2 id="week-3" tabindex="-1"><a class="header-anchor" href="#week-3"><span>Week 3</span></a></h2><h3 id="debugger" tabindex="-1"><a class="header-anchor" href="#debugger"><span>Debugger</span></a></h3><ul><li>The debugger prints the current port, execution depth, and goal (with the current variable bindings) at each step.</li><li>use <code>trace.</code> to start tracing, and <code>notrace.</code> to stop tracing. <code>creep</code> can be used to step through the program one step at a time.</li><li>Bird box model: the debugger shows the current state of the program, and the user can selectively step through the program to examine the intermediate states.</li></ul><h3 id="infinite-backtracking-loop" tabindex="-1"><a class="header-anchor" href="#infinite-backtracking-loop"><span>Infinite backtracking loop</span></a></h3><ul><li>If a goal cannot be proven, Prolog will backtrack and try other possibilities. This can lead to an infinite loop.</li><li>To avoid this, we can use the <code>once</code> predicate, which will try to prove the goal once, and fail if it cannot be proven。</li></ul><h3 id="tail-recursion" tabindex="-1"><a class="header-anchor" href="#tail-recursion"><span>Tail Recursion</span></a></h3><ul><li><p>Tail recursion is a special case of recursion where the recursive call is the last operation performed in the function.</p></li><li><p>Efficiency: Tail recursion helps to avoid adding stack frames with each recursive call, thereby reducing memory consumption. Especially with deep recursion, it can prevent stack overflow errors.</p></li><li><p>Optimization: Some Prolog implementations can optimize tail-recursive predicates by reusing the same stack frame, making the performance of tail recursion as efficient as iterative solutions.</p></li><li><p>We make factorial tail recursive by introducing an accumulating parameter, or just an accumulator. This is an extra parameter to the predicate that holds a partially computed result.</p></li></ul>',59)]))}]]),r=JSON.parse('{"path":"/posts/unimelb/COMP90048.html","title":"Declarative Programming (COMP90048)","lang":"en-US","frontmatter":{"icon":"pen-to-square","date":"2025-03-02T00:00:00.000Z","category":["Learning Records"],"tag":["Unimelb"],"description":"Declarative Programming (COMP90048) Week 1 Imperative languages are based on commands, in the form of instructions and statements. Commands are executed. Commands have an effect...","head":[["meta",{"property":"og:url","content":"https://crc011220.github.io/personalweb/personalweb/posts/unimelb/COMP90048.html"}],["meta",{"property":"og:site_name","content":"Richard Chen"}],["meta",{"property":"og:title","content":"Declarative Programming (COMP90048)"}],["meta",{"property":"og:description","content":"Declarative Programming (COMP90048) Week 1 Imperative languages are based on commands, in the form of instructions and statements. Commands are executed. Commands have an effect..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2025-03-24T06:44:56.000Z"}],["meta",{"property":"article:tag","content":"Unimelb"}],["meta",{"property":"article:published_time","content":"2025-03-02T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-24T06:44:56.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Declarative Programming (COMP90048)\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-03-02T00:00:00.000Z\\",\\"dateModified\\":\\"2025-03-24T06:44:56.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Richard Chen\\"}]}"]]},"headers":[{"level":2,"title":"Week 1","slug":"week-1","link":"#week-1","children":[]},{"level":2,"title":"Prolog","slug":"prolog","link":"#prolog","children":[{"level":3,"title":"Rules","slug":"rules","link":"#rules","children":[]},{"level":3,"title":"Equality","slug":"equality","link":"#equality","children":[]},{"level":3,"title":"Disjunction and Conjunction","slug":"disjunction-and-conjunction","link":"#disjunction-and-conjunction","children":[]},{"level":3,"title":"Negation","slug":"negation","link":"#negation","children":[]},{"level":3,"title":"Closed World Assumption","slug":"closed-world-assumption","link":"#closed-world-assumption","children":[]}]},{"level":2,"title":"Week 2","slug":"week-2","link":"#week-2","children":[{"level":3,"title":"Prolog Concepts","slug":"prolog-concepts","link":"#prolog-concepts","children":[]},{"level":3,"title":"Proper Lists","slug":"proper-lists","link":"#proper-lists","children":[]},{"level":3,"title":"Append","slug":"append","link":"#append","children":[]},{"level":3,"title":"e.g. Find the first n th elements of a list","slug":"e-g-find-the-first-n-th-elements-of-a-list","link":"#e-g-find-the-first-n-th-elements-of-a-list","children":[]},{"level":3,"title":"Arithmetic","slug":"arithmetic","link":"#arithmetic","children":[]},{"level":3,"title":"Logic and Resolution","slug":"logic-and-resolution","link":"#logic-and-resolution","children":[]}]},{"level":2,"title":"Week 3","slug":"week-3","link":"#week-3","children":[{"level":3,"title":"Debugger","slug":"debugger","link":"#debugger","children":[]},{"level":3,"title":"Infinite backtracking loop","slug":"infinite-backtracking-loop","link":"#infinite-backtracking-loop","children":[]},{"level":3,"title":"Tail Recursion","slug":"tail-recursion","link":"#tail-recursion","children":[]}]}],"git":{"createdTime":1740916663000,"updatedTime":1742798696000,"contributors":[{"name":"Ruochen Chen","email":"ruocchen1220@gmail.com","commits":3}]},"readingTime":{"minutes":4.23,"words":1268},"filePathRelative":"posts/unimelb/COMP90048.md","localizedDate":"March 2, 2025","excerpt":"\\n<h2>Week 1</h2>\\n<h4>Imperative languages are based on commands, in the form of instructions and statements.</h4>\\n<ul>\\n<li>Commands are executed.</li>\\n<li>Commands have an effect, such as to update the computation state,and later code may depend on this update.</li>\\n</ul>\\n<h4>Logic programming languages are based on finding values that satisfy a set of constraints.</h4>","autoDesc":true}')},6262:(i,s)=>{s.A=(i,s)=>{const e=i.__vccOpts||i;for(const[i,a]of s)e[i]=a;return e}}}]);