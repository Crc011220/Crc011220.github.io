"use strict";(self.webpackChunkpersonalweb=self.webpackChunkpersonalweb||[]).push([[4876],{1942:(t,d,e)=>{e.r(d),e.d(d,{comp:()=>c,data:()=>i});var o=e(641);const r={},c=(0,e(6262).A)(r,[["render",function(t,d){return(0,o.uX)(),(0,o.CE)("div",null,d[0]||(d[0]=[(0,o.Fv)('<h2 id="动态规划" tabindex="-1"><a class="header-anchor" href="#动态规划"><span>动态规划</span></a></h2><h3 id="背包问题" tabindex="-1"><a class="header-anchor" href="#背包问题"><span>背包问题</span></a></h3><table><thead><tr><th>背包类型</th><th>问题类型</th><th>推荐数组类型</th><th>遍历顺序</th><th>是否倒序容量</th><th>状态转移方程</th></tr></thead><tbody><tr><td>01背包</td><td>价值最大</td><td>一维 / 二维</td><td>先物品，再容量</td><td>✅（一维需要）❌（二维不需要）</td><td><code>dp[j] = max(dp[j], dp[j-w] + v)</code></td></tr><tr><td>完全背包</td><td>价值最大</td><td>一维 / 二维</td><td>先物品，再容量（正序）</td><td>❌</td><td><code>dp[j] = max(dp[j], dp[j-w] + v)</code></td></tr><tr><td>完全背包</td><td>组合数</td><td>一维 / 二维</td><td>先物品，再容量（正序）</td><td>❌</td><td><code>dp[j] += dp[j-w]</code></td></tr><tr><td>完全背包</td><td>排列数</td><td>一维</td><td>先容量，再物品（正序）</td><td>❌</td><td><code>dp[j] += dp[j-w]</code></td></tr></tbody></table><pre><code>                            |\n</code></pre><ul><li>✅ 01背包一维数组要倒序，防止同一轮多次选同一个物品。</li><li>❌ 二维数组不需要倒序，因为每层是独立的，不会重复使用。</li><li>✅ 完全背包组合数是“先物品再容量”，保证每种组合只计算一次。</li><li>✅ 完全背包排列数是“先容量再物品”，考虑顺序不同的情况。</li></ul><h3 id="股票交易" tabindex="-1"><a class="header-anchor" href="#股票交易"><span>股票交易</span></a></h3><table><thead><tr><th>题号</th><th>限制条件</th><th>状态定义 <code>dp[i][k][h]</code></th><th>状态转移方程</th><th>初始状态</th></tr></thead><tbody><tr><td><strong>121</strong><br>买卖一次</td><td>最多 1 次交易</td><td><code>dp[i][0]</code>：不持股<br><code>dp[i][1]</code>：持股</td><td><code>dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])</code><br><code>dp[i][1] = max(dp[i-1][1], -prices[i])</code></td><td><code>dp[0][0] = 0</code><br><code>dp[0][1] = -prices[0]</code></td></tr><tr><td><strong>122</strong><br>无限次交易</td><td>不限制交易次数</td><td>同上</td><td><code>dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])</code><br><code>dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])</code></td><td>同上</td></tr><tr><td><strong>123</strong><br>最多 2 次</td><td><code>k=0/1/2</code>, 三维 （也可以枚举所有的dp数组）</td><td><code>dp[i][k][h]</code></td><td><code>dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])</code><br><code>dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])</code></td><td>初始化 <code>dp[0][k][1] = -prices[0]</code>，<code>dp[0][k][0] = 0</code></td></tr><tr><td><strong>188</strong><br>最多 k 次交易</td><td>任意 k 值</td><td>同上, 必须三维因为无法枚举</td><td>同 123</td><td>同 123</td></tr><tr><td><strong>309</strong><br>含冷冻期</td><td>卖出后 1 天不能买入</td><td><code>dp[i][0]</code>：不持股<br><code>dp[i][1]</code>：持股<br><code>dp[i][2]</code>：冷冻期</td><td><code>dp[i][0] = max(dp[i-1][0], dp[i-1][2])</code><br><code>dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])</code><br><code>dp[i][2] = dp[i-1][1] + prices[i]</code></td><td><code>dp[0][0] = 0</code>, <code>dp[0][1] = -prices[0]</code>, <code>dp[0][2] = 0</code></td></tr><tr><td><strong>714</strong><br>含手续费</td><td>每次交易扣 fee</td><td><code>dp[i][0]</code>：不持股<br><code>dp[i][1]</code>：持股</td><td><code>dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i] - fee)</code><br><code>dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])</code></td><td>同 121</td></tr></tbody></table>',7)]))}]]),i=JSON.parse('{"path":"/zh/posts/algo/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.html","title":"","lang":"zh-CN","frontmatter":{"icon":"pen-to-square","date":"2025-05-12T00:00:00.000Z","category":["Learning Records"],"tag":["Algorithm"],"description":"动态规划 背包问题 ✅ 01背包一维数组要倒序，防止同一轮多次选同一个物品。 ❌ 二维数组不需要倒序，因为每层是独立的，不会重复使用。 ✅ 完全背包组合数是“先物品再容量”，保证每种组合只计算一次。 ✅ 完全背包排列数是“先容量再物品”，考虑顺序不同的情况。 股票交易","head":[["meta",{"property":"og:url","content":"https://crc011220.github.io/zh/posts/algo/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.html"}],["meta",{"property":"og:site_name","content":"Richard Chen"}],["meta",{"property":"og:description","content":"动态规划 背包问题 ✅ 01背包一维数组要倒序，防止同一轮多次选同一个物品。 ❌ 二维数组不需要倒序，因为每层是独立的，不会重复使用。 ✅ 完全背包组合数是“先物品再容量”，保证每种组合只计算一次。 ✅ 完全背包排列数是“先容量再物品”，考虑顺序不同的情况。 股票交易"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-05-12T12:41:35.000Z"}],["meta",{"property":"article:tag","content":"Algorithm"}],["meta",{"property":"article:published_time","content":"2025-05-12T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-05-12T12:41:35.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-05-12T00:00:00.000Z\\",\\"dateModified\\":\\"2025-05-12T12:41:35.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Richard Chen\\"}]}"]]},"headers":[{"level":2,"title":"动态规划","slug":"动态规划","link":"#动态规划","children":[{"level":3,"title":"背包问题","slug":"背包问题","link":"#背包问题","children":[]},{"level":3,"title":"股票交易","slug":"股票交易","link":"#股票交易","children":[]}]}],"git":{"createdTime":1747053695000,"updatedTime":1747053695000,"contributors":[{"name":"Ruochen Chen","email":"ruocchen1220@gmail.com","commits":1}]},"readingTime":{"minutes":2.12,"words":635},"filePathRelative":"zh/posts/algo/动态规划.md","localizedDate":"2025年5月12日","excerpt":"<h2>动态规划</h2>\\n<h3>背包问题</h3>\\n<table>\\n<thead>\\n<tr>\\n<th>背包类型</th>\\n<th>问题类型</th>\\n<th>推荐数组类型</th>\\n<th>遍历顺序</th>\\n<th>是否倒序容量</th>\\n<th>状态转移方程</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>01背包</td>\\n<td>价值最大</td>\\n<td>一维 / 二维</td>\\n<td>先物品，再容量</td>\\n<td>✅（一维需要）❌（二维不需要）</td>\\n<td><code>dp[j] = max(dp[j], dp[j-w] + v)</code></td>\\n</tr>\\n<tr>\\n<td>完全背包</td>\\n<td>价值最大</td>\\n<td>一维 / 二维</td>\\n<td>先物品，再容量（正序）</td>\\n<td>❌</td>\\n<td><code>dp[j] = max(dp[j], dp[j-w] + v)</code></td>\\n</tr>\\n<tr>\\n<td>完全背包</td>\\n<td>组合数</td>\\n<td>一维 / 二维</td>\\n<td>先物品，再容量（正序）</td>\\n<td>❌</td>\\n<td><code>dp[j] += dp[j-w]</code></td>\\n</tr>\\n<tr>\\n<td>完全背包</td>\\n<td>排列数</td>\\n<td>一维</td>\\n<td>先容量，再物品（正序）</td>\\n<td>❌</td>\\n<td><code>dp[j] += dp[j-w]</code></td>\\n</tr>\\n</tbody>\\n</table>","autoDesc":true}')},6262:(t,d)=>{d.A=(t,d)=>{const e=t.__vccOpts||t;for(const[t,o]of d)e[t]=o;return e}}}]);