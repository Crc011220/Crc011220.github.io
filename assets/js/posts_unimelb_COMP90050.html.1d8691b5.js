"use strict";(self.webpackChunkpersonalweb=self.webpackChunkpersonalweb||[]).push([[9340],{4201:(t,e,a)=>{a.r(e),a.d(e,{comp:()=>d,data:()=>l});var i=a(641);const n=a.p+"assets/img/memory-hierarchy.7001c79d.png",r=a.p+"assets/img/memory-hierarchy-model.12c863eb.png",o=a.p+"assets/img/hashing.0f59ebe0.png",s={},d=(0,a(6262).A)(s,[["render",function(t,e){const a=(0,i.g2)("RouteLink");return(0,i.uX)(),(0,i.CE)("div",null,[e[8]||(e[8]=(0,i.Fv)('<h1 id="advanced-database-systems-comp90050" tabindex="-1"><a class="header-anchor" href="#advanced-database-systems-comp90050"><span>Advanced Database Systems (COMP90050)</span></a></h1><h2 id="week-1" tabindex="-1"><a class="header-anchor" href="#week-1"><span>Week 1</span></a></h2><h3 id="modelling-disk-access" tabindex="-1"><a class="header-anchor" href="#modelling-disk-access"><span>Modelling Disk Access</span></a></h3><p>Disk access time = seek time + rotational delay + (transfer length / bandwidth)</p><ul><li>Seek time: the time it takes to locate the requested sector on the disk.</li><li>Rotational delay: the time it takes to rotate the disk to the correct position.</li><li>Transfer length: the number of bytes to be transferred.</li><li>Bandwidth: the maximum rate of data transfer.</li></ul><h3 id="hdd-vs-ssd" tabindex="-1"><a class="header-anchor" href="#hdd-vs-ssd"><span>HDD vs SSD</span></a></h3><table><thead><tr><th><strong>Feature</strong></th><th><strong>HDD</strong></th><th><strong>SSD</strong></th></tr></thead><tbody><tr><td><strong>Storage Type</strong></td><td>Magnetic disks</td><td>Flash memory</td></tr><tr><td><strong>Speed</strong></td><td>Slower (100MB/s to 200MB/s)</td><td>Faster (500MB/s to 5000MB/s+)</td></tr><tr><td><strong>Durability</strong></td><td>Less durable, susceptible to damage</td><td>More durable, resistant to shocks</td></tr><tr><td><strong>Capacity</strong></td><td>Larger capacities (up to 10TB+)</td><td>Smaller capacities (up to 4TB+)</td></tr><tr><td><strong>Noise</strong></td><td>Noisy due to moving parts</td><td>Silent</td></tr><tr><td><strong>Power Consumption</strong></td><td>Higher power consumption</td><td>Lower power consumption</td></tr><tr><td><strong>Cost</strong></td><td>More affordable for large storage</td><td>More expensive per GB</td></tr></tbody></table><ul><li>SSD do not have seek and rotation delays.</li><li>Moore’s law: memory chip capacity doubles every 18 months since 1970</li><li>Joy’s law for processors: processor performance doubles every two years since 1984</li></ul><figure><img src="'+n+'" alt="Memory Hierarchy" tabindex="0" loading="lazy"><figcaption>Memory Hierarchy</figcaption></figure><figure><img src="'+r+'" alt="Memory Hierarchy Model" tabindex="0" loading="lazy"><figcaption>Memory Hierarchy Model</figcaption></figure><h3 id="disk-access-time" tabindex="-1"><a class="header-anchor" href="#disk-access-time"><span>Disk Access Time</span></a></h3><ol><li>For HDD:</li></ol><ul><li>Disk Access Time = Seek Time + Rotational Delay + Transfer Time</li></ul><ol start="2"><li>For SSD:</li></ol><ul><li>Disk Access Time = Transfer Time</li></ul><ol start="3"><li>For both, Transfer Time = Transfer Length / Bandwidth</li></ol><h3 id="hit-ratio" tabindex="-1"><a class="header-anchor" href="#hit-ratio"><span>Hit Ratio</span></a></h3><ul><li>Hit ratio = (Number of hits) / (Number of requests)</li><li>Hit ratio (HR): the percentage of requests that are satisfied by the buffer.</li><li>If the hit ratio (HB) is high, the effective access time (EA) will be closer to the buffer access time (BC), meaning accessing data will generally be fast.</li><li>If the hit ratio is low, the access time will be closer to the disk access time (D), meaning it will take longer to access the data, as more requests will result in disk accesses instead of buffer hits.</li><li>Effective memory access time, EA = H*C+(1-H)*M,where H = hit ratio, C = cache access time; M = memory access time</li></ul><h2 id="week-2" tabindex="-1"><a class="header-anchor" href="#week-2"><span>Week 2</span></a></h2><h3 id="storage-area-networks-sans" tabindex="-1"><a class="header-anchor" href="#storage-area-networks-sans"><span>Storage Area Networks (SANs)</span></a></h3><ul><li>A SAN is a network of storage devices that provides a single logical storage space to multiple hosts.</li><li>SANs are used to increase storage capacity, availability, and performance.</li><li>They are used for shared-disk file systems</li><li>They regularly also allow for automated back up functionality</li><li>It was the fundamental storage for data center type systems with mainframes for decades</li><li>Different versions evolved over time to allow for more data but fundamentals are the same even today</li><li>They came with their own networking capabilities</li><li>We visit a version of these when we see what can be done about failures</li><li>In a nutshell failure probability of one disk is different to 100s of disks which requires design choices</li></ul><h3 id="deductive-database-systems-ddbs" tabindex="-1"><a class="header-anchor" href="#deductive-database-systems-ddbs"><span>Deductive database systems (DDBS)</span></a></h3><ul><li>e.g. prolog</li></ul><hr><h3 id="comparison-table-between-nested-loop-join-and-block-nested-loop-join" tabindex="-1"><a class="header-anchor" href="#comparison-table-between-nested-loop-join-and-block-nested-loop-join"><span>Comparison Table between Nested Loop Join and Block Nested-Loop Join</span></a></h3><table><thead><tr><th>Criteria</th><th>Nested Loop Join (NLJ)</th><th>Block Nested-Loop Join (BNLJ)</th></tr></thead><tbody><tr><td><strong>Data Access Level</strong></td><td>Record-by-record</td><td>Block-by-block</td></tr><tr><td><strong>I/O Cost</strong></td><td>High</td><td>Reduced</td></tr><tr><td><strong>Seeks</strong></td><td>High</td><td>Lower</td></tr><tr><td><strong>Memory Requirement</strong></td><td>Low</td><td>Higher (requires memory to store a block)</td></tr><tr><td><strong>Best for</strong></td><td>Small tables or indexed joins</td><td>Large tables with limited memory</td></tr><tr><td><strong>Performance</strong></td><td>Poor for large tables</td><td>Better for large tables</td></tr></tbody></table><h3 id="worst-case-cost-estimation" tabindex="-1"><a class="header-anchor" href="#worst-case-cost-estimation"><span>Worst Case Cost Estimation</span></a></h3><ul><li><p>r is called the outer relation and s is the inner relation of the join. In the worst case, if there is enough memory only to hold one block of each table, the estimated cost is:</p></li><li><p><strong>Block Transfers</strong>:<br> [ n_r \\times b_s + b_r ]</p></li><li><p><strong>Seeks</strong>:<br> [ n_r + b_r ]</p></li></ul><h4 id="calculation-example" tabindex="-1"><a class="header-anchor" href="#calculation-example"><span>Calculation Example</span></a></h4><h4 id="given" tabindex="-1"><a class="header-anchor" href="#given"><span><strong>Given:</strong></span></a></h4><table><thead><tr><th>Table</th><th>Records</th><th>Blocks</th></tr></thead><tbody><tr><td><code>customer</code></td><td>10,000</td><td>400</td></tr><tr><td><code>depositor</code></td><td>5,000</td><td>100</td></tr></tbody></table><h4 id="costs" tabindex="-1"><a class="header-anchor" href="#costs"><span><strong>Costs:</strong></span></a></h4><table><thead><tr><th>Method</th><th>Block Transfers</th><th>Seeks</th></tr></thead><tbody><tr><td><strong>Nested Loop Join</strong></td><td>( 10,000 \\times 100 + 400 = 1,000,400 )</td><td>( 10,000 + 400 = 10,400 )</td></tr><tr><td><strong>Block Nested-Loop Join</strong></td><td>( 400 \\times 100 = 40,000 )</td><td>( 400 + 100 = 500 )</td></tr></tbody></table><h3 id="other-join-comparison" tabindex="-1"><a class="header-anchor" href="#other-join-comparison"><span>Other Join Comparison</span></a></h3><table><thead><tr><th>Criteria</th><th>Nested-Loop Join</th><th>Block Nested-Loop Join</th><th>Indexed Nested-Loop Join</th><th>Merge Join</th><th>Hash Join</th></tr></thead><tbody><tr><td><strong>Data Access Level</strong></td><td>Record-by-record</td><td>Block-by-block</td><td>Record-by-record (with index)</td><td>Sort and merge</td><td>Partitioning and hashing</td></tr><tr><td><strong>I/O Cost</strong></td><td>High</td><td>Reduced</td><td>Low</td><td>Low</td><td>Low</td></tr><tr><td><strong>Seeks</strong></td><td>High</td><td>Lower</td><td>Low</td><td>Low</td><td>Low</td></tr><tr><td><strong>Memory Requirement</strong></td><td>Low</td><td>Higher (for block storage)</td><td>Low</td><td>Moderate</td><td>High</td></tr><tr><td><strong>Best for</strong></td><td>Small tables or indexed joins</td><td>Large tables with limited memory</td><td>When the inner table has an index</td><td>When both tables are sorted</td><td>Large tables where sorting is expensive</td></tr><tr><td><strong>Performance</strong></td><td>Poor for large tables</td><td>Better for large tables</td><td>Efficient when an index exists</td><td>Very efficient for sorted data</td><td>Efficient when no natural order of data exists</td></tr></tbody></table><h2 id="week-3" tabindex="-1"><a class="header-anchor" href="#week-3"><span>Week 3</span></a></h2><ul><li>Sql query will be convert to relational algebra and then convert to physical plan.</li><li>Left deep join: the left table is processed first, then the right table is processed. This is what the optimizer will do by default.</li></ul><h3 id="heuristic-optimization-techniques" tabindex="-1"><a class="header-anchor" href="#heuristic-optimization-techniques"><span>Heuristic optimization techniques</span></a></h3><ul><li>Perform selections early (reduces the number of tuples)</li><li>Perform projections early (reduces the number of attributes)</li><li>Perform most restrictive selection and join operations (i.e. with smallest result size) before other similar operations</li><li>Optimizers often use simple heuristics for very cheap queries, and perform exhaustive enumeration for more expensive queries</li></ul><h3 id="indexing" tabindex="-1"><a class="header-anchor" href="#indexing"><span>Indexing</span></a></h3><ul><li>Indexing mechanisms used to speed up access to desired data in a similar way to look up in a phone book</li><li>Search Key - attribute or set of attributes used to look up records/rows in a system, like an ID of a person</li><li>An index file consists of records (called index entries) of the form search-key, pointer to where data is</li><li>Index files are typically much smaller than the original data files and many parts of it are already in memory</li></ul><h4 id="order-indices" tabindex="-1"><a class="header-anchor" href="#order-indices"><span>Order indices</span></a></h4><p>search keys are stored in some order</p><h4 id="hash-indices" tabindex="-1"><a class="header-anchor" href="#hash-indices"><span>Hash indices</span></a></h4><p>search keys are distributed hopefully uniformly across “buckets” using a “function”</p><h3 id="b-tree" tabindex="-1"><a class="header-anchor" href="#b-tree"><span>B+ Tree</span></a></h3>',46)),(0,i.Lk)("ul",null,[(0,i.Lk)("li",null,[e[1]||(e[1]=(0,i.eW)("InnoDB ")),(0,i.bF)(a,{to:"/posts/clich%C3%A9/2.html"},{default:(0,i.k6)((()=>e[0]||(e[0]=[(0,i.eW)("Check this out")]))),_:1})])]),e[9]||(e[9]=(0,i.Fv)('<h2 id="week-4" tabindex="-1"><a class="header-anchor" href="#week-4"><span>Week 4</span></a></h2><h3 id="hash-indexing" tabindex="-1"><a class="header-anchor" href="#hash-indexing"><span>Hash Indexing</span></a></h3><ul><li>Hashing is a technique used to map data of an arbitrary size to a fixed-size value, typically a number.</li><li>The hash function takes an input of any size and produces a fixed-size output.</li><li>The hash function should be deterministic, meaning that it should always produce the same output for the same input. <img src="'+o+'" alt="Hash Indexing" loading="lazy"></li></ul><h3 id="bitmap-indexing" tabindex="-1"><a class="header-anchor" href="#bitmap-indexing"><span>Bitmap Indexing</span></a></h3>',4)),(0,i.Lk)("ul",null,[e[5]||(e[5]=(0,i.Lk)("li",null,"A bitmap index is a data structure that stores a set of values in a compact form, allowing for fast and efficient retrieval of values that match a given condition.",-1)),e[6]||(e[6]=(0,i.Lk)("li",null,"A bitmap index is a special type of index that stores a set of values in a bitmap, where each bit represents a value in the index.",-1)),e[7]||(e[7]=(0,i.Lk)("li",null,"A bitmap index is used to quickly locate the values that match a given condition, without having to search through the entire index.",-1)),(0,i.Lk)("li",null,[e[3]||(e[3]=(0,i.eW)("A bitmap index is typically used to speed up queries that involve a large number of values that are stored in a database. ")),(0,i.bF)(a,{to:"/posts/clich%C3%A9/12.html"},{default:(0,i.k6)((()=>e[2]||(e[2]=[(0,i.eW)("Check This Out")]))),_:1}),e[4]||(e[4]=(0,i.eW)(")"))])]),e[10]||(e[10]=(0,i.Fv)('<h3 id="index-structures-comparison" tabindex="-1"><a class="header-anchor" href="#index-structures-comparison"><span>Index Structures Comparison</span></a></h3><h3 id="index-structures-comparison-1" tabindex="-1"><a class="header-anchor" href="#index-structures-comparison-1"><span>Index Structures Comparison</span></a></h3><table><thead><tr><th>Index Type</th><th>Data Structure</th><th>Key Characteristics</th><th>Advantages</th><th>Disadvantages</th><th>Best Use Cases</th></tr></thead><tbody><tr><td>B+ Tree</td><td>Balanced Tree</td><td>Multi-way search tree<br>All data in leaf nodes</td><td>- Disk-friendly<br>- Efficient range queries<br>- Stable performance</td><td>- High insert/delete overhead<br>- Space consumption</td><td>Relational databases<br>Ordered data<br>Range queries</td></tr><tr><td>Hash Index</td><td>Hash Table</td><td>Direct mapping<br>Keys to storage locations</td><td>- Fast insertion<br>- O(1) equality queries<br>- Compact space</td><td>- No range queries<br>- Hash collisions<br>- Not order-preserving</td><td>Equality lookups<br>Caching<br>Unique identifiers</td></tr><tr><td>Bitmap Index</td><td>Bitmap array</td><td>Represent data existence via bits</td><td>- Compressed storage<br>- Fast bit operations<br>- Efficient aggregation</td><td>- High update cost<br>- Suitable for low-cardinality columns<br>- Space overhead</td><td>Data warehouses<br>Analytical queries<br>Low-mutation data</td></tr><tr><td>Quadtree</td><td>Tree-based spatial division</td><td>Recursive four-way space partitioning<br>2D spatial indexing</td><td>- Fast spatial queries<br>- Data clustering<br>- Recursive division</td><td>- Unbalanced depth<br>- Additional space overhead<br>- Dimension-limited</td><td>Geographic Information Systems<br>Spatial clustering<br>Collision detection</td></tr><tr><td>K-D Tree</td><td>Binary space partitioning</td><td>Multi-dimensional space recursive division</td><td>- High-dimensional space queries<br>- Nearest neighbor search<br>- Dynamic adjustment</td><td>- Complex construction<br>- Unstable performance<br>- Curse of dimensionality</td><td>Machine learning<br>Spatial clustering<br>High-dimensional data</td></tr><tr><td>R-Tree</td><td>Balanced tree for spatial data</td><td>Hierarchical minimum bounding rectangles</td><td>- Efficient multi-dimensional indexing<br>- Handles complex spatial queries<br>- Supports overlapping regions</td><td>- Higher computational complexity<br>- Overhead in updates<br>- Performance degrades with high dimensionality</td><td>Geographical databases<br>Spatial networks<br>Location-based services</td></tr><tr><td>R+ Tree</td><td>Variant of R-Tree</td><td>No overlapping node regions</td><td>- Improved query performance<br>- More precise spatial indexing<br>- Reduced search space</td><td>- More complex construction<br>- Higher maintenance cost<br>- Less flexible with irregular data</td><td>Advanced spatial databases<br>Precise geographic querying<br>Complex spatial analysis</td></tr></tbody></table><h4 id="in-depth-analysis" tabindex="-1"><a class="header-anchor" href="#in-depth-analysis"><span>In-Depth Analysis</span></a></h4><h4 id="b-tree-1" tabindex="-1"><a class="header-anchor" href="#b-tree-1"><span>B+ Tree</span></a></h4><ul><li>Widely used in database indexing</li><li>Maintains data order</li><li>Supports efficient range queries</li></ul><h4 id="hash-index" tabindex="-1"><a class="header-anchor" href="#hash-index"><span>Hash Index</span></a></h4><ul><li>Commonly used for fast key-value lookups</li><li>Trades space for query speed</li><li>Unsuitable for sorting-required scenarios</li></ul><h4 id="bitmap-index" tabindex="-1"><a class="header-anchor" href="#bitmap-index"><span>Bitmap Index</span></a></h4><ul><li>Compressed storage</li><li>Ideal for low-cardinality, infrequently updated data</li><li>Bit operations provide efficient aggregation</li></ul><h4 id="quadtree" tabindex="-1"><a class="header-anchor" href="#quadtree"><span>Quadtree</span></a></h4><ul><li>2D space specialized indexing</li><li>Recursive division improves query efficiency</li><li>Common in Geographic Information Systems</li></ul><h4 id="k-d-tree" tabindex="-1"><a class="header-anchor" href="#k-d-tree"><span>K-D Tree</span></a></h4><ul><li>Multi-dimensional space generic indexing</li><li>Effective method for high-dimensional data</li><li>Excellent for nearest neighbor search scenarios、</li></ul><h4 id="r-tree" tabindex="-1"><a class="header-anchor" href="#r-tree"><span>R-Tree</span></a></h4><ul><li>Designed for multi-dimensional indexing</li><li>Uses minimum bounding rectangles (MBR)</li><li>Key in spatial databases and GIS</li><li>Handles non-point spatial objects efficiently</li></ul><h4 id="r-tree-1" tabindex="-1"><a class="header-anchor" href="#r-tree-1"><span>R+ Tree</span></a></h4><ul><li>Addresses R-Tree&#39;s overlapping limitations</li><li>Ensures no node region overlap</li><li>Provides more precise spatial querying</li><li>Computational overhead for maintenance</li></ul><h2 id="week-5" tabindex="-1"><a class="header-anchor" href="#week-5"><span>Week 5</span></a></h2><h3 id="acid-properties" tabindex="-1"><a class="header-anchor" href="#acid-properties"><span>ACID Properties</span></a></h3><ul><li>Atomicity: A transaction is a single unit of work that either succeeds completely or fails completely.</li><li>Consistency: A transaction must maintain database consistency.</li><li>Isolation: Transactions should not interfere with each other.</li><li>Durability: Once a transaction is committed, it should remain committed even in the event of a system failure.</li></ul><h3 id="flat-transactions" tabindex="-1"><a class="header-anchor" href="#flat-transactions"><span>Flat Transactions</span></a></h3><ul><li>A flat transaction is a transaction that is executed as a single unit of work.</li><li>Flat transactions do not model many real applications</li><li>If a system fails during a flat transaction, all the changes are lost.</li></ul><h4 id="savepoints" tabindex="-1"><a class="header-anchor" href="#savepoints"><span>Savepoints</span></a></h4><ul><li>Savepoints are a mechanism that allows a transaction to create a savepoint before executing a set of statements.</li><li>If a system fails during a savepoint, all the changes made after the savepoint are lost.</li></ul><h2 id="week-6" tabindex="-1"><a class="header-anchor" href="#week-6"><span>Week 6</span></a></h2><h3 id="some-simple-concurrency-control-approaches" tabindex="-1"><a class="header-anchor" href="#some-simple-concurrency-control-approaches"><span>Some simple concurrency control approaches:</span></a></h3><ul><li>Dekker&#39;s algorithm (write some code to guarantee exclusive access) - needs almost no hardware support, but the code turns out to be complicated to implement especially for more than two transactions/processes</li><li>OS supported primitives (through interrupt calls) - expensive, independent of number of processes</li><li>Spin locks (using atomic lock/unlock instructions) –common</li></ul><h3 id="a-semaphore-is-a-more-general-concurrency-control-tool-more-flexible-than-a-lock-its-working-mechanism-can-be-understood-as" tabindex="-1"><a class="header-anchor" href="#a-semaphore-is-a-more-general-concurrency-control-tool-more-flexible-than-a-lock-its-working-mechanism-can-be-understood-as"><span>A semaphore is a more general concurrency control tool, more flexible than a lock. Its working mechanism can be understood as:</span></a></h3><ol><li>get(): Attempt to acquire the semaphore, if it is already occupied:</li></ol><ul><li>If no one is waiting, &quot;wait&quot;</li><li>If someone is waiting, add yourself to the waiting queue</li></ul><ol start="2"><li>give(): Release the semaphore, and:</li></ol><ul><li>If there is a waiting queue, wake up the first one (FIFO)</li></ul><table><thead><tr><th>Feature</th><th>Semaphore</th><th>Spin Lock</th></tr></thead><tbody><tr><td>Nature</td><td>Concurrency control mechanism (counting allowed)</td><td>A type of lock implementation</td></tr><tr><td>Thread Blocking</td><td>Yes (threads are put to sleep while waiting)</td><td>No (threads busy-wait without yielding CPU)</td></tr><tr><td>Suitable Scenarios</td><td>High-contention situations needing queuing</td><td>Short critical sections, context switch is expensive</td></tr><tr><td>CPU Usage</td><td>Low (waiting threads don&#39;t consume CPU)</td><td>High (waiting threads consume CPU while spinning)</td></tr><tr><td>Wake-up Mechanism</td><td>FIFO queue wakes the next waiting thread</td><td>No wake-up mechanism, relies on continuous retry</td></tr><tr><td>Counting Support</td><td>Yes (can manage multiple resources)</td><td>No (typically only supports 1 lock)</td></tr><tr><td>Risk of Deadlock</td><td>Yes (misuse can lead to deadlocks)</td><td>Yes (can hang if lock isn&#39;t properly released)</td></tr><tr><td>Typical Implementation</td><td>OS-level (e.g., P/V operations, wait queues)</td><td>Atomic variables + busy-loop (user/kernel space)</td></tr><tr><td>Language Primitives</td><td>Java&#39;s <code>Semaphore</code>, POSIX <code>sem_wait()</code></td><td>Atomic ops in C, custom SpinLock in Java</td></tr><tr><td>Reentrancy</td><td>Not reentrant by default</td><td>Not reentrant by default</td></tr></tbody></table><h4 id="semaphore-is-like-you-queue-up-and-wait-to-be-called" tabindex="-1"><a class="header-anchor" href="#semaphore-is-like-you-queue-up-and-wait-to-be-called"><span>Semaphore is like “you queue up and wait to be called”;</span></a></h4><h4 id="spin-lock-is-like-you-keep-knocking-on-the-door-until-someone-opens" tabindex="-1"><a class="header-anchor" href="#spin-lock-is-like-you-keep-knocking-on-the-door-until-someone-opens"><span>Spin Lock is like “you keep knocking on the door until someone opens”.</span></a></h4><h3 id="deadlock-solutions" tabindex="-1"><a class="header-anchor" href="#deadlock-solutions"><span>Deadlock solutions</span></a></h3><ul><li>Have enough resources so that no waiting occurs</li><li>Do not allow a process to wait long, simply rollback after a certain time</li><li>Linearly order the resources and request of resources should follow this order</li><li>Pre-declare all necessary resources</li><li>Periodically check the graph for cycles</li></ul><h2 id="week-7" tabindex="-1"><a class="header-anchor" href="#week-7"><span>Week 7</span></a></h2><ul><li>When dependency graph has cycles (circular dependencies) then there is a violation of isolation and a possibility of inconsistency</li><li>If two transactions have the same dependency graph, then they will have the same final state.</li></ul><h3 id="serial-history" tabindex="-1"><a class="header-anchor" href="#serial-history"><span>Serial History</span></a></h3><ol><li><strong>Definition of Isolated History</strong>: <ul><li>A history is considered isolated if and only if it is equivalent to a serial history.</li><li>In other words, all transactions are executed in a sequential order.</li></ul></li><li><strong>Definition of Serial History</strong>: <ul><li>A serial history is the result obtained by executing each transaction in sequence.</li></ul></li><li><strong>Outcome of N Transactions</strong>: <ul><li>N transactions can produce up to N! different serial histories.</li></ul></li><li><strong>Acceptability of Any Serial History</strong>: <ul><li>There is no need to worry about choosing which serial history to accept.</li></ul></li><li><strong>Concurrent Transaction Set</strong>: <ul><li>Therefore, creating a concurrent transaction set that is actually equivalent to a serial history will be isolated.</li></ul></li></ol><h3 id="bad-executions" tabindex="-1"><a class="header-anchor" href="#bad-executions"><span>Bad Executions</span></a></h3><ol><li><strong>Transaction Order</strong>: <ul><li>If transaction T1 is executed before transaction T2, it is denoted as T1 &lt;&lt; T2.</li></ul></li><li><strong>Before and After Sets</strong>: <ul><li>Before(T) = {T&#39; | T&#39; &lt;&lt; T}: Represents the set of all transactions executed before transaction T.</li><li>After(T) = {T&#39; | T &lt;&lt; T&#39;}: Represents the set of all transactions executed after transaction T.</li></ul></li><li><strong>Definition of Wormhole Transaction</strong>: <ul><li>If a transaction T&#39; belongs to both Before(T) and After(T), i.e., T&#39; ∈ Before(T) ∩ After(T), then T&#39; is called a wormhole transaction.</li><li>This implies the existence of a circular dependency relationship T &lt;&lt; T&#39; &lt;&lt; T.</li></ul></li><li><strong>Impact of Wormhole Transactions</strong>: <ul><li>The presence of wormhole transactions indicates that there is no good isolation between transactions, i.e., the conditions for serial execution are not met.</li><li>This situation can lead to cycles in the transaction dependency graph, thereby disrupting the isolation of transactions.</li></ul></li><li><strong>Wormhole Theorem</strong>: <ul><li>A history is isolated (isolated) if and only if it has no wormhole transactions.</li></ul></li></ol><h2 id="week-8" tabindex="-1"><a class="header-anchor" href="#week-8"><span>Week 8</span></a></h2><h3 id="lock-compatibility-matrix" tabindex="-1"><a class="header-anchor" href="#lock-compatibility-matrix"><span>Lock Compatibility Matrix</span></a></h3><h4 id="current-mode-of-lock" tabindex="-1"><a class="header-anchor" href="#current-mode-of-lock"><span>Current Mode of Lock</span></a></h4><table><thead><tr><th>Request</th><th>Free</th><th>Shared</th><th>Exclusive</th></tr></thead><tbody><tr><td><strong>Shared request (SLOCK)</strong> <br> Used to block others writing/modifying</td><td>Compatible <br> Request granted immediately <br> Changes Mode from Free to Shared</td><td>Compatible <br> Request granted immediately <br> Mode stays Shared</td><td>Conflict <br> Request delayed until the state becomes compatible <br> Mode stays Exclusive</td></tr><tr><td><strong>Exclusive request (XLOCK)</strong> <br> Used to block others reading or writing/modifying</td><td>Compatible <br> Request granted immediately <br> Changes Mode from Free to Exclusive</td><td>Conflict <br> Request delayed until the state becomes compatible <br> Mode stays Shared</td><td>Conflict <br> Request delayed until the state becomes compatible <br> Mode stays Exclusive</td></tr></tbody></table><h3 id="degrees-of-isolation" tabindex="-1"><a class="header-anchor" href="#degrees-of-isolation"><span>Degrees of Isolation</span></a></h3><table><thead><tr><th>Isolation Level</th><th>Problems Avoided</th><th>Description</th></tr></thead><tbody><tr><td><strong>Read Uncommitted</strong>（Read Uncommitted）</td><td>❌Dirty Read、❌Non-repeatable Read、❌Phantom Read</td><td>A transaction can read data that <strong>has not been committed</strong> by other transactions. The lowest level, data is not secure.</td></tr><tr><td><strong>Read Committed</strong>（Read Committed）</td><td>✅Dirty Read，❌Non-repeatable Read、❌Phantom Read</td><td>Can only read data that <strong>has been committed</strong> by other transactions. This is the default isolation level for SQL Server and Oracle.</td></tr><tr><td><strong>Repeatable Read</strong>（Repeatable Read）</td><td>✅Dirty Read、✅Non-repeatable Read，❌Phantom Read</td><td>The same row data will be read consistently within a transaction. This is the default level for MySQL InnoDB.</td></tr><tr><td><strong>Serializable</strong>（Serializable）</td><td>✅Dirty Read、✅Non-repeatable Read、✅Phantom Read</td><td>The highest isolation level, transactions are executed completely serially, with the lowest efficiency but the highest consistency. Usually implemented through locking or range query control.</td></tr></tbody></table><table><thead><tr><th>Exception</th><th>Explanation</th></tr></thead><tbody><tr><td><strong>Dirty Read（Dirty Read）</strong></td><td>A transaction reads data modified by <strong>an uncommitted transaction</strong>.</td></tr><tr><td><strong>Non-repeatable Read（Non-repeatable Read）</strong></td><td>A transaction reads the same data twice, with different results (because another transaction updated and committed the data).</td></tr><tr><td><strong>Phantom Read（Phantom Read）</strong></td><td>A transaction executes the same query twice, seeing &quot;phantom&quot; rows added (because another transaction inserted new rows).</td></tr></tbody></table><table><thead><tr><th>Isolation Level</th><th>Dirty Read</th><th>Non-repeatable Read</th><th>Phantom Read</th></tr></thead><tbody><tr><td>Read Uncommitted</td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td>Read Committed</td><td>❌</td><td>✅</td><td>✅</td></tr><tr><td>Repeatable Read</td><td>❌</td><td>❌</td><td>✅</td></tr><tr><td>Serializable</td><td>❌</td><td>❌</td><td>❌</td></tr></tbody></table><h3 id="granularity-of-locks" tabindex="-1"><a class="header-anchor" href="#granularity-of-locks"><span>Granularity of Locks</span></a></h3><table><thead><tr><th>Lock Granularity</th><th>Description</th><th>Concurrency</th><th>System Overhead</th></tr></thead><tbody><tr><td><strong>Database-level Lock</strong></td><td>Locks the entire database. The coarsest, suitable for management tools or backup operations.</td><td>Lowest</td><td>Smallest</td></tr><tr><td><strong>Table-level Lock (Table Lock)</strong></td><td>Locks an entire table, preventing other transactions from writing or reading and writing.</td><td>Low</td><td>Small</td></tr><tr><td><strong>Page-level Lock (Page Lock)</strong></td><td>Locks a page (e.g., 8KB) containing multiple rows. A compromise solution.</td><td>Medium</td><td>Medium</td></tr><tr><td><strong>Row-level Lock (Row Lock)</strong></td><td>Locks a single record/row, commonly used in OLTP systems.</td><td>High</td><td>High</td></tr><tr><td><strong>Column-level Lock (Column Lock)</strong></td><td>Locks a specific column, rarely used.</td><td>Highest</td><td>Highest</td></tr></tbody></table><h3 id="lock-type" tabindex="-1"><a class="header-anchor" href="#lock-type"><span>Lock Type</span></a></h3><table><thead><tr><th>Lock Type</th><th>Full Name</th><th>Description</th></tr></thead><tbody><tr><td><strong>X</strong></td><td>Exclusive Lock（Exclusive Lock）</td><td>Prevents other transactions from reading or modifying the resource. The transaction itself can read and write, while others cannot do anything. Used for write operations.</td></tr><tr><td><strong>S</strong></td><td>Shared Lock（Shared Lock）</td><td>Allows multiple transactions to read simultaneously, but cannot write. Used for read operations.</td></tr><tr><td><strong>U</strong></td><td>Update Lock（Update Lock）</td><td>A &quot;middle lock&quot; to prevent deadlocks, used in scenarios where a read is about to become a write. At most one U lock, other transactions can share reads but cannot write.</td></tr><tr><td><strong>IS</strong></td><td>Intent Shared（Intent Shared Lock）</td><td>Indicates that the transaction <strong>intends</strong> to add a shared lock at a finer granularity (e.g., row). Acts on table/page level.</td></tr><tr><td><strong>IX</strong></td><td>Intent Exclusive（Intent Exclusive Lock）</td><td>Indicates that the transaction <strong>intends</strong> to add an exclusive lock at a finer granularity. Allows multiple transactions to add exclusive locks at different granularity resources.</td></tr><tr><td><strong>SIX</strong></td><td>Shared with Intent Exclusive</td><td>Adds an S lock at the table level, allowing an X lock to be added at the <strong>row level</strong>. Typically, only one SIX lock can exist for a table.</td></tr></tbody></table><h3 id="two-version-locking-and-nested-transactions-and-locking" tabindex="-1"><a class="header-anchor" href="#two-version-locking-and-nested-transactions-and-locking"><span>Two-Version Locking and Nested Transactions and Locking</span></a></h3><table><thead><tr><th>Feature</th><th>Two-Version Locking</th><th>Nested Transactions and Locking</th></tr></thead><tbody><tr><td>Target</td><td>Enhance read-write concurrency</td><td>Manage lock semantics in nested transactions</td></tr><tr><td>Lock Policy</td><td>Write lock + multiple version data</td><td>Hierarchical lock management</td></tr><tr><td>Multi-Version Support</td><td>Yes（read old, write new）</td><td>No（traditional lock semantics）</td></tr><tr><td>Application Scenario</td><td>High concurrency read + light write scenarios</td><td>Complex process transactions, module transaction nesting</td></tr><tr><td>Read-Write Concurrency</td><td>High</td><td>Depends on lock granularity</td></tr><tr><td>Implementation Complexity</td><td>Medium to high</td><td>High</td></tr></tbody></table><h3 id="optimistic-concurrency-control-and-pessmistic-concurrency-control" tabindex="-1"><a class="header-anchor" href="#optimistic-concurrency-control-and-pessmistic-concurrency-control"><span>Optimistic Concurrency Control and Pessmistic Concurrency Control</span></a></h3><table><thead><tr><th>Feature</th><th>Optimistic Concurrency Control (OCC)</th><th>Pessimistic Concurrency Control (PCC)</th></tr></thead><tbody><tr><td>Basic Assumption</td><td>Conflicts rarely occur</td><td>Conflicts frequently occur</td></tr><tr><td>Locking Strategy</td><td>Transactions do not lock data, allowing free reading and modification</td><td>Transactions lock data when reading and modifying, preventing other transactions from accessing</td></tr><tr><td>Conflict Detection Timing</td><td>Conflict detection is performed when the transaction is committed</td><td>Conflict detection is performed during the execution of the transaction</td></tr><tr><td>Performance Impact</td><td>Reduces lock contention, improves concurrency performance</td><td>Increases lock contention, may reduce concurrency performance</td></tr><tr><td>Applicable Scenarios</td><td>Read-heavy, write-light, with few conflicts</td><td>Write-heavy, with many conflicts</td></tr><tr><td>Transaction Termination Frequency</td><td>May be high, because conflict detection is performed at commit time</td><td>Usually low, because conflicts are prevented during the execution of the transaction</td></tr><tr><td>Retry Overhead</td><td>May be high, because aborted transactions need to be retried</td><td>Usually low, because fewer conflicts lead to fewer aborted transactions</td></tr><tr><td>Implementation Technology</td><td>Version control, shadow pages, validation, etc</td><td>Locking mechanism (shared locks, exclusive locks, etc)</td></tr></tbody></table><h3 id="backward-validation-and-forward-validation" tabindex="-1"><a class="header-anchor" href="#backward-validation-and-forward-validation"><span>&quot;Backward Validation&quot; and &quot;Forward Validation&quot;</span></a></h3><table><thead><tr><th>Feature</th><th>Backward Validation</th><th>Forward Validation</th></tr></thead><tbody><tr><td>Definition</td><td>Starting from the result, inversely checking the correctness and rationality of the input data</td><td>Starting from the input data, forwardly predicting the accuracy and reliability of the result</td></tr><tr><td>Application Scenario</td><td>Used for debugging and diagnosing system failures, especially in finding the root cause of problems in complex systems</td><td>Used for evaluating the predictive ability of models, especially in machine learning and data analysis fields</td></tr><tr><td>Data Flow</td><td>From result to cause</td><td>From cause to result</td></tr><tr><td>Validation Process</td><td>Analyzing output results, tracing back to their causes and conditions</td><td>Based on known conditions and rules, deriving expected output results</td></tr><tr><td>Goal</td><td>Ensuring system stability and security</td><td>Improving model accuracy and generalization ability</td></tr><tr><td>Tools and Technologies</td><td>Fault diagnosis tools, log analysis, reverse engineering, etc.</td><td>Statistical methods, cross-validation, A/B testing, etc.</td></tr></tbody></table><h3 id="time-stamp-based-concurrency-control" tabindex="-1"><a class="header-anchor" href="#time-stamp-based-concurrency-control"><span>Time-stamp-based Concurrency Control</span></a></h3><table><thead><tr><th style="text-align:left;">Category</th><th style="text-align:left;">Specific Content</th><th style="text-align:left;">Explanation/Impact</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>Core Advantages</strong></td><td style="text-align:left;"><strong>Serializability Guarantee</strong></td><td style="text-align:left;">Ensures that the final result of concurrent transactions is equivalent to some serial execution order, thereby ensuring data consistency.</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;"><strong>Lock-Free</strong></td><td style="text-align:left;">Transactions typically do not acquire explicit locks during execution, reducing lock contention and waiting, theoretically improving performance in low-conflict environments.</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;"><strong>Transaction Isolation</strong></td><td style="text-align:left;">Ensures that transactions read data that conforms to the version order of their timestamps.</td></tr><tr><td style="text-align:left;"><strong>Core Disadvantages</strong></td><td style="text-align:left;"><strong>Transaction Abort and Restart</strong></td><td style="text-align:left;">Conflicts require transactions to be aborted and restarted, incurring additional overhead and resource waste, potentially reducing performance under high conflict conditions.</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;"><strong>Timestamp Management</strong></td><td style="text-align:left;">Requires a reliable mechanism to generate globally unique and monotonically increasing timestamps, which can be complex to implement.</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;"><strong>Implementation Complexity</strong></td><td style="text-align:left;">The implementation logic of TSCC is typically more complex than that of simple lock mechanisms.</td></tr></tbody></table>',64))])}]]),l=JSON.parse('{"path":"/posts/unimelb/COMP90050.html","title":"Advanced Database Systems (COMP90050)","lang":"en-US","frontmatter":{"icon":"pen-to-square","date":"2025-03-02T00:00:00.000Z","category":["Learning Records"],"tag":["Unimelb"],"description":"Advanced Database Systems (COMP90050) Week 1 Modelling Disk Access Disk access time = seek time + rotational delay + (transfer length / bandwidth) Seek time: the time it takes t...","head":[["meta",{"property":"og:url","content":"https://crc011220.github.io/personalweb/personalweb/posts/unimelb/COMP90050.html"}],["meta",{"property":"og:site_name","content":"Richard Chen"}],["meta",{"property":"og:title","content":"Advanced Database Systems (COMP90050)"}],["meta",{"property":"og:description","content":"Advanced Database Systems (COMP90050) Week 1 Modelling Disk Access Disk access time = seek time + rotational delay + (transfer length / bandwidth) Seek time: the time it takes t..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2025-05-07T12:41:12.000Z"}],["meta",{"property":"article:tag","content":"Unimelb"}],["meta",{"property":"article:published_time","content":"2025-03-02T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-05-07T12:41:12.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Advanced Database Systems (COMP90050)\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-03-02T00:00:00.000Z\\",\\"dateModified\\":\\"2025-05-07T12:41:12.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Richard Chen\\"}]}"]]},"headers":[{"level":2,"title":"Week 1","slug":"week-1","link":"#week-1","children":[{"level":3,"title":"Modelling Disk Access","slug":"modelling-disk-access","link":"#modelling-disk-access","children":[]},{"level":3,"title":"HDD vs SSD","slug":"hdd-vs-ssd","link":"#hdd-vs-ssd","children":[]},{"level":3,"title":"Disk Access Time","slug":"disk-access-time","link":"#disk-access-time","children":[]},{"level":3,"title":"Hit Ratio","slug":"hit-ratio","link":"#hit-ratio","children":[]}]},{"level":2,"title":"Week 2","slug":"week-2","link":"#week-2","children":[{"level":3,"title":"Storage Area Networks (SANs)","slug":"storage-area-networks-sans","link":"#storage-area-networks-sans","children":[]},{"level":3,"title":"Deductive database systems (DDBS)","slug":"deductive-database-systems-ddbs","link":"#deductive-database-systems-ddbs","children":[]},{"level":3,"title":"Comparison Table between Nested Loop Join and Block Nested-Loop Join","slug":"comparison-table-between-nested-loop-join-and-block-nested-loop-join","link":"#comparison-table-between-nested-loop-join-and-block-nested-loop-join","children":[]},{"level":3,"title":"Worst Case Cost Estimation","slug":"worst-case-cost-estimation","link":"#worst-case-cost-estimation","children":[]},{"level":3,"title":"Other Join Comparison","slug":"other-join-comparison","link":"#other-join-comparison","children":[]}]},{"level":2,"title":"Week 3","slug":"week-3","link":"#week-3","children":[{"level":3,"title":"Heuristic optimization techniques","slug":"heuristic-optimization-techniques","link":"#heuristic-optimization-techniques","children":[]},{"level":3,"title":"Indexing","slug":"indexing","link":"#indexing","children":[]},{"level":3,"title":"B+ Tree","slug":"b-tree","link":"#b-tree","children":[]}]},{"level":2,"title":"Week 4","slug":"week-4","link":"#week-4","children":[{"level":3,"title":"Hash Indexing","slug":"hash-indexing","link":"#hash-indexing","children":[]},{"level":3,"title":"Bitmap Indexing","slug":"bitmap-indexing","link":"#bitmap-indexing","children":[]},{"level":3,"title":"Index Structures Comparison","slug":"index-structures-comparison","link":"#index-structures-comparison","children":[]},{"level":3,"title":"Index Structures Comparison","slug":"index-structures-comparison-1","link":"#index-structures-comparison-1","children":[]}]},{"level":2,"title":"Week 5","slug":"week-5","link":"#week-5","children":[{"level":3,"title":"ACID Properties","slug":"acid-properties","link":"#acid-properties","children":[]},{"level":3,"title":"Flat Transactions","slug":"flat-transactions","link":"#flat-transactions","children":[]}]},{"level":2,"title":"Week 6","slug":"week-6","link":"#week-6","children":[{"level":3,"title":"Some simple concurrency control approaches:","slug":"some-simple-concurrency-control-approaches","link":"#some-simple-concurrency-control-approaches","children":[]},{"level":3,"title":"A semaphore is a more general concurrency control tool, more flexible than a lock. Its working mechanism can be understood as:","slug":"a-semaphore-is-a-more-general-concurrency-control-tool-more-flexible-than-a-lock-its-working-mechanism-can-be-understood-as","link":"#a-semaphore-is-a-more-general-concurrency-control-tool-more-flexible-than-a-lock-its-working-mechanism-can-be-understood-as","children":[]},{"level":3,"title":"Deadlock solutions","slug":"deadlock-solutions","link":"#deadlock-solutions","children":[]}]},{"level":2,"title":"Week 7","slug":"week-7","link":"#week-7","children":[{"level":3,"title":"Serial History","slug":"serial-history","link":"#serial-history","children":[]},{"level":3,"title":"Bad Executions","slug":"bad-executions","link":"#bad-executions","children":[]}]},{"level":2,"title":"Week 8","slug":"week-8","link":"#week-8","children":[{"level":3,"title":"Lock Compatibility Matrix","slug":"lock-compatibility-matrix","link":"#lock-compatibility-matrix","children":[]},{"level":3,"title":"Degrees of Isolation","slug":"degrees-of-isolation","link":"#degrees-of-isolation","children":[]},{"level":3,"title":"Granularity of Locks","slug":"granularity-of-locks","link":"#granularity-of-locks","children":[]},{"level":3,"title":"Lock Type","slug":"lock-type","link":"#lock-type","children":[]},{"level":3,"title":"Two-Version Locking and Nested Transactions and Locking","slug":"two-version-locking-and-nested-transactions-and-locking","link":"#two-version-locking-and-nested-transactions-and-locking","children":[]},{"level":3,"title":"Optimistic Concurrency Control and Pessmistic Concurrency Control","slug":"optimistic-concurrency-control-and-pessmistic-concurrency-control","link":"#optimistic-concurrency-control-and-pessmistic-concurrency-control","children":[]},{"level":3,"title":"\\"Backward Validation\\" and \\"Forward Validation\\"","slug":"backward-validation-and-forward-validation","link":"#backward-validation-and-forward-validation","children":[]},{"level":3,"title":"Time-stamp-based Concurrency Control","slug":"time-stamp-based-concurrency-control","link":"#time-stamp-based-concurrency-control","children":[]}]}],"git":{"createdTime":1742122096000,"updatedTime":1746621672000,"contributors":[{"name":"Ruochen Chen","email":"ruocchen1220@gmail.com","commits":12}]},"readingTime":{"minutes":11.46,"words":3437},"filePathRelative":"posts/unimelb/COMP90050.md","localizedDate":"March 2, 2025","excerpt":"\\n<h2>Week 1</h2>\\n<h3>Modelling Disk Access</h3>\\n<p>Disk access time = seek time + rotational delay + (transfer length / bandwidth)</p>\\n<ul>\\n<li>Seek time: the time it takes to locate the requested sector on the disk.</li>\\n<li>Rotational delay: the time it takes to rotate the disk to the correct position.</li>\\n<li>Transfer length: the number of bytes to be transferred.</li>\\n<li>Bandwidth: the maximum rate of data transfer.</li>\\n</ul>","autoDesc":true}')},6262:(t,e)=>{e.A=(t,e)=>{const a=t.__vccOpts||t;for(const[t,i]of e)a[t]=i;return a}}}]);