"use strict";(self.webpackChunkpersonalweb=self.webpackChunkpersonalweb||[]).push([[5496],{39295:(s,i,e)=>{e.r(i),e.d(i,{comp:()=>t,data:()=>l});var a=e(20641);const n={},t=(0,e(66262).A)(n,[["render",function(s,i){return(0,a.uX)(),(0,a.CE)("div",null,i[0]||(i[0]=[(0,a.Fv)('<h1 id="question-24" tabindex="-1"><a class="header-anchor" href="#question-24"><span>Question 24</span></a></h1><h2 id="swap-nodes-in-pairs" tabindex="-1"><a class="header-anchor" href="#swap-nodes-in-pairs"><span>Swap Nodes in Pairs</span></a></h2><p>Given a linked list, swap every two adjacent nodes and return its head. You must solve it using recursion.</p><h2 id="approach-recursion" tabindex="-1"><a class="header-anchor" href="#approach-recursion"><span>Approach: Recursion</span></a></h2><ol><li><strong>Base Case</strong>: If the list is empty or has only one node, return the <code>head</code> as no swapping is needed.</li><li><strong>Recursive Step</strong>: Recursively solve the problem for the remaining nodes (i.e., after the first pair), then swap the first two nodes.</li><li><strong>Return New Head</strong>: The new head of the list after the swap will be the second node in the first pair.</li></ol><p>This recursive approach ensures that each pair is swapped as we progress through the list.</p><h2 id="complexity" tabindex="-1"><a class="header-anchor" href="#complexity"><span>Complexity</span></a></h2><ul><li><strong>Time Complexity</strong>: ( O(n) ), where ( n ) is the number of nodes in the list. We traverse each node exactly once.</li><li><strong>Space Complexity</strong>: ( O(n) ), due to the recursion stack (worst case for a list of length ( n )).</li></ul><h2 id="java-code-implementation" tabindex="-1"><a class="header-anchor" href="#java-code-implementation"><span>Java Code Implementation</span></a></h2><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Solution</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> ListNode</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> swapPairs</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">ListNode</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> head</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // Base case: If the list is empty or has only one node, return head</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (head </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">==</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> ||</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> head</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">next</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> ==</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">            return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> head;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        }</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // Nodes to be swapped</span></span>\n<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        ListNode</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> first</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> head;</span></span>\n<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        ListNode</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> second</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> head</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">next</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // Recursive call to swap the rest of the list</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        first</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">next</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> swapPairs</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">second</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">next</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // Perform the swap</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        second</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">next</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> first;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // Return the new head node, which is &#39;second&#39;</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> second;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',10)]))}]]),l=JSON.parse('{"path":"/posts/algorithm/8.html","title":"Question 24","lang":"en-US","frontmatter":{"icon":"pen-to-square","date":"2024-11-15T00:00:00.000Z","category":["Learning Records"],"tag":["LeetCode"],"description":"Question 24 Swap Nodes in Pairs Given a linked list, swap every two adjacent nodes and return its head. You must solve it using recursion. Approach: Recursion Base Case: If the ...","head":[["meta",{"property":"og:url","content":"https://crc011220.github.io/posts/algorithm/8.html"}],["meta",{"property":"og:site_name","content":"Ruochen Chen"}],["meta",{"property":"og:title","content":"Question 24"}],["meta",{"property":"og:description","content":"Question 24 Swap Nodes in Pairs Given a linked list, swap every two adjacent nodes and return its head. You must solve it using recursion. Approach: Recursion Base Case: If the ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2024-11-18T12:33:48.000Z"}],["meta",{"property":"article:tag","content":"LeetCode"}],["meta",{"property":"article:published_time","content":"2024-11-15T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-11-18T12:33:48.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Question 24\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-11-15T00:00:00.000Z\\",\\"dateModified\\":\\"2024-11-18T12:33:48.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Ruochen Chen\\"}]}"]]},"headers":[{"level":2,"title":"Swap Nodes in Pairs","slug":"swap-nodes-in-pairs","link":"#swap-nodes-in-pairs","children":[]},{"level":2,"title":"Approach: Recursion","slug":"approach-recursion","link":"#approach-recursion","children":[]},{"level":2,"title":"Complexity","slug":"complexity","link":"#complexity","children":[]},{"level":2,"title":"Java Code Implementation","slug":"java-code-implementation","link":"#java-code-implementation","children":[]}],"git":{"createdTime":1731845998000,"updatedTime":1731933228000,"contributors":[{"name":"Ruochen Chen","email":"ruocchen1220@gmail.com","commits":1}]},"readingTime":{"minutes":0.78,"words":234},"filePathRelative":"posts/algorithm/8.md","localizedDate":"November 15, 2024","excerpt":"\\n<h2>Swap Nodes in Pairs</h2>\\n<p>Given a linked list, swap every two adjacent nodes and return its head. You must solve it using recursion.</p>\\n<h2>Approach: Recursion</h2>\\n<ol>\\n<li><strong>Base Case</strong>: If the list is empty or has only one node, return the <code>head</code> as no swapping is needed.</li>\\n<li><strong>Recursive Step</strong>: Recursively solve the problem for the remaining nodes (i.e., after the first pair), then swap the first two nodes.</li>\\n<li><strong>Return New Head</strong>: The new head of the list after the swap will be the second node in the first pair.</li>\\n</ol>","autoDesc":true}')},66262:(s,i)=>{i.A=(s,i)=>{const e=s.__vccOpts||s;for(const[s,a]of i)e[s]=a;return e}}}]);