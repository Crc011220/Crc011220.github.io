"use strict";(self.webpackChunkpersonalweb=self.webpackChunkpersonalweb||[]).push([[5843],{6074:(n,s,i)=>{i.r(s),i.d(s,{comp:()=>l,data:()=>p});var a=i(641);const e={},l=(0,i(6262).A)(e,[["render",function(n,s){return(0,a.uX)(),(0,a.CE)("div",null,s[0]||(s[0]=[(0,a.Fv)('<h1 id="图" tabindex="-1"><a class="header-anchor" href="#图"><span>图</span></a></h1><h2 id="图的种类" tabindex="-1"><a class="header-anchor" href="#图的种类"><span>图的种类</span></a></h2><ul><li>有向图</li><li>无向图</li><li>加权图</li></ul><h2 id="度" tabindex="-1"><a class="header-anchor" href="#度"><span>度</span></a></h2><ul><li>度：一个顶点的度是与该顶点相关联的边的条数</li><li>入度：有向图中，有多少边指向该节点</li><li>出度：有向图中，该节点指向了多少边</li></ul><h2 id="图的存储" tabindex="-1"><a class="header-anchor" href="#图的存储"><span>图的存储</span></a></h2><ul><li>连通图：在无向图中，任何两个节点都是可以到达的，我们称之为连通图</li><li>强连通图：在有向图中，任何两个节点是可以相互到达的，我们称之为强连通图</li></ul><h2 id="图的表示" tabindex="-1"><a class="header-anchor" href="#图的表示"><span>图的表示</span></a></h2><ul><li><p>邻接矩阵：是图的另一种表示方式，它是一个二维数组，其中每个元素表示两个节点之间是否有边。</p><ul><li>表达方式简单，易于理解</li><li>检查任意两个顶点间是否存在边的操作非常快</li><li>适合稠密图，在边数接近顶点数平方的图中，邻接矩阵是一种空间效率较高的表示方法。</li><li>遇到稀疏图，会导致申请过大的二维数组造成空间浪费 且遍历 边 的时候需要遍历整个n * n矩阵，造成时间浪费</li></ul></li><li><p>邻接表：是图的另一种表示方式，它是一个链表，其中每个节点表示一个顶点，每个节点包含一个指向其他节点的指针。</p><ul><li>对于稀疏图的存储，只需要存储边，空间利用率高</li><li>遍历节点连接情况相对容易</li><li>检查任意两个节点间是否存在边，效率相对低，需要 O(V)时间，V表示某节点连接其他节点的数量。</li><li>实现相对复杂，不易理解</li></ul></li></ul><h2 id="图的遍历" tabindex="-1"><a class="header-anchor" href="#图的遍历"><span>图的遍历</span></a></h2><ul><li>深度优先搜索</li><li>广度优先搜索</li></ul><h3 id="深度优先搜索" tabindex="-1"><a class="header-anchor" href="#深度优先搜索"><span>深度优先搜索</span></a></h3><div class="language-psudocode line-numbers-mode" data-highlighter="shiki" data-ext="psudocode" data-title="psudocode" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>void dfs(参数) {</span></span>\n<span class="line"><span>    if (终止条件) {</span></span>\n<span class="line"><span>        存放结果;</span></span>\n<span class="line"><span>        return;</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    for (选择：本节点所连接的其他节点) {</span></span>\n<span class="line"><span>        处理节点;</span></span>\n<span class="line"><span>        dfs(图，选择的节点); // 递归</span></span>\n<span class="line"><span>        回溯，撤销处理结果</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="广度优先搜索" tabindex="-1"><a class="header-anchor" href="#广度优先搜索"><span>广度优先搜索</span></a></h3><div class="language-psudocode line-numbers-mode" data-highlighter="shiki" data-ext="psudocode" data-title="psudocode" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>int dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; // 表示四个方向</span></span>\n<span class="line"><span>// grid 是地图，也就是一个二维数组</span></span>\n<span class="line"><span>// visited标记访问过的节点，不要重复访问</span></span>\n<span class="line"><span>// x,y 表示开始搜索节点的下标</span></span>\n<span class="line"><span>void bfs(vector&lt;vector&lt;char&gt;&gt;&amp; grid, vector&lt;vector&lt;bool&gt;&gt;&amp; visited, int x, int y) {</span></span>\n<span class="line"><span>    queue&lt;pair&lt;int, int&gt;&gt; que; // 定义队列</span></span>\n<span class="line"><span>    que.push({x, y}); // 起始节点加入队列</span></span>\n<span class="line"><span>    visited[x][y] = true; // 只要加入队列，立刻标记为访问过的节点</span></span>\n<span class="line"><span>    while(!que.empty()) { // 开始遍历队列里的元素</span></span>\n<span class="line"><span>        pair&lt;int ,int&gt; cur = que.front(); que.pop(); // 从队列取元素</span></span>\n<span class="line"><span>        int curx = cur.first;</span></span>\n<span class="line"><span>        int cury = cur.second; // 当前节点坐标</span></span>\n<span class="line"><span>        for (int i = 0; i &lt; 4; i++) { // 开始想当前节点的四个方向左右上下去遍历</span></span>\n<span class="line"><span>            int nextx = curx + dir[i][0];</span></span>\n<span class="line"><span>            int nexty = cury + dir[i][1]; // 获取周边四个方向的坐标</span></span>\n<span class="line"><span>            if (nextx &lt; 0 || nextx &gt;= grid.size() || nexty &lt; 0 || nexty &gt;= grid[0].size()) continue;  // 坐标越界了，直接跳过</span></span>\n<span class="line"><span>            if (!visited[nextx][nexty]) { // 如果节点没被访问过</span></span>\n<span class="line"><span>                que.push({nextx, nexty});  // 队列添加该节点为下一轮要遍历的节点</span></span>\n<span class="line"><span>                visited[nextx][nexty] = true; // 只要加入队列立刻标记，避免重复访问</span></span>\n<span class="line"><span>            }</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',15)]))}]]),p=JSON.parse('{"path":"/zh/posts/algo/%E5%9B%BE.html","title":"图","lang":"zh-CN","frontmatter":{"icon":"pen-to-square","date":"2025-05-22T00:00:00.000Z","category":["Learning Records"],"tag":["Algorithm"],"description":"图 图的种类 有向图 无向图 加权图 度 度：一个顶点的度是与该顶点相关联的边的条数 入度：有向图中，有多少边指向该节点 出度：有向图中，该节点指向了多少边 图的存储 连通图：在无向图中，任何两个节点都是可以到达的，我们称之为连通图 强连通图：在有向图中，任何两个节点是可以相互到达的，我们称之为强连通图 图的表示 邻接矩阵：是图的另一种表示方式，它是一...","head":[["meta",{"property":"og:url","content":"https://crc011220.github.io/zh/posts/algo/%E5%9B%BE.html"}],["meta",{"property":"og:site_name","content":"Richard Chen"}],["meta",{"property":"og:title","content":"图"}],["meta",{"property":"og:description","content":"图 图的种类 有向图 无向图 加权图 度 度：一个顶点的度是与该顶点相关联的边的条数 入度：有向图中，有多少边指向该节点 出度：有向图中，该节点指向了多少边 图的存储 连通图：在无向图中，任何两个节点都是可以到达的，我们称之为连通图 强连通图：在有向图中，任何两个节点是可以相互到达的，我们称之为强连通图 图的表示 邻接矩阵：是图的另一种表示方式，它是一..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-05-23T13:31:08.000Z"}],["meta",{"property":"article:tag","content":"Algorithm"}],["meta",{"property":"article:published_time","content":"2025-05-22T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-05-23T13:31:08.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"图\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-05-22T00:00:00.000Z\\",\\"dateModified\\":\\"2025-05-23T13:31:08.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Richard Chen\\"}]}"]]},"headers":[{"level":2,"title":"图的种类","slug":"图的种类","link":"#图的种类","children":[]},{"level":2,"title":"度","slug":"度","link":"#度","children":[]},{"level":2,"title":"图的存储","slug":"图的存储","link":"#图的存储","children":[]},{"level":2,"title":"图的表示","slug":"图的表示","link":"#图的表示","children":[]},{"level":2,"title":"图的遍历","slug":"图的遍历","link":"#图的遍历","children":[{"level":3,"title":"深度优先搜索","slug":"深度优先搜索","link":"#深度优先搜索","children":[]},{"level":3,"title":"广度优先搜索","slug":"广度优先搜索","link":"#广度优先搜索","children":[]}]}],"git":{"createdTime":1748007068000,"updatedTime":1748007068000,"contributors":[{"name":"Ruochen Chen","email":"ruocchen1220@gmail.com","commits":1}]},"readingTime":{"minutes":2.66,"words":798},"filePathRelative":"zh/posts/algo/图.md","localizedDate":"2025年5月22日","excerpt":"\\n<h2>图的种类</h2>\\n<ul>\\n<li>有向图</li>\\n<li>无向图</li>\\n<li>加权图</li>\\n</ul>\\n<h2>度</h2>\\n<ul>\\n<li>度：一个顶点的度是与该顶点相关联的边的条数</li>\\n<li>入度：有向图中，有多少边指向该节点</li>\\n<li>出度：有向图中，该节点指向了多少边</li>\\n</ul>\\n<h2>图的存储</h2>\\n<ul>\\n<li>连通图：在无向图中，任何两个节点都是可以到达的，我们称之为连通图</li>\\n<li>强连通图：在有向图中，任何两个节点是可以相互到达的，我们称之为强连通图</li>\\n</ul>\\n<h2>图的表示</h2>\\n<ul>\\n<li>\\n<p>邻接矩阵：是图的另一种表示方式，它是一个二维数组，其中每个元素表示两个节点之间是否有边。</p>\\n<ul>\\n<li>表达方式简单，易于理解</li>\\n<li>检查任意两个顶点间是否存在边的操作非常快</li>\\n<li>适合稠密图，在边数接近顶点数平方的图中，邻接矩阵是一种空间效率较高的表示方法。</li>\\n<li>遇到稀疏图，会导致申请过大的二维数组造成空间浪费 且遍历 边 的时候需要遍历整个n * n矩阵，造成时间浪费</li>\\n</ul>\\n</li>\\n<li>\\n<p>邻接表：是图的另一种表示方式，它是一个链表，其中每个节点表示一个顶点，每个节点包含一个指向其他节点的指针。</p>\\n<ul>\\n<li>对于稀疏图的存储，只需要存储边，空间利用率高</li>\\n<li>遍历节点连接情况相对容易</li>\\n<li>检查任意两个节点间是否存在边，效率相对低，需要 O(V)时间，V表示某节点连接其他节点的数量。</li>\\n<li>实现相对复杂，不易理解</li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true}')},6262:(n,s)=>{s.A=(n,s)=>{const i=n.__vccOpts||n;for(const[n,a]of s)i[n]=a;return i}}}]);