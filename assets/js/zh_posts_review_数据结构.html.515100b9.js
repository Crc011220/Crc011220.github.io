"use strict";(self.webpackChunkpersonalweb=self.webpackChunkpersonalweb||[]).push([[1993],{2946:(s,n,a)=>{a.r(n),a.d(n,{comp:()=>d,data:()=>t});var i=a(641);const e=a.p+"assets/img/sort.a6f27ddb.png",l={},d=(0,a(6262).A)(l,[["render",function(s,n){return(0,i.uX)(),(0,i.CE)("div",null,n[0]||(n[0]=[(0,i.Fv)('<h1 id="数据结构" tabindex="-1"><a class="header-anchor" href="#数据结构"><span>数据结构</span></a></h1><h2 id="数据结构的概念" tabindex="-1"><a class="header-anchor" href="#数据结构的概念"><span>数据结构的概念</span></a></h2><h3 id="基本概念" tabindex="-1"><a class="header-anchor" href="#基本概念"><span>基本概念</span></a></h3><ul><li>数据：能输入到计算机中并且被计算机程序处理的符号的总称</li><li>数据元素：数据的基本单位。有时，一个数据元素可由若干数据项组成</li><li>数据结构的存储方式： <ul><li>顺序存储：把逻辑上相邻的结点存储在物理位置上相邻的存储单元中</li><li>链式存储：把逻辑上相邻的结点存储在物理位置上不相邻的存储单元中，结点间的逻辑关系是由附加的指针字段表示的</li><li>索引存储：存储结点信息的同时，还建立附加的索引表，索引表中的每一项称为索引项，索引项的一般形式是（关键字，地址）</li><li>散列存储：根据结点的关键字直接计算出该结点的存储地址</li></ul></li><li>算法： <ul><li>算法特征：有穷性、确切性、输入、输出、可行性</li><li>算法评定：健壮性、可读性、正确性、空间复杂度</li><li>时间复杂度：算法运行时间随问题规模增长的变化趋势</li><li>空间复杂度：算法运行时所占用的存储空间随问题规模增长的变化趋势</li></ul></li></ul><h2 id="线性表" tabindex="-1"><a class="header-anchor" href="#线性表"><span>线性表</span></a></h2><ul><li>线性表的表示方法：顺序表示、链式表示。</li><li>线性表的存储结构和实现：线性链表、循环链表、双向链表。</li><li>链表的四种形式：单链表、双链表、循环单链表、循环双链表。</li><li>线性表的相关操作 <ul><li>线性链表判空（L 为头指针）：</li></ul></li></ul><div class="language-pseudocode line-numbers-mode" data-highlighter="shiki" data-ext="pseudocode" data-title="pseudocode" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>带头结点：L→next==null;</span></span>\n<span class="line"><span>不带头结点：L==null</span></span>\n<span class="line"><span>循环链表判空：L→next==L</span></span>\n<span class="line"><span>双向链表判空：L→next==L</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="顺序表和链表的比较" tabindex="-1"><a class="header-anchor" href="#顺序表和链表的比较"><span>顺序表和链表的比较</span></a></h3><table><thead><tr><th>对比维度</th><th>顺序表</th><th>链表</th></tr></thead><tbody><tr><td>存储结构</td><td><strong>顺序存储</strong>（数组）</td><td><strong>链式存储</strong>（指针连接结点）</td></tr><tr><td>存取方式</td><td>支持<strong>顺序 + 随机访问</strong></td><td>只能<strong>从表头顺序访问</strong>（逐个遍历）</td></tr><tr><td>按序号查找</td><td><code>O(1)</code>（直接通过下标访问）</td><td><code>O(n)</code>（逐个结点向后找）</td></tr><tr><td>按值查找</td><td>无序：<code>O(n)</code>；有序可二分：<code>O(log n)</code></td><td><code>O(n)</code></td></tr><tr><td>插入操作</td><td>平均需移动半个表长元素，<code>O(n)</code></td><td>修改指针即可，<code>O(1)</code>（找到位置后）</td></tr><tr><td>删除操作</td><td>同插入，平均 <code>O(n)</code></td><td>修改指针即可，<code>O(1)</code>（找到位置后）</td></tr><tr><td>存储密度</td><td>高（只存值）</td><td>低（每个结点需额外指针域）</td></tr><tr><td>空间分配</td><td>需<strong>预分配固定大小</strong>（可能浪费）</td><td><strong>动态分配</strong>，灵活但碎片化</td></tr><tr><td>扩容方式</td><td>需手动申请更大数组并复制元素</td><td>不需要，动态申请新结点</td></tr><tr><td>应用场景</td><td>查询频繁、数据量稳定</td><td>插入/删除频繁、不定长数据</td></tr></tbody></table><h2 id="栈和队列" tabindex="-1"><a class="header-anchor" href="#栈和队列"><span>栈和队列</span></a></h2><ul><li>栈和队列的定义 <ul><li>栈：栈是限定仅在表尾进行插入或删除操作的线性表。先进后出，后进先出</li><li>队列：队列是只允许在一端进行插入操作、而在另一端进行删除操作的线性表。先进先出，后进后出</li></ul></li></ul><h3 id="栈" tabindex="-1"><a class="header-anchor" href="#栈"><span>栈</span></a></h3><ul><li>应用： <ul><li>数制转换：将一个数从一种进制转换为另一种进制</li><li>括号匹配检验：检查表达式中的括号是否匹配</li><li>行编辑程序：编辑程序中的行编辑功能</li><li>表达式求值：将中缀表达式转换为后缀表达式，然后求值</li></ul></li><li>操作： <ul><li>判空：S.top == -1</li><li>判满：S.top == MaxSize - 1</li><li>进栈要先移动指针，再进元素</li><li>出栈要先取元素，再移动指针</li></ul></li></ul><h3 id="队列" tabindex="-1"><a class="header-anchor" href="#队列"><span>队列</span></a></h3><ul><li>应用： <ul><li>层次遍历 <ul><li>比如二叉树的层次遍历</li></ul></li><li>计算机系统 <ul><li>解决主机与外部设备之间速度不匹配</li><li>解决由多用户引起的资源竞争</li></ul></li></ul></li><li>操作： <ul><li>判空：Q.front == Q.rear</li><li>判满：（rear+1）mod MAXSIZE==front</li><li>求元素个数：（rear-front+MAXSIZE）mod MAXSIZE</li><li>插入：（rear+n）mod MAXSIZE</li><li>删除：（front+n）mod MAXSIZE</li></ul></li></ul><h2 id="数组与特殊矩阵" tabindex="-1"><a class="header-anchor" href="#数组与特殊矩阵"><span>数组与特殊矩阵</span></a></h2><ul><li>数组：有序的元素序列</li><li>二维数组在内存中其实是一维的。有两种存储方式： <ul><li>行为主序：按行依次存储，先存完第 0 行，再存第 1 行，依此类推</li><li>列为主序：按列依次存储，先存完第 0 列，再存第 1 列，依此类推</li></ul></li></ul><h3 id="特殊矩阵" tabindex="-1"><a class="header-anchor" href="#特殊矩阵"><span>特殊矩阵：</span></a></h3><ul><li>特殊矩阵：值相同的元素或者零元素在矩阵中的分布有一定规律。</li></ul><h4 id="对称矩阵" tabindex="-1"><a class="header-anchor" href="#对称矩阵"><span>对称矩阵</span></a></h4><p>满足：<code>A[i][j] == A[j][i]</code><strong>例子</strong>（主对角线两边对称）：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>A = </span></span>\n<span class="line"><span>[ 1  2  3 ]</span></span>\n<span class="line"><span>[ 2  4  5 ]</span></span>\n<span class="line"><span>[ 3  5  6 ]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>A[0][1] = 2</code> 与 <code>A[1][0] = 2</code> 相等，其他同理。</li><li>主对角线为对称轴。</li></ul><h4 id="上三角矩阵-上半区有值-下半为0" tabindex="-1"><a class="header-anchor" href="#上三角矩阵-上半区有值-下半为0"><span>上三角矩阵（上半区有值，下半为0）：</span></a></h4><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>U = </span></span>\n<span class="line"><span>[ 1  2  3 ]</span></span>\n<span class="line"><span>[ 0  4  5 ]</span></span>\n<span class="line"><span>[ 0  0  6 ]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="下三角矩阵-下半区有值-上半为0" tabindex="-1"><a class="header-anchor" href="#下三角矩阵-下半区有值-上半为0"><span>下三角矩阵（下半区有值，上半为0）：</span></a></h4><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>L = </span></span>\n<span class="line"><span>[ 1  0  0 ]</span></span>\n<span class="line"><span>[ 2  4  0 ]</span></span>\n<span class="line"><span>[ 3  5  6 ]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>主对角线下/上方全部为 0 或固定值，常见于高斯消元等场景。</li></ul><h4 id="对角矩阵-diagonal-matrix" tabindex="-1"><a class="header-anchor" href="#对角矩阵-diagonal-matrix"><span>对角矩阵（Diagonal Matrix）</span></a></h4><p><strong>例子</strong>（除主对角线外全为 0）：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>D = </span></span>\n<span class="line"><span>[ 1  0  0 ]</span></span>\n<span class="line"><span>[ 0  2  0 ]</span></span>\n<span class="line"><span>[ 0  0  3 ]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>只有 <code>A[0][0]</code>, <code>A[1][1]</code>, <code>A[2][2]</code> 非 0，其他为 0。</li><li>带状矩阵是对角矩阵的推广，例如：</li></ul><p><strong>带状对角矩阵</strong>（主对角线和其上下各一条对角线也有值）：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>B = </span></span>\n<span class="line"><span>[ 1  2  0 ]</span></span>\n<span class="line"><span>[ 3  4  5 ]</span></span>\n<span class="line"><span>[ 0  6  7 ]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="稀疏矩阵" tabindex="-1"><a class="header-anchor" href="#稀疏矩阵"><span>稀疏矩阵：</span></a></h3><ul><li>稀疏矩阵：其非零元素较零元素少，且分布没有一定规律</li><li>存储方法：</li></ul><h4 id="三元组表" tabindex="-1"><a class="header-anchor" href="#三元组表"><span>三元组表</span></a></h4><p>用一个三元组 <code>(row, col, value)</code> 来表示一个非零元素的位置和数值，节省空间。</p><p>稀疏矩阵 ➜ 用三元组 ➜ 每个非零值 ➜ 一个记录 <code>(i, j, v)</code></p><p>原始稀疏矩阵：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>M =</span></span>\n<span class="line"><span>[ 0  0  3 ]</span></span>\n<span class="line"><span>[ 4  0  0 ]</span></span>\n<span class="line"><span>[ 0  5  0 ]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>三元组表示为：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>(row, col, value)</span></span>\n<span class="line"><span>(0, 2, 3)</span></span>\n<span class="line"><span>(1, 0, 4)</span></span>\n<span class="line"><span>(2, 1, 5)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>好处</strong>：只记录非零元素，空间效率高。</p><h4 id="十字链表法" tabindex="-1"><a class="header-anchor" href="#十字链表法"><span>十字链表法</span></a></h4><p>为每行每列建立指针，将非零元素用结点连接，<strong>适合频繁插入删除</strong>。</p><ul><li>每个非零节点包含：<strong>值、行下标、列下标、右指针、下指针</strong></li><li>每行有一个<strong>行头结点</strong>，每列有一个<strong>列头结点</strong></li></ul><p>稀疏矩阵 ➜ 链表 ➜ 横指针右移（行）、竖指针下移（列）</p><p>稀疏矩阵：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>M =</span></span>\n<span class="line"><span>[ 0  0  3 ]</span></span>\n<span class="line"><span>[ 4  0  0 ]</span></span>\n<span class="line"><span>[ 0  5  0 ]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>十字链表中节点内容为（每个节点）：</p><ul><li><code>(0,2,3)</code> → 行0的右指针指向它，列2的下指针指向它</li><li><code>(1,0,4)</code> → 行1的右指针，列0的下指针</li><li><code>(2,1,5)</code> → 行2的右指针，列1的下指针</li></ul><p><strong>好处</strong>：</p><ul><li>插入删除快</li><li>遍历某行或某列效率高</li><li>空间效率适中，比三元组表更适合动态变化的数据结构</li></ul><h3 id="广义表" tabindex="-1"><a class="header-anchor" href="#广义表"><span>广义表</span></a></h3><table><thead><tr><th>项目</th><th>含义描述</th><th>例子</th></tr></thead><tbody><tr><td><strong>长度</strong></td><td>广义表<strong>最外层元素</strong>的个数</td><td><code>(a, b, (c, d), e)</code> 长度为 <strong>4</strong></td></tr><tr><td><strong>深度</strong></td><td>广义表中<strong>括号嵌套的最大层数</strong></td><td><code>(a, (b, (c, d)))</code> 深度为 <strong>3</strong></td></tr><tr><td><strong>表头</strong></td><td>第一个元素（不管是原子还是子表）</td><td><code>(a, b, c)</code> 的表头为 <code>a</code></td></tr><tr><td><strong>表尾</strong></td><td>除去第一个元素后的剩余部分（仍然是广义表）</td><td><code>(a, b, c)</code> 的表尾为 <code>(b, c)</code></td></tr></tbody></table><h2 id="树和二叉树" tabindex="-1"><a class="header-anchor" href="#树和二叉树"><span>树和二叉树</span></a></h2><h3 id="概念" tabindex="-1"><a class="header-anchor" href="#概念"><span>概念</span></a></h3><table><thead><tr><th>速记点编号</th><th>名称</th><th>定义说明</th><th>示例（以下图树为例）</th></tr></thead><tbody><tr><td>1️⃣</td><td>子节点 / 孩子节点</td><td>某节点直接连接的下一层节点</td><td><code>A</code> 的子节点有 <code>B</code>、<code>C</code>、<code>D</code></td></tr><tr><td>2️⃣</td><td>节点的度</td><td>某节点的子节点数</td><td><code>A</code> 的度是 3；<code>B</code> 的度是 2</td></tr><tr><td>3️⃣</td><td>叶节点 / 终端节点</td><td>度为 0 的节点（没有子节点）</td><td><code>E</code>、<code>F</code>、<code>G</code>、<code>H</code> 是叶节点</td></tr><tr><td>4️⃣</td><td>非终端节点</td><td>度不为 0 的节点</td><td><code>A</code>、<code>B</code>、<code>C</code> 是非终端节点</td></tr><tr><td>5️⃣</td><td>父节点 / 双亲节点</td><td>某节点的直接上层节点</td><td><code>B</code> 的父节点是 <code>A</code>，<code>E</code> 的父节点是 <code>B</code></td></tr><tr><td>6️⃣</td><td>兄弟节点</td><td>具有相同父节点的节点</td><td><code>B</code>、<code>C</code>、<code>D</code> 是兄弟节点；<code>E</code> 和 <code>F</code> 是兄弟</td></tr><tr><td>7️⃣</td><td>树的度</td><td>树中所有节点度的最大值</td><td>树的度是 3（<code>A</code> 有 3 个子节点）</td></tr><tr><td>8️⃣</td><td>节点的层次</td><td>根为第 1 层，子节点为第 2 层，以此类推</td><td><code>A</code> 在第 1 层，<code>B</code> 在第 2 层，<code>E</code> 在第 3 层</td></tr><tr><td>9️⃣</td><td>树的高度 / 深度</td><td>节点的最大层次</td><td>最深为第 3 层，所以高度是 3</td></tr><tr><td>🔟</td><td>堂兄弟节点</td><td>父节点不同，但父节点在同一层的节点</td><td><code>E</code>（父为 <code>B</code>）和 <code>G</code>（父为 <code>C</code>）是堂兄弟</td></tr><tr><td>1️⃣1️⃣</td><td>祖先节点</td><td>从根到某节点路径中经过的所有节点</td><td><code>E</code> 的祖先有 <code>A</code> 和 <code>B</code></td></tr><tr><td>1️⃣2️⃣</td><td>子孙节点</td><td>某节点为根的子树中所有节点</td><td><code>B</code> 的子孙包括 <code>E</code> 和 <code>F</code></td></tr></tbody></table><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>        A</span></span>\n<span class="line"><span>      / | \\</span></span>\n<span class="line"><span>     B  C  D</span></span>\n<span class="line"><span>    / \\  \\</span></span>\n<span class="line"><span>   E   F  G</span></span>\n<span class="line"><span>          \\</span></span>\n<span class="line"><span>           H</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="树的表示方法" tabindex="-1"><a class="header-anchor" href="#树的表示方法"><span>树的表示方法</span></a></h3><table><thead><tr><th>表示方法</th><th>描述说明</th></tr></thead><tbody><tr><td>树形表示法</td><td>以树的结构展示节点之间的层次关系，直观易懂</td></tr><tr><td>嵌套集合表示法</td><td>使用集合嵌套的方式表示树的层次结构</td></tr><tr><td>凹入表示法</td><td>通过缩进表示节点的层次关系，层次越深缩进越多</td></tr><tr><td>广义表表示法</td><td>使用广义表的形式表示树的结构，类似于列表嵌套</td></tr></tbody></table><h4 id="树形表示法" tabindex="-1"><a class="header-anchor" href="#树形表示法"><span>树形表示法</span></a></h4><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>        A</span></span>\n<span class="line"><span>      / | \\</span></span>\n<span class="line"><span>     B  C  D</span></span>\n<span class="line"><span>    / \\  \\</span></span>\n<span class="line"><span>   E   F  G</span></span>\n<span class="line"><span>          \\</span></span>\n<span class="line"><span>           H</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="嵌套集合表示法" tabindex="-1"><a class="header-anchor" href="#嵌套集合表示法"><span>嵌套集合表示法</span></a></h4><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>{A, {B, {E}, {F}}, {C, {G, {H}}}, {D}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h4 id="凹入表示法" tabindex="-1"><a class="header-anchor" href="#凹入表示法"><span>凹入表示法</span></a></h4><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>A</span></span>\n<span class="line"><span>    B</span></span>\n<span class="line"><span>        E</span></span>\n<span class="line"><span>        F</span></span>\n<span class="line"><span>    C</span></span>\n<span class="line"><span>        G</span></span>\n<span class="line"><span>            H</span></span>\n<span class="line"><span>    D</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="广义表表示法" tabindex="-1"><a class="header-anchor" href="#广义表表示法"><span>广义表表示法</span></a></h4><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>(A, (B, (E, F)), (C, (G, H)), D)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="树的存储结构" tabindex="-1"><a class="header-anchor" href="#树的存储结构"><span>树的存储结构</span></a></h3><table><thead><tr><th>存储方式</th><th>结构特点</th></tr></thead><tbody><tr><td><strong>双亲顺序存储结构</strong></td><td>每个节点包含数据和其父节点在数组中的下标。适用于查找双亲操作多的场景。</td></tr><tr><td><strong>孩子链式存储结构</strong></td><td>每个节点有一个指针域，指向其“所有子节点的链表头”。适合查找子节点频繁的场景。</td></tr><tr><td><strong>孩子兄弟存储结构</strong></td><td>每个节点有两个指针：一个指向第一个孩子，一个指向下一个兄弟。适合任意树转二叉树。</td></tr></tbody></table><h4 id="双亲顺序存储结构" tabindex="-1"><a class="header-anchor" href="#双亲顺序存储结构"><span>双亲顺序存储结构</span></a></h4><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>        A</span></span>\n<span class="line"><span>      / | \\</span></span>\n<span class="line"><span>     B  C  D</span></span>\n<span class="line"><span>    / \\  \\</span></span>\n<span class="line"><span>   E   F  G</span></span>\n<span class="line"><span>          \\</span></span>\n<span class="line"><span>           H</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="孩子链式存储结构" tabindex="-1"><a class="header-anchor" href="#孩子链式存储结构"><span>孩子链式存储结构</span></a></h4><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>        A</span></span>\n<span class="line"><span>      / | \\</span></span>\n<span class="line"><span>     B  C  D</span></span>\n<span class="line"><span>    / \\  \\</span></span>\n<span class="line"><span>   E   F  G</span></span>\n<span class="line"><span>          \\</span></span>\n<span class="line"><span>           H</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="孩子兄弟存储结构" tabindex="-1"><a class="header-anchor" href="#孩子兄弟存储结构"><span>孩子兄弟存储结构</span></a></h4><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>        A</span></span>\n<span class="line"><span>      / | \\</span></span>\n<span class="line"><span>     B  C  D</span></span>\n<span class="line"><span>    / \\  \\</span></span>\n<span class="line"><span>   E   F  G</span></span>\n<span class="line"><span>          \\</span></span>\n<span class="line"><span>           H</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="二叉树" tabindex="-1"><a class="header-anchor" href="#二叉树"><span>二叉树</span></a></h3><ul><li>满二叉树：深度为 k，有 2^k-1 个结点</li><li>完全二叉树：深度为 k，有 n 个结点，且结点 1 到 k-1 是满二叉树，第 k 层从左到右依次填满 <ul><li>满二叉树一定是完全二叉树，但完全二叉树不一定是满二叉树</li></ul></li></ul><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>        1</span></span>\n<span class="line"><span>      /   \\</span></span>\n<span class="line"><span>     2     3</span></span>\n<span class="line"><span>    / \\   / \\</span></span>\n<span class="line"><span>   4  5  6  7</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><table><thead><tr><th>性质内容</th><th>示例（以 n = 7 的完全二叉树为例）</th></tr></thead><tbody><tr><td>深度为 k 的二叉树最多有 2^k - 1 个节点</td><td>深度为 3 时最多节点数：2³ - 1 = 7</td></tr><tr><td>叶子结点数 n_0 = n_2 + 1，其中 n_2 是度为 2 的结点数</td><td>若有 3 个度为 2 的节点，则叶子结点数为 3 + 1 = 4</td></tr><tr><td>n 个节点的完全二叉树深度是 ⌊log₂n⌋ + 1</td><td>n=7，⌊log₂7⌋ + 1 = 2 + 1 = 3 层</td></tr><tr><td>第 i 个结点的双亲编号为 ⌊i/2⌋（i=1 时无父节点）</td><td>编号 3 的节点：⌊3/2⌋ = 1，其父是 1 号节点</td></tr><tr><td>左孩子为编号 2i，若 2i &gt; n，则无左孩子</td><td>编号 3 的节点：左孩子编号 2×3=6，存在</td></tr><tr><td>右孩子为编号 2i+1，若 2i+1 &gt; n，则无右孩子</td><td>编号 3 的节点：右孩子编号 2×3+1=7，存在</td></tr><tr><td>对任何一棵二叉树，度为0的结点（叶子结点）总是比度为2的结点多一个</td><td>叶子结点数为 4，度为2的结点数为 3，叶子结点数比度为2的结点数多1</td></tr></tbody></table><ul><li>节点的编号与其父节点编号之间存在固定的数学关系。对于任意一个编号为n的节点,其父节点的编号为 n/2 (向下取整)</li><li>二叉树的先序遍历序列和后序遍历序列正好相反，这棵树必须是一条单向的斜线，且树的高度恰好等于结点数。</li></ul><h3 id="二叉树的存储结构" tabindex="-1"><a class="header-anchor" href="#二叉树的存储结构"><span>二叉树的存储结构</span></a></h3><table><thead><tr><th>存储方式</th><th>描述</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>顺序存储结构</td><td>用数组表示完全二叉树，节点编号从 1 开始，节点 i 的左孩子是 2i，右孩子是 2i+1</td><td>快速定位父子节点</td><td>空间浪费（非完全二叉树）</td><td>完全二叉树或接近完全</td></tr><tr><td>链式存储结构</td><td>每个节点用一个结构体（或对象）表示，含数据域、左孩子指针、右孩子指针</td><td>空间利用率高，灵活</td><td>不能随机访问</td><td>一般二叉树</td></tr></tbody></table><h3 id="二叉树的遍历" tabindex="-1"><a class="header-anchor" href="#二叉树的遍历"><span>二叉树的遍历</span></a></h3><ul><li>中序遍历专属于二叉树，因为它需要左右子树的明确划分，其他树形结构没有这种区分，所以不存在中序遍历。</li></ul><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>        1</span></span>\n<span class="line"><span>      /   \\</span></span>\n<span class="line"><span>     2     3</span></span>\n<span class="line"><span>    / \\   / \\</span></span>\n<span class="line"><span>   4  5  6  7</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><table><thead><tr><th>遍历方式</th><th>顺序规则</th><th>遍历结果</th><th>口诀</th></tr></thead><tbody><tr><td>前序遍历</td><td>根 → 左 → 右</td><td><strong>1 2 4 5 3 6 7</strong></td><td>根在前</td></tr><tr><td>中序遍历</td><td>左 → 根 → 右</td><td><strong>4 2 5 1 6 3 7</strong></td><td>根在中</td></tr><tr><td>后序遍历</td><td>左 → 右 → 根</td><td><strong>4 5 2 6 7 3 1</strong></td><td>根在后</td></tr><tr><td>层次遍历</td><td>按层从左到右</td><td><strong>1 2 3 4 5 6 7</strong></td><td>BFS</td></tr></tbody></table><h3 id="树和森林遍历" tabindex="-1"><a class="header-anchor" href="#树和森林遍历"><span>树和森林遍历</span></a></h3><ul><li>森林：多棵树组成，可先转为二叉树再进行遍历</li></ul><table><thead><tr><th>遍历类型</th><th>访问顺序</th><th>说明</th><th>口诀</th></tr></thead><tbody><tr><td>先根遍历</td><td>根 → 左 → 右</td><td>先访问根节点，再访问子树（前序遍历）</td><td>根左右</td></tr><tr><td>后根遍历</td><td>左 → 右 → 根</td><td>先访问所有子树，最后访问根节点</td><td>左右根</td></tr><tr><td>层次遍历</td><td>从上到下，从左到右</td><td>按层次顺序访问节点，广度优先遍历</td><td>层次遍历（BFS）</td></tr></tbody></table><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>树1:           A</span></span>\n<span class="line"><span>              / \\</span></span>\n<span class="line"><span>             B   C</span></span>\n<span class="line"><span>            /</span></span>\n<span class="line"><span>           D</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>树2:         X</span></span>\n<span class="line"><span>            / | \\</span></span>\n<span class="line"><span>           Y  Z  W</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>先根遍历（访问顺序：先遍历树1，再遍历树2）：</li></ul><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>A B D C X Y Z W</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>后根遍历（访问顺序：先遍历树1，再遍历树2）：</li></ul><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>D B C A Y Z W X</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>层次遍历（访问顺序：先遍历树1，再遍历树2）：</li></ul><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>A B C D X Y Z W</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="森林转换成二叉树" tabindex="-1"><a class="header-anchor" href="#森林转换成二叉树"><span>森林转换成二叉树</span></a></h3><ul><li><p>将森林中的每棵小树以“左孩子-右兄弟”方式转换成二叉树结构。</p><ul><li>例如，假设有一棵树，根节点A有三个子节点B、C、D。转换后，B是A的左孩子，C是B的右兄弟，D是C的右兄弟。</li></ul><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>  A</span></span>\n<span class="line"><span> /|\\</span></span>\n<span class="line"><span>B C D</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>转换为:</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>  A</span></span>\n<span class="line"><span> /</span></span>\n<span class="line"><span>B</span></span>\n<span class="line"><span> \\</span></span>\n<span class="line"><span>  C</span></span>\n<span class="line"><span>   \\</span></span>\n<span class="line"><span>    D</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>将第二棵二叉树作为第一棵二叉树的右孩子。</p><ul><li>举例来说，如果有两棵树，第一棵树的根节点是A，第二棵树的根节点是X，那么转换后，X将作为A的右孩子。</li></ul><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>第一棵树:    A</span></span>\n<span class="line"><span>           /</span></span>\n<span class="line"><span>          B</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>第二棵树:    X</span></span>\n<span class="line"><span>           /</span></span>\n<span class="line"><span>          Y</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>转换为:</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>  A</span></span>\n<span class="line"><span> / \\</span></span>\n<span class="line"><span>B   X</span></span>\n<span class="line"><span>   /</span></span>\n<span class="line"><span>  Y</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>第三棵二叉树作为第一棵二叉树右孩子的右孩子，以此类推。</p><ul><li>例如，假设有三棵树，第一棵树的根节点是A，第二棵树的根节点是X，第三棵树的根节点是Y。转换后，X是A的右孩子，Y是X的右孩子。</li></ul><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>第一棵树:    A</span></span>\n<span class="line"><span>           /</span></span>\n<span class="line"><span>          B</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>第二棵树:    X</span></span>\n<span class="line"><span>           /</span></span>\n<span class="line"><span>          Y</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>第三棵树:    Z</span></span>\n<span class="line"><span>           /</span></span>\n<span class="line"><span>          W</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>转换为:</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>  A</span></span>\n<span class="line"><span> / \\</span></span>\n<span class="line"><span>B   X</span></span>\n<span class="line"><span>   / \\</span></span>\n<span class="line"><span>  Y   Z</span></span>\n<span class="line"><span>     /</span></span>\n<span class="line"><span>    W</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h3 id="赫夫曼树" tabindex="-1"><a class="header-anchor" href="#赫夫曼树"><span>赫夫曼树</span></a></h3><ul><li>Huffman算法：每次选择权值最小的两个节点合并，形成一个新的节点，权值为两个节点权值之和</li></ul><table><thead><tr><th>速记点</th><th>定义</th><th>举例</th></tr></thead><tbody><tr><td>树的路径长度</td><td>所有结点从根到该结点路径长度的总和。完全二叉树路径长度最短。</td><td>如完全二叉树（3层满二叉树），路径长度最短。</td></tr><tr><td>带权路径长度（WPL）</td><td>所有叶子结点路径长度乘以对应权值的加和。</td><td>有叶子结点权值分别为2、3、5，路径长度分别为1、2、2，WPL=2×1+3×2+5×2=20</td></tr><tr><td>赫夫曼编码</td><td>从根开始，左分支编码0，右分支编码1，叶子结点路径编码。</td><td>权值5的叶子结点路径为“左-右-左”，编码为“0 1 0”。</td></tr></tbody></table><p>假设一棵树结构如下：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>        (root)</span></span>\n<span class="line"><span>        /     \\</span></span>\n<span class="line"><span>      A(2)    B(3)</span></span>\n<span class="line"><span>              /   \\</span></span>\n<span class="line"><span>           C(5)  D(1)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p><strong>路径长度</strong>：</p><ul><li>root到A的路径长度 = 1</li><li>root到B的路径长度 = 1</li><li>root到C的路径长度 = 2</li><li>root到D的路径长度 = 2</li><li>树的路径长度 = 1 + 1 + 2 + 2 = 6</li></ul></li><li><p><strong>带权路径长度（WPL）</strong>（只考虑叶子节点，假设A、C、D是叶子）：</p><ul><li>A(权2)路径长度1，贡献 = 2×1=2</li><li>C(权5)路径长度2，贡献 = 5×2=10</li><li>D(权1)路径长度2，贡献 = 1×2=2</li><li>WPL = 2 + 10 + 2 = 14</li></ul></li><li><p><strong>赫夫曼编码</strong>（假设左0右1）：</p><ul><li>A的路径是左分支 = <code>0</code></li><li>B是右分支 = <code>1</code></li><li>C是B的左分支 = <code>1 0</code></li><li>D是B的右分支 = <code>1 1</code></li></ul></li></ul><h3 id="最优二叉树" tabindex="-1"><a class="header-anchor" href="#最优二叉树"><span>最优二叉树</span></a></h3><ul><li>指的是带权路径长度（WPL）最小的二叉树</li><li>最常见的最优二叉树就是 —— 赫夫曼树（Huffman Tree）</li></ul><h3 id="b树" tabindex="-1"><a class="header-anchor" href="#b树"><span>B树</span></a></h3><table><thead><tr><th>内容</th><th>备注示例</th></tr></thead><tbody><tr><td>所有<strong>叶子结点都在同一层</strong></td><td>没有“高度不一致”问题</td></tr><tr><td>M 阶表示<strong>最多有 M 个子树指针</strong>（即 M 个分支）</td><td>M 阶 = 最多 M 个孩子</td></tr><tr><td>关键字数量满足 <code>⌈m/2⌉ - 1 ≤ n ≤ m - 1</code></td><td>每个结点至少要有一半满</td></tr><tr><td>关键字<strong>递增排列</strong></td><td>支持范围查找</td></tr></tbody></table><h3 id="b树和b-树对比" tabindex="-1"><a class="header-anchor" href="#b树和b-树对比"><span>B树和B+树对比</span></a></h3><table><thead><tr><th>对比项</th><th>B 树</th><th>B+ 树</th></tr></thead><tbody><tr><td>用途</td><td>多用于<strong>文件系统索引</strong></td><td>多用于<strong>数据库索引</strong></td></tr><tr><td>子树数</td><td>有 <strong>n 个关键字</strong> → <strong>n+1 棵子树</strong></td><td>有 <strong>n 个关键字</strong> → <strong>n 棵子树</strong></td></tr><tr><td>数据存储</td><td><strong>数据存储在所有结点上（内结点 + 叶结点）</strong></td><td><strong>数据只存在叶子节点，内节点只作索引</strong></td></tr><tr><td>查询效率</td><td>查询速度中等，可能在内结点找到</td><td>所有查找都到叶子，<strong>查找路径一致，适合范围查询</strong></td></tr><tr><td>叶子节点链接</td><td>不一定有链接</td><td><strong>所有叶子结点通过指针串联，便于区间遍历</strong></td></tr></tbody></table><h2 id="图" tabindex="-1"><a class="header-anchor" href="#图"><span>图</span></a></h2><ul><li>线性表可以是空表，树可以是空树，但图不可以是空图</li></ul><h3 id="概念-1" tabindex="-1"><a class="header-anchor" href="#概念-1"><span>概念</span></a></h3><ul><li>无向图∶每条边都是没有方向的</li><li>有向图∶每条边都是有方向的</li><li>连通图：图中任意两个顶点都是连通的（有路径的）</li><li>顶点度数： <ul><li>无向图：顶点v的度数是与v相关联的边的数目</li><li>有向图：顶点v的度数是顶点v的入度（该顶点为终点的边的数目）与出度（以该顶点为起点的边的数目）之和</li></ul></li><li>连通分量：无向图中的极大连通子图 <ul><li>连通子图：内部任意两个顶点都连通。</li><li>极大（最大）：不能再往里加点使它仍然连通了，一旦加点就“不全连通”了。</li></ul></li><li>强连通图：有向图中任意两个顶点都是连通的</li></ul><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>   A → B</span></span>\n<span class="line"><span>   ↑   ↓</span></span>\n<span class="line"><span>   D ← C</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>强连通分量：有向图中的极大强连通子图</li></ul><h3 id="图的存储结构" tabindex="-1"><a class="header-anchor" href="#图的存储结构"><span>图的存储结构</span></a></h3><ul><li>邻接矩阵：所谓邻接矩阵存储，是指用一个一维数组存储图中顶点的信息，用一个二维数组存储图中边的信息（即各顶点之间的邻接关系），存储顶点之间邻接关系的二维数组称为邻接矩阵。</li><li>邻接表：在邻接表中存在两种结点：顶点表结点和边表结点</li><li>十字链表：十字链表是有向图的一种链式存储结构。在十字链表中，对应于有向图中的每条弧有一个结点，对应于每个顶点也有一个结点。</li><li>邻接多表：邻接多重表是无向图的另一种链式存储结构。</li></ul><h4 id="邻接矩阵" tabindex="-1"><a class="header-anchor" href="#邻接矩阵"><span>邻接矩阵</span></a></h4><table><thead><tr><th>图类型</th><th>行/列意义</th><th>特点</th><th>边数与1的关系</th><th>空间优化</th></tr></thead><tbody><tr><td>有向图</td><td>行：出度，列：入度</td><td>入度和 = 出度和</td><td>所有 1 的个数 = 边数</td><td>无法压缩</td></tr><tr><td>无向图</td><td>行或列的 1 的个数 = 顶点度</td><td>矩阵对称</td><td>所有 1 的个数 = 边数 × 2</td><td>可压缩为上/下三角区域</td></tr></tbody></table><ul><li><p><strong>定义</strong>：邻接矩阵由两个部分组成：</p><ul><li>顶点数组（存储所有顶点）</li><li>邻接矩阵（二维数组表示顶点之间的边）</li></ul></li></ul><h4 id="_1️⃣-有向图示例" tabindex="-1"><a class="header-anchor" href="#_1️⃣-有向图示例"><span>1️⃣ 有向图示例</span></a></h4><p>图结构：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>A → B</span></span>\n<span class="line"><span>B → C</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>邻接矩阵（有向）：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>     A B C</span></span>\n<span class="line"><span>   -------</span></span>\n<span class="line"><span>A | 0 1 0</span></span>\n<span class="line"><span>B | 0 0 1</span></span>\n<span class="line"><span>C | 0 0 0</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>出度：</p><ul><li>A 的出度 = 第 1 行中 1 的个数 = 1</li><li>B 的出度 = 第 2 行中 1 的个数 = 1</li><li>C 的出度 = 第 3 行中 1 的个数 = 0</li></ul><p>入度：</p><ul><li>A 的入度 = 第 1 列中 1 的个数 = 0</li><li>B 的入度 = 第 2 列中 1 的个数 = 1</li><li>C 的入度 = 第 3 列中 1 的个数 = 1</li></ul><p>总出度 = 总入度 = 2 ✅</p><h4 id="_2️⃣-无向图示例" tabindex="-1"><a class="header-anchor" href="#_2️⃣-无向图示例"><span>2️⃣ 无向图示例</span></a></h4><p>图结构：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>A — B</span></span>\n<span class="line"><span>B — C</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>邻接矩阵（无向）：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>     A B C</span></span>\n<span class="line"><span>   -------</span></span>\n<span class="line"><span>A | 0 1 0</span></span>\n<span class="line"><span>B | 1 0 1</span></span>\n<span class="line"><span>C | 0 1 0</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>对称矩阵 ✅</li><li>A 度 = 第 1 行中 1 的个数 = 1</li><li>B 度 = 第 2 行中 1 的个数 = 2</li><li>C 度 = 第 3 行中 1 的个数 = 1</li></ul><p>矩阵中总共有 4 个 1，对应 2 条边（因为每条边占两个 1）✅</p><ul><li><strong>对称矩阵</strong> ➜ 只需存上三角或下三角部分（不含对角线）</li><li><strong>空间需求</strong> = n(n - 1)/2</li></ul><p>比如：</p><ul><li>对于 5 个顶点，需空间 = 5×4/2 = 10 个元素</li></ul><h4 id="邻接表" tabindex="-1"><a class="header-anchor" href="#邻接表"><span>邻接表</span></a></h4><table><thead><tr><th>描述</th><th>备注举例</th></tr></thead><tbody><tr><td>定义：对图中每个顶点都建立一个单链表，存储该顶点的邻接点信息。</td><td>每个顶点对应一个链表，链表节点为邻接点</td></tr><tr><td>无向图中，某顶点的邻接表节点数 = 该顶点的度（与多少个顶点相连）。</td><td>顶点 A 与 B、C 相连，A 的邻接表有 2 个节点</td></tr><tr><td>有向图中，某顶点的邻接表节点数 = 该顶点的出度（指向多少个顶点）。</td><td>顶点 A 有边指向 B、C，A 的邻接表有 2 个节点</td></tr></tbody></table><h4 id="简单示例" tabindex="-1"><a class="header-anchor" href="#简单示例"><span>简单示例</span></a></h4><ul><li><p>无向图：顶点 A — B、C 邻接表：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>A -&gt; B -&gt; C  </span></span>\n<span class="line"><span>B -&gt; A  </span></span>\n<span class="line"><span>C -&gt; A</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>有向图：顶点 A → B、C 邻接表：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>A -&gt; B -&gt; C  </span></span>\n<span class="line"><span>B -&gt; (无邻接点)  </span></span>\n<span class="line"><span>C -&gt; (无邻接点)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h4 id="邻接矩阵和邻接表对比" tabindex="-1"><a class="header-anchor" href="#邻接矩阵和邻接表对比"><span>邻接矩阵和邻接表对比</span></a></h4><table><thead><tr><th>特性</th><th>邻接矩阵</th><th>邻接表</th></tr></thead><tbody><tr><td><strong>定义</strong></td><td>用二维数组存储顶点间边的关系</td><td>用链表存储每个顶点的邻接点信息</td></tr><tr><td><strong>空间复杂度</strong></td><td>固定为 $O(n^2)$</td><td>边少时节省空间，约为 $O(n + e)$</td></tr><tr><td><strong>适用场景</strong></td><td>边数多，稠密图</td><td>边数少，稀疏图</td></tr><tr><td><strong>查询边是否存在</strong></td><td>$O(1)$ 直接通过矩阵索引查找</td><td>需要遍历链表，最坏 $O(k)$ （k是度）</td></tr><tr><td><strong>遍历邻接点</strong></td><td>需扫描整行，时间 $O(n)$</td><td>直接遍历链表，时间 $O(k)$</td></tr><tr><td><strong>入度/出度统计</strong></td><td>有向图：行代表出度，列代表入度，易统计</td><td>出度易统计，入度不易，需遍历所有链表</td></tr><tr><td><strong>实现复杂度</strong></td><td>简单，数组直接实现</td><td>较复杂，需要链表指针操作</td></tr></tbody></table><h4 id="十字链表" tabindex="-1"><a class="header-anchor" href="#十字链表"><span>十字链表</span></a></h4><h4 id="邻接多表" tabindex="-1"><a class="header-anchor" href="#邻接多表"><span>邻接多表</span></a></h4><h3 id="图的遍历" tabindex="-1"><a class="header-anchor" href="#图的遍历"><span>图的遍历</span></a></h3><table><thead><tr><th>内容</th><th>DFS（深度优先遍历）</th><th>BFS（广度优先遍历）</th></tr></thead><tbody><tr><td>遍历方式</td><td>类似树的先序遍历，从一个顶点沿深度方向尽可能走远</td><td>类似树的层次遍历，一层层按广度逐层访问</td></tr><tr><td>适用图类型</td><td>有向图或无向图均可</td><td>有向图或无向图均可</td></tr><tr><td>数据结构实现</td><td>栈（递归调用本质上用栈）</td><td>队列</td></tr><tr><td>应用场景</td><td>路径搜索、拓扑排序、连通性检测</td><td>最短路径搜索（无权图）、层次划分</td></tr><tr><td>访问顺序特点</td><td>先访问尽可能深的邻接点，后回溯</td><td>先访问当前层所有邻接点，再访问下一层</td></tr></tbody></table><h3 id="最小生成树" tabindex="-1"><a class="header-anchor" href="#最小生成树"><span>最小生成树</span></a></h3><ul><li>保留 n - 1 条边，其中 n 是顶点数</li><li>所有顶点都连通（连通图）</li><li>边权和最小</li><li>没有环（是树结构）</li><li>在<strong>带权无向连通图</strong>中，选出一棵包含所有顶点的生成树，使所有边权之和最小。</li></ul><h4 id="最小生成树算法" tabindex="-1"><a class="header-anchor" href="#最小生成树算法"><span>最小生成树算法</span></a></h4><table><thead><tr><th>特点</th><th>Prim 算法</th><th>Kruskal 算法</th></tr></thead><tbody><tr><td>思路</td><td><strong>顶点为中心</strong>，逐渐扩展生成树</td><td><strong>边为中心</strong>，按权值排序选择边</td></tr><tr><td>适用图类型</td><td>稠密图更优</td><td>稀疏图更优</td></tr><tr><td>数据结构</td><td>通常使用优先队列（堆）维护边</td><td>并查集（Union-Find）判环</td></tr><tr><td>操作步骤</td><td>每次选取与生成树相连的最小边</td><td>按边权从小到大加入边，避免环路</td></tr><tr><td>时间复杂度</td><td>$O(V^2)$ 或 $O(E \\log V)$（堆优化）</td><td>$O(E \\log E)$（排序边和并查集）</td></tr><tr><td>举例</td><td>从起点A开始，逐渐连入权重最小的边</td><td>从最小边开始，连通不同集合的顶点</td></tr></tbody></table><h4 id="简单例子" tabindex="-1"><a class="header-anchor" href="#简单例子"><span>简单例子：</span></a></h4><h4 id="图的顶点和边-权重" tabindex="-1"><a class="header-anchor" href="#图的顶点和边-权重"><span>图的顶点和边（权重）：</span></a></h4><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>顶点：A, B, C</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>边：</span></span>\n<span class="line"><span>A — B : 1</span></span>\n<span class="line"><span>B — C : 2</span></span>\n<span class="line"><span>A — C : 3</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="图示" tabindex="-1"><a class="header-anchor" href="#图示"><span>图示：</span></a></h4><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>   </span></span>\n<span class="line"><span>A — 1 — B</span></span>\n<span class="line"><span> \\      |</span></span>\n<span class="line"><span>  3     2</span></span>\n<span class="line"><span>   \\   / </span></span>\n<span class="line"><span>    C</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="prim-算法-从-a-开始" tabindex="-1"><a class="header-anchor" href="#prim-算法-从-a-开始"><span>Prim 算法（从 A 开始）：</span></a></h4>',164),(0,i.Lk)("ul",null,[(0,i.Lk)("li",null,"起点 A，只连接 A-B(1) 和 A-C(3)，选最小边 A-B(1)"),(0,i.Lk)("li",{"A,":"",B:""},"集合"),(0,i.Lk)("li",null,"连接 B-C(2) 和 A-C(3)，选 B-C(2)"),(0,i.Lk)("li",null,"集合 {A, B, C}，结束")],-1),(0,i.Fv)('<p><strong>选边：A-B(1), B-C(2)</strong></p><h4 id="kruskal-算法" tabindex="-1"><a class="header-anchor" href="#kruskal-算法"><span>Kruskal 算法：</span></a></h4><ul><li><p>按权重排序边：A-B(1), B-C(2), A-C(3)</p></li><li><p>依次加入边，不成环：</p><ul><li>加 A-B(1)</li><li>加 B-C(2)</li><li>加 A-C(3) 会成环，跳过</li></ul></li></ul><p><strong>选边：A-B(1), B-C(2)</strong></p><h4 id="最小生成树边集" tabindex="-1"><a class="header-anchor" href="#最小生成树边集"><span>最小生成树边集：</span></a></h4><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>A-B (1), B-C (2)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h4 id="总权重" tabindex="-1"><a class="header-anchor" href="#总权重"><span>总权重：</span></a></h4><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>1 + 2 = 3</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="拓扑排序" tabindex="-1"><a class="header-anchor" href="#拓扑排序"><span>拓扑排序</span></a></h3><ul><li>应用于有向无环图（DAG），不适用有环图。</li><li>排序结果是一种满足依赖关系的线性序列。</li><li>常用于任务调度、编译依赖分析等场景。</li></ul><h4 id="拓扑排序算法" tabindex="-1"><a class="header-anchor" href="#拓扑排序算法"><span>拓扑排序算法</span></a></h4><table><thead><tr><th>特点</th><th>AOV网</th><th>AOE网</th></tr></thead><tbody><tr><td>图的元素</td><td>顶点是活动，弧是顺序关系</td><td>顶点是事件，弧是活动（带时间）</td></tr><tr><td>主要用途</td><td>分析活动依赖顺序</td><td>关键路径分析、时间管理</td></tr></tbody></table><h4 id="aov网-activity-on-vertex" tabindex="-1"><a class="header-anchor" href="#aov网-activity-on-vertex"><span>AOV网（Activity on Vertex）</span></a></h4><ul><li><strong>顶点表示活动，边表示活动间的依赖关系</strong>。</li></ul><h4 id="例子" tabindex="-1"><a class="header-anchor" href="#例子"><span>例子：</span></a></h4><p>活动：A, B, C, D</p><p>依赖关系：</p><ul><li>A → C （完成A后才能开始C）</li><li>B → C</li><li>C → D</li></ul><h4 id="图示-顶点是活动" tabindex="-1"><a class="header-anchor" href="#图示-顶点是活动"><span>图示（顶点是活动）：</span></a></h4><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>A     B</span></span>\n<span class="line"><span> \\   /</span></span>\n<span class="line"><span>   C</span></span>\n<span class="line"><span>   |</span></span>\n<span class="line"><span>   D</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h4 id="aoe网-activity-on-edge" tabindex="-1"><a class="header-anchor" href="#aoe网-activity-on-edge"><span>AOE网（Activity on Edge）</span></a></h4><ul><li><strong>顶点表示事件（活动的开始或结束时刻），边表示活动，边上带活动持续时间</strong>。</li></ul><h4 id="例子-1" tabindex="-1"><a class="header-anchor" href="#例子-1"><span>例子：</span></a></h4><p>事件：1, 2, 3, 4</p><p>活动及持续时间：</p><ul><li>活动A（持续3天）：1 → 2</li><li>活动B（持续2天）：1 → 3</li><li>活动C（持续4天）：2 → 4</li><li>活动D（持续5天）：3 → 4</li></ul><h4 id="图示-边是活动" tabindex="-1"><a class="header-anchor" href="#图示-边是活动"><span>图示（边是活动）：</span></a></h4><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>1</span></span>\n<span class="line"><span>|\\</span></span>\n<span class="line"><span>| \\</span></span>\n<span class="line"><span>A  B</span></span>\n<span class="line"><span>(3)(2)</span></span>\n<span class="line"><span>|    \\</span></span>\n<span class="line"><span>2-----3</span></span>\n<span class="line"><span> \\    \\</span></span>\n<span class="line"><span>  C    D</span></span>\n<span class="line"><span> (4)  (5)</span></span>\n<span class="line"><span>   \\   /</span></span>\n<span class="line"><span>     4</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="最短路径算法" tabindex="-1"><a class="header-anchor" href="#最短路径算法"><span>最短路径算法</span></a></h3><table><thead><tr><th>特点</th><th>迪杰斯特拉算法（Dijkstra）</th><th>弗洛伊德算法（Floyd）</th></tr></thead><tbody><tr><td>计算目标</td><td>单源最短路径</td><td>所有顶点对最短路径</td></tr><tr><td>支持的权值类型</td><td>非负权边</td><td>可含负权边（无负权回路）</td></tr><tr><td>时间复杂度</td><td>$O((V+E) \\log V)$（使用堆优化）</td><td>$O(V^3)$</td></tr><tr><td>算法思想</td><td>贪心</td><td>动态规划</td></tr><tr><td>适用图类型</td><td>稠密或稀疏图</td><td>较小规模图</td></tr><tr><td>典型应用</td><td>地图导航、网络路由</td><td>交通网络全局路径规划</td></tr></tbody></table><h4 id="举例" tabindex="-1"><a class="header-anchor" href="#举例"><span>举例</span></a></h4><h4 id="图的顶点和边-带权有向图" tabindex="-1"><a class="header-anchor" href="#图的顶点和边-带权有向图"><span>图的顶点和边（带权有向图）</span></a></h4><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>顶点：A, B, C, D</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>边及权重：</span></span>\n<span class="line"><span>A → B : 1</span></span>\n<span class="line"><span>A → C : 4</span></span>\n<span class="line"><span>B → C : 2</span></span>\n<span class="line"><span>B → D : 6</span></span>\n<span class="line"><span>C → D : 3</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="dijkstra-算法-单源最短路径" tabindex="-1"><a class="header-anchor" href="#dijkstra-算法-单源最短路径"><span>Dijkstra 算法（单源最短路径）</span></a></h4><h4 id="目标" tabindex="-1"><a class="header-anchor" href="#目标"><span>目标：</span></a></h4><p>从顶点 A 出发，找出 A 到其他顶点的最短路径。</p><h4 id="过程" tabindex="-1"><a class="header-anchor" href="#过程"><span>过程：</span></a></h4><table><thead><tr><th>步骤</th><th>确定的最短路径</th><th>距离估计 (A 到各点)</th></tr></thead><tbody><tr><td>初始化</td><td>A到A距离0，其他∞</td><td>A:0, B:∞, C:∞, D:∞</td></tr><tr><td>1</td><td>从A开始，更新邻接点距离</td><td>B:1 (A→B), C:4 (A→C), D:∞</td></tr><tr><td>2</td><td>选择未确定中距离最小点B（距离1）</td><td>通过B更新C和D：C:3 (1+2), D:7 (1+6)</td></tr><tr><td>3</td><td>选择未确定中距离最小点C（距离3）</td><td>通过C更新D：D:6 (3+3)</td></tr><tr><td>4</td><td>选择未确定中距离最小点D（距离6）</td><td>结束</td></tr></tbody></table><h4 id="结果" tabindex="-1"><a class="header-anchor" href="#结果"><span>结果：</span></a></h4><ul><li>A→A: 0</li><li>A→B: 1</li><li>A→C: 3</li><li>A→D: 6</li></ul><h4 id="floyd-算法-所有顶点对最短路径" tabindex="-1"><a class="header-anchor" href="#floyd-算法-所有顶点对最短路径"><span>Floyd 算法（所有顶点对最短路径）</span></a></h4><h4 id="目标-1" tabindex="-1"><a class="header-anchor" href="#目标-1"><span>目标：</span></a></h4><p>计算任意两点间的最短路径。</p><h4 id="初始化邻接矩阵-无连接为-∞" tabindex="-1"><a class="header-anchor" href="#初始化邻接矩阵-无连接为-∞"><span>初始化邻接矩阵（无连接为 ∞）：</span></a></h4><table><thead><tr><th></th><th>A</th><th>B</th><th>C</th><th>D</th></tr></thead><tbody><tr><td><strong>A</strong></td><td>0</td><td>1</td><td>4</td><td>∞</td></tr><tr><td><strong>B</strong></td><td>∞</td><td>0</td><td>2</td><td>6</td></tr><tr><td><strong>C</strong></td><td>∞</td><td>∞</td><td>0</td><td>3</td></tr><tr><td><strong>D</strong></td><td>∞</td><td>∞</td><td>∞</td><td>0</td></tr></tbody></table><h4 id="过程-1" tabindex="-1"><a class="header-anchor" href="#过程-1"><span>过程：</span></a></h4><p>动态更新路径长度，尝试通过顶点 k（从 A 到 D）中转。</p><ul><li>以 k=A，k=B，k=C，k=D 为中转点，更新路径长度。</li><li>最终邻接矩阵：</li></ul><table><thead><tr><th></th><th>A</th><th>B</th><th>C</th><th>D</th></tr></thead><tbody><tr><td><strong>A</strong></td><td>0</td><td>1</td><td>3</td><td>6</td></tr><tr><td><strong>B</strong></td><td>∞</td><td>0</td><td>2</td><td>5</td></tr><tr><td><strong>C</strong></td><td>∞</td><td>∞</td><td>0</td><td>3</td></tr><tr><td><strong>D</strong></td><td>∞</td><td>∞</td><td>∞</td><td>0</td></tr></tbody></table><h4 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h4><ul><li><strong>Dijkstra</strong>：从A点出发，找出到其他点的最短路径。</li><li><strong>Floyd</strong>：计算所有点之间的最短路径。</li></ul><h2 id="查找" tabindex="-1"><a class="header-anchor" href="#查找"><span>查找</span></a></h2><h3 id="概念-2" tabindex="-1"><a class="header-anchor" href="#概念-2"><span>概念</span></a></h3><table><thead><tr><th>速记点</th><th>静态查找表</th><th>动态查找表</th></tr></thead><tbody><tr><td>定义</td><td>只能进行<strong>查找</strong>操作的查找结构</td><td>在查找过程中可以同时进行<strong>插入</strong>和<strong>删除</strong>操作</td></tr><tr><td>数据元素</td><td>固定不变，表内数据元素不增删</td><td>支持元素的动态增删，表内容可变化</td></tr><tr><td>典型应用</td><td>只读的数据集合，如词典、配置文件</td><td>实时更新的数据集合，如数据库索引、缓存</td></tr><tr><td>维护复杂度</td><td>较低，因为数据固定，结构简单</td><td>较高，需要维护结构平衡或调整以保证效率</td></tr></tbody></table><h3 id="查找方法" tabindex="-1"><a class="header-anchor" href="#查找方法"><span>查找方法</span></a></h3><table><thead><tr><th>方法名称</th><th>速记内容</th><th>适用条件</th><th>特点说明</th></tr></thead><tbody><tr><td>顺序查找法</td><td>又称线性查找，在无序或有序的线性表中逐个查找</td><td>适用于无序或有序线性表</td><td>简单，效率低，时间复杂度O(n)</td></tr><tr><td>折半查找法</td><td>又称二分查找，针对有序顺序表，通过不断折半范围缩小查找范围</td><td>只适用于有序的顺序表</td><td>高效，时间复杂度O(log n)</td></tr><tr><td>分块查找法</td><td>又称索引顺序查找，结合顺序查找和折半查找优点，分块并建立索引</td><td>适用于数据量较大且有序的顺序表</td><td>结构动态，查找速度快</td></tr></tbody></table><h3 id="bst-二叉搜索树" tabindex="-1"><a class="header-anchor" href="#bst-二叉搜索树"><span>BST 二叉搜索树</span></a></h3><ul><li>左子树所有节点值小于根节点值</li><li>右子树所有节点值大于根节点值</li><li>左右子树也分别为二叉搜索树</li></ul><h3 id="平衡二叉树-avl树" tabindex="-1"><a class="header-anchor" href="#平衡二叉树-avl树"><span>平衡二叉树 AVL树</span></a></h3><ul><li>左右子树高度差不超过1</li><li>左右子树也分别为平衡二叉树</li></ul><table><thead><tr><th>特点</th><th>AVL树</th><th>红黑树</th></tr></thead><tbody><tr><td><strong>定义</strong></td><td>一种高度平衡的二叉排序树，任意节点左右子树高度差 ≤ 1</td><td>一种自平衡的二叉搜索树，满足红黑性质保证平衡</td></tr><tr><td><strong>平衡条件</strong></td><td>节点的左右子树高度差最多为1</td><td>满足红黑性质（节点颜色和路径黑色节点数规则）</td></tr><tr><td><strong>平衡强度</strong></td><td>比红黑树更严格，树更“平”</td><td>平衡条件较松，允许一定不平衡</td></tr><tr><td><strong>旋转次数</strong></td><td>插入或删除后可能需要多次旋转</td><td>插入或删除后最多需要两次旋转</td></tr><tr><td><strong>查询效率</strong></td><td>平均和最坏情况下查询性能好，时间复杂度 $O(\\log n)$</td><td>查询性能略逊于AVL，时间复杂度也为 $O(\\log n)$</td></tr><tr><td><strong>插入/删除效率</strong></td><td>插入删除时调整次数多，开销相对大</td><td>插入删除时调整次数少，开销相对小</td></tr><tr><td><strong>应用场景</strong></td><td>适合查询多、修改少的场景</td><td>适合查询和修改均衡的场景，常用于系统底层数据结构</td></tr></tbody></table><h3 id="哈希表-散列表" tabindex="-1"><a class="header-anchor" href="#哈希表-散列表"><span>哈希表（散列表）</span></a></h3><ul><li>根据关键字 直接计算出地址 进行查找，提高查找效率，平均时间复杂度为 O(1)。</li></ul><h3 id="哈希函数构造方法" tabindex="-1"><a class="header-anchor" href="#哈希函数构造方法"><span>哈希函数构造方法</span></a></h3><table><thead><tr><th>方法名称</th><th>描述</th><th>例子（M=13）</th></tr></thead><tbody><tr><td>直接定址法</td><td>f(key) = key</td><td>key = 10 → f(10)=10</td></tr><tr><td>除留余数法</td><td>f(key) = key mod M</td><td>key = 26 → f(26)=0</td></tr><tr><td>数字分析法</td><td>从 key 中取出某几位数字作为地址</td><td>key=123456 → 取345</td></tr><tr><td>平方取中法</td><td>对 key 平方后取中间几位作为地址</td><td>key=123 → 123²=15129 → 取中间512</td></tr></tbody></table><h3 id="哈希冲突解决方法" tabindex="-1"><a class="header-anchor" href="#哈希冲突解决方法"><span>哈希冲突解决方法</span></a></h3><table><thead><tr><th>方法</th><th>描述</th><th>举例</th></tr></thead><tbody><tr><td>开放定址法</td><td>冲突后向后找下一个空位（线性探测/二次探测）</td><td>位置冲突后试 M+1、M+2...</td></tr><tr><td>链地址法</td><td>每个槽位存一个链表，冲突的 key 依次链入</td><td>类似“拉链法”</td></tr><tr><td>再哈希法</td><td>换另一个哈希函数再计算地址</td><td>多函数备用</td></tr><tr><td>建立公共溢出区</td><td>所有冲突的记录统一存储在溢出区</td><td>辅助数组</td></tr></tbody></table><h2 id="排序" tabindex="-1"><a class="header-anchor" href="#排序"><span>排序</span></a></h2><h3 id="概念-3" tabindex="-1"><a class="header-anchor" href="#概念-3"><span>概念</span></a></h3><ul><li>内部排序∶ 指待排序记录存放在内存中进行的排序过程</li><li>外部排序∶ 指待排序记录的数量很大，内存一次不能容纳全部记录，在排序过程中尚需对外存进行访问的排序过程，通常采用归并排序法。</li><li>稳定排序∶ 如果在排序文件中存在多个关键字相同的记录，经过排序后，这些关键字相同的记录之间的前后相对次序保持不变的排序方法</li><li>不稳定排序∶若具有相同关键字的记录在排序结束后，其前后相对次序发生变化的排序方法</li></ul><h3 id="插入排序" tabindex="-1"><a class="header-anchor" href="#插入排序"><span>插入排序</span></a></h3><h4 id="直接插入排序" tabindex="-1"><a class="header-anchor" href="#直接插入排序"><span>直接插入排序</span></a></h4><h4 id="示例序列-7-2-8-1" tabindex="-1"><a class="header-anchor" href="#示例序列-7-2-8-1"><span>示例序列：<code>[7, 2, 8, 1]</code></span></a></h4><p><strong>步骤演示</strong>：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>初始：已排序 [7] | 未排序 [2, 8, 1]</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>插入2：与7比较 → 插入前面 → [2, 7]</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>插入8：与7比较 → 插入后面 → [2, 7, 8]</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>插入1：与8、7、2比较 → 插入最前 → [1, 2, 7, 8]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>📌 结果：<code>[1, 2, 7, 8]</code></p><h4 id="折半插入排序" tabindex="-1"><a class="header-anchor" href="#折半插入排序"><span>折半插入排序</span></a></h4><p><strong>示例序列</strong>：<code>[6, 4, 9, 3]</code></p><p><strong>步骤演示</strong>（与插入排序过程一样，但<strong>查找插入位置用折半查找</strong>）：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>初始：已排序 [6] | 未排序 [4, 9, 3]</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>插入4：</span></span>\n<span class="line"><span>    二分查找：在[6]中找4的插入位置 → 插入前面 → [4, 6]</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>插入9：</span></span>\n<span class="line"><span>    二分查找：在[4,6]中找9的插入位置 → 插入后面 → [4, 6, 9]</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>插入3：</span></span>\n<span class="line"><span>    二分查找：在[4,6,9]中找3的插入位置 → 插入最前 → [3, 4, 6, 9]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>📌 结果：<code>[3, 4, 6, 9]</code></p><p>🔎 差别：查插入位置用折半查找（更快），但<strong>元素移动过程一样</strong>。</p><h4 id="希尔排序" tabindex="-1"><a class="header-anchor" href="#希尔排序"><span>希尔排序</span></a></h4><p><strong>示例序列</strong>：<code>[9, 1, 2, 5, 7, 4, 8, 6, 3, 5]</code></p><p><strong>核心思想</strong>：按间隔分组，对每组进行插入排序，然后缩小间隔重复</p><h4 id="第一步-gap-5-按间隔5分组" tabindex="-1"><a class="header-anchor" href="#第一步-gap-5-按间隔5分组"><span>第一步：gap = 5，按间隔5分组</span></a></h4><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>原数组：[9, 1, 2, 5, 7, 4, 8, 6, 3, 5]</span></span>\n<span class="line"><span>索引：   0  1  2  3  4  5  6  7  8  9</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>分组（间隔5）：</span></span>\n<span class="line"><span>组1：[9, 4]     → 插入排序 → [4, 9]</span></span>\n<span class="line"><span>组2：[1, 8]     → 插入排序 → [1, 8]  </span></span>\n<span class="line"><span>组3：[2, 6]     → 插入排序 → [2, 6]</span></span>\n<span class="line"><span>组4：[5, 3]     → 插入排序 → [3, 5]</span></span>\n<span class="line"><span>组5：[7, 5]     → 插入排序 → [5, 7]</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>重排组合：[4, 1, 2, 3, 5, 9, 8, 6, 5, 7]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="第二步-gap-2-按间隔2分组" tabindex="-1"><a class="header-anchor" href="#第二步-gap-2-按间隔2分组"><span>第二步：gap = 2，按间隔2分组</span></a></h4><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>数组：[4, 1, 2, 3, 5, 9, 8, 6, 5, 7]</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>分组（间隔2）：</span></span>\n<span class="line"><span>组1：[4, 2, 5, 8, 5] → 插入排序 → [2, 4, 5, 5, 8]</span></span>\n<span class="line"><span>组2：[1, 3, 9, 6, 7] → 插入排序 → [1, 3, 6, 7, 9]</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>重排组合：[2, 1, 4, 3, 5, 6, 5, 7, 8, 9]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="第三步-gap-1-整体插入排序" tabindex="-1"><a class="header-anchor" href="#第三步-gap-1-整体插入排序"><span>第三步：gap = 1，整体插入排序</span></a></h4><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>数组：[2, 1, 4, 3, 5, 6, 5, 7, 8, 9]</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>对每个元素进行插入排序：</span></span>\n<span class="line"><span>插入1到2前 → [1, 2, 4, 3, 5, 6, 5, 7, 8, 9]</span></span>\n<span class="line"><span>插入4到正确位置 → [1, 2, 4, 3, 5, 6, 5, 7, 8, 9]</span></span>\n<span class="line"><span>插入3到正确位置 → [1, 2, 3, 4, 5, 6, 5, 7, 8, 9]</span></span>\n<span class="line"><span>...继续插入排序...</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>📌 结果：<code>[1, 2, 3, 4, 5, 5, 6, 7, 8, 9]</code></p><p><strong>💡 理解要点</strong>：</p><ul><li>希尔排序是插入排序的改进版</li><li>通过大间隔分组，让元素&quot;跳跃式&quot;移动，减少移动次数</li><li>逐步缩小间隔，最终变成普通的插入排序</li><li>比直接插入排序效率更高</li></ul><h3 id="选择排序" tabindex="-1"><a class="header-anchor" href="#选择排序"><span>选择排序</span></a></h3><h4 id="简单选择排序" tabindex="-1"><a class="header-anchor" href="#简单选择排序"><span>简单选择排序</span></a></h4><p><strong>示例序列</strong>：<code>[5, 3, 1, 4]</code></p><p><strong>步骤演示</strong>：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>初始：[5, 3, 1, 4]</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>第1轮：找最小值1，与第1位5交换</span></span>\n<span class="line"><span>[1, 3, 5, 4]</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>第2轮：从第2位开始，找最小值3，已在正确位置</span></span>\n<span class="line"><span>[1, 3, 5, 4]</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>第3轮：从第3位开始，找最小值4，与第3位5交换</span></span>\n<span class="line"><span>[1, 3, 4, 5]</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>第4轮：只剩最后一位，已排序完成</span></span>\n<span class="line"><span>[1, 3, 4, 5]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>📌 结果：<code>[1, 3, 4, 5]</code></p><h4 id="堆排序" tabindex="-1"><a class="header-anchor" href="#堆排序"><span>堆排序</span></a></h4><p><strong>示例序列</strong>：<code>[4, 1, 3, 2]</code></p><p><strong>步骤演示</strong>：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>初始：[4, 1, 3, 2]</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>1. 建堆（大顶堆）：</span></span>\n<span class="line"><span>   [4, 1, 3, 2] → [4, 2, 3, 1]</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>2. 依次取出堆顶元素：</span></span>\n<span class="line"><span>   取出4 → [1, 2, 3]</span></span>\n<span class="line"><span>   取出3 → [1, 2] </span></span>\n<span class="line"><span>   取出2 → [1]</span></span>\n<span class="line"><span>   取出1 → []</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>3. 倒序排列：4, 3, 2, 1</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>📌 结果：<code>[1, 2, 3, 4]</code></p><h3 id="交换排序" tabindex="-1"><a class="header-anchor" href="#交换排序"><span>交换排序</span></a></h3><h4 id="冒泡排序" tabindex="-1"><a class="header-anchor" href="#冒泡排序"><span>冒泡排序</span></a></h4><p><strong>示例序列</strong>：<code>[5, 3, 1, 4]</code></p><p><strong>步骤演示</strong>：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>初始：[5, 3, 1, 4]</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>第1轮：相邻比较交换</span></span>\n<span class="line"><span>5&gt;3 → [3, 5, 1, 4]</span></span>\n<span class="line"><span>5&gt;1 → [3, 1, 5, 4]</span></span>\n<span class="line"><span>5&gt;4 → [3, 1, 4, 5]</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>第2轮：继续相邻比较</span></span>\n<span class="line"><span>3&gt;1 → [1, 3, 4, 5]</span></span>\n<span class="line"><span>3&lt;4 → [1, 3, 4, 5]</span></span>\n<span class="line"><span>4&lt;5 → [1, 3, 4, 5]</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>第3轮：继续相邻比较</span></span>\n<span class="line"><span>1&lt;3, 3&lt;4, 4&lt;5 → 无交换，排序完成</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>📌 结果：<code>[1, 3, 4, 5]</code></p><h4 id="快速排序" tabindex="-1"><a class="header-anchor" href="#快速排序"><span>快速排序</span></a></h4><ul><li>快速排序的主要优势在于处理随机分布的数据,通过分区操作将数据分成两部分进行递归排序。但对于已经接近有序的序列,分区操作的效果很差,导致分区极不均衡。</li></ul><p><strong>示例序列</strong>：<code>[5, 3, 1, 4]</code></p><p><strong>步骤演示</strong>：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>初始：[5, 3, 1, 4]</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>第1轮：选择基准值5</span></span>\n<span class="line"><span>分区：小于5的放左边，大于5的放右边</span></span>\n<span class="line"><span>[3, 1, 4] + [5] + []</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>递归排序左半部分[3, 1, 4]：</span></span>\n<span class="line"><span>选择基准值3</span></span>\n<span class="line"><span>[1] + [3] + [4]</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>递归排序右半部分[]：</span></span>\n<span class="line"><span>空数组，无需排序</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>合并：[1, 3, 4, 5]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>📌 结果：<code>[1, 3, 4, 5]</code></p><h3 id="归并排序" tabindex="-1"><a class="header-anchor" href="#归并排序"><span>归并排序</span></a></h3><p><strong>示例序列</strong>：<code>[5, 3, 1, 4]</code></p><p><strong>步骤演示</strong>：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>初始：[5, 3, 1, 4]</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>第1层分解：</span></span>\n<span class="line"><span>[5, 3] 和 [1, 4]</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>第2层分解：</span></span>\n<span class="line"><span>[5] [3] [1] [4]</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>第1层合并：</span></span>\n<span class="line"><span>[5] + [3] → [3, 5]</span></span>\n<span class="line"><span>[1] + [4] → [1, 4]</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>第2层合并：</span></span>\n<span class="line"><span>[3, 5] + [1, 4] → [1, 3, 4, 5]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>📌 结果：<code>[1, 3, 4, 5]</code></p><h3 id="基数排序" tabindex="-1"><a class="header-anchor" href="#基数排序"><span>基数排序</span></a></h3><p><strong>示例序列</strong>：<code>[23, 12, 31, 45]</code></p><p><strong>步骤演示</strong>：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>初始：[23, 12, 31, 45]</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>按个位数排序：</span></span>\n<span class="line"><span>23(3), 12(2), 31(1), 45(5)</span></span>\n<span class="line"><span>→ [31, 12, 23, 45]</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>按十位数排序：</span></span>\n<span class="line"><span>31(3), 12(1), 23(2), 45(4)</span></span>\n<span class="line"><span>→ [12, 23, 31, 45]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>📌 结果：<code>[12, 23, 31, 45]</code></p><h3 id="总结-1" tabindex="-1"><a class="header-anchor" href="#总结-1"><span>总结</span></a></h3><figure><img src="'+e+'" alt="排序算法" tabindex="0" loading="lazy"><figcaption>排序算法</figcaption></figure><h3 id="比较次数与初始序列无关的排序方法有哪些" tabindex="-1"><a class="header-anchor" href="#比较次数与初始序列无关的排序方法有哪些"><span>比较次数与初始序列无关的排序方法有哪些？</span></a></h3><ul><li>比较次数与初始序列无关的排序方法，主要分为两类： <ul><li>比较类排序：仅<strong>选择排序</strong>，其比较次数固定为 n(n-1)/2，不随初始序列变化；</li><li>非比较类排序：以<strong>基数排序</strong>为代表，无元素间比较操作，自然与初始序列无关（类似的还有计数排序、桶排序，但计数排序依赖 “已知数值范围”，基数排序适用性更广）。</li></ul></li></ul>',132)]))}]]),t=JSON.parse('{"path":"/zh/posts/review/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html","title":"数据结构","lang":"zh-CN","frontmatter":{"icon":"pen-to-square","date":"2025-07-20T00:00:00.000Z","category":["Learning Records"],"tag":["Review"],"description":"数据结构 数据结构的概念 基本概念 数据：能输入到计算机中并且被计算机程序处理的符号的总称 数据元素：数据的基本单位。有时，一个数据元素可由若干数据项组成 数据结构的存储方式： 顺序存储：把逻辑上相邻的结点存储在物理位置上相邻的存储单元中 链式存储：把逻辑上相邻的结点存储在物理位置上不相邻的存储单元中，结点间的逻辑关系是由附加的指针字段表示的 索引存储...","head":[["meta",{"property":"og:url","content":"https://crc011220.github.io/zh/posts/review/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html"}],["meta",{"property":"og:site_name","content":"Ruochen Chen"}],["meta",{"property":"og:title","content":"数据结构"}],["meta",{"property":"og:description","content":"数据结构 数据结构的概念 基本概念 数据：能输入到计算机中并且被计算机程序处理的符号的总称 数据元素：数据的基本单位。有时，一个数据元素可由若干数据项组成 数据结构的存储方式： 顺序存储：把逻辑上相邻的结点存储在物理位置上相邻的存储单元中 链式存储：把逻辑上相邻的结点存储在物理位置上不相邻的存储单元中，结点间的逻辑关系是由附加的指针字段表示的 索引存储..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-10-21T04:43:08.000Z"}],["meta",{"property":"article:tag","content":"Review"}],["meta",{"property":"article:published_time","content":"2025-07-20T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-10-21T04:43:08.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"数据结构\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-07-20T00:00:00.000Z\\",\\"dateModified\\":\\"2025-10-21T04:43:08.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Ruochen Chen\\"}]}"]]},"headers":[{"level":2,"title":"数据结构的概念","slug":"数据结构的概念","link":"#数据结构的概念","children":[{"level":3,"title":"基本概念","slug":"基本概念","link":"#基本概念","children":[]}]},{"level":2,"title":"线性表","slug":"线性表","link":"#线性表","children":[{"level":3,"title":"顺序表和链表的比较","slug":"顺序表和链表的比较","link":"#顺序表和链表的比较","children":[]}]},{"level":2,"title":"栈和队列","slug":"栈和队列","link":"#栈和队列","children":[{"level":3,"title":"栈","slug":"栈","link":"#栈","children":[]},{"level":3,"title":"队列","slug":"队列","link":"#队列","children":[]}]},{"level":2,"title":"数组与特殊矩阵","slug":"数组与特殊矩阵","link":"#数组与特殊矩阵","children":[{"level":3,"title":"特殊矩阵：","slug":"特殊矩阵","link":"#特殊矩阵","children":[]},{"level":3,"title":"稀疏矩阵：","slug":"稀疏矩阵","link":"#稀疏矩阵","children":[]},{"level":3,"title":"广义表","slug":"广义表","link":"#广义表","children":[]}]},{"level":2,"title":"树和二叉树","slug":"树和二叉树","link":"#树和二叉树","children":[{"level":3,"title":"概念","slug":"概念","link":"#概念","children":[]},{"level":3,"title":"树的表示方法","slug":"树的表示方法","link":"#树的表示方法","children":[]},{"level":3,"title":"树的存储结构","slug":"树的存储结构","link":"#树的存储结构","children":[]},{"level":3,"title":"二叉树","slug":"二叉树","link":"#二叉树","children":[]},{"level":3,"title":"二叉树的存储结构","slug":"二叉树的存储结构","link":"#二叉树的存储结构","children":[]},{"level":3,"title":"二叉树的遍历","slug":"二叉树的遍历","link":"#二叉树的遍历","children":[]},{"level":3,"title":"树和森林遍历","slug":"树和森林遍历","link":"#树和森林遍历","children":[]},{"level":3,"title":"森林转换成二叉树","slug":"森林转换成二叉树","link":"#森林转换成二叉树","children":[]},{"level":3,"title":"赫夫曼树","slug":"赫夫曼树","link":"#赫夫曼树","children":[]},{"level":3,"title":"最优二叉树","slug":"最优二叉树","link":"#最优二叉树","children":[]},{"level":3,"title":"B树","slug":"b树","link":"#b树","children":[]},{"level":3,"title":"B树和B+树对比","slug":"b树和b-树对比","link":"#b树和b-树对比","children":[]}]},{"level":2,"title":"图","slug":"图","link":"#图","children":[{"level":3,"title":"概念","slug":"概念-1","link":"#概念-1","children":[]},{"level":3,"title":"图的存储结构","slug":"图的存储结构","link":"#图的存储结构","children":[]},{"level":3,"title":"图的遍历","slug":"图的遍历","link":"#图的遍历","children":[]},{"level":3,"title":"最小生成树","slug":"最小生成树","link":"#最小生成树","children":[]},{"level":3,"title":"拓扑排序","slug":"拓扑排序","link":"#拓扑排序","children":[]},{"level":3,"title":"最短路径算法","slug":"最短路径算法","link":"#最短路径算法","children":[]}]},{"level":2,"title":"查找","slug":"查找","link":"#查找","children":[{"level":3,"title":"概念","slug":"概念-2","link":"#概念-2","children":[]},{"level":3,"title":"查找方法","slug":"查找方法","link":"#查找方法","children":[]},{"level":3,"title":"BST 二叉搜索树","slug":"bst-二叉搜索树","link":"#bst-二叉搜索树","children":[]},{"level":3,"title":"平衡二叉树 AVL树","slug":"平衡二叉树-avl树","link":"#平衡二叉树-avl树","children":[]},{"level":3,"title":"哈希表（散列表）","slug":"哈希表-散列表","link":"#哈希表-散列表","children":[]},{"level":3,"title":"哈希函数构造方法","slug":"哈希函数构造方法","link":"#哈希函数构造方法","children":[]},{"level":3,"title":"哈希冲突解决方法","slug":"哈希冲突解决方法","link":"#哈希冲突解决方法","children":[]}]},{"level":2,"title":"排序","slug":"排序","link":"#排序","children":[{"level":3,"title":"概念","slug":"概念-3","link":"#概念-3","children":[]},{"level":3,"title":"插入排序","slug":"插入排序","link":"#插入排序","children":[]},{"level":3,"title":"选择排序","slug":"选择排序","link":"#选择排序","children":[]},{"level":3,"title":"交换排序","slug":"交换排序","link":"#交换排序","children":[]},{"level":3,"title":"归并排序","slug":"归并排序","link":"#归并排序","children":[]},{"level":3,"title":"基数排序","slug":"基数排序","link":"#基数排序","children":[]},{"level":3,"title":"总结","slug":"总结-1","link":"#总结-1","children":[]},{"level":3,"title":"比较次数与初始序列无关的排序方法有哪些？","slug":"比较次数与初始序列无关的排序方法有哪些","link":"#比较次数与初始序列无关的排序方法有哪些","children":[]}]}],"git":{"createdTime":1753006022000,"updatedTime":1761021788000,"contributors":[{"name":"Ruochen Chen","email":"ruocchen1220@gmail.com","commits":4}]},"readingTime":{"minutes":31.75,"words":9524},"filePathRelative":"zh/posts/review/数据结构.md","localizedDate":"2025年7月20日","excerpt":"\\n<h2>数据结构的概念</h2>\\n<h3>基本概念</h3>\\n<ul>\\n<li>数据：能输入到计算机中并且被计算机程序处理的符号的总称</li>\\n<li>数据元素：数据的基本单位。有时，一个数据元素可由若干数据项组成</li>\\n<li>数据结构的存储方式：\\n<ul>\\n<li>顺序存储：把逻辑上相邻的结点存储在物理位置上相邻的存储单元中</li>\\n<li>链式存储：把逻辑上相邻的结点存储在物理位置上不相邻的存储单元中，结点间的逻辑关系是由附加的指针字段表示的</li>\\n<li>索引存储：存储结点信息的同时，还建立附加的索引表，索引表中的每一项称为索引项，索引项的一般形式是（关键字，地址）</li>\\n<li>散列存储：根据结点的关键字直接计算出该结点的存储地址</li>\\n</ul>\\n</li>\\n<li>算法：\\n<ul>\\n<li>算法特征：有穷性、确切性、输入、输出、可行性</li>\\n<li>算法评定：健壮性、可读性、正确性、空间复杂度</li>\\n<li>时间复杂度：算法运行时间随问题规模增长的变化趋势</li>\\n<li>空间复杂度：算法运行时所占用的存储空间随问题规模增长的变化趋势</li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true}')},6262:(s,n)=>{n.A=(s,n)=>{const a=s.__vccOpts||s;for(const[s,i]of n)a[s]=i;return a}}}]);